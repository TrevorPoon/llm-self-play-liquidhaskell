{"code": "f :: Int -> Int\nf x =\n  x\n", "input": "42", "status": "success", "output": "42"}
{"code": "f :: Int -> Int\nf = (+ 3)\n", "input": "42", "status": "success", "output": "45"}
{"code": "f44 :: () -> Integer\nf44 () = 44", "input": "()", "status": "success", "output": "44"}
{"code": "fInt :: Integer -> ()\nfInt _ = ()", "input": "42", "status": "success", "output": "()"}
{"code": "fInt :: Integer -> ()\nfInt x = ()", "input": "42", "status": "success", "output": "()"}
{"code": "m::Int->[Int]\nm r=[s*r|s<-[1..10]]", "input": "42", "status": "success", "output": "[42,84,126,168,210,252,294,336,378,420]"}
{"code": "test :: Int -> Int\ntest n = n + 1\n", "input": "42", "status": "success", "output": "43"}
{"code": "f :: Int -> Int\nf 0\n  = 1\nf x\n  = x\n", "input": "42", "status": "success", "output": "42"}
{"code": "f :: Int -> Maybe Int\nf n = Just (n+1)", "input": "42", "status": "success", "output": "Just 43"}
{"code": "double :: Int -> Int\ndouble x = x * 2\n", "input": "42", "status": "success", "output": "84"}
{"code": "m :: Int -> (Int, Bool)\nm x = (x, True)", "input": "42", "status": "success", "output": "(42,True)"}
{"code": "f i = i :: Int\n\ng :: Int -> ()\ng i = ()\n", "input": "42", "status": "success", "output": "()"}
{"code": "foo :: Int -> Int\nfoo bar = bar * 10 + 4\n", "input": "42", "status": "success", "output": "424"}
{"code": "isBigGang :: Int -> Bool\nisBigGang x = x > 9", "input": "42", "status": "success", "output": "True"}
{"code": "double :: Integer -> Integer\ndouble x = x + x", "input": "42", "status": "success", "output": "84"}
{"code": "import Control.Monad\nf :: Int -> Int\nf = (+ 3)\n", "input": "42", "status": "success", "output": "45"}
{"code": "addPair :: (Int,Int) -> Int\naddPair (x,y) = x + y", "input": "(42, 42)", "status": "success", "output": "84"}
{"code": "fac :: Integer -> Integer\nfac n = product [1..n]\n", "input": "42", "status": "success", "output": "1405006117752879898543142606244511569936384000000000"}
{"code": "p :: Int -> Int\np x = x\n\nq :: Int -> Bool\nq _ = True", "input": "42", "status": "success", "output": "42"}
{"code": "fact :: Int -> Int\nfact 0 = 1\nfact x = x * fact(x-1)", "input": "42", "status": "success", "output": "7538058755741581312"}
{"code": "factorial :: Int -> Int\nfactorial n = product [1..n]\n", "input": "42", "status": "success", "output": "7538058755741581312"}
{"code": "doubleAll :: [Int] -> [Int]\ndoubleAll xs = map (^2) xs", "input": "[42, 42]", "status": "success", "output": "[1764,1764]"}
{"code": "fact :: Int -> Int\nfact 0 = 1\nfact n = n * fact (n - 1)", "input": "42", "status": "success", "output": "7538058755741581312"}
{"code": "guard :: Bool -> [()]\nguard True = [()]\nguard False = []", "input": "True", "status": "success", "output": "[()]"}
{"code": "f :: Int -> String\nf x = show (x,x,x)\n\n--g = 1.0 :: Int\n", "input": "42", "status": "success", "output": "\"(42,42,42)\""}
{"code": "factorial :: Integer -> Integer\nfactorial n = product [1..n]\n", "input": "42", "status": "success", "output": "1405006117752879898543142606244511569936384000000000"}
{"code": "valor::Int -> Int\nvalor a | a>0 = a | a<0 = a*(-1) | a==0 = 0", "input": "42", "status": "success", "output": "42"}
{"code": "facto::Int -> Int\nfacto n | n>0 = n | n<0 = n*(-1) | n==0 = 0\n", "input": "42", "status": "success", "output": "42"}
{"code": "s :: Int -> Int\ns n | n == 1 = 1\n    | otherwise = n + s (n-1)", "input": "42", "status": "success", "output": "903"}
{"code": "eje13 :: [Int] -> Int\neje13 xs = sum (filter even (map (^2) xs))", "input": "[42, 42]", "status": "success", "output": "3528"}
{"code": "\nsum' :: [Integer] -> Integer \nsum' = foldl (\\acc x -> acc + x) 0\n", "input": "[42, 42]", "status": "success", "output": "84"}
{"code": "f :: Int -> [Int]\nf i = [ j | j <- [i], h <- [j], k <- [h]]\n\ng i = i", "input": "42", "status": "success", "output": "[42]"}
{"code": "f3 :: Int -> Int\nf3 0 = 0\nf3 x = if x < 0\n       then -1\n       else 1\n", "input": "42", "status": "success", "output": "1"}
{"code": "-- Lazy typesafe BKK cipher\nbkkCrypt :: String -> String\nbkkCrypt = id\n", "input": "\"hello\"", "status": "success", "output": "\"hello\""}
{"code": "sumnats :: Int -> Int\nsumnats n = foldr (+) 0 (map (\\x -> x^2) [1..n])\n", "input": "42", "status": "success", "output": "25585"}
{"code": "import Data.Char\nnextchar :: Char  -> Char\nnextchar c = chr ((ord c) + 1)", "input": "'a'", "status": "success", "output": "'b'"}
{"code": "par::Int->String\npar x = if mod x 2==0 then \"Numero par\" else \"Numero impar\"", "input": "42", "status": "success", "output": "\"Numero par\""}
{"code": "factorial :: Int -> Int\nfactorial 0 = 1\nfactorial n = n * factorial (n - 1)\n", "input": "42", "status": "success", "output": "7538058755741581312"}
{"code": "power :: (Int , Int) -> Int\npower (x, 0) = 1\npower (x, y) = x * power(x,y-1)\n", "input": "(42, 42)", "status": "success", "output": "4121466560160202752"}
{"code": "myAbs :: Integer -> Integer\nmyAbs x =\n  if (x >= 0)\n    then x\n    else x * (-1)\n", "input": "42", "status": "success", "output": "42"}
{"code": "f4 :: Int -> Int\nf4 x\n    | x < 0     = 0\n    | x > 0     = 1\n    | otherwise = 2\n", "input": "42", "status": "success", "output": "1"}
{"code": "toNat :: [()] -> Int\ntoNat = length\n\ntoLst :: Int -> [()]\ntoLst n = replicate n ()", "input": "[(), ()]", "status": "success", "output": "2"}
{"code": "factorial :: Integer -> Integer\nfactorial 0 = 1\nfactorial n = n * factorial (n - 1)", "input": "42", "status": "success", "output": "1405006117752879898543142606244511569936384000000000"}
{"code": "factorial :: Integer -> Integer\nfactorial 0 = 1\nfactorial x = x * factorial (x - 1)", "input": "42", "status": "success", "output": "1405006117752879898543142606244511569936384000000000"}
{"code": "sumtorial :: Integer -> Integer\nsumtorial 0 = 0\nsumtorial n = n + sumtorial (n - 1)\n", "input": "42", "status": "success", "output": "903"}
{"code": "area :: Double -> Double\narea x = c + s\n\twhere\n\tc = (x / 2) ^ 2 * pi / 2\n\ts = x ^ 2\n", "input": "2.71", "status": "success", "output": "10.2281213259036"}
{"code": "\nsquare :: [Double] -> [Double]\nsquare (x:xs) = x^2 : square xs\nsquare []     = []\n\n\n", "input": "[2.71, 2.71]", "status": "success", "output": "[7.3441,7.3441]"}
{"code": "f1 :: Int -> Int\nf1 x = x + c where\n    a = 1\n    b = 2\n    c = d - a\n    d = b + 2\n\n", "input": "42", "status": "success", "output": "45"}
{"code": "euclideanNorm :: [Double] -> Double\neuclideanNorm p = sqrt . sum $ map (\\ n -> n*n) p", "input": "[2.71, 2.71]", "status": "success", "output": "3.8325187540310877"}
{"code": "revR :: [Int] -> [Int]\nrevR [] = []\nrevR (x:[]) = [] ++ [x]\nrevR (x:xs) = revR(xs) ++ [x]", "input": "[42, 42]", "status": "success", "output": "[42,42]"}
{"code": "numeroMayor:: Int->Int\nnumeroMayor x = if x > 100\n            then x\n            else x*2", "input": "42", "status": "success", "output": "84"}
{"code": "multipleNumber :: Int -> [Int]\nmultipleNumber m = [x | x <- [1,2..100], (x `mod` m) == 0]\n", "input": "42", "status": "success", "output": "[42,84]"}
{"code": "p :: (Int, Int, Bool) -> Int\np (x, _, _) = x\n\nq :: (Int, Int, Bool) -> Bool\nq (_, _, b) = b", "input": "(42, 42, True)", "status": "success", "output": "42"}
{"code": "sumList :: [Int] -> Int\nsumList l = if length l == 0 then 0 else head l + sumList (tail l)\n", "input": "[42, 42]", "status": "success", "output": "84"}
{"code": "removeNonUppercase :: [Char] -> [Char]\nremoveNonUppercase st=[x|x<-st,x `elem` ['A'..'Z']]\n", "input": "['a', 'a']", "status": "success", "output": "\"\""}
{"code": "sumaListas::[[Int]]->[Int]\nsumaListas []=[]\nsumaListas (xss:xs) = [sum xss] ++ sumaListas xs\n", "input": "[[42, 42], [42, 42]]", "status": "success", "output": "[84,84]"}
{"code": "f :: Int -> Either String Int\nf a = if a < 5\n      then Right a\n      else Left \"Wrong data\"\n", "input": "42", "status": "success", "output": "Left \"Wrong data\""}
{"code": "selectEvenPos :: [Int] -> [Int]\nselectEvenPos xs = [xs!!x |\u00a0x <- [0..(length xs)-1], even (x)]", "input": "[42, 42]", "status": "success", "output": "[42]"}
{"code": "myFilter :: String -> [String]\nmyFilter = filter (\\x -> notElem x [\"a\", \"an\", \"the\"]) . words \n", "input": "\"hello\"", "status": "success", "output": "[\"hello\"]"}
{"code": "mc91 :: Integer -> Integer\nmc91 n\n  | n > 100 = (n - 10)\n  | otherwise = (mc91 . mc91) (n + 11)\n", "input": "42", "status": "success", "output": "91"}
{"code": "--need prelude\nf :: Int -> Int\nf = (+1)\n\nexs :: [([Int],[Int])]\nexs = \n  [ ([1,2,3],[2,3,4])\n  ]\n\n", "input": "42", "status": "success", "output": "43"}
{"code": "factorial :: Integer -> Integer\nfactorial x\n    | x > 1 = x * factorial (x - 1)\n    | otherwise = 1", "input": "42", "status": "success", "output": "1405006117752879898543142606244511569936384000000000"}
{"code": "lucky :: Int -> String\nlucky 7 = \"LUCKY NUMBER SEVEN!\"\nlucky x = \"Sorry, you're out of luck, pal!\"\n", "input": "42", "status": "success", "output": "\"Sorry, you're out of luck, pal!\""}
{"code": "noArts :: String -> [String]\nnoArts xs = filter (\\x -> not (elem x [\"the\", \"a\", \"an\"])) $ words xs\n", "input": "\"hello\"", "status": "success", "output": "[\"hello\"]"}
{"code": "countDigits :: Integer -> Integer\ncountDigits 0 = 0\ncountDigits n = succ $ countDigits $ quot n 10\n\n", "input": "42", "status": "success", "output": "2"}
{"code": "factorial :: Integer -> Integer\nfactorial 0 = 0\nfactorial 1 = 1\nfactorial n = n * factorial ( n - 1 )", "input": "42", "status": "success", "output": "1405006117752879898543142606244511569936384000000000"}
{"code": "factorial :: Integer -> Integer\nfactorial 0 = 1;\nfactorial 1 = 1;\nfactorial x = x * factorial (x - 1)\n", "input": "42", "status": "success", "output": "1405006117752879898543142606244511569936384000000000"}
{"code": "sumNaturals :: Int -> Int\nsumNaturals limit = sum [ x | x <- [1..limit], x `rem` 3 == 0 || x `rem` 5 == 0]", "input": "42", "status": "success", "output": "450"}
{"code": "dist0 :: (Double, Double) -> Double\ndist0 (x, y) = sqrt $ x ^ 2 + y ^ 2\n\np :: (Double, Double)\np = (9, 5)\n", "input": "(2.71, 2.71)", "status": "success", "output": "3.8325187540310877"}
{"code": "doublelist :: [Integer] -> [Integer]\ndoublelist []     = []\ndoublelist (x:xs) = (x * 2) : (doublelist xs)\n", "input": "[42, 42]", "status": "success", "output": "[84,84]"}
{"code": "allEven :: [Integer] -> [Integer]\nallEven [] = []\nallEven (h:t) = if even h then h:allEven t else allEven t", "input": "[42, 42]", "status": "success", "output": "[42,42]"}
{"code": "startsWithSymbol :: (String, String, Int) -> Bool\nstartsWithSymbol (name, symbol, _) = isPrefixOf symbol name", "input": "(\"hello\", \"hello\", 42)", "status": "success", "output": "True"}
{"code": "listToNumber :: [Int] -> Int\nlistToNumber [] = 0\nlistToNumber (x:xs) = x*(10^(length xs)) + (listToNumber xs)", "input": "[42, 42]", "status": "success", "output": "462"}
{"code": "\n-- Type annotation (optional)\nfactorial :: Integer -> Integer\n \n-- Using a list\nfactorial n = product [1..n]\n", "input": "42", "status": "success", "output": "1405006117752879898543142606244511569936384000000000"}
{"code": "calcBmis :: [( Double, Double)] -> [Double]\ncalcBmis xs = [bmi | (w, h) <- xs, let bmi = w / h ^ 2, bmi > 25.0]\n", "input": "[(2.71, 2.71), (2.71, 2.71)]", "status": "success", "output": "[]"}
{"code": "-- Defina a fun\u00e7\u00e3o cubo :: Int -> Int que calcula\n-- o cubo de um n\u00famero.\n\ncube :: (Int) -> Int\ncube x = x^3\n\n", "input": "(42)", "status": "success", "output": "74088"}
{"code": "findMax :: [Int] -> Int\nfindMax [x] = x\nfindMax (x : y : ys)\n\t|x >= y   = findMax(x:ys)\n\t|otherwise = findMax (y:ys)\n", "input": "[42, 42]", "status": "success", "output": "42"}
{"code": "\n\ntestWhere :: [Char] -> Char\ntestWhere [] = 'e'\ntestWhere xs = theFirst xs\n   where theFirst (h:_) = h\n\n-- test git\n", "input": "['a', 'a']", "status": "success", "output": "'a'"}
{"code": "twiceWhenEven :: [Integer] -> [Integer]\ntwiceWhenEven xs = do\n  x <- xs\n  if even x\n    then [x*x, x*x]\n    else [x*x]\n", "input": "[42, 42]", "status": "success", "output": "[1764,1764,1764,1764]"}
{"code": "pos:: Int -> String\npos a | a>0 = show(a)++\" Es positivo\" | a<0 = show(a)++\" Es negativo\" | a==0 = show(a)++\" Es cero\" ", "input": "42", "status": "success", "output": "\"42 Es positivo\""}
{"code": "-- Defina uma fun\u00e7\u00e3o negar :: Int -> Int para mudar o\n-- sinal de um n\u00famero inteiro\n\ndeny :: (Int) -> Int\ndeny x = -x\n", "input": "(42)", "status": "success", "output": "-42"}
{"code": "{-- snippet fragment --}\nmean :: [Double] -> Double\nmean xs = sum xs / fromIntegral (length xs)\n{-- /snippet fragment --}\n", "input": "[2.71, 2.71]", "status": "success", "output": "2.71"}
{"code": "import           Data.Char\nimport           Data.List\n\naddPairs :: [(Int, Int)] -> [Int]\naddPairs xs = [x+y  | (x,y) <- xs]", "input": "[(42, 42), (42, 42)]", "status": "success", "output": "[84,84]"}
{"code": "\n-- Type annotation (optional)\nfactorial :: Integer -> Integer\n \n-- Point-free style\nfactorial = foldr (*) 1 . enumFromTo 1\n", "input": "42", "status": "success", "output": "1405006117752879898543142606244511569936384000000000"}
{"code": "positive :: [Int] -> Int \r\npositive  [] \t=0\r\npositive  (x:xs)\t\r\n\t| x > 0 =  1+ (positive xs)\r\n\t| otherwise = positive xs\r\n \r\n\r\n", "input": "[42, 42]", "status": "success", "output": "2"}
{"code": "urlEncode :: String -> String\nurlEncode [] = []\nurlEncode (' ':xs) = \"%20\" ++ urlEncode xs\nurlEncode (x:xs) = x : urlEncode xs\n", "input": "\"hello\"", "status": "success", "output": "\"hello\""}
{"code": "myWords :: [Char] -> [[Char]]\nmyWords [] = []\nmyWords xs = (takeWhile (/= ' ') xs) : (myWords (drop 1 $ dropWhile (/= ' ') xs))\n", "input": "['a', 'a']", "status": "success", "output": "[\"aa\"]"}
{"code": "doubleSmallNumber :: Int -> Int\ndoubleSmallNumber x = if x<100\n                         then x*2\n                         else x\n", "input": "42", "status": "success", "output": "84"}
{"code": "to_tens :: Integer -> [Integer]\r\nto_tens 0 = []\r\nto_tens n = to_tens (n `div` 10) ++ [n `mod` 10] \r\n\r\nans = sum $ to_tens (2^1000)", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "rotateMatrix :: [[Integer]] -> [[Integer]]\nrotateMatrix = reverse . transpose\n  where transpose = foldr (zipWith (:)) (repeat [])\n", "input": "[[42, 42], [42, 42]]", "status": "success", "output": "[[42,42],[42,42]]"}
{"code": "-- Compute the sum of the integers from 1 to n.\nsumtorial :: Integer -> Integer\nsumtorial 0 = 0\nsumtorial n = n + sumtorial (n-1)\n\n", "input": "42", "status": "success", "output": "903"}
{"code": "\n-- Type annotation (optional)\nfactorial :: Integer -> Integer\n \n-- Using fold (implements product)\nfactorial n = foldl1 (*) [1..n]\n", "input": "42", "status": "success", "output": "1405006117752879898543142606244511569936384000000000"}
{"code": "calcBmis :: [(Double, Double)] -> [Double]\ncalcBmis xs = [bmi w h | (w, h) <- xs]\n    where bmi weight height = weight / height ^ 2\n", "input": "[(2.71, 2.71), (2.71, 2.71)]", "status": "success", "output": "[0.36900369003690037,0.36900369003690037]"}
{"code": "tribonacci :: Int -> Int\ntribonacci n =\n  let initList = [1,1,0] in\n    head $ foldl (\\x _ -> ((sum $ take 3 x) : x)) initList [3..n]\n", "input": "42", "status": "success", "output": "43844049029"}
{"code": "--import Control.Monad.Instances    \naddStuff :: Int -> Int  \naddStuff = do      \n  a <- (*2)      \n  b <- (+10)      \n  return (a+b) ", "input": "42", "status": "success", "output": "136"}
{"code": "sumN :: Integer -> Integer\nsumN n = sum [0 .. n]\n\nsum3N :: Integer -> Integer\nsum3N n = sum $ filter ((== 0) . (`mod` 3)) [0 .. 3 * n]\n", "input": "42", "status": "success", "output": "903"}
{"code": "firstLetter :: String -> String\nfirstLetter \"\" = \"Empty string\"\nfirstLetter all@(x:xs) = \"The first letter of \" ++ all ++ \" is \" ++ [x]\n", "input": "\"hello\"", "status": "success", "output": "\"The first letter of hello is h\""}
{"code": "cuenta_signo:: [Int] -> (Int, Int)\ncuenta_signo l\n  | l == [] = (0,0)\n  | otherwise = (length [x | x<-l, x>0], length [x | x<-l, x<0] )\n", "input": "[42, 42]", "status": "success", "output": "(2,0)"}
{"code": "sayMe :: Int -> String\nsayMe 1 = \"One!\"\nsayMe 2 = \"Two!\"\nsayMe 3 = \"Three!\"\nsayMe 4 = \"Four!\"\nsayMe 5 = \"Five!\"\nsayMe x = \"Not in range\"\n", "input": "42", "status": "success", "output": "\"Not in range\""}
{"code": "sumOfSquares n = sum $ map (^2) [1..n]\n\nsquareOfSum n = sum [1..n] ^ 2\n\nsolve :: Integer -> Integer\nsolve n = squareOfSum n - sumOfSquares n\n", "input": "42", "status": "success", "output": "789824"}
{"code": "sumUncurried :: (Integer, Integer) -> Integer\nsumUncurried (a, b) = a + b\n\nsumCurried :: Integer -> Integer -> Integer\nsumCurried a b = a + b\n", "input": "(42, 42)", "status": "success", "output": "84"}
{"code": "-- Defina a fun\u00e7\u00e3o cubo utilizando a fun\u00e7\u00e3o quadrado.\n\nsquare :: (Int) -> Int\nsquare x = x^2\n\ncube :: (Int) -> Int\ncube x = square(x) * x\n", "input": "(42)", "status": "success", "output": "1764"}
{"code": "leapyear :: Int -> Bool\nleapyear year \n\t| mod year 4 == 0 = True\n\t| mod year 100 == 0 = False\n\t| mod year 400 == 0 = True\n\t| otherwise = False", "input": "42", "status": "success", "output": "False"}
{"code": "totient :: Int -> Int\ntotient 1 = 1\ntotient m = length $ filter (coprime m) [1..m-1]\n\ncoprime :: Int -> Int -> Bool\ncoprime a b = gcd a b == 1\n", "input": "42", "status": "success", "output": "12"}
{"code": "fibs = 0 : 1 : zipWith (+) fibs (tail fibs)\n\n    \nevenValuedFiboSum :: Int -> Int\nevenValuedFiboSum n = sum $ filter even $ takeWhile (<=n) fibs", "input": "42", "status": "success", "output": "44"}
{"code": "import Data.Either\n\ndigits :: Int -> Int\ndigits = length . show\n\nshowResult :: (Either a b) -> Int\nshowResult a = if (isRight a) then 1 else 2\n\n", "input": "42", "status": "success", "output": "2"}
{"code": "quicksort :: [Int] -> [Int]\nquicksort [] = []\nquicksort (x:xs) = quicksort [x1 | x1 <- xs, x1 < x] ++ [x] ++ quicksort [x2 | x2 <- xs, x2 >= x]\n", "input": "[42, 42]", "status": "success", "output": "[42,42]"}
{"code": "factorial :: Integer -> Integer\nfactorial 1 = 1\nfactorial n = n * factorial (n - 1)\n\nsolve = sum . map (read . return) . show . factorial $ 100\n", "input": "42", "status": "success", "output": "1405006117752879898543142606244511569936384000000000"}
{"code": "-- file: ch04/Filter.hs\n\noddList :: [Int] -> [Int]\noddList [] = []\noddList (x:xs)\n    | odd x     = x : oddList xs\n    | otherwise = oddList xs\n\n", "input": "[42, 42]", "status": "success", "output": "[]"}
{"code": "firstLetter :: String -> String\nfirstLetter \"\" = \"Empty string, whoops!\"\nfirstLetter all@(x:xs) = \"The first letter of \" ++ all ++ \" is \" ++ [x]\n", "input": "\"hello\"", "status": "success", "output": "\"The first letter of hello is h\""}
{"code": "\n-- Type annotation (optional)\nfactorial :: Integer -> Integer\n \n---- Using recursion\nfactorial 0 = 1\nfactorial n | n > 0 = n * factorial (n - 1)\n", "input": "42", "status": "success", "output": "1405006117752879898543142606244511569936384000000000"}
{"code": "fib :: Int -> Int\nfib n = fib' 0 1 n where\n    fib' :: Int -> Int -> Int -> Int\n    fib' x0 _ 0 = x0\n    fib' x0 x1 n = fib' x1 (x0 + x1) (n - 1)\n\n", "input": "42", "status": "success", "output": "267914296"}
{"code": "isPrime :: Integer -> Bool\nisPrime n = and [ n `mod` i /= 0 | i <- [2..n-1]]\n\nprimeList :: Integer -> [Integer]\nprimeList n = filter isPrime [2..n]", "input": "42", "status": "success", "output": "False"}
{"code": "myWords :: String -> [String]\nmyWords [] = []\nmyWords (' ' : cs) = myWords cs\nmyWords cs = (takeWhile (/= ' ') cs) : myWords (dropWhile (/= ' ') cs)", "input": "\"hello\"", "status": "success", "output": "[\"hello\"]"}
{"code": "\n\nevenList :: [Int] -> [Int]\nevenList (x:xs) | even x    = x : evenList xs\n                | otherwise = evenList xs\nevenList []                 = []\n", "input": "[42, 42]", "status": "success", "output": "[42,42]"}
{"code": "selectEven :: [Int] -> [Int]\nselectEven [] = []\nselectEven xs \n\t| even (last xs) = selectEven (init xs) ++ [last xs]\n\t| otherwise = selectEven (init xs)", "input": "[42, 42]", "status": "success", "output": "[42,42]"}
{"code": "reverseInt :: Integer -> Integer\nreverseInt x | x < 0     = 0 - (read . reverse . tail . show $ x)\n             | otherwise = read . reverse . show $ x\n", "input": "42", "status": "success", "output": "24"}
{"code": "moveZero :: [Int] -> [Int]\nmoveZero = foldr (\\x acc -> if x /= 0\n                            then x:acc\n                            else acc ++ [x]) []\n", "input": "[42, 42]", "status": "success", "output": "[42,42]"}
{"code": "halve :: Double -> Double\nhalve = (/ 2)\n\nseven :: Integer\nseven = 7\n\nconvert :: (Double -> Double) -> Integer -> Double\nconvert f n = f $ fromIntegral n\n", "input": "2.71", "status": "success", "output": "1.355"}
{"code": "user_pred :: Int -> Bool\nuser_pred x = x > 1\n\nexs :: [([Int], [Int])]\nexs = [ ( [1,2,3,4], [2,3,4] ),\n        ( [-1,-2], [] ),\n        ( [0, 1, 2], [2] ) ]\n", "input": "42", "status": "success", "output": "True"}
{"code": "factor :: Integer -> Integer\nfactor n\n\t| n < 2 = 1\n\t| otherwise = head $ filter ((== 0) . (n `mod`)) [2 ..]\n\nsquares :: [Integer]\nsquares = map (^ 2) [0 ..]\n", "input": "42", "status": "success", "output": "2"}
{"code": "add1 :: Integer -> Integer\r\nadd1 x = 1 + x\r\n\r\nasc :: [Integer]\r\nasc = 1 : map add1 asc\r\n\r\ndoubling :: [Integer]\r\ndoubling = 1 : zipWith (+) doubling doubling\r\n", "input": "42", "status": "success", "output": "43"}
{"code": "primes :: Integer -> [Integer]\nprimes n = filterPrime [2..n] \n  where filterPrime [] = []\n\tfilterPrime (p:xs) =  p : filterPrime [x | x <- xs, x `mod` p /= 0]\n", "input": "42", "status": "success", "output": "[2,3,5,7,11,13,17,19,23,29,31,37,41]"}
{"code": "fact n = product [1..n]\r\n\r\nto_tens :: Integer -> [Integer]\r\nto_tens 0 = []\r\nto_tens n = to_tens (n `div` 10) ++ [n `mod` 10] \r\n\r\n\r\nans = sum $ to_tens $ fact 100", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "isPrime :: Int -> Bool\nisPrime 1 = False\nisPrime n = let lim = floor $ sqrt $ fromIntegral n\n             in foldl (\\acc x -> acc && rem n x /= 0) True [2..lim]\n", "input": "42", "status": "success", "output": "False"}
{"code": "square :: Integer -> Integer\nsquare x = x*x\n\nsumSquare n = sum $ fmap square [1..n]\nsquareSum n = square $ sum [1..n]\n\ndifference n = (sumSquare n) - (squareSum n)\n", "input": "42", "status": "success", "output": "1764"}
{"code": "-- Defina a fun\u00e7\u00e3o menor :: Int -> Int que devolve\n-- o menor de dois inteiros.\n\nlower :: (Int, Int) -> Int\nlower (a, b) | a < b = a\n             | otherwise = b\n", "input": "(42, 42)", "status": "success", "output": "42"}
{"code": "reserveStr :: String -> String\nreserveStr []     = []\nreserveStr (c:cs) =  reserveStr cs ++ [c]\n\nisAnagram :: String -> String -> Bool\nisAnagram = ((==).reserveStr)\n", "input": "\"hello\"", "status": "success", "output": "\"olleh\""}
{"code": "import Data.List (sort)\n\ndifferentPairs :: String -> Bool\ndifferentPairs s = and $ zipWith (/=) s (tail s)\n\nisUnique :: String -> Bool\nisUnique = differentPairs . sort\n", "input": "\"hello\"", "status": "success", "output": "False"}
{"code": " --Dise\u00f1ar una funcion en Haskell para calcular el factorial de un numero positivo.\nfactorial:: Int -> Int\nfactorial n | n==0 = 0 | n > 1 = n *factorial(n-1)| n==1 = 1\n", "input": "42", "status": "success", "output": "7538058755741581312"}
{"code": "factorial :: Integer -> Integer\nfactorial 0 = 1\nfactorial n = n * factorial (n - 1)\n\n--solution = 40 choose 20\nsolution = factorial 40 `div` (factorial 20 * factorial 20)", "input": "42", "status": "success", "output": "1405006117752879898543142606244511569936384000000000"}
{"code": "-- Aufgabe 12.1\n-- | The 'f' function returns a reversed list of non-zero integers\n--\nf :: [Int] -> [Int]\nf []\t\t\t= []\nf (x:xs)\n\t| x > 0 \t= f xs ++ [x]\n\t| otherwise = f xs\n", "input": "[42, 42]", "status": "success", "output": "[42,42]"}
{"code": "greatest :: Integer -> Integer\ngreatest n\n\t| modOfTen == n = n\n\t| otherwise     = modOfTen `max` greatest quotOfTen\n\twhere modOfTen  = mod n 10\n\t      quotOfTen = quot n 10", "input": "42", "status": "success", "output": "4"}
{"code": "fizzbuzz :: Int -> String\nfizzbuzz x | mod x 15 == 0 = \"FizzBuzz\"\n           | mod x 5 == 0  = \"Buzz\"\n           | mod x 3 == 0  = \"Fizz\"\n           | otherwise     = show x\n", "input": "42", "status": "success", "output": "\"Fizz\""}
{"code": "\n-- Type annotation (optional)\nfactorial :: Integer -> Integer\n \n-- Using recursion but written without pattern matching\nfactorial n = if n > 0 then n * factorial (n-1) else 1", "input": "42", "status": "success", "output": "1405006117752879898543142606244511569936384000000000"}
{"code": "import Data.List\n\nstrangeSort :: [Int] -> [Int]\nstrangeSort [] = []\nstrangeSort xs = sort oddXs ++ reverse (sort evenXs) where\n  oddXs = [x | x<-xs, odd x]\n  evenXs = xs \\\\ oddXs", "input": "[42, 42]", "status": "success", "output": "[42,42]"}
{"code": "-- this function has the same effect as\n-- (+) <$> (*2) <*> (+10)\n\nimport Control.Monad.Instances\n\naddStuff :: Int -> Int\naddStuff = do\n    a <- (*2)\n    b <- (+10)\n    return (a+b)\n", "input": "42", "status": "success", "output": "136"}
{"code": "addDigits :: Int -> Int\naddDigits num\n  | num < 0 = -1\n  | num `elem` [0..9] = num\n  | num >= 10 = addDigits (sum (sepa num))\n  where sepa num = map (\\x -> read [x]::Int) (show num)\n", "input": "42", "status": "success", "output": "6"}
{"code": "d::Int->Double\nd 1 = 1.0\nd k = d (k-1) * sqrt (1 / (2*(1+cos(pi/3/(2^^(k-1))))))\n\ns::Int->Double\ns 1 = 2*d 1\ns k = (2^(k)) * (d k) --s (k-1) - d (k-1) + 2 * (d k)\n\nphi = (1.0+sqrt(5))/2.0", "input": "42", "status": "success", "output": "4.762103122614447e-13"}
{"code": "factorial :: Integer -> Integer\nfactorial n = product[1..n]\n\ncircumference :: Float -> Float\ncircumference r = 2 * pi * r\n\ncircumference' :: Double -> Double\ncircumference' r = 2 * pi * r\n", "input": "42", "status": "success", "output": "1405006117752879898543142606244511569936384000000000"}
{"code": "factorial :: Integer -> Integer\n-- factorial n = product [1..n]\n\n-- factorial 0 = 1\n-- factorial n = n * factorial (n - 1)\n\nfactorial n\n  | n == 0 = 1\n  | otherwise = n * factorial (n - 1)\n", "input": "42", "status": "success", "output": "1405006117752879898543142606244511569936384000000000"}
{"code": "isBigGang :: Int -> (Bool,String)\nisBigGang x = (x > 9, \"Compared gang size to 9.\")\n\napplyGang :: Monoid m => (a,m)->(a->(b,m))->(b,m)\napplyGang (x,s) f = let (y,s')=f x in (y,s`mappend`s')", "input": "42", "status": "success", "output": "(True,\"Compared gang size to 9.\")"}
{"code": "{-- snippet oddList --}\noddList :: [Int] -> [Int]\n\noddList (x:xs) | odd x     = x : oddList xs\n               | otherwise = oddList xs\noddList _                  = []\n{-- /snippet oddList --}\n", "input": "[42, 42]", "status": "success", "output": "[]"}
{"code": "-- Determine if a natural number is prime.\n\nisPrime :: Int -> Bool\nisPrime x = if x == 1 then True else null [k | k <- [2..isqrt x], x `mod` k == 0]\n    where isqrt = floor . sqrt . fromIntegral\n", "input": "42", "status": "success", "output": "False"}
{"code": "isPrime :: Int -> Bool\nisPrime n = isPrime' n 2\n\nisPrime' :: Int -> Int -> Bool\nisPrime' 2 _ = True\nisPrime' n k\n\t| (n - 1) == k = True\n\t| n `mod` k == 0 = False\n\t| otherwise = isPrime' n (k + 1)\n", "input": "42", "status": "success", "output": "False"}
{"code": "playerRankUp :: Integer -> [Char]\nplayerRankUp points = if points >= 100\n    then \"Well done! You have advanced to the qualifying stage. Win 2 out of your next 3 games to rank up.\"\n    else \"False\"", "input": "42", "status": "success", "output": "\"False\""}
{"code": "import qualified Data.Set as Set\n\ndistinctPowers :: Int -> Int\ndistinctPowers n = let l = [2..n]\n                    in length $ Set.fromList  [ a^b | a <- l, b <- l]\n\n-- distinctPowers 100 == 9183\n", "input": "42", "status": "success", "output": "1357"}
{"code": "fibonacci :: Integer -> Integer\nfibonacci n = \n    let helper a b n | n == 0 = a\n                     | n == 1 = b\n                     | otherwise = helper b (a + b) (n - 1)\n    in helper 0 1 (abs n)\n", "input": "42", "status": "success", "output": "267914296"}
{"code": "fizzbuzz :: Integer -> [String]\nfizzbuzz n = map f [1..n]\n\nf :: Integer -> String\nf n | n `mod` 15 == 0 = \"fizzbuzz\"\n    | n `mod` 3 == 0 = \"fizz\"\n    | n `mod` 5 == 0 = \"buzz\"\n    | otherwise = show n\n", "input": "42", "status": "success", "output": "[\"1\",\"2\",\"fizz\",\"4\",\"buzz\",\"fizz\",\"7\",\"8\",\"fizz\",\"buzz\",\"11\",\"fizz\",\"13\",\"14\",\"fizzbuzz\",\"16\",\"17\",\"fizz\",\"19\",\"buzz\",\"fizz\",\"22\",\"23\",\"fizz\",\"buzz\",\"26\",\"fizz\",\"28\",\"29\",\"fizzbuzz\",\"31\",\"32\",\"fizz\",\"34\",\"buzz\",\"fizz\",\"37\",\"38\",\"fizz\",\"buzz\",\"41\",\"fizz\"]"}
{"code": "{-# TYPE nat = {x | x > 0} #-}\n{-# TYPE notNull = {xs | not (null xs)} #-}\n\n{-# CONTRACT f :: nat -> nat #-}\nf :: Int -> Int\nf x = x \n\n{-# CONTRACT g :: notNull -> any #-}\ng :: [Int] -> Int\ng (x:xs) = x\n", "input": "42", "status": "success", "output": "42"}
{"code": "productOfDigits :: Int -> Int\nproductOfDigits 0 = 0\nproductOfDigits n = iter n 1\n    where \n        iter n result\n            |n == 0 = result\n            |otherwise = iter (div n 10) (result * mod n 10)", "input": "42", "status": "success", "output": "8"}
{"code": "dist0 :: (Double, Double) -> Double\ndist0 (x, y) = sqrt $ x ^ 2 + y ^ 2\n\ninCircle :: (Double, Double) -> Double -> (Double, Double) -> Bool\ninCircle (x0, y0) r (x, y) = (x - x0) ^ 2 + (y - y0) ^ 2 <= r ^ 2\n", "input": "(2.71, 2.71)", "status": "success", "output": "3.8325187540310877"}
{"code": "import Data.List\nimport Data.Char\n\nisPangram :: String -> Bool\nisPangram str = size == 26\n  where size = length $ foldl (\\y x -> if not (x `elem` y) && isAlpha x then [x] ++  y  else y ) [] $ map toUpper str", "input": "\"hello\"", "status": "success", "output": "False"}
{"code": "import Data.Char\n\nucfirst :: String -> String\nucfirst \"\" = \"\"\nucfirst (c:cs) = toUpper c : cs\n\ntoUpperCase :: String -> String\ntoUpperCase = map toUpper\n\nuchead :: String -> Char\nuchead = head . (map toUpper)", "input": "\"hello\"", "status": "success", "output": "\"Hello\""}
{"code": "sumN :: Integer -> Integer\nsumN n = sum [0 .. n]\n\nsum3N :: Integer -> Integer\nsum3N n = sum $ map (* 3) [0 .. n]\n\nsum3N5 :: Integer -> Integer\nsum3N5 n = sum . map (* 3) $ filter ((/= 0) . (`mod` 5)) [0 .. n]\n", "input": "42", "status": "success", "output": "903"}
{"code": "reward :: Int -> Int\nreward height =\n  reward_ind height 5000000000\n\nreward_ind :: Int -> Int -> Int\nreward_ind height init =\n  if height < 210000\n  then init\n  else reward_ind (height - 210000) $ init `div` 2\n", "input": "42", "status": "success", "output": "5000000000"}
{"code": "-- Dada a fun\u00e7\u00e3o abaixo\nfun :: (Int) -> Int\nfun x | x < 10    = 1\n      | x < 5     = 2\n      | otherwise = 3\n-- Qual o resultado das seguintes avalia\u00e7\u00f5es?\n-- a) Q: fun 1\n--    R: 1\n-- b) Q: fun 7\n--    R: 1", "input": "(42)", "status": "success", "output": "3"}
{"code": "doubleMe x = x + x\n\ndoubleUs x y = doubleMe x + doubleMe y\n\ndoubleSmallNumber x = if x > 100 then x else x*2\n\nremoveNonUppercase :: [Char] -> [Char]  \nremoveNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]  ", "input": "['a', 'a']", "status": "success", "output": "\"\""}
{"code": "factors :: Int -> [Int]\nfactors n = [i | i <- [1..n], (mod n i) == 0]\n\nisPrime :: Int -> Bool\nisPrime n = n > 2 && tail (factors n) == [n]\n\nnextPrime :: Int -> Int\nnextPrime n = head [i | i <- [n..], isPrime i]\n\n", "input": "42", "status": "success", "output": "[1,2,3,6,7,14,21,42]"}
{"code": "is_prime :: Int -> Bool\nis_prime n\n    | n < 2             = False\n    | n == 2            = True\n    | (n `mod` 2) == 0  = False\n    | otherwise         = all (( /=0 ).(mod n)) (takeWhile (\\x -> x*x <= n) [3,5..])\n\n", "input": "42", "status": "success", "output": "False"}
{"code": "\n\ndoubler :: Integer -> Integer\ndoubler v = v * 2\n\nsum42 :: (Integer -> Integer) -> Integer\nsum42 f = (f 42) + (f 42)\n\napply2 :: (Integer -> Integer) -> (Integer -> Integer)\napply2 f = f . f\n-- shorter : apply2 = (.)\n", "input": "42", "status": "success", "output": "84"}
{"code": "import Data.Char\nimport Data.List\n\nduplicateCount :: String -> Int\nduplicateCount input = length $ filter (\\x -> length x > 1 ) groupStr\n  where lowerStr = map toLower input\n        groupStr = group . sort $ lowerStr\n\n", "input": "\"hello\"", "status": "success", "output": "1"}
{"code": "isUgly :: Int -> Bool\nisUgly 0 = False\nisUgly a\n  | a `elem` [1,2,3,5] = True\n  | a `mod` 2 == 0 = isUgly (a `div` 2)\n  | a `mod` 3 == 0 = isUgly (a `div` 3)\n  | a `mod` 5 == 0 = isUgly (a `div` 5)\n  | otherwise = False\n\n", "input": "42", "status": "success", "output": "False"}
{"code": "divisibleByEleven = filter (\\x -> mod x 11 == 0) [100..999]\n\nisPalindrome :: Integer -> Bool\nisPalindrome x = read(reverse(show x)) == x\n\nproblem4 = maximum [x*y|x <- [100..999], y<-divisibleByEleven, isPalindrome (x*y)]\n", "input": "42", "status": "success", "output": "False"}
{"code": "to_tens :: Integer -> [Integer]\r\nto_tens 0 = []\r\nto_tens n = to_tens (n `div` 10) ++ [n `mod` 10] \r\n\r\n\r\nis_num_valid 1 = False\r\nis_num_valid num = \t\tlet tens = to_tens num\r\n\t\t\t\t\t\tin (sum $ map (\\x -> x^5) tens) == num\r\n\r\n\r\n", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "import Data.List  \n\nreverseString :: String -> String\nreverseString s = if (length s) <= 1 then s else l++r where\n  r = reverseString(take( (genericLength s) `div` 2) s)\n  l = reverseString(drop( (genericLength s) `div` 2) s)", "input": "\"hello\"", "status": "success", "output": "\"olleh\""}
{"code": "-- Products of the pythagorean triplets (a,b,c) s.t. a+b+c = n, \n-- if one exists or [] otherwise.\nprodPythTrip :: Int -> [Int]\nprodPythTrip n = [a*b*c | c <- [1..n-2], b <- [1..c-1], a <- [1..b-1], a*a + b*b == c*c, a+b+c==n]\n", "input": "42", "status": "success", "output": "[]"}
{"code": "-- two ways of examining stricteness of Haskell\n-- 1. injecting bottom\n-- 2. examing GHC core\n\ndiscriminatory :: Bool -> Int\ndiscriminatory b =\n  case b of\n    True -> 1\n    False -> 0\n\n-- on stack ghci, run ':set -ddump-simpl'\n", "input": "True", "status": "success", "output": "1"}
{"code": "-- Function declaration\nsum_of_first_n_numbers :: Integer -> Integer;\n-- Base cases\nsum_of_first_n_numbers 0 = 0;\nsum_of_first_n_numbers 1 = 1;\n-- Recursive function call\nsum_of_first_n_numbers n = n + (sum_of_first_n_numbers(n-1));", "input": "42", "status": "success", "output": "903"}
{"code": "filter' :: [Int] -> [Int]\nfilter' []       = []\nfilter' (_:s:ts) = s:(filter' ts)\nfilter' (_:[])   = []\n\nlastReminding :: [Int] -> Int\nlastReminding nL\n  | length nL == 1 = head nL\n  | otherwise = (lastReminding.reverse.filter') nL\n", "input": "[42, 42]", "status": "success", "output": "[42]"}
{"code": "isMono :: [Int] -> Bool\r\nisMono = isMonoBy (<=)\r\n\r\nisMonoBy :: (Int -> Int -> Bool) -> [Int] -> Bool\r\nisMonoBy lte = loop\r\n  where\r\n    loop []       = True\r\n    loop [_]      = True\r\n    loop (x:y:zs) = (x `lte` y) && loop (y:zs)\r\n", "input": "[42, 42]", "status": "success", "output": "True"}
{"code": "bmiTell :: Double -> String\nbmiTell bmi\n    | bmi <= 18.5 = \"Your underweight, eat more!\"\n\t| bmi <= 25.0 = \"Looking good!\"\n\t| bmi <= 30.0 = \"Your overweight. Let's work out together!\"\n\t| otherwise   = \"You're obese. Go see a doctor.\"\n", "input": "2.71", "status": "success", "output": "\"Your underweight, eat more!\""}
{"code": "import Data.List\n\npart1 :: String -> String\npart1 = map (head . head . reverse . sortOn length . group . sort) . transpose . words\n\npart2 :: String -> String\npart2 = map (head . head . sortOn length . group . sort) . transpose . words\n", "input": "\"hello\"", "status": "success", "output": "\"hello\""}
{"code": "longestSlideDown :: [[Int]] -> Int\nlongestSlideDown list = l (reverse list)\n  where l (x:[]) = head x\n        l (x:y:o) = l (s:o)\n          where s = [k + max a b | n <- [0..(length y)-1], let k = y !! n, let [a,b] = take 2 $ drop n x]", "input": "[[42, 42], [42, 42]]", "status": "success", "output": "84"}
{"code": "import Data.Monoid\n\nisBigGang :: Int -> (Bool, String)\nisBigGang x = (x > 9,\"Compared gang size to 9\")\n\napplyLog :: Monoid m => (a,m) -> (a -> (b,m)) -> (b, m)\napplyLog (x, log) f = let (y, newLog) = f x in (y, log `mappend` newLog)\n\n\n", "input": "42", "status": "success", "output": "(True,\"Compared gang size to 9\")"}
{"code": "isPrime :: Int -> Bool\nisPrime n = isDividable n (n-1)\n    where isDividable 1 _ = False\n          isDividable 2 _ = True\n          isDividable x 2 = (x `mod` 2) > 0\n          isDividable x y = (x `mod` y) > 0 && isDividable x (y - 1)\n\n", "input": "42", "status": "success", "output": "False"}
{"code": "import Text.ParserCombinators.Parsec\n\ncsvFile = endBy line eol\nline = sepBy cell (char ',')\ncell = many (noneOf \",\\n\")\neol = char '\\n'\n\nparseCSV :: String -> Either ParseError [[String]]\nparseCSV input = parse csvFile \"(unknown)\" input\n", "input": "\"hello\"", "status": "success", "output": "Left \"(unknown)\" (line 1, column 6):\nunexpected end of input\nexpecting \",\" or \"\\n\""}
{"code": "mySum :: [Integer] -> Integer\nmySum [] = 0\nmySum (x : xs) = x + mySum xs\n\nmyProduct :: [Integer] -> Integer\nmyProduct [] = 1\nmyProduct (x : xs) = x * myProduct xs\n\nmyLength :: [a] -> Int\nmyLength [] = 0\nmyLength (_ : xs) = 1 + myLength xs\n", "input": "[42, 42]", "status": "success", "output": "84"}
{"code": "seqA :: Integer -> Integer\nseqA n = \n    let helper a b c n | n == 0 = a\n                       | n == 1 = b\n                       | n == 2 = c\n                       | otherwise = helper b c (c + b - 2 * a) (n - 1)\n    in helper 1 2 3 n\n", "input": "42", "status": "success", "output": "-72069"}
{"code": "isBigGang :: Int -> (Bool, String)\nisBigGang x = let n = 9 in (x > n, \"Compared the gang size to \" ++ show n ++ \".\")\n\napplyLog :: (a, String) -> (a -> (b, String)) -> (b, String)\napplyLog (x,log) f = let (y, newLog) = f x in (y, log++newLog)", "input": "42", "status": "success", "output": "(True,\"Compared the gang size to 9.\")"}
{"code": "dec2int :: [Integer] -> Integer\n\n-- failed\n--dec2int = foldr (\\ x y -> 10 * x + y) 0\n\n-- failed\n--dec2int = foldr (\\ x y -> x + 10 * y) 0\n\n-- correct\ndec2int = foldl (\\ x y -> 10 * x + y) 0\n\n-- failed\n--dec2int = foldr (\\ x y -> 10 * x + y) 0", "input": "[42, 42]", "status": "success", "output": "462"}
{"code": "factorial :: Integer -> Integer\nfactorial 0 = 1\nfactorial n = n * factorial (n - 1)\n\nsumDigits :: Integer -> Integer\nsumDigits n\n    | n < 10    = n\n    | otherwise = n `mod` 10 + sumDigits (n `div` 10)\n    \nsolution = sumDigits $ factorial 100", "input": "42", "status": "success", "output": "1405006117752879898543142606244511569936384000000000"}
{"code": "-- find the largest palindrome of the product of two 3 digit numbers\npalindrome :: Int -> Bool\npalindrome x = show x == (reverse $ show x)\n\npalProducts = [x*y | x <- [100..999], y <- [100..999], palindrome (x*y)]\n\nproblem4 = maximum palProducts", "input": "42", "status": "success", "output": "False"}
{"code": "import Data.Char\nimport Data.List\n\ndigitSum :: Int -> Int\ndigitSum = sum . map digitToInt . show\n\nfirstTo40 :: Maybe Int\nfirstTo40 = find (\\x -> digitSum x == 40) [1..]\n\nfirstTo :: Int -> Maybe Int\nfirstTo n = find (\\x -> digitSum x == n) [1..]\n", "input": "42", "status": "success", "output": "6"}
{"code": "import Prelude\n-- Determine whether a given integer number is prime.\n-- Ineffient method\nisPrime :: Int -> Bool\nisPrime n\n    | n <= 0 = error \"You must insert a natural number.\\n\"\n    | otherwise = length [i | i <- [1..n], n `mod` i == 0] == 2\n", "input": "42", "status": "success", "output": "False"}
{"code": "import Data.List\r\nimport Data.Ord\r\n\r\nto_tens :: Int -> [Int]\r\nto_tens 0 = []\r\nto_tens n = to_tens (n `div` 10) ++ [n `mod` 10] \r\n\r\n\r\nirrational = concat $ map to_tens [1..]\r\n\r\n\r\nans = product $ map (\\x -> irrational !! (x-1)) [10^d | d <- [0..6]]", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "chain :: Integer -> [Integer]\nchain 1 = [1]\nchain n\n    | even n = n : chain (n `div` 2)\n    | odd n = n : chain (n*3 + 1)\n\nnumLongChains :: Int\nnumLongChains =\n    length (filter isLong (map chain [1..100]))\n    where isLong xs = length xs > 15\n", "input": "42", "status": "success", "output": "[42,21,64,32,16,8,4,2,1]"}
{"code": "-- Problem 30\n-- (1.00 secs, 1,320,266,496 bytes)\n\nimport Data.Char (digitToInt)\n\nsum5th :: Int -> Int\nsum5th n = sum . map (^5) . map digitToInt . show $ n\n\n-- take 6 found by observation\ne030 = sum . take 6 . filter (\\n -> n == sum5th n) $ [2..]", "input": "42", "status": "success", "output": "1056"}
{"code": "\r\nimport Data.List\r\n\r\n\r\nto_tens :: Integer -> [Integer]\r\nto_tens 0 = []\r\nto_tens n = to_tens (n `div` 10) ++ [n `mod` 10] \r\n\r\nfibs = 0 : 1 : zipWith (+) fibs (tail fibs)\r\n\r\nans = head $ filter (\\(i,x) -> (length $ show x) >= 1000) (zip [0..] fibs)", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "doubleUs x y = x * 2 + y * 2\n\ndoubleMe x = x + x\n\ndoubleSmallNumber x = if x > 100\n                        then x\n                        else x * 2\n\nremoveNonUppercase :: [Char] -> [Char]\nremoveNonUppercase st = [c | c <- st, c `elem` ['A'..'Z']]\n", "input": "['a', 'a']", "status": "success", "output": "\"\""}
{"code": "import Data.Ord (comparing)\nimport Data.List (group, minimumBy)\n\nstringCompress :: String -> String\nstringCompress s = minimumBy (comparing length) [compressed, s]\n  where compressed = foldr (\\x acc -> head x : show (length x) ++ acc) \"\" (group s)\n", "input": "\"hello\"", "status": "success", "output": "\"hello\""}
{"code": "digits :: Int -> [Int]\ndigits 0 = []\ndigits x = (x `mod` 10):(digits (x `div` 10))\n\ndigitSet :: Int -> [[Int]]\ndigitSet k = filter (\\x -> not $ 0 `elem` x) $ map digits [n..m]\n             where n = 10 ^ (k - 1)\n                   m = (10 ^ k) - 1\n\n\n", "input": "42", "status": "success", "output": "[2,4]"}
{"code": "\n-- file: ch07/return2.hs\nimport Data.Char(toUpper)\n\nisYes :: String -> Bool\nisYes inpStr = (toUpper . head $ inpStr) == 'Y'\n\nisGreen :: IO Bool\nisGreen =\n  do putStrLn \"Is green your favorite color?\"\n     inpStr <- getLine\n     return (isYes inpStr)\n", "input": "\"hello\"", "status": "success", "output": "False"}
{"code": "-- Eliminate duplicate chars in str\ncompress :: [Char] -> [Char]\n\ncompress str\n    | length str == 0 = \"\"\n    | length xs == 0 = [x]\n    | otherwise =\n        if x == head xs\n        then compress xs\n        else x : compress xs\n     where x:xs = str\n", "input": "['a', 'a']", "status": "success", "output": "\"a\""}
{"code": "fibNextPair :: (Integer, Integer) -> (Integer, Integer)\nfibNextPair (x, y) = (y, x + y)\n\nfibNthPair :: Integer -> (Integer, Integer)\nfibNthPair 1 = (1, 1)\nfibNthPair n = fibNextPair (fibNthPair (n - 1))\n\nfib :: Integer -> Integer\nfib = fst . fibNthPair", "input": "(42, 42)", "status": "success", "output": "(42,84)"}
{"code": "fact :: Num a => Integer -> a\nfact x = fromIntegral (product [1..x])\n\ncosSeries :: Double -> Integer -> Double\ncosSeries x l = sum[(helperOfCos x i) | i <- [0,2..l]]\n\nhelperOfCos x i = if i `mod` 4 == 0 then x ^ i / (fact i) else -(x ^ i) / (fact i)\n\n\n", "input": "42", "status": "success", "output": "1405006117752879898543142606244511569936384000000000"}
{"code": "fizzbuzz = map divisionCheck [1..100]\n\ndivisionCheck :: Integer -> String\ndivisionCheck n\n\t| div5 (div3 n) == 0\t= \"FizzBuzz\"\n\t| div3 n  == 0 \t \t= \"Fizz\"\n\t| div5 n  == 0 \t\t= \"Buzz\"\n\t| otherwise\t\t= show n \n\twhere \tdiv3 n = n `rem` 3\n\t\tdiv5 n = n `rem` 5\n", "input": "42", "status": "success", "output": "\"FizzBuzz\""}
{"code": "product1 :: [Int] -> Int\nproduct1 [] = 1\nproduct1 l = (head l) * product1(tail l)\n\nqsort [] = []\nqsort (x:xs) = \tqsort smaller ++ [x] ++ qsort larger\n\twhere\n\t\tsmaller = [a | a <- xs, a <= x]\n\t\tlarger = [b | b <- xs, b > x]\n\nqsortrev l = reverse(qsort l)\n", "input": "[42, 42]", "status": "success", "output": "1764"}
{"code": "isPerfect :: Int -> Int\nisPerfect x = sum [y | y <- [1..x], x /= y, x `mod` y == 0]\n\nperfects :: Int -> [Int]\nperfects x = [y | y <- [1..x], (isPerfect y) == y]\n\nscalaproduct :: [Int] -> [Int] -> Int\nscalaproduct xs ys = sum [a * b | (a, b) <- zip xs ys]\n", "input": "42", "status": "success", "output": "54"}
{"code": "whatTimeIsIt :: Float -> String\nwhatTimeIsIt angle = show hour ++ \":\" ++ show (60 - min)\n  where everyHourAngle = 360 / 12\n        everyMinAngle = 360 / 60\n        hour = angle / everyHourAngle\n        min = (angle - hour * everyHourAngle) / everyMinAngle", "input": "3.14", "status": "success", "output": "\"0.10466667:60.0\""}
{"code": "import Data.List\n\npopFactor :: Integer -> Maybe (Integer, Integer)\npopFactor n | n < 2 = Nothing\npopFactor n = Just (f, n `div` f)\n\twhere f = head $ filter ((== 0) . (n `mod`)) [2 ..]\n\nfactorization :: Integer -> [Integer]\nfactorization = unfoldr popFactor\n", "input": "42", "status": "success", "output": "Just (2,21)"}
{"code": "descomposicion::Int->[Int]\ndescomposicion n = if n < 10 then [n]\n                else descomposicion(div n 10) ++ [mod n 10]\n\nsumaDigitos::[Int]->Int\nsumaDigitos[]=0\nsumaDigitos(x:xs)=if mod x 5==0 then x+sumaDigitos xs\n                  else sumaDigitos xs\n", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "descomposicion::Int->[Int]\ndescomposicion n = if n < 10 then [n]\n                else descomposicion(div n 10) ++ [mod n 10]\n\nimpares::[Int]->[Int]\nimpares []=[]\nimpares (x:xs)=if odd x then [x]++impares xs\n                else impares(xs)\n\n                \n", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "explosiveSum :: Int -> Integer\nexplosiveSum n\n  | n < 0 = 0\n  | otherwise = s n n  \n\nmemo f = map (\\x -> map (f x) [0..]) [0..]\nstore = memo s\n\ns 0 _ = 1\ns n k = sum [memos (n-l) l | l <- [1..r]]\n    where r = if n > k then k else n\n\nmemos n k = store !! n !! k", "input": "42", "status": "success", "output": "53174"}
{"code": "unfold p h t x\n    | p x = []\n    | otherwise = h x : unfold p h t (t x)\n\ntype Bit = Int\n\nint2bin :: Int -> [Bit]\nint2bin 0 = []\nint2bin n = n `mod` 2 : int2bin (n `div` 2)\n\nchop8 :: [Bit] -> [[Bit]]\nchop8 [] = []\nchop8 bits = take 8 bits : chop8 (drop 8 bits)\n", "input": "42", "status": "success", "output": "[0,1,0,1,0,1]"}
{"code": "primeFactors :: Integer -> [Integer]\nprimeFactors n =\n  case factors of\n    [] -> [n]\n    _  -> factors ++ primeFactors (n `div` (head factors))\n  where factors = take 1 $ filter (\\x -> (n `mod` x) == 0) [2 .. n-1]\n\nanswer = maximum $ primeFactors 600851475143\n", "input": "42", "status": "success", "output": "[2,3,7]"}
{"code": "import Data.Char\n\ncountLowerCase :: String -> Int\n-- countLowerCase str = length (filter isLower str)\ncountLowerCase = length . filter isLower\n\ncountLowercaseAndDigits :: String -> Int\ncountLowercaseAndDigits =\n    length . filter (\\c -> isLower c || isDigit c)\n", "input": "\"hello\"", "status": "success", "output": "5"}
{"code": "import Data.Char \nimport Data.List \n\ndigitSum :: Int -> Int \ndigitSum = sum . map digitToInt . show\n\nno = Nothing\njh = Just \"Hey\"\n\nj5 = find (>4) [3,4,5,6,7]\nnada = find (>114) [3,4,5,6,7]\n\nfirstTo40 :: Maybe Int \nfirstTo40 = find (\\x -> digitSum x == 40) [1..]\n\n", "input": "42", "status": "success", "output": "6"}
{"code": "\ncountingLatticePath :: Int -> Integer\ncountingLatticePath n = head $ fn (take (n+1) $ repeat 1)\n  where\n    fn r@(x:[]) = r -- result\n    fn xs = let t = tail xs\n                h = head t * 2\n             in fn $ foldl (\\acc v -> acc ++ [last acc + v]) [h] (tail t)\n\n", "input": "42", "status": "success", "output": "1678910486211891090247320"}
{"code": "carry :: [Integer] -> [Integer]\ncarry [] = []\ncarry [0] = []\ncarry [x] = m : carry [d]\n  where (d, m) = divMod x 10\ncarry (x:y:xs) = m : carry (y + d : xs)\n  where (d, m) = divMod x 10\n\nsumLists :: [Integer] -> [Integer] -> [Integer]\nsumLists = (carry .) . zipWith (+)\n", "input": "[42, 42]", "status": "success", "output": "[2,6,4]"}
{"code": "{-- snippet all --}\nimport Data.Char(toUpper)\n\nisYes :: String -> Bool\nisYes inpStr = (toUpper . head $ inpStr) == 'Y'\n\nisGreen :: IO Bool\nisGreen =\n    do putStrLn \"Is green your favorite color?\"\n       inpStr <- getLine\n       return (isYes inpStr)\n{-- /snippet all --}\n", "input": "\"hello\"", "status": "success", "output": "False"}
{"code": "-- 2^15 = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.\n-- \n-- What is the sum of the digits of the number 2^1000?\n--\n-- Seems trivial. Did I miss something?\n--\n-- 1366\nimport Data.Char\n\nsum2ToThe :: Int -> Int\nsum2ToThe n = sum . map digitToInt $ show $ 2^n\n", "input": "42", "status": "success", "output": "46"}
{"code": "{- List comprehension is a way to transform, filter and combine lists.\n-}\n\n-- Here is an example of a function named \"removeNonUppercase\" that filters\n-- all lowercase symbols\n\nremoveNonUppercase :: [Char] -> [Char]\nremoveNonUppercase st = [s | s <- st, elem s ['A'..'Z']]\n\n", "input": "['a', 'a']", "status": "success", "output": "\"\""}
{"code": "-- Defina uma fun\u00e7\u00e3o maior3 :: Int -> Int -> Int -> Int\n-- que devolve o maior de tr\u00eas n\u00fameros.\n\nhigher :: (Int, Int) -> Int\nhigher (a, b) | a > b = a\n              | otherwise = b\n\nhigher3 :: (Int, Int, Int) -> Int\nhigher3 (a, b, c) = higher(higher(a, b), higher(b, c))\n", "input": "(42, 42)", "status": "success", "output": "42"}
{"code": "data Day = Mon | Tues | Weds | Thurs | Fri | Sat | Sun deriving (Eq, Ord, Show)\n\nintToDay :: Int -> Maybe Day\nintToDay x =\n\tif x > 7 || x < 1 \n\t\tthen Nothing\n\t\telse getDay x\n\twhere\n\t\tgetDay x = lookup x getDays\n\t\tgetDays = zip [1..7] [Mon, Tues, Weds, Thurs, Fri, Sat, Sun]\n\n", "input": "42", "status": "success", "output": "Nothing"}
{"code": "fibonacci :: Integer -> Integer\nfibonacci 0 = 0\nfibonacci n = go 1 0 ((abs n) - 1)\n     where go acc prev m\n                       | m /= 0 = go (acc + prev) (acc) (m - 1)\n                       | otherwise = sign * acc\n           sign = if n < 0 then (-1)^((abs n)+1) else 1\n", "input": "42", "status": "success", "output": "267914296"}
{"code": "myWords :: String -> [String]\nmyWords = splitOnChar ' '\n\nsplitOnChar :: Char -> String -> [String]\nsplitOnChar _ [] = []\nsplitOnChar c (x : xs)\n    | c == x = splitOnChar c xs\n    | otherwise = takeWhile (/= c) (x:xs)\n                  : splitOnChar c (dropWhile(/= c) (x:xs))\n", "input": "\"hello\"", "status": "success", "output": "[\"hello\"]"}
{"code": "{-- snippet all --}\nimport Text.ParserCombinators.Parsec\n\ncsvFile = endBy line eol\nline = sepBy cell (char ',')\ncell = many (noneOf \",\\n\")\neol = char '\\n'\n\nparseCSV :: String -> Either ParseError [[String]]\nparseCSV input = parse csvFile \"(unknown)\" input\n{-- /snippet all --}\n", "input": "\"hello\"", "status": "success", "output": "Left \"(unknown)\" (line 1, column 6):\nunexpected end of input\nexpecting \",\" or \"\\n\""}
{"code": "estPi :: Int -> Double\n-- estPi n = 4 * estPi4 n\nestPi = (4 *) . estPi4\n\nestPi4 :: Int -> Double\nestPi4 0 = 1\nestPi4 n = estPi4 (n - 1) + (- 1) ^ n / (2 * fromIntegral n + 1)\n\nestPi' :: Int -> Double\nestPi' n = (4 *) . sum . take n $ map (\\k -> (- 1) ** k / (2 * k + 1)) [0 ..]\n", "input": "42", "status": "success", "output": "3.1648453252882898"}
{"code": "-- Implementation of the collatz sequence in Haskell\nimport Debug.Trace\ncollatz :: Integer -> Integer\ncollatz 1 = trace(\"N=1\") 1\ncollatz n = if even n\n             then trace(\"N=\"++show n++\" is even\") collatz (div n 2)\n\t     else trace(\"N=\"++show n++\" is not even\") collatz (3*n+1)\n", "input": "42", "status": "success", "output": "1"}
{"code": "bmiTell :: Double -> String\nbmiTell bmi\n    | bmi <= 18.5 = \"You're underweight, you emo, you!\"\n    | bmi <= 25.0 = \"You're supposedly normal. Pffft, I bet you're ugly!\"\n    | bmi <= 30.0 = \"You're fat! Lose some weight, fatty!\"\n    | otherwise = \"You're a whale, congratulations!\"\n", "input": "2.71", "status": "success", "output": "\"You're underweight, you emo, you!\""}
{"code": "introduction :: (String, Integer) -> String\nintroduction (n, a) =\n\t\"My name is \" ++ n ++\n\t\". I'm \" ++ show a ++ \" years old.\"\n\nintroductionYj :: Integer -> String\nintroductionYj = curry introduction \"Yoshikuni Jujo\"\n\nmyCurry :: ((a, b) -> c) -> a -> b -> c\nmyCurry f x y = f (x, y)\n", "input": "(\"hello\", 42)", "status": "success", "output": "\"My name is hello. I'm 42 years old.\""}
{"code": "piGuess :: Int -> Double\npiGuess n = sum (map f [1..n])\n\nf :: Int -> Double\nf x = 4*(-1)^(x+1) / (2.0 * k - 1)\n\twhere k = fromIntegral x\n\neGuess :: (Enum a, Fractional a) => a -> a\neGuess n = sum (map g [1..n]) + 1\n\ng :: (Enum a, Fractional a) => a -> a\ng x = 1 / (product [1..x])\n\n", "input": "42", "status": "success", "output": "3.117786501758878"}
{"code": "removeNonUppercase :: [Char] -> [Char]\nremoveNonUppercase st = [c | c <- st, c `elem` ['A'..'Z']]\n\naddTree :: Int -> Int -> Int -> Int\naddTree x y z = x + y + z\n\nfactrial :: Integer -> Integer\nfactrial n = product [1..n]\n\ncircumference :: Float -> Float\ncircumference r = 2 * pi * r\n", "input": "['a', 'a']", "status": "success", "output": "\"\""}
{"code": "-- 3.2\n_3a x = x ++ \"!\"\n_3b x = x !! 4\n_3c x = drop 9 x\n\n-- 3.3\nthirdLetter :: String -> Char\nthirdLetter x = x !! 3\n\n-- 3.4\nletterIndex :: Int -> Char\nletterIndex x = \"Curry is awesome\" !! x\n\n-- 3.5\nrvrs = (drop 9 x) ++ (drop 5 (take 9 x)) ++ (take 5 x)\n  where x = \"Curry is awesome\"\n", "input": "\"hello\"", "status": "success", "output": "'l'"}
{"code": "-- Deda a fun\u00e7\u00e3o abaixo\nfun :: (Int) -> Int\nfun x | x < 10 = 1\n      | x < 100 = 2\n      | x < 1000 = 3\n      | otherwise = 4\n-- Qual o resultado das seguintes avalia\u00e7\u00f5es?\n-- a) Q: fun 400\n--    R: 3\n-- b) Q: fun 50\n--    R: 2\n-- c) Q: fun 1050\n--    R: 4\n-- d) Q: fun 0\n--    R: 1\n", "input": "(42)", "status": "success", "output": "2"}
{"code": "to_tens :: Integer -> [Integer]\r\nto_tens 0 = []\r\nto_tens n = to_tens (n `div` 10) ++ [n `mod` 10] \r\n\r\n\r\n\r\nfac 0 = 1\r\nfac 1 = 1\r\nfac n = product [1..n]\r\n\r\n\r\nis_curious 1 = False\r\nis_curious 2 = False\r\nis_curious n = (sum $ map fac $ to_tens n) == n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncui = filter is_curious [1..]", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "removeNonUppercase :: [Char] -> [Char]\r\nremoveNonUppercase st = [c | c <- st, c `elem` ['A' .. 'Z']]\r\n\r\nhello 1 = \"hi\"\r\nhello 2 = \"hello\"\r\nhello x = \"Error\"\r\n\r\nlocations :: Char -> String ->[Int]\r\nlocations x ys = \r\n\tmap fst (filter (isChar) (zip [0..] ys))\r\n\twhere\r\n\t\tisChar (_,q) = x == q\r\n", "input": "['a', 'a']", "status": "success", "output": "\"\""}
{"code": "minfree :: [Int] -> Int\nminfree xs = head $ [0..] // xs\n\n(//) :: Eq a => [a] -> [a] -> [a]\n--xs // ys = [x | x <- xs, foldr (\\y r -> r && y /= x) True ys]\n--xs // ys = [x | x <- xs, notElem x ys]\n--xs // ys = [x | x <- xs, all (/= x) ys]\nxs // ys = [x | x <- xs, foldr ((&&).(/= x)) True ys]\n", "input": "[42, 42]", "status": "success", "output": "0"}
{"code": "import Data.List\r\nimport Data.Ord\r\n\r\nitiv :: Integer -> [Integer]\r\nitiv 1 = [1]\r\nitiv n\r\n\t| n `mod` 2 == 0 = n : (itiv (n `div` 2))\r\n\t| otherwise = n : (itiv (3*n + 1))\r\n\r\nchains = [length $ itiv i | i <- [1..1000000]]\r\n\r\nmaxi xs = maximumBy (comparing fst) (zip xs [0..])\r\n\r\nans = maxi chains", "input": "42", "status": "success", "output": "[42,21,64,32,16,8,4,2,1]"}
{"code": "import Data.List\n\nsortArray :: [Int] -> [Int]\nsortArray xs = replaceOdd xs oddSortList\n  where oddSortList = sort $ filter odd xs\n\nreplaceOdd :: [Int] -> [Int] -> [Int]\nreplaceOdd xs [] = xs\nreplaceOdd (x:xs) os\n  | odd x = head os : replaceOdd xs (tail os)\n  | otherwise = x : replaceOdd xs os", "input": "[42, 42]", "status": "success", "output": "[42,42]"}
{"code": "a338426 :: Int -> Integer\na338426 = (!!) a338426_list\n\na338426_list :: [Integer]\na338426_list = 1 : 2 : 28 : 154 : 1206 : 8364 : 60614 : 432636 : recurse a338426_list where\n  recurse as@(a8:a7:a6:a5:a4:a3:a2:a1:_) = 7*a1 + 6*a2 - 39*a3 + 29*a4 + 28*a5 - 26*a6 - 10*a7 + 6*a8 : recurse (tail as)\n", "input": "42", "status": "success", "output": "372224751429963795267820078274022786"}
{"code": "foo :: Int -> Int\nfoo 0 = 1\nfoo 1 = 1\nfoo n = 2 * n\n\ndescribeList :: [a] -> String  \ndescribeList xs = \"The list is \" ++ case xs of [] -> \"empty.\"  \n                                               [x] -> \"a singleton list.\"  \n                                               xs -> \"a longer list.\"\n", "input": "42", "status": "success", "output": "84"}
{"code": "popFactor :: Integer -> Maybe (Integer, Integer)\npopFactor n | n < 2 = Nothing\npopFactor n = Just (f, n `div` f)\n\twhere f = head $ filter ((== 0) . (n `mod`)) [2 ..]\n\nfactorization :: Integer -> [Integer]\nfactorization n = case popFactor n of\n\tNothing -> []\n\tJust (f, n') -> f : factorization n'\n", "input": "42", "status": "success", "output": "Just (2,21)"}
{"code": "-- file: ch04/dlts.hs\n\nimport Data.List (isPrefixOf)\n\ndlts :: String -> [String]\ndlts = foldr step [] . lines\n    where step line ds\n            | \"#define DLT_\" `isPrefixOf` line = secondWord line : ds\n            | otherwise                       = ds\n          secondWord = head . tail . words\n", "input": "\"hello\"", "status": "success", "output": "[]"}
{"code": "import Control.Applicative\n\nhurr :: Integer -> Integer\nhurr = (*2)\n\ndurr :: Integer -> Integer\ndurr = (+10)\n\nm :: Integer -> Integer\nm = hurr . durr\n\nm' :: Integer -> Integer\nm' = fmap hurr durr\n\nm2 :: Integer -> Integer\nm2 = (+) <$> hurr <*> durr\n\nm3 :: Integer -> Integer\nm3 = liftA2 (+) hurr durr", "input": "42", "status": "success", "output": "84"}
{"code": "data Node  = Node  {id_   :: Integer} deriving (Show)\ndata Stack = Stack {nodes :: [Node]}  deriving (Show)\n\nst :: Integer -> [Node]\nst 0 = []\nst x = [Node x] ++  st(x-1)\n\ntest001 :: Integer -> Stack\ntest001 x = Stack (st x)\n\nprintF :: Stack -> [Integer]\nprintF x = \n    [(id_ n) | n <- (nodes x)]\n\n\n", "input": "42", "status": "success", "output": "[Node {id_ = 42},Node {id_ = 41},Node {id_ = 40},Node {id_ = 39},Node {id_ = 38},Node {id_ = 37},Node {id_ = 36},Node {id_ = 35},Node {id_ = 34},Node {id_ = 33},Node {id_ = 32},Node {id_ = 31},Node {id_ = 30},Node {id_ = 29},Node {id_ = 28},Node {id_ = 27},Node {id_ = 26},Node {id_ = 25},Node {id_ = 24},Node {id_ = 23},Node {id_ = 22},Node {id_ = 21},Node {id_ = 20},Node {id_ = 19},Node {id_ = 18},Node {id_ = 17},Node {id_ = 16},Node {id_ = 15},Node {id_ = 14},Node {id_ = 13},Node {id_ = 12},Node {id_ = 11},Node {id_ = 10},Node {id_ = 9},Node {id_ = 8},Node {id_ = 7},Node {id_ = 6},Node {id_ = 5},Node {id_ = 4},Node {id_ = 3},Node {id_ = 2},Node {id_ = 1}]"}
{"code": "fibTuple :: (Integer, Integer, Integer) -> (Integer, Integer, Integer)\nfibTuple (x, y, 0) = (x, y, 0)\nfibTuple (x, y, index) = fibTuple (y, x + y, index - 1)\n\nfibResult :: (Integer, Integer, Integer) -> (Integer)\nfibResult (x, y, z) = x\n\nfib :: Integer -> Integer\nfib x = fibResult (fibTuple (0, 1, x))", "input": "(42, 42, 42)", "status": "success", "output": "(18206766354,29459166786,0)"}
{"code": "doubleme x = x + x\ndoubleus x y = x*2 + y*2\ndoublesmallnumber x = if x < 100\n    then x * 2\n    else x\n\ncircumference :: Float -> Float  \ncircumference r = 2 * pi * r \n\ncircumference' :: Double -> Double  \ncircumference' r = 2 * pi * r \n\nlucky :: (Integral a) => a -> String\nlucky 7 = \"Yes\"\nlucky x = \"No\"\n", "input": "3.14", "status": "success", "output": "19.729202"}
{"code": "{- Example of using guards in Haskell\nScript is absolutly free/libre, but with no guarantee.\nAuthor: Ondrej Profant -}\n\nisNeg :: Int -> Bool\nisNeg x = if x < 0 \n\t\tthen True \n\t\telse False\n\nmyabs :: Int -> Int\nmyabs x\n\t| x < 0 = -x\n\t| x >= 0 = x\n\t\nmyabs2 :: Int -> Int\nmyabs2 x = if isNeg(x)\n\tthen -x\n\telse x", "input": "42", "status": "success", "output": "False"}
{"code": "-- xor [False, True, False] == True\n-- xor [False, True, False, False, True] == False\nxor :: [Bool] -> Bool\nxor = odd . foldr (\\x acc -> if x then acc + 1 else acc) (0 :: Integer)\n\n-- map' odd [1, 2, 3, 4] == [True, False, True, False]\nmap' :: (a -> b) -> [a] -> [b]\nmap' f = foldr (\\x acc -> f x : acc) []\n", "input": "[True, True]", "status": "success", "output": "False"}
{"code": "import Data.Char\n\ntoDigits :: Integer -> [Integer]\ntoDigits 0 = []\ntoDigits n\n  | n < 0 = []\n  | otherwise = map fromIntegral $ map digitToInt $ show n\n\ntoDigitsRev :: Integer -> [Integer]\ntoDigitsRev 0 = []\ntoDigitsRev n\n  | n < 0 = []\n  | otherwise = map fromIntegral $ map digitToInt $ reverse . show $ n\n", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "doubleMe x = x + x\n\ndoubleUs x y = doubleMe x + doubleMe y\n\ndoubleSmallNumber x = if x > 100\n\t\t\tthen x\n\t\t\telse x * 2\n\ndoubleSmallNumber' x = if x > 100 then x else x * 2 + 1\n\nfactorial :: Integer -> Integer  \nfactorial n = product [1..n]  \n\ncircumference :: Float -> Float  \ncircumference r = 2 * pi * r  \n\n\n", "input": "42", "status": "success", "output": "1405006117752879898543142606244511569936384000000000"}
{"code": "import Data.List\n\nsplitLines :: String -> [String]\nsplitLines [] = []\nsplitLines xs =\n  let (pre,suf) = break isReturn xs\n  in pre : case suf of\n    ('\\r':'\\n':rest) -> splitLines rest\n    ('\\r':rest) -> splitLines rest\n    ('\\n':rest) -> splitLines rest\n    _ -> []\n\nisReturn c = c == '\\r' || c == '\\n'\n    \n", "input": "\"hello\"", "status": "success", "output": "[\"hello\"]"}
{"code": "-- This is a comment\n--rm_up :: [Char] -> [Char]\nrmUp :: String -> String\nrmUp st = [ c | c <- st, elem c ['A'..'Z'] ]\n\naddThree :: Int -> Int -> Int -> Int\naddThree x y z = x + y + z\n\nfactorial :: Integer -> Integer\nfactorial n = product [1..n]\n\ncircumference :: Float -> Float\ncircumference r = 2 * pi * r\n\n", "input": "\"hello\"", "status": "success", "output": "\"\""}
{"code": "addOne :: Int -> Int\naddOne x = x + 1\n\nadd = (+)\n\nlucky :: Int -> String\nlucky 7 = \"LUCKY NUMBER 7!\"\nlucky _ = \"Too bad :(\"\n\napplyToBothThenAdd f x y = add (f x) (f y)\n\nisSpeaker :: String -> Bool\nisSpeaker \"Teodor\" = True\nisSpeaker _        = False\n\nsquaredSum :: Int -> Int -> Int\nsquaredSum x y = x*x + y*y\n", "input": "42", "status": "success", "output": "43"}
{"code": "\nf :: Int -> Maybe Int\nf a  | a > 0  = Just (a - 1)\n     | otherwise = Nothing\n\ncomp :: (a -> Maybe b) -> (b -> Maybe c) -> (a -> Maybe c)\ncomp f g a  = do\n    b <- f a\n    c <- g b\n    return c\n\n\ncomp2 :: (a -> Maybe b) -> (b -> Maybe c) -> (a -> Maybe c)\ncomp2 f g a = f a >>= (\\b -> g b >>= (\\c -> return c))\n", "input": "42", "status": "success", "output": "Just 41"}
{"code": "properfactors :: Int -> [Int]\nproperfactors x = filter (\\y -> (x `mod` y == 0)) [2..(x-1)]\n\nnumproperfactors :: Int -> Int\nnumproperfactors x = length (properfactors x)\n\nprimes :: [Int]\nprimes = filter (\\x -> (numproperfactors x == 0)) [2..]\n\n-- use the take function as this is a infinite list\n-- take 3 primes\n", "input": "42", "status": "success", "output": "[2,3,6,7,14,21]"}
{"code": "localMaxima :: [Integer] -> [Integer]\nlocalMaxima list\n  | length list > 2 = map (\\(_,b,_) -> b) (filter (\\(a,b,c) -> a < b && b > c)(neighborList list))\n  | otherwise = []\n\nneighborList :: [Integer] -> [(Integer, Integer, Integer)]\nneighborList (a:b:c:xs) = (a,b,c) : (neighborList (b:c:xs))\nneighborList list = []", "input": "[42, 42]", "status": "success", "output": "[]"}
{"code": "data NestedInteger = Empty | NestedInteger Int NestedInteger deriving (Show)\n\ndeserialize :: [Int] -> NestedInteger\ndeserialize []     = Empty\ndeserialize (x:xs) = NestedInteger x (deserialize xs)\n\nparerIntList :: String -> [Int]\nparerIntList ss = read ('[' :[s | s <- ss, s /= '[' && s /= ']'] ++ [']']) :: [Int]\n\n", "input": "[42, 42]", "status": "success", "output": "NestedInteger 42 (NestedInteger 42 Empty)"}
{"code": "andd :: [Bool] -> Bool\nandd []  = error \"list empty\"\nandd [x] = x\nandd (x:xs) = if x == True then\n                andd xs\n              else\n                x\n\norr :: [Bool] -> Bool\norr [] = error \"list empty\"\norr [x] = x\norr (x:xs) = if x == True then\n                True\n             else\n                orr xs\n", "input": "[True, True]", "status": "success", "output": "True"}
{"code": "import Text.ParserCombinators.Parsec\n\ncsvFile = endBy line eol\nline = sepBy cell (char ',')\ncell = many (noneOf \",\\n\\r\")\n\n{-- snippet eol --}\neol = \n    do char '\\n'\n       char '\\r' <|> return '\\n'\n{-- /snippet eol --}\n\nparseCSV :: String -> Either ParseError [[String]]\nparseCSV input = parse csvFile \"(unknown)\" input\n", "input": "\"hello\"", "status": "success", "output": "Left \"(unknown)\" (line 1, column 6):\nunexpected end of input\nexpecting \",\" or \"\\n\""}
{"code": "import Data.Char (isLower, ord)\n\nlowerToCode :: Char -> Maybe Int\nlowerToCode c\n\t| isLower c = Just $ ord c\n\t| otherwise = Nothing\n\nevenDiv2 :: Int -> Maybe Int\nevenDiv2 n\n\t| even n = Just $ n `div` 2\n\t| otherwise = Nothing\n\nbindM :: Maybe a -> (a -> Maybe b) -> Maybe b\nJust x `bindM` f = f x\nNothing `bindM` _ = Nothing\n", "input": "'a'", "status": "success", "output": "Just 97"}
{"code": "-- exercice address:\n-- https://leetcode.com/problems/fizz-buzz/\n\n-- my great implementation!\nfizzbuzz :: Int -> String\nfizzbuzz i\n    | i `mod` 3 == 0 && i `mod` 5 == 0 = \"FizzBuzz\"\n    | i `mod` 3 == 0 = \"Fizz\"\n    | i `mod` 5 == 0 = \"Buzz\"\n    | otherwise = show i\n\n-- simple run loop\nrun = do\n    map fizzbuzz [1..15]\n", "input": "42", "status": "success", "output": "\"Fizz\""}
{"code": "yesNo :: Bool -> [Char]\nyesNo True = \"Yes\"\nyesNo False = \"No\"\n\ntrueman :: (Num a) => [Bool] -> a\ntrueman [] = 0\ntrueman (True:xs) = 1 + trueman xs\ntrueman (False:xs) = trueman xs\n\nlistToPairs :: [a] -> [(a,a)]\nlistToPairs [] = []\nlistToPairs [x] = []\nlistToPairs [x,y] = [(x,y)]\nlistToPairs (a:b:c) = (a,b):(listToPairs c)\n", "input": "True", "status": "success", "output": "\"Yes\""}
{"code": "\nimport Data.Char (digitToInt)\n\nasInt :: [Char] -> Int\nasInt = loop 0\n\nloop :: Int -> [Char] -> Int\nloop acc [] = acc\nloop acc (x:xs) = let acc' = acc*10 + digitToInt x\n                  in loop acc' xs\n\n\nloop' :: Int -> [Char] -> Int\nloop' acc [] = acc\nloop' acc (x:xs) = loop acc' xs\n  where acc' = acc*10 + digitToInt x\n", "input": "['a', 'a']", "status": "success", "output": "110"}
{"code": "likes :: [String] -> String\nlikes [] = \"no one likes this\"\nlikes (x:[]) = x ++ \" likes this\"\nlikes (x:y:[]) = x ++ \" and \" ++ y ++  \" like this\"\nlikes (x:y:xs) \n    | length xs > 1 = x ++ \", \" ++ y ++ \" and \" ++ (show $ length xs) ++  \" others like this\"\n    | otherwise = x ++ \", \" ++ y ++ \" and \" ++ xs!!0 ++  \" like this\"", "input": "[\"hello\", \"hello\"]", "status": "success", "output": "\"hello and hello like this\""}
{"code": "--type declaration on functions\nremoveNonUppercase :: [Char] -> [Char]  \nremoveNonUppercase st = [ c | c <- st, elem c ['A'..'Z']]   \n\n-- the last parametr is the reutnr type\naddThree :: Int -> Int -> Int -> Int  \naddThree x y z = x + y + z  \n\n\n--data types:\n-- Int\n-- Integer (not bounded)\n-- Float\n-- Double\n-- Bool\n-- Char", "input": "['a', 'a']", "status": "success", "output": "\"\""}
{"code": "myProduct :: [Integer] -> Integer\nmyProduct [] = 0\nmyProduct (x:xs) = x * product(xs)\n\n\nmyProduct' :: [Integer] -> Integer\nmyProduct' [] = 0\nmyProduct' l = foldr(*) 1 l\n\nmyStar :: (Num a, Eq a) => a -> a -> a\nmyStar 0 _ = 0\nmyStar _ 0 = 0\nmyStar x y = x * y\n\nmyProduct'' :: [Integer] -> Integer\nmyProduct'' = foldr(myStar) 1\n", "input": "[42, 42]", "status": "success", "output": "1764"}
{"code": "{--\r\n - Problem 31\r\n(**) Determine whether a given integer number is prime.\r\n\r\n    Example:\r\n    * (is\u2010prime 7)\r\n    T\r\n\r\n    Example in Haskell:\r\n    P31> isPrime 7\r\n    True\r\n --}\r\n\r\nisPrime :: Int -> Bool\r\nisPrime 1 = False\r\nisPrime n = 0 `notElem` map (n `mod`) [2, 3 .. m]\r\n    where m = floor . sqrt $ fromIntegral n \r\n", "input": "42", "status": "success", "output": "False"}
{"code": "import Data.List\ntriangleNumbers = scanl1 (+) [0..]\n\nfactorize :: Int -> [Int]\nfactorize x =\n  let firstHalf = filter (\\y -> x `mod` y == 0) [1..floor(sqrt (fromIntegral x))]\n      secondHalf = map (x `div`) firstHalf\n  in firstHalf++ reverse secondHalf\n\nproblem12 = find (\\x -> length x > 500) $ map factorize triangleNumbers\n", "input": "42", "status": "success", "output": "[1,2,3,6,7,14,21,42]"}
{"code": "\nproblem :: Int -> Int\nproblem x\n  | x < 0 = 0\n  | otherwise = fn 0 [0..x-1]\n  where\n    fn a [] = a\n    fn a (y:ys)\n      | isMultiple = fn (a+y) ys\n      | otherwise  = fn a ys\n      where\n        isMultiple = y `mod` 3 == 0 || y `mod` 5 == 0\n\n-- sum [3,6..999] + sum [5,10..999] - sum [15,30..999] \n-- problem 1000 == 233168\n", "input": "42", "status": "success", "output": "408"}
{"code": "-- Calculates the diference between the the square of the sum of the list\n-- and the sum of the squares of the list.\ndiffSquares :: [Int] -> Int\ndiffSquares [] = 0\ndiffSquares xs = squareOfSums - sumOfSquares\n  where\n    squareOfSums = (sum xs)^2\n    sumOfSquares = sum $ map (^2) xs\n\nanswer :: Int\nanswer = diffSquares [1..100]\n", "input": "[42, 42]", "status": "success", "output": "3528"}
{"code": "--- Project Euler: Problem 1\n\n--- If we list all the natural numbers below 10 that are multiples of 3\n--- or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. Find\n--- the sum of all the multiples of 3 or 5 below 1000.\n\nsolution :: Int -> Int\nsolution limit = sum [x | x <- [1..limit], x `mod` 3 == 0 || x `mod` 5 == 0]\n", "input": "42", "status": "success", "output": "450"}
{"code": "import Data.Char\nimport Data.List\n\ndigitize :: Int -> [Int]\ndigitize x = map digitToInt $ show x \n\npalindrome :: Eq a => [a] -> Bool\npalindrome xs = xs == (reverse xs)\n\nnumdrome :: Int -> Bool\nnumdrome = palindrome . digitize\n\nlist = [x |a <- [1..999], b <- [1..999], let x = a*b]\n\nlargestDrome = last $ sort $ filter numdrome list\n", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "import Text.ParserCombinators.Parsec\n\ncsvFile = endBy line eol\nline = sepBy cell (char ',')\ncell = many (noneOf \",\\n\\r\")\n\n{-- snippet eol --}\n-- This function is not correct!\neol = string \"\\n\" <|> string \"\\n\\r\"\n{-- /snippet eol --}\n\nparseCSV :: String -> Either ParseError [[String]]\nparseCSV input = parse csvFile \"(unknown)\" input\n", "input": "\"hello\"", "status": "success", "output": "Left \"(unknown)\" (line 1, column 6):\nunexpected end of input\nexpecting \",\", \"\\n\" or \"\\n\\r\""}
{"code": "import Text.ParserCombinators.Parsec\n\ncsvFile = endBy line eol\nline = sepBy cell (char ',')\ncell = many (noneOf \",\\n\\r\")\n\n{-- snippet eol --}\n-- This function is not correct!\neol = string \"\\n\\r\" <|> string \"\\n\"\n{-- /snippet eol --}\n\nparseCSV :: String -> Either ParseError [[String]]\nparseCSV input = parse csvFile \"(unknown)\" input\n", "input": "\"hello\"", "status": "success", "output": "Left \"(unknown)\" (line 1, column 6):\nunexpected end of input\nexpecting \",\", \"\\n\\r\" or \"\\n\""}
{"code": "factorial :: Int -> Int\nfactorial n = if n == 0 then 1 else n * factorial (n-1)\n\nbinomial :: Int -> Int -> Int\nbinomial n k\n  | (0 <= k) && (k <= n) = factorial n `div` factorial k `div` factorial (n-k)\n  | otherwise = 0\n\nseatings :: Int -> Int\nseatings n = max 0 $ sum [(-2)^k * binomial n k * factorial (2 * n - k - 1) | k <- [0..n]]\n\n", "input": "42", "status": "success", "output": "7538058755741581312"}
{"code": "\n\nprimeFactors :: Int -> [Int]\nprimeFactors x = fn x [2..x]\n  where\n    fn x' [] = []\n    fn x' (y:ys)\n      | x' `mod` y == 0 = y : fn (x' `div` y) [2..x']\n      | otherwise = fn x' ys\n\n-- primeFactors 13195 == [5,7,13,29]\n\nmaxPrimeFactor :: Int -> Int\nmaxPrimeFactor x = maximum $ primeFactors x\n\n-- maxPrimeFactor 600851475143 == 6857\n\n", "input": "42", "status": "success", "output": "[2,3,7]"}
{"code": "import qualified Data.Set as Set\nimport Data.List\n\nmultiples :: Int -> [Int]\nmultiples n = map (n*) [1..6]\n\ndigitMultiples :: Int -> Set.Set String\ndigitMultiples n = Set.fromList $ map (sort . show) $ multiples n\n\nanswer = take 1 solutions\n        where solutions = filter (\\(a,s) -> (length s)==1) $ zip [1..] $ map digitMultiples [1..]\n", "input": "42", "status": "success", "output": "[42,84,126,168,210,252]"}
{"code": "import Control.Monad\n\nevensGuard :: Int -> [Int]\nevensGuard n = do\n  val <- [1..n]\n  guard (even val)\n  return val\n\n-- Filter function using do-notation.\n-- Looks cool! Btw.\nmyFilter :: (a -> Bool) -> [a] -> [a]\nmyFilter f xs = do\n  val <- xs\n  guard $ f val\n  return val\n\n-- TODO: implement my own Alternative typeclass and guard function.\n", "input": "42", "status": "success", "output": "[2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42]"}
{"code": "{-- snippet dlts --}\nimport Data.List (isPrefixOf)\n\ndlts :: String -> [String]\n\ndlts = foldr step [] . lines\n{-- /snippet dlts --}\n{-- snippet step --}\n  where step l ds\n          | \"#define DLT_\" `isPrefixOf` l = secondWord l : ds\n          | otherwise                     = ds\n        secondWord = head . tail . words\n{-- /snippet step --}\n", "input": "\"hello\"", "status": "success", "output": "[]"}
{"code": "-- /**\n-- * Given an arbitrary input string, return the first nonrepeated character in\n-- * the string. For example:\n-- *\n-- *   firstNonRepeatedCharacter('ABA'); // => 'B'\n-- *   firstNonRepeatedCharacter('AACBDB'); // => 'C'\n-- */\ncountChar :: String -> Char\ncountChar str = head [ char | char <- str, (length $ filter (== char) str) == 1]\n", "input": "\"hello\"", "status": "success", "output": "'h'"}
{"code": "\nisPrime :: Integer -> Bool\nisPrime x = ([] == [y | y <- [2..floor (sqrt $ fromIntegral x)], mod x y == 0])\n\nprimeSumPairs :: Integer -> [(Integer, Integer, Integer)]\nprimeSumPairs n =\n  map makePairSum $ filter isPrimeSum [(x, y)|x <-[1..n], y <- [1..(x-1)]]\n  where\n    isPrimeSum (a,b) = isPrime $ a + b\n    makePairSum (a,b) = (a,b,a+b)\n\n\n", "input": "42", "status": "success", "output": "False"}
{"code": "import Data.List\n\nsortNumbersDescending :: [Int] -> [Int]\nsortNumbersDescending [] = []\nsortNumbersDescending xs = {-reverseR $ -} sortR xs where\n  sortR = quicksort where\n    quicksort [] = []\n    quicksort (x:xs) = quicksort [y | y<-xs,y>=x ] ++ [x] ++ quicksort [z | z <- xs, z<x]\n  -- reverseR [] = []\n  -- reverseR (x:xs) = reverseR xs++[x]", "input": "[42, 42]", "status": "success", "output": "[42,42]"}
{"code": "sumNumbersUpTo :: Integer -> Integer\nsumNumbersUpTo n = n*(n+1) `div` 2\n\nsumEvenNumbersUpTo :: Integer -> Integer\nsumEvenNumbersUpTo n = k*(k+1)\n        where k = n `div` 2\n\nsumDiagonals :: Integer -> Integer\nsumDiagonals 1 = 1\nsumDiagonals n = sumDiagonals (n-2) + 4*((n-2)^2) + 10*step\n        where k = (n+1) `div` 2\n              step = n-1\n", "input": "42", "status": "success", "output": "903"}
{"code": "import Data.Array\n\nminfree :: [Int] -> Int\nminfree = findFalse . buildList\n\nfindFalse :: Array Int Bool -> Int\nfindFalse = length . takeWhile id . elems\n\nbuildList :: [Int] -> Array Int Bool\nbuildList xs = accumArray (||) False (0, n) $\n                 zip [x | x <- xs, x <= n] $ repeat True\n               where\n                 n = length xs\n", "input": "[42, 42]", "status": "success", "output": "0"}
{"code": "\nsplitLines :: [Char] -> [[Char]]\nsplitLines [] = []\nsplitLines xs =\n    let (pre, suf) = break (\\c -> c == '\\r' || c == '\\n') xs\n    in pre : case suf of\n               ('\\r':'\\n':rest) -> splitLines rest\n               ('\\r':rest)      -> splitLines rest\n               ('\\n':rest)      -> splitLines rest\n               _                -> []\n", "input": "['a', 'a']", "status": "success", "output": "[\"aa\"]"}
{"code": "import Data.Char\n\nlet2int :: Char -> Int\nlet2int c = ord c - ord 'a'\n\nint2let :: Int -> Char\nint2let n = chr (ord 'a' + n)\n\nshift :: Int -> Char -> Char\nshift n c\n\t| isLower c = int2let ((let2int c + n) `mod` 26)\n\t| isUpper c = toUpper (n `shift` (toLower c))\n\t| otherwise = c\n\nencode :: Int -> String -> String\nencode n xs = [shift n x | x <- xs]", "input": "'a'", "status": "success", "output": "0"}
{"code": "-- \u5b57\u53e5\u89e3\u6790\n\nwhiteSpaces :: String -> String\nwhiteSpaces ('\\t':xs) = '\\t':whiteSpaces xs\nwhiteSpaces (' ':xs) = ' ':whiteSpaces xs\nwhiteSpaces ('\\\\':'\\n':xs) = '\\\\':'\\n':whiteSpaces xs\nwhiteSpaces ('\\n':xs) = '\\n':whiteSpaces xs\nwhiteSpaces (x:xs) = \"\"\n\nlexer :: String -> [String]\nlexer [] = [[]]\nlexer (x:[]) = [[x]]\nlexer (x:xs) = [[x], xs]\n\n", "input": "\"hello\"", "status": "success", "output": "\"\""}
{"code": "-- Calculate Hailstone sequence: http://en.wikipedia.org/wiki/Hailstone_sequence\nhailstone :: Integer -> [Integer]\nhailstone n\n        | n <= 0    = []\n        | n == 1    = [1]\n        | even n    = n : hailstone (n `div` 2)  \n        | otherwise = n : hailstone (n * 3 + 1)\n\nhailstoneLength :: Integer -> Int\nhailstoneLength = length . hailstone \n\n", "input": "42", "status": "success", "output": "[42,21,64,32,16,8,4,2,1]"}
{"code": "powerOfTwo :: Int -> Integer\npowerOfTwo n = product (take n (repeat 2))\n\nlogTwo :: Integer -> Int\nlogTwo v = fromIntegral (last [x | x <- [1..v], (powerOfTwo (fromInteger x)) <= v])\n\ncopy :: Int -> a -> [a]\ncopy n x = take n (repeat x)\n\nmultiApply :: (a -> a) -> Int -> a -> a\nmultiApply f n x\n\t| n > 0 = last (take (n + 1) (iterate f x))\n\t| n <= 0 = x\n", "input": "42", "status": "success", "output": "4398046511104"}
{"code": "import Data.List (sortBy)\n\nlargestPalindrome :: Int -> Int\nlargestPalindrome x = \n    let l = [x,x-1..0]\n        product = sortBy (flip compare) [i * j | i <- l, j <- l]\n        fn (y:ys)\n          | show y == (reverse . show) y = y\n          | otherwise = fn ys\n        in fn product\n\n-- largestPalindrome 99 == 9009\n-- largestPalindrome 999 == 906609\n", "input": "42", "status": "success", "output": "1221"}
{"code": "removeNonUppercase :: String -> String\nremoveNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]\n\naddThree :: Int -> Int -> Int -> Int\naddThree x y z = x + y + z\n\nfactorial :: Integer -> Integer\nfactorial x = product [1..x]\n\ncircumference :: Float -> Float\ncircumference r = 2 * pi * r\n\ncircumference' :: Double -> Double\ncircumference' r = 2 * pi * r\n", "input": "\"hello\"", "status": "success", "output": "\"\""}
{"code": "-- different ways to generate primes\n\nps :: Int -> [Int]\nps 2 = [2]\nps n =\n    let pn1 = ps (n-1) in\n    if any (==0) $ map (rem n) pn1\n    then pn1\n    else pn1 ++ [n]\n\nisqrt :: Integral a => a -> a\nisqrt = ceiling . sqrt . fromIntegral\n\nispm :: Int -> Bool\nispm 1 = True\nispm 2 = True\nispm n = null [q | q <- [x | x <- [2..(isqrt n)], ispm x], rem n q == 0]\n", "input": "42", "status": "success", "output": "[2,3,5,7,11,13,17,19,23,29,31,37,41]"}
{"code": "{-- snippet all --}\nimport Text.ParserCombinators.Parsec\n\ncsvFile = endBy line eol\nline = sepBy cell (char ',')\ncell = many (noneOf \",\\n\\r\")\n\neol =   try (string \"\\n\\r\")\n    <|> try (string \"\\r\\n\")\n    <|> string \"\\n\"\n    <|> string \"\\r\"\n\nparseCSV :: String -> Either ParseError [[String]]\nparseCSV input = parse csvFile \"(unknown)\" input\n{-- /snippet all --}\n", "input": "\"hello\"", "status": "success", "output": "Left \"(unknown)\" (line 1, column 6):\nunexpected end of input\nexpecting \",\", \"\\n\\r\", \"\\r\\n\", \"\\n\" or \"\\r\""}
{"code": "import Data.List\n\nisDivis :: Int -> Bool\nisDivis n = and $ fmap test [1..20]\n  where test x = mod n x == 0\n\nnextNum (num, val) = (num+1, isDivis $ num+1)\n\n--255255 is obtained by multiplying all the prime numbers less than 20\nsmallest' (num, True) = num\nsmallest' (num, False) = smallest' (num+255255, isDivis $ num+255255)\n\nsmallest = smallest' (255255, False)\n", "input": "42", "status": "success", "output": "False"}
{"code": "removeNonUppercase :: [Char] -> [Char]  \nremoveNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]\n\naddThree :: Int -> Int -> Int -> Int  \naddThree x y z = x + y + z \n\nfactorial :: Integer -> Integer  \nfactorial n = product [1..n]\n\ncircumference :: Float -> Float  \ncircumference r = 2 * pi * r \n\ncircumference' :: Double -> Double  \ncircumference' r = 2 * pi * r", "input": "['a', 'a']", "status": "success", "output": "\"\""}
{"code": "\nimport Data.List (isPrefixOf)\n\ndlts :: String -> [String]\ndlts = foldr step [] . lines\n  where step l ds\n          | \"#define DLT_\" `isPrefixOf` l = secondWord l : ds\n          | otherwise                     = ds\n        secondWord = head . tail . words\n\ndlts' :: String -> [String]\ndlts' = map (head . tail . words) . filter (\"#define DLT_\" `isPrefixOf`) . lines\n\n", "input": "\"hello\"", "status": "success", "output": "[]"}
{"code": "validBraces :: String -> Bool\nvalidBraces = f []\n  where\n    isOpen x    = x == '(' || x == '{' || x == '['\n    isMatch x y = x == '(' && y == ')' || x == '{' && y == '}' || x == '[' && y == ']'\n    f [] [] = True\n    f _  [] = False\n    f st (x:xs) =\n        if   isOpen x\n        then f (x:st) xs\n        else not (null st) && let y:ys = st in isMatch y x && f ys xs\n", "input": "\"hello\"", "status": "success", "output": "False"}
{"code": "\nremoveNonUppercase :: String -> String\nremoveNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]\n\naddThree :: Int -> Int -> Int -> Int  \naddThree x y z = x + y + z \n\nfactorial :: Integer -> Integer  \nfactorial n = product [1..n]  \n\ncircumference :: Float -> Float  \ncircumference r = 2 * pi * r  \n\ncircumference0' :: Double -> Double  \ncircumference0' r = 2 * pi * r ", "input": "\"hello\"", "status": "success", "output": "\"\""}
{"code": "import Data.Char (toLower, isSpace)\n\npalindromePermutation :: String -> Bool\npalindromePermutation s = length oddLetters <= 1\n  where cleanString = filter (not . isSpace) $ map toLower s\n        oddLetters = odd cleanString []\n        odd [] acc = acc\n        odd (x:xs) acc | x `elem` acc = odd xs (filter (/= x) acc)\n                       | otherwise = odd xs (x:acc)\n", "input": "\"hello\"", "status": "success", "output": "False"}
{"code": "numbersCount :: Int -> Int\nnumbersCount = length . show\n\nrepl :: Int -> a -> [a]\nrepl = \\i -> take i . repeat\n\n--import Data.List\n\n--f :: String -> String\n--f s = unlines (map unwords (transpose (map words (lines s))))\n\nmapn :: (Int -> a -> b) -> [a] -> [b]\nmapn = mapn_rec 0\n    where mapn_rec _ f [] = []\n          mapn_rec n f (a:xp) = (f n a) : (mapn_rec (n + 1) f xp)", "input": "42", "status": "success", "output": "2"}
{"code": "-- ex7.1.hs\n\nimport Control.Monad\n\nbrokenThreeJumps :: Int -> [Int]\nbrokenThreeJumps year =\n  let jumpList = [(-1),3,5] in\n    do \n      x <- jumpList\n      y <- jumpList\n      z <- jumpList\n      return $ year+x+y+z\n\nbrokenJumps :: Int -> Int -> [Int] -> [Int]\nbrokenJumps year times jumpList =\n  let offsets = map sum (replicateM times jumpList) in\n  map (year+) offsets", "input": "42", "status": "success", "output": "[39,43,45,43,47,49,45,49,51,43,47,49,47,51,53,49,53,55,45,49,51,49,53,55,51,55,57]"}
{"code": "import Data.Char (intToDigit)\nimport Numeric (showIntAtBase)\n\ntoBinary :: Int -> String\ntoBinary x = showIntAtBase 2 intToDigit x \"\"\n\ndoubleBasePalindromes :: Int -> Int\ndoubleBasePalindromes limit = sum [ x | \n    x <- [0..limit], \n    let y = show x, \n    let b = toBinary x, \n        y == reverse y, \n        b == reverse b]\n\n-- doubleBasePalindromes 1000000 == 872187\n\n", "input": "42", "status": "success", "output": "\"101010\""}
{"code": "splitLines :: String -> [String]\nsplitLines [] = []\nsplitLines cs =\n    let (pre, suf) = break isLineTerminator cs\n    in pre : case suf of\n               ('\\r':'\\n':rest) -> splitLines rest\n               ('\\r':rest)      -> splitLines rest\n               ('\\n':rest)      -> splitLines rest\n               _                -> []\n\nisLineTerminator c = c == '\\r' || c == '\\n'", "input": "\"hello\"", "status": "success", "output": "[\"hello\"]"}
{"code": "-- Aufgabe 12.3\n-- a)\n\n-- The length of the longest list\n\n--[[1,2,3], [23,32], [5,7,6,4]] = 4\n\n\n-- b)\n\nmax_length :: [[Int]] -> Int\nmax_length [] = -1\nmax_length (x:xs) = maximum' (list_length x) (max_length xs)\n\nlist_length :: [Int] -> Int\nlist_length []\t\t= 0\nlist_length (x:xs)  = 1 + list_length xs\n\nmaximum' :: Int -> Int -> Int\nmaximum' x y\n\t| x > y \t= x\n\t| otherwise = y\n", "input": "[[42, 42], [42, 42]]", "status": "success", "output": "2"}
{"code": "h :: [Int] -> String\nh list = ph (zip [0..9] (histInRange [0..9] list))\n  \nph :: [(Int,Int)] -> String\nph [] = []\nph ((idx, value):xs) = (show idx) ++ \"|\" ++ (replicate value '*') ++ \"\\n\" ++ ph xs\n                \n\n\nhistInRange :: [Int] -> [Int] -> [Int]\nhistInRange [] _ = []\nhistInRange _ [] = []\nhistInRange (x:xs) list = (length (filter (== x) (list))) : (histInRange xs list) ", "input": "[42, 42]", "status": "success", "output": "\"0|\\n1|\\n2|\\n3|\\n4|\\n5|\\n6|\\n7|\\n8|\\n9|\\n\""}
{"code": "splitLines :: String -> [String]\nsplitLines [] = []\nsplitLines cs =\n    let (prefix, suffix) = break isLineTerminator cs\n    in prefix : case suffix of\n        ('\\r':'\\n':rest)    -> splitLines rest\n        ('\\n':rest)         -> splitLines rest\n        ('\\r':rest)         -> splitLines rest\n        otherwise           -> []\n\nisLineTerminator char = char == '\\r' || char == '\\n'\n", "input": "\"hello\"", "status": "success", "output": "[\"hello\"]"}
{"code": "import Text.ParserCombinators.Parsec\n\ncsvFile = endBy line eol\nline = sepBy cell (char ',')\ncell = many (noneOf \",\\n\\r\")\n\n{-- snippet eol --}\neol =   try (string \"\\n\\r\")\n    <|> try (string \"\\r\\n\")\n    <|> string \"\\n\"\n    <|> string \"\\r\"\n    <?> \"end of line\"\n{-- /snippet eol --}\n\nparseCSV :: String -> Either ParseError [[String]]\nparseCSV input = parse csvFile \"(unknown)\" input\n", "input": "\"hello\"", "status": "success", "output": "Left \"(unknown)\" (line 1, column 6):\nunexpected end of input\nexpecting \",\" or end of line"}
{"code": "-- Merge sort in Haskell\n\nmergeSort :: [Int] -> [Int]\nmergeSort [] = []\nmergeSort [x] = [x]\nmergeSort xs = let (a, b) = splitAt ((length xs) `div` 2) xs\n               in merge (mergeSort a) (mergeSort b)\n               where merge [] ys = ys\n                     merge xs [] = xs\n                     merge (x:xs) (y:ys) = if x <= y then x:(merge xs (y:ys)) else y:(merge ys (x:xs))\n", "input": "[42, 42]", "status": "success", "output": "[42,42]"}
{"code": "import Data.Char\nimport Data.List\n\ndetectCapitalUse :: String -> Bool\ndetectCapitalUse [] = error \"Function accepts non-empty Strings only.\"\ndetectCapitalUse s\n  | onlyFirstUpper s = True\n  | allUpper       s = True\n  | allLower       s = True\n  | otherwise        = False\n  where\n    onlyFirstUpper (x:xs) = isUpper x && allLower xs\n    allUpper = all isUpper\n    allLower = all isLower", "input": "\"hello\"", "status": "success", "output": "True"}
{"code": "to_tens :: Integer -> [Integer]\r\nto_tens 0 = []\r\nto_tens n = to_tens (n `div` 10) ++ [n `mod` 10] \r\n\r\nto_binary :: Integer -> [Integer]\r\nto_binary 0 = []\r\nto_binary n = to_binary (n `div` 2) ++ [n `mod` 2] \r\n\r\nis_palindrome xs = xs == (reverse xs)\r\n\r\n\r\nis_palindrome_base n = is_palindrome (to_tens n) && is_palindrome (to_binary n)\r\n\r\n\r\nans = sum $ filter is_palindrome_base [1..1000000]", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "collatz :: Int -> [Int]\ncollatz x\n  | x==1 = [1]\n  | even x = x: (collatz (x`div`2))\n  | odd x = x: (collatz (3*x+1))\n\nlengthOfCollatz :: Int -> (Int, Int)\nlengthOfCollatz x = (x, length $ collatz x)\n\nsearchInLists :: Int -> [[Int]] -> Bool\nsearchInLists x list = elem x $ concat list\n\ncollats = foldl (\\acc x-> if(searchInLists x acc) then acc else collatz x : acc)[] [1000000,999999..1]\n", "input": "42", "status": "success", "output": "[42,21,64,32,16,8,4,2,1]"}
{"code": "import Control.Monad\nimport Data.Char (isAlpha, toLower)\nimport System.Exit (exitSuccess)\n\nnormalize :: String -> String\nnormalize = map toLower . filter isAlpha\n\npalindrome :: IO ()\npalindrome = forever $ do\n  line <- getLine\n  let line' = normalize line\n  case (line' == reverse line') of\n    True -> putStrLn \"It's a palindrome!\"\n    False -> do\n      putStrLn \"Nope!\"\n      exitSuccess", "input": "\"hello\"", "status": "success", "output": "\"hello\""}
{"code": "fibonacci :: Integer -> Integer\nfibonacci n | n == 0 = 0\n            | n == 1 = 1\n            | n == -1 = 1\n            | n > 1 = positiveHelper 0 1 n\n            | n < -1 = negativeHelper 0 1 n\n\npositiveHelper a b n | n == 0 = a\n                     | n > 0 = positiveHelper b (a + b) (n - 1)\n\nnegativeHelper a b n | n == 0 = a\n                     | n < 0 = negativeHelper b (a - b) (n + 1)", "input": "42", "status": "success", "output": "267914296"}
{"code": "import Data.Char\n\ncap :: String -> String\ncap = map toUpper\n\nrev :: String -> String\nrev = reverse\n\ntupled :: String -> (String, String)\ntupled = (,) <$> cap <*> rev\n\ntupled' :: String -> (String, String)\ntupled' = do\n    c <- cap\n    r <- rev\n    return (c,r)\n\ntupled'' :: String -> (String, String)\ntupled'' = cap >>= \n                \\c -> rev >>=\n                       \\r -> return (c,r)\n", "input": "\"hello\"", "status": "success", "output": "\"HELLO\""}
{"code": "import Text.ParserCombinators.Parsec\n\ncsvFile = endBy line eol\nline = sepBy cell (char ',')\ncell = many (noneOf \",\\n\\r\")\n\n{-- snippet eol --}\neol =   try (string \"\\n\\r\")\n    <|> try (string \"\\r\\n\")\n    <|> string \"\\n\"\n    <|> string \"\\r\"\n    <|> fail \"Couldn't find EOL\"\n{-- /snippet eol --}\n\nparseCSV :: String -> Either ParseError [[String]]\nparseCSV input = parse csvFile \"(unknown)\" input\n", "input": "\"hello\"", "status": "success", "output": "Left \"(unknown)\" (line 1, column 6):\nunexpected end of input\nexpecting \",\", \"\\n\\r\", \"\\r\\n\", \"\\n\" or \"\\r\"\nCouldn't find EOL"}
{"code": "-- find the difference between the sum of squares and the square of sums\n\nsumSquare :: [Int] -> Int\nsumSquare = sum . map ( ^ 2 )\n\nsquareSum :: [Int] -> Int\nsquareSum xs = \n    s ^ 2 \n  where s = sum xs\n\n-- ans 1..100\nans :: Int -> Int -> Int\nans x y\n  | sumSquare [x..y] > squareSum [x..y] = sumSquare [x..y] - squareSum [x..y]\n  | otherwise             = squareSum [x..y] - sumSquare [x..y]\n", "input": "[42, 42]", "status": "success", "output": "3528"}
{"code": "myadd x y = x + y\n\nmylength [] count = count\nmylength (x:xs) count = mylength xs (1 + count)\n\nadd5 :: [Int] -> [Int]\nadd5 [] = []\nadd5 (x:xs) = (x+5):add5(xs)       \n\nmymap :: (x -> y) -> [x] -> [y]\nmymap f [] = []\nmymap f (x:xs) = f x:mymap f xs\n\nmyfilter :: (x -> Bool) -> [x] -> [x]\nmyfilter f [] = []\nmyfilter f (x:xs) | f x = x:myfilter f xs\n                  | otherwise =  myfilter f xs", "input": "[42, 42]", "status": "success", "output": "[47,47]"}
{"code": "\n-- Factorial [tail recursion] in Haskell\n-- Prashanth Babu V V :: 02nd Dec, 2016.\n\nfactorial :: Integer -> Integer\nfactorial n = tailrecFact n 1\n\n\ntailrecFact :: Integer -> Integer -> Integer\ntailrecFact n acc   | n == 1    = acc\n                    | otherwise = tailrecFact (n-1) (acc * n)\n\n\n\n-- ghci factorial\n    -- factorial 12       -- > 479001600 \n    -- factorial 10       -- > 3628800\n", "input": "42", "status": "success", "output": "1405006117752879898543142606244511569936384000000000"}
{"code": "removeLowerCase :: [Char] -> [Char]\nremoveLowerCase str = [ c | c <- str, c `elem` ['A'..'Z']]\naddThree :: Int -> Int -> Int -> Int\naddThree x y z = x + y + z\nfactorial :: Integer -> Integer --Integer has larger max and min values than Int\nfactorial n = product [1..n]\ncircumference :: Float -> Float\ncircumference r = 2 * pi * r\ncircumference' :: Double -> Double\ncircumference' r = 2 * pi * r\n", "input": "['a', 'a']", "status": "success", "output": "\"\""}
{"code": "-- goldbach's conjectue\n-- find two primes that sum up to a given even number\n\np40 :: Int -> (Int,Int)\np40 n = let primes = sieve [2..] where\n                sieve (x:xs) = x : sieve [ z | z <- xs, mod z x /= 0 ]\n            isPrime n = n == (head . dropWhile (<n) $ primes)\n            m = head . filter f . takeWhile (<=n) $ primes where\n                f x = isPrime (n-x)\n        in (n-m,m)\n", "input": "42", "status": "success", "output": "(37,5)"}
{"code": "-- Thinking Functionally with Haskell \n-- Chapter 2, Homework C\n--\n-- Input: \"The morphology of prex- an essay in meta-algorithmics\n-- Output:\"The Morphology Of Prex- An Essay In Meta-algorithmics\n--\n\nimport Data.Char (toUpper)\n\ncapitalize :: String -> String\ncapitalize = unwords . map capitalizeWord . words\n\n\ncapitalizeWord :: String -> String\ncapitalizeWord str = toUpper (head str) : tail str\n", "input": "\"hello\"", "status": "success", "output": "\"Hello\""}
{"code": "isPrime :: Int -> Bool\nisPrime n = ( [] == [ i | i <- [2..floor (sqrt (fromIntegral n))], mod n i == 0]) \n\nprimesBelow :: Int -> [Int]\nprimesBelow n = [ x | x <- [1..n], isPrime x ]\n\n--gbMakeup :: Int -> [(Int,Int)]\ngbMakeup n = [ (p+2*s*s,p,s) | p <- primesBelow n, s <- [1..floor (sqrt (fromIntegral n))], p+2*s*s == n ]\n\n\nfirstExcept = [ a | a <- [1,3..1000000], gbMakeup a == [], not (isPrime a) ]", "input": "42", "status": "success", "output": "False"}
{"code": "letterCombinations :: String -> [String]\nletterCombinations [] = [[]]\nletterCombinations (x:xs) = case lookup x dict of\n  Nothing -> []\n  Just ys -> [ a:b | a <- ys, b <- letterCombinations xs]\n  where dict = [ ('2', \"abc\")       , ('3', \"def\")\n               , ('4', \"ghi\")       , ('5', \"jkl\")\n               , ('6', \"mno\")       , ('7', \"pqrs\")\n               , ('8', \"tuv\")       , ('9', \"wxyz\") ]\n", "input": "\"hello\"", "status": "success", "output": "[]"}
{"code": "quicksort :: [Int] -> [Int]\nquicksort [] = []\nquicksort (x:xs) = quicksort [x1 | x1 <- xs, x1 < x] ++ [x] ++ quicksort [x2 | x2 <- xs, x2 >= x]\n\n\nrep :: Int -> Int -> [Int]\nrep 0 _ = []\nrep n x = x : rep (n-1) x\n\nseln :: [a] -> Int -> a\nseln (x:_) 0 = x\nseln (x:xs) n = seln xs (n-1)\n\ninl :: Eq a => a -> [a] -> Bool \ninl x [] = False \ninl x (y:ys) | x == y    = True\n             | otherwise = inl x ys \n", "input": "[42, 42]", "status": "success", "output": "[42,42]"}
{"code": "-- file: ch04/SplitLines.hs\nsplitLines :: String -> [String]\n\nsplitLines [] = []\nsplitLines cs =\n    let (pre, suf) = break isLineTerminator cs\n    in pre : case suf of\n                ('\\r':'\\n':rest)  -> splitLines rest\n                ('\\r':rest)       -> splitLines rest\n                ('\\n':rest)       -> splitLines rest\n                _                 -> []\n\nisLineTerminator c = c == '\\r' || c == '\\n'", "input": "\"hello\"", "status": "success", "output": "[\"hello\"]"}
{"code": "{--\nIn the final example above, why does it only return a single a?\n\nBecause the first character is an 'a'\n\nExercises: Thy Fearful Symmetry\n--}\n\n-- 1\n\nmyWords :: String -> [String]\nmyWords []     = []\nmyWords x = (takeWord x):(myWords $ dropWord x)\n  where\n    takeWord = takeWhile (/=' ')\n    dropWord = (dropWhile (==' ') . dropWhile (/=' '))\n\n-- 2. See PoemLines.hs\n\n-- 3. See PoemLines.hs mySection function\n", "input": "\"hello\"", "status": "success", "output": "[\"hello\"]"}
{"code": "-- :load C:\\Local\\Dev\\haskell\\learn_chapter2.hs\n\nremoveNonUppercase :: [Char] -> [Char]\nremoveNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z'] ]\n\nadd3 :: Int -> Int -> Int -> Int\nadd3 x y z = x + y + z\n\naddLengths :: String -> String -> Int\naddLengths s1 s2 = length s1 + length s2\n\ncircumference :: Float -> Float\ncircumference r = 2 * pi * r\n\ncircumference' :: Double -> Double\ncircumference' r = 2 * pi * r\n\n\n", "input": "['a', 'a']", "status": "success", "output": "\"\""}
{"code": "-- 2.1 \u660e\u793a\u7684\u306a\u578b\u5ba3\u8a00\n\nremoveNonUppercase :: [Char] -> [Char]\nremoveNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z'] ]\n\naddThree :: Int -> Int -> Int -> Int\naddThree x y z = x + y + z\n\n-- 2.2 \u4e00\u822c\u7684\u306aHaskell\u306e\u578b\n\nfactorial :: Integer -> Integer\nfactorial n = product [1..n]\n\ncircumference :: Float -> Float\ncircumference r = 2 * pi * r\n\ncircumference' :: Double -> Double\ncircumference' r = 2 * pi * r\n", "input": "['a', 'a']", "status": "success", "output": "\"\""}
{"code": "sumOfDivisors :: Int -> Int\nsumOfDivisors number = iter 1 2\n    where\n        iter result current\n            |current == number = result\n            |(mod number current) == 0 = iter (result + current) (current + 1)\n            |otherwise = iter result (current + 1)\n\ninterestingNumber :: Int -> Bool\ninterestingNumber number\n    |number <= 1 = False\n    |otherwise = number == (sumOfDivisors (sumOfDivisors number))\n\n", "input": "42", "status": "success", "output": "54"}
{"code": "\n-- simple problem:\n-- input string like \"abcde\"\n-- and output like:\n-- [\"\", \"a\", \"ab\", \"abc\", \"abcd\", \"abcde\"]\n\n\n-- main function (has to be called)\nbuildSteps :: [Char] -> [[Char]]\nbuildSteps str = [] : take (length str) (nextStep str 1)\n\n\n-- Careful! this is an infinite loop!\n-- it has to be used with a take call for example\nnextStep :: [Char] -> Int -> [[Char]]\nnextStep str i = (take i str) : nextStep str (i+1)\n\n", "input": "['a', 'a']", "status": "success", "output": "[\"\",\"a\",\"aa\"]"}
{"code": "detectCapitalUse :: String -> Bool\ndetectCapitalUse [] = error \"Function accepts non-empty Strings only.\"\ndetectCapitalUse s\n  | onlyFirstUpper s = True\n  | allUpper       s = True\n  | allLower       s = True\n  | otherwise        = False\n  where\n    onlyFirstUpper (x:xs) = isUpper x && allLower xs\n    allUpper = all isUpper\n    allLower = all isLower\n    isUpper = (`elem` ['A'..'Z'])\n    isLower = (`elem` ['a'..'z'])", "input": "\"hello\"", "status": "success", "output": "True"}
{"code": "root :: Double -> [Double]\nroot 0 = [0]\nroot x\t| x < 0 = []\n\t| otherwise = [- sqrt x, sqrt x]\n\ncalc :: Double -> Double -> [Double]\ncalc a b = root . (+ b) =<< root a\n\ngrd :: Bool -> [()]\ngrd False = []\ngrd True = [()]\n\ncalc2 :: Double -> Double -> [Double]\ncalc2 a b = do\n\tx <- root a\n\ty <- root $ x + b\n\tgrd $ y >= 0\n\treturn y\n\ncalc3 :: Double -> Double -> [Double]\ncalc3 a b = [ y | x <- root a, y <- root $ x + b, y >= 0 ]\n", "input": "2.71", "status": "success", "output": "[-1.6462077633154328,1.6462077633154328]"}
{"code": "fib :: Int -> Int\nfib n = fibGen 0 1 n\n\nfibs :: [Integer]\nfibs = 0 : 1 : [ a + b | (a, b) <- zip fibs (tail fibs)]\n\nfibGen :: Int -> Int -> Int -> Int\nfibGen a b n = case n of\n    0 -> a\n    n -> fibGen b (a + b) (n - 1)\n\nfibPoly :: (Num a, Eq a, Num b, Eq b) => a -> b\nfibPoly n = fibGenPoly 0 1 n\n\nfibGenPoly :: (Num a, Eq a, Num b, Eq b) => b -> b -> a -> b\nfibGenPoly a b 0 = a\nfibGenPoly a b n = fibGenPoly b (a + b) (n - 1)\n", "input": "42", "status": "success", "output": "267914296"}
{"code": "rle :: String -> [(Int, Char)]\nrle \"\"     = []\nrle [x]    = [(1, x)]\nrle (x:xs) = do\n    let tmp = rle xs\n    if (snd (tmp !! 0)) == x then\n       ((((fst (tmp !! 0)) + 1), x) : (tail tmp))\n    else\n       ((1, x) : tmp)\n\nrld :: [(Int, Char)] -> String\nrld [] = \"\"\nrld (x:xs) = if (fst x) == 0 then\n                rld xs\n             else\n                val : (rld (((fst x) - 1, val) : xs))\n                    where val = snd x\n", "input": "\"hello\"", "status": "success", "output": "[(1,'h'),(1,'e'),(2,'l'),(1,'o')]"}
{"code": "isListPalindrome :: [Char] -> Bool\nisListPalindrome str = case (length str) of\n    0 -> True\n    1 -> True\n    2 -> head str == last str\n    _ -> head str == last str && (isListPalindrome $ init $ tail str)\n\nisNumPalindrome :: Integer -> Bool\nisNumPalindrome n = isListPalindrome $ show n\n\n--findLargestPalindrome :: () -> Integer\nfindLargestPalindrome = maximum [ m * n | m <- [999, 998..1], n <- [m, m-1..1], isNumPalindrome (m * n)]", "input": "['a', 'a']", "status": "success", "output": "True"}
{"code": "doubleMe x = x + x\n\ndoubleUs x y = x * 2 + y * 2\ndoubleUs2 x y = doubleMe x + doubleMe y\n\ndoubleSmallNumber x = if x > 100\n  then x\n  else x * 2\n\ndoubleSmallNumber' x = (if x > 100 then x else x*2) + 1\n\nconanO'Brien = \"It's a-me, Conan O'Brien!\"\n\n\nfactorial :: Integer -> Integer\nfactorial n = product [1..n]\n\ncircumference :: Float -> Float\ncircumference r = 2 * pi * r\n\ncircumference' :: Double -> Double\ncircumference' r = 2 * pi * r\n", "input": "42", "status": "success", "output": "1405006117752879898543142606244511569936384000000000"}
{"code": "-- Examples from chapter 3\n-- http://learnyouahaskell.com/types-and-typeclasses\n\nremoveNonUppercase :: String -> String\nremoveNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]\n\naddThree :: Int -> Int -> Int -> Int\naddThree a b c = a + b + c\n\nfactorial :: Integer -> Integer\nfactorial n = product [1..n]\n\ncircumference :: Float -> Float  \ncircumference r = 2 * pi * r\n\ncircumference' :: Double -> Double  \ncircumference' r = 2 * pi * r\n", "input": "\"hello\"", "status": "success", "output": "\"\""}
{"code": "sum_n n | n == 0 = 0\n        | otherwise = n + sum_n (n-1)\n\nrep n a = if n == 1 then [a] else [a] ++ rep (n-1) a\n\npyths n = [(a,b,c) | a <- [1..n], b<-[1..n], c<-[1..n], a*a + b*b == c*c]\n\nfactors :: Int -> [Int]\nfactors n = [x | x <- [1..n], n `mod` x == 0]\n\nprime :: Int -> Bool\nprime n = factors n == [1,n]\n\nperfect :: Int -> Bool\nperfect n = sum (factors n) == n + n\n\nperfects :: Int -> [Int]\nperfects n = [x | x <- [1..n], perfect x]\n\n", "input": "42", "status": "success", "output": "[1,2,3,6,7,14,21,42]"}
{"code": "fac :: Integer -> Integer\nfac n \n    | n < 0     = error \"Negative arg\"\n    | n == 0    = 1\n    | otherwise = n * fac (n - 1)\n\ndigits :: Integer -> [Integer]\ndigits n\n    | n < 0     = error \"Negative arg\"\n    | n < 10    = [n]\n    | otherwise = digits (div n 10) ++ digits (rem n 10)\n\nmySum :: [Integer] -> Integer\nmySum []        = 0\nmySum [x]       = x\nmySum (x:xs)    = x + mySum xs\n\nanswer :: Integer\nanswer = mySum (digits (fac 100))\n", "input": "42", "status": "success", "output": "1405006117752879898543142606244511569936384000000000"}
{"code": "-- 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.\n\n-- What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?\n\n-- smallest positive number that is evenly divisible by all of the numbers from 1 to n\n-- lcm [1 to n]\n\nlcm' = foldl (lcm) 1\n\nmyList :: Int -> [Int]\nmyList n = [2 .. n]\n\nsmallestMul :: Int -> Int\nsmallestMul n = lcm' (myList n)\n", "input": "42", "status": "success", "output": "[2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42]"}
{"code": "-- fix the code\n\nimport Control.Monad.Trans.Maybe\nimport Control.Monad\n\nisValid :: String -> Bool\nisValid = elem '!'\n\nmaybeExcite :: MaybeT IO String\nmaybeExcite = MaybeT $ do\n  v <- getLine\n  guard $ isValid v\n  return $ Just v\n\ndoExcite :: IO ()\ndoExcite = do\n  putStrLn \"say something excite!\"\n  excite <- runMaybeT maybeExcite\n  case excite of\n    Nothing -> putStrLn \"MOAR EXCITE\"\n    Just e -> putStrLn (\"Good, was very excite: \" ++ e)\n", "input": "\"hello\"", "status": "success", "output": "False"}
{"code": "import Control.Applicative\n\nboop = (*2)\ndoop = (+10)\n\n-- function composition\nbip :: Integer -> Integer\nbip = boop . doop\n\n-- context is Functor\nbloop :: Integer -> Integer\nbloop = fmap boop doop\n\n-- context is Applicative\nbbop :: Integer -> Integer\nbbop = (+) <$> boop <*> doop\n\nduwop :: Integer -> Integer\nduwop = liftA2 (+) boop doop\n\n-- context is Monad\nboopDoop :: Integer -> Integer\nboopDoop = do\n  a <- boop\n  b <- doop\n  return (a + b)\n", "input": "42", "status": "success", "output": "104"}
{"code": "triangle n = (n * (n+1)) `div` 2\r\n\r\ntriangles = map triangle [1..]\r\n\r\ndivisors :: Integer -> [Integer]\r\ndivisors n = filter (\\x -> mod n x == 0) [1..n]\r\n\r\ndivisors2 :: Integer -> Integer\r\ndivisors2 n = \tlet aux i = if i*i < n then 2 else 1\r\n\t\t\t\tin sum [aux i | i <- [1..truncate (sqrt $ fromInteger n)], n `mod` i == 0]\r\n\r\n--ans = [x | i <- [1..10], let x = triangle i, length $ divisors x > 5]\r\nans = head $ filter (\\y -> divisors2 y > 500) triangles", "input": "42", "status": "success", "output": "[1,2,3,6,7,14,21,42]"}
{"code": "fun1 :: [Integer] -> Integer\nfun1 [] = 1\nfun1 (x:xs)\n    | even x    = (x - 2) * fun1 xs\n    | otherwise = fun1 xs\n\nfun1' :: [Integer] -> Integer\nfun1' = foldr (*) 1 . map (\\x -> x - 2) . filter even\n\nfun2 :: Integer -> Integer\nfun2 1 = 0\nfun2 n | even n     = n + fun2 (n `div` 2)\n       | otherwise  = fun2 (3 * n + 1)\n\nfun2' :: Integer -> Integer\nfun2' = sum . filter even . takeWhile (/=1) . iterate (\\y -> if odd y then 3 * y + 1 else y `div` 2)\n", "input": "[42, 42]", "status": "success", "output": "1600"}
{"code": "import Data.Char\n\nlet2int :: Char -> Int\nlet2int = \\ c -> ord c - ord 'a'\n\nint2let :: Int -> Char\nint2let = \\ n -> chr (ord 'a' + n)\n\nshift :: Int -> Char -> Char\nshift n c\n  | isLower c = int2let ((let2int c + n) `mod` 26)\n  | isUpper c = toUpper (int2let ((let2int (toLower c) + n) `mod` 26))\n  | otherwise = c\n\nencode :: Int -> String -> String\nencode n xs = [shift n x | x <- xs]\n\n\ntest = encode 13 \"Think like a Fundamentalist Code like a Hacker\"\n", "input": "'a'", "status": "success", "output": "0"}
{"code": "-- huffman coding\n\n\nimport Control.Arrow\nimport Data.Ord\nimport Data.List\n\np50    :: [(Char,Int)] -> [(Char,String)]\np50    = \n        let shrink [(_,ys)] = sortBy (comparing fst) ys\n            shrink (x:xs:ys) = shrink $ insertBy (comparing fst) (add x xs) ys\n\n            add (p1, xs1) (p2,xs2) = \n                (p1+p2, map (second ('0':)) xs1 ++ map (second ('1':)) xs2)\n        in shrink . map (\\(c,f) -> (f, [(c,\"\")])) . sortBy (comparing snd)\n", "input": "[('a', 42), ('a', 42)]", "status": "success", "output": "[('a',\"0\"),('a',\"1\")]"}
{"code": "import Data.List (transpose)\n\nzeroMatrix :: [[Integer]] -> [[Integer]]\nzeroMatrix x = [[zero i j v | (j, v) <- zip [0..] row] | (i, row) <- zip [0..] x]\n  where zeroRows = zeroIndices x\n        zeroCols = zeroIndices $ transpose x\n        zeroIndices y = map fst $ filter snd $ zip [0..] (map (any (== 0)) y)\n        zero row col val | row `elem` zeroRows = 0\n                         | col `elem` zeroCols = 0\n                         | otherwise = val\n", "input": "[[42, 42], [42, 42]]", "status": "success", "output": "[[42,42],[42,42]]"}
{"code": "-- Solutions for the \"Think Differently\" excercise at shuklan.com\n-- http://shuklan.com/haskell\n-- \n-- Description:\n-- http://shuklan.com/haskell/lec02.html#/0/22\n-- \n-- Author: Tamas Gal\n\n\nfacA :: Integer -> Integer\nfacA n\n  | n == 0     = 1\n  | otherwise = n * facA (n-1)\n\nfacB :: Integer -> Integer\nfacB n = product [1..n]\n\nfacC :: Integer -> Integer\nfacC n = foldl (*) 1 [1..n]\n\nfacD :: Integer -> Integer\nfacD n = if n < 2 then 1 else n * facD (n-1)\n", "input": "42", "status": "success", "output": "1405006117752879898543142606244511569936384000000000"}
{"code": "{--\r\n - Problem 39\r\n(*) A list of prime numbers.\r\n    Given a range of integers by its lower and upper limit, construct a list of all prime numbers in that range.\r\n\r\n    Example in Haskell:\r\n    P29> primesR 10 20\r\n    [11,13,17,19]\r\n --}\r\n\r\nisPrime :: Int -> Bool\r\nisPrime 1 = False\r\nisPrime n = 0 `notElem` map (n `mod`) [2, 3 .. m]\r\n    where m = floor . sqrt $ fromIntegral n \r\n\r\nprimesR :: Int -> Int -> [Int]\r\nprimesR l r = filter isPrime [l .. r]\r\n", "input": "42", "status": "success", "output": "False"}
{"code": "import Control.Monad.Trans.Maybe\nimport Control.Monad\nimport Control.Monad.IO.Class\n\nisValid :: String -> Bool\nisValid v = '!' `elem` v\n\n\nmaybeExcite :: MaybeT IO String\nmaybeExcite = do\n  v <- liftIO getLine\n  guard $ isValid v\n  return v\n\n  \ndoExcite :: IO ()\ndoExcite = do\n  putStrLn \"say something excite!\"\n  excite <- runMaybeT maybeExcite\n  case excite of\n    Nothing -> putStrLn \"MOAR EXCITE\"\n    Just e -> putStrLn (\"Good, was very excite: \" ++ e)\n", "input": "\"hello\"", "status": "success", "output": "False"}
{"code": "{--\r\n - Problem 35\r\n(**) Determine the prime factors of a given positive integer. Construct a flat list containing the prime\r\n    factors in ascending order.\r\n\r\n    Example:\r\n    * (prime\u2010factors 315)\r\n    (3 3 5 7)\r\n\r\n    Example in Haskell:\r\n    > primeFactors 315\r\n    [3, 3, 5, 7]\r\n --}\r\n\r\nprimeFactors :: Int -> [Int]\r\nprimeFactors 1 = []\r\nprimeFactors n = k : primeFactors (n `quot` k) where\r\n    k = head $ filter (\\a -> n `mod` a == 0) [2, 3 .. n] \r\n", "input": "42", "status": "success", "output": "[2,3,7]"}
{"code": "doubleMe :: Int -> Int\ndoubleMe x = x * 2\n\ndoubleSmallNumber :: Int -> Int\ndoubleSmallNumber x = if x > 100\n    then x\n    else x * 2\n\nebg :: [Char] -> Bool\nebg x = elem (head x) ['A'..'Z']\n\ncircumference :: Double -> Double\ncircumference r = 2 * pi * r\n\ndoubleSmallNumber' :: Int -> Int\ndoubleSmallNumber' x\n    | x > 100 = x\n    | otherwise = x * 2\n\nxor :: Bool -> Bool -> Bool\nxor x y\n    | x == False && y == True = True\n    | x == True && y == True = False", "input": "42", "status": "success", "output": "84"}
{"code": "import Data.List\n\nnextRow :: String -> String\nnextRow previous =\n  let isTrap \"^^.\" = '^'\n      isTrap \".^^\" = '^'\n      isTrap \"^..\" = '^'\n      isTrap \"..^\" = '^'\n      isTrap _ = '.'\n  in map isTrap $ transpose [\".\" ++ init previous, previous, tail previous ++ \".\"]\n\npart1 :: String -> Int\npart1 = length . filter (== '.') . concat . take 40 . iterate nextRow\n\npart2 :: String -> Int\npart2 = length . filter (== '.') . concat . take 400000 . iterate nextRow\n", "input": "\"hello\"", "status": "success", "output": "\".....\""}
{"code": "\ndoubleSmallNumber x = if x > 100\n                       then x\n                       else x*2\n\ndoubleSmallNumber' x = (if x > 100 then x else x*2) + 1\n\nlength' xs = sum [1 | _ <- xs]\n\nremoveNonUppercase :: String -> String\nremoveNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]\n\naddThree :: Int -> Int -> Int -> Int\naddThree x y z = x + y + z\n\ncircumference :: Double -> Double\ncircumference r = 2 * pi * r\n\nmeow :: Int -> (Int, Int)\nmeow r = (2 * r, r)\n\n", "input": "\"hello\"", "status": "success", "output": "\"\""}
{"code": "import Data.Char\n\nlet2int :: Char -> Int\nlet2int c\n  | isLower c = ord c - ord 'a'\n  | isUpper c = ord c - ord 'A'\n  \nint2letL :: Int -> Char\nint2letL n = chr (ord 'a' + n)\n\nint2letU :: Int -> Char\nint2letU n = chr (ord 'A' + n)\n\nshift :: Int -> Char -> Char\nshift n c\n  | isLower c = int2letL ((let2int c + n) `mod` 26)\n  | isUpper c = int2letU ((let2int c + n) `mod` 26)\n  | otherwise = c\n  \nencode :: Int -> String -> String\nencode n xs = [shift n x | x <- xs]\n", "input": "'a'", "status": "success", "output": "0"}
{"code": "import Data.Map as M\n\ncountChars :: String -> M.Map Char Int\ncountChars x = addCounts x M.empty\n\naddCounts :: String -> M.Map Char Int -> M.Map Char Int\naddCounts \"\"     map = map\naddCounts (x:xs) map = addCounts xs (insertWith (+) x 1 map)\n\n\naddCounts' :: String -> M.Map Char Int -> M.Map Char Int\naddCounts' s map = Prelude.foldl (\\m c -> insertWith (+) c 1 m) map s\n\nreverseList :: [Int] -> [Int]\nreverseList [] = []\nreverseList (x:xs) = reverseList xs ++ [x]\n", "input": "\"hello\"", "status": "success", "output": "fromList [('e',1),('h',1),('l',2),('o',1)]"}
{"code": "import Data.List\n\nisPandigital :: [Char] -> Bool\nisPandigital str = if sort str == ['1'..'9'] then True else False\n\nconcatAll :: [[Char]] -> [Char]\nconcatAll strList = foldl (\\acc s -> acc ++ s) [] strList\n\npandigitalMul n max = concatAll [ show s | s <- [ n*i | i <- [1..max] ] ]\n\ntoInts :: [[Char]] -> [Int]\ntoInts strList = [ read n :: Int | n <- strList ]\n\nfindPM n max = toInts [pandigitalMul x y | x <- [2..n], y <- [1..max], isPandigital (pandigitalMul x y) ]\n\n", "input": "['a', 'a']", "status": "success", "output": "False"}
{"code": "\ndo1test = do\n    c <- getChar \n    putChar 'x'\n    putChar c\n    putChar '\\n'\n\nmake_string :: Char -> String\nmake_string achar = \"\\nThe character is : \" ++ [achar]\n\ndo2test = do\n    let mychar = 'U'\n    c <- getChar     \n    putStrLn (make_string c)\n    putChar mychar\n    putChar '\\n'\n\n\ndo3test = do   \n    c <- getChar     \n    let phrase = make_string c\n    putStrLn phrase   \n    putChar '\\n'\n\ndoReturn = do\n    c <- getChar\n    let test = c == 'y'\n    return test\n", "input": "'a'", "status": "success", "output": "\"\\nThe character is : a\""}
{"code": "import Data.List\nisPalindrome :: Int -> Bool\nisPalindrome n = n == reverse' n\n\ndigitsCount :: Int -> Int\ndigitsCount n\n  | n >= 0 && n <= 9 = 1\n  | otherwise = 1 + (digitsCount $ n `div` 10)\n\nreverse' :: Int -> Int\nreverse' n\n  | n >= 0 && n <= 9 = n\n  | otherwise = (n `rem` 10)*(10^((digitsCount n)-1)) + (reverse' $ n `div` 10)\n\nlargestPalindromeProduct :: [Char]\nlargestPalindromeProduct = show $ maximum [(x*y) | x <- [100..999], y <- [100..999], isPalindrome(x*y)]", "input": "42", "status": "success", "output": "False"}
{"code": "\nimport Control.Monad\n\npds :: Integer -> [Integer]\npds n = helper 2\n\twhere lim = round $ sqrt $ fromInteger n\n\t      helper d \n\t\t| d >= lim   = [1]\n\t\t| rem == 0  = e ++ (helper (d+1) )\n\t\t| otherwise = helper (d+1)\n\t\twhere rem = n `mod` d\n\t\t      d'  = n `div` d\n\t\t      e   = if(d == d')\n\t\t\t\tthen [d]\n\t\t\t\telse [d,d']\n\n--d :: Int -> Int\nd = sum . pds\n\np21 = sum $ do\n\ta <- [4 .. 10000]\n\tlet b = d a\n\tguard( a /= b)\n\tguard( b < 10000)\n\tguard( a == (d b))\n\treturn a --, b)\n", "input": "42", "status": "success", "output": "[2,21,3,14,1]"}
{"code": "doubleMe x = x + x\n\ndoubleUs x y = doubleMe x + doubleMe y \n\ndoubleSmallNumber x = if x > 100\n                        then x\n                        else x * 2\n\nremoveNoneUppercase :: String -> String\nremoveNoneUppercase string = [ c | c <- string, elem c ['A'..'Z']]\n\nlucky :: (Integral a) => a -> String\nlucky 7 = \"Lucky number seven!\"\nlucky x = \"Sorry, you're out of luck, pal.\"\n\nfactorial :: (Integral a) => a -> a\nfactorial 0 = 1\nfactorial n = n * factorial (n - 1)\n", "input": "\"hello\"", "status": "success", "output": "\"\""}
{"code": "import Data.Char\n\ncap :: [Char] -> [Char]\ncap xs = map toUpper xs\n\nrev :: [Char] -> [Char]\nrev xs = reverse xs\n\ncomposed :: [Char] -> [Char]\ncomposed = cap . rev\n\nfmapped :: [Char] -> [Char]\nfmapped = fmap cap rev\n\ntupled :: [Char] -> ([Char],[Char])\ntupled = (,) <$> cap <*> rev\n\ntupled' :: [Char] -> ([Char],[Char])\ntupled' = do\n    c <- cap\n    r <- rev\n    return (c,r)\n\ntupled'' :: [Char] -> ([Char],[Char])\ntupled'' =\n    cap >>= (\\c -> rev >>= (\\r -> return (c,r)))\n", "input": "['a', 'a']", "status": "success", "output": "\"AA\""}
{"code": "import Data.List\n\nminfree :: [Int] -> Int\nminfree xs = findhead 0 (length xs, xs)\n\nfindhead :: Int -> (Int, [Int]) -> Int\nfindhead s (n, xs) | n == 0       = s\n                   | c == offset  = findhead b (n - c, vs)\n                   | otherwise    = findhead s (c, us)\n                     where\n                       (us, vs) = partition (< b) xs\n                       offset = 1 + n `div` 2\n                       b = s + offset\n                       c = length us\n\n", "input": "[42, 42]", "status": "success", "output": "0"}
{"code": "singleSort :: [Integer] -> [Integer]\nsingleSort [x] = [x]\nsingleSort (x:y:zs) | x > y     = x : singleSort (y:zs)\n                    | otherwise = y : singleSort (x:zs)\n\nbubleSort :: [Integer] -> [Integer]\nbubleSort x = iterate singleSort x !! length x\n\nresult = bubleSort [2,4,1,3,5]\n--\n-- bsort []  = []\n-- bsort [x] = [x]\n-- bsort (x:xs) | x < y     = x : bsort (y:ys)\n--              | otherwise = y : bsort (x:ys)\n--              where\n--              (y:ys) = bsort xs\n", "input": "[42, 42]", "status": "success", "output": "[42,42]"}
{"code": "-- file: ch04/Map.hs\n\nimport Data.Char (toUpper)\n\nsquare :: [Double] -> [Double]\nsquare [] = []\nsquare (x:xs) = x * x : square xs\n\n-- rewrite using map\n\nsquare2 xs = map squareOne xs\n    where squareOne x = x * x\n\nuppercase :: String -> String\nuppercase [] = []\nuppercase (x:xs) = toUpper(x) : uppercase xs\n\n-- rewrite using map\n\nuppercase2 xs = map toUpper xs\n\n-- Let's implement map ourselves:\n\nmyMap :: (a -> b) -> [a] -> [b]\nmyMap f (x:xs) = f x : myMap f xs\nmyMap _ [] = []\n", "input": "[2.71, 2.71]", "status": "success", "output": "[7.3441,7.3441]"}
{"code": "-- 2^15 = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.\n-- What is the sum of the digits of the number 2^1000?\n-- http://projecteuler.net/index.php?section=problems&id=16\n\n\n-- stolen from http://projecteuler.net/index.php?section=forum&id=20\nsumDigits :: Integer -> Integer \nsumDigits 0 = 0 \nsumDigits n = (n `mod` 10) + sumDigits (n `div` 10)\n\npowSum a = sumDigits ( 2 ^ a)\n\n--skipped around did P20 first, this sumDigits is much better then what I had thought of.\n", "input": "42", "status": "success", "output": "6"}
{"code": "evenSum :: [Integer] -> Integer\nevenSum l = accumSum 0 l\n\naccumSum n l = if l == []\n                  then n\n                  else let x = head l\n                           xs = tail l\n                       in if even x\n                             then accumSum (n+x) xs\n                             else accumSum n xs\n                                    \n\nevenSum' :: [Integer] -> Integer\nevenSum' [] = 0\nevenSum' (x:xs) = if even x then x + evenSum' xs else evenSum' xs     ", "input": "[42, 42]", "status": "success", "output": "84"}
{"code": "{-- snippet mySum --}\nmySum xs = helper 0 xs\n    where helper acc (x:xs) = helper (acc + x) xs\n          helper acc _      = acc\n{-- /snippet mySum --}\n\n{-- snippet foldlSum --}\nfoldlSum xs = foldl step 0 xs\n    where step acc x = acc + x\n{-- /snippet foldlSum --}\n\n{-- snippet niceSum --}\nniceSum :: [Integer] -> Integer\nniceSum xs = foldl (+) 0 xs\n{-- /snippet niceSum --}\n\n{-- snippet nicerSum --}\nnicerSum :: [Integer] -> Integer\nnicerSum = foldl (+) 0\n{-- /snippet nicerSum --}\n", "input": "[42, 42]", "status": "success", "output": "84"}
{"code": "import Data.Char\n\ncalcLuhnChecksum :: Int -> Int\ncalcLuhnChecksum n = (sum $ oddsn ++ map (\\d -> sum $ digits $ d * 2) evensn) * 9 `mod` 10\n  where oddsn = odds $ digits n\n        evensn = evens $ digits n\n        odds (x:y:xs) = x : odds xs\n        odds (x:[])   = x : []\n        odds _ = []\n        evens (x:y:xs) = y : evens xs\n        evens _ = []\n        digits :: Int -> [Int]\n        digits = map ((subtract zero) . ord) . show\n          where zero = ord '0'\n        \n        \n", "input": "42", "status": "success", "output": "2"}
{"code": "-- file: ch04/SplitLines.hs\n-- From chapter 4, http://book.realworldhaskell.org/read/functional-programming.html\n\nsplitLines :: String -> [String]\nsplitLines [] = []\nsplitLines cs =\n    let (pre, suf) = break isLineTerminator cs\n    in  pre : case suf of\n                    ('\\r':'\\n':rest) -> splitLines rest\n                    ('\\r':rest) -> splitLines rest\n                    ('\\n':rest) -> splitLines rest\n                    _ -> []\n\nisLineTerminator c = c == '\\r' || c == '\\n'\n", "input": "\"hello\"", "status": "success", "output": "[\"hello\"]"}
{"code": "{--\r\n - Problem 34\r\n(**) Calculate Euler's totient function phi(m).\r\n    Euler's so-called totient function phi(m) is defined as the number of positive integers r (1 <= r < m) that\r\n    are coprime to m.\r\n\r\n    Example: m = 10: r = 1,3,7,9\u037e thus phi(m) = 4. \r\n\r\n    Note the special case: phi(1) = 1.\r\n\r\n    Example:\r\n    * (totient\u2010phi 10)\r\n    4\r\n\r\n    Example in Haskell:\r\n    * totient 10\r\n    4\r\n --}\r\n\r\ntotient :: Int -> Int\r\ntotient n = length $ filter (== 1) $ map (gcd n) [1 .. n-1]\r\n", "input": "42", "status": "success", "output": "12"}
{"code": "import Data.List\n\ncoFactors :: Int -> [Int]\ncoFactors n = filter (test n) [1..(intSqrt n)] --generates factors upto sqrt\n  where intSqrt = floor . sqrt . fromIntegral\n        test n x = mod n x == 0\n\nfactors :: Int -> [Int]\nfactors n = (fmap (div n) fac) ++ fac  \n  where fac = coFactors n\n\nprime n = (length $ factors n) <= 2\n\nlargestPrime' :: Int -> [Int]\nlargestPrime' n = dropWhile (not . prime) (reverse $ sort $ factors n)\n\nlargestPrime :: Int -> Int\nlargestPrime n = head $ largestPrime' n \n", "input": "42", "status": "success", "output": "[1,2,3,6]"}
{"code": "import Prelude\n\nisPrime :: Int -> Bool\nisPrime n\n    | n <= 0 = error \"You must insert a natural number.\\n\"\n    | otherwise = length [i | i <- [1..n], n `mod` i == 0] == 2\n\ndividesN :: Int -> [Int] -> [Int]\ndividesN n xs = [x | x <- xs, n `mod` x == 0]\n\nprimeFactors :: Int -> [Int]\nprimeFactors 1 = []\nprimeFactors n\n    | n <= 0 = error \"n must be positive.\\n\"\n    | otherwise = (minimum (dividesN n (filter isPrime [1..n]))):(primeFactors (n `div` (minimum (dividesN n (filter isPrime [1..n])))))\n", "input": "42", "status": "success", "output": "False"}
{"code": "-- FINISHED\n\nimport Data.List (foldl')\n\n\npresses :: String -> Int\npresses = foldl' (\\acc c -> acc + (evalMap keymap c)) 0\n\n\n-- | Unsafe.\nevalMap :: Eq a => Eq b => [([a], b)] -> a -> b\nevalMap f x = head . map snd . filter (\\(ks, v) -> x `elem` ks) $ f\n\n\n-- | Maps an upper-case letter or a space\n--   to the number of keypresses required.\nkeymap :: [([Char], Int)]\nkeymap =\n  [ (\"aAdDgGjJmMpPtTwW 1\", 1)\n  , (\"bBeEhHkKnNqQuUxX0\", 2)\n  , (\"cCfFiIlLoOrRvVyY\", 3)\n  , (\"sSzZ234568\", 4)\n  , (\"79\", 5)\n  ]\n", "input": "\"hello\"", "status": "success", "output": "13"}
{"code": "isPrime :: Int -> Bool\nisPrime n\n    | n <= 1 = False\n    | otherwise = isPrime' 2 n\n        where\n            isPrime' current n\n                | current == n = True\n                | mod n current == 0 = False\n                | otherwise = isPrime' (current + 1) n\n\ntruncatablePrime :: Int -> Bool\ntruncatablePrime x\n    | x <= 1 = False\n    |otherwise = truncatablePrime' x\n\twhere\n\t    truncatablePrime' x\n\t\t| (isPrime x) == True = truncatablePrime' (div x 10)\n\t\t| x == 0 = True\n\t\t| otherwise = False", "input": "42", "status": "success", "output": "False"}
{"code": "f :: Int -> [Int]\nf 0 = [1]\nf n = let t = f (n - 1) in (t!!0 * n) : t\n\nfact = reverse (f 9)\n\ng :: Int -> Int\ng 0 = 0\ng n = (fact!!(mod n 10)) + g (quot n 10)\n\nh :: Int -> [Int]\nh n = iterate g n\n\n\nhelper :: [Int] -> [Int] -> [Int]\nhelper (x:xs) t = if elem x t then t\n                  else helper xs (x:t)\n\nlen :: Int -> Int\nlen n = length $ helper (h n) []\n\nans :: Int -> Int -> Int\nans 0 x = x\nans n x = if len n == 60 then ans (n-1) (x+1)\n          else ans (n - 1) x\n        \n\nanswer = ans 1000000 0", "input": "42", "status": "success", "output": "[7538058755741581312,-2894979756195840000,-70609262346240000,2304077777655037952,4789013295250014208,1096907932701818880,9003737871877668864,6399018521010896896,4926277576697053184,3400198294675128320,-6045878379276664832,4999213071378415616,-8764578968847253504,-7055958792655077376,-5968160532966932480,-5483646897237262336,-1569523520172457984,7034535277573963776,-7835185981329244160,8128291617894825984,-1250660718674968576,-4249290049419214848,2432902008176640000,121645100408832000,6402373705728000,355687428096000,20922789888000,1307674368000,87178291200,6227020800,479001600,39916800,3628800,362880,40320,5040,720,120,24,6,2,1,1]"}
{"code": "-- file: ch4/exB1.hs\n-- A function that converts a `String` to an `Int`\n-- Daniel Brice\n\nimport Data.Char (digitToInt)\n\nsafeDigitToInt :: Char -> Int\nsafeDigitToInt '.' = error \"safeDigitToInt: '.' is not an allowed input.\"\nsafeDigitToInt dig = digitToInt dig\n\nsafeAsInt :: String -> Int\nsafeAsInt ('-' : xs) = (- 1) * (safeAsInt xs)\nsafeAsInt \"\"         = error \"safeAsInt: \\\"\\\" is not an allowed input.\"\nsafeAsInt xs         = foldl step 0 xs\n  where\n    step acc dig = acc * 10 + (safeDigitToInt dig)\n", "input": "'a'", "status": "success", "output": "10"}
{"code": "import Control.Monad.Writer\n\nlogNumber :: Int -> Writer [String] Int\nlogNumber x = writer (x, [\"Got number: \" ++ show x])\n\nmultWithLog :: Writer [String] Int\nmultWithLog = do\n  a <- logNumber 3\n  b <- logNumber 5\n  tell [\"Gonna multiply these two\"]\n  return (a*b)\n\ngcd' :: Int -> Int -> Writer [String]      Int\ngcd' a b\n  | b == 0 = do\n    tell [\"Finished with \" ++ show a]\n    return a\n  | otherwise = do \n      tell [show a ++ \" mod \" ++ show b ++ \" = \" ++ show (a `mod` b)]\n      gcd' b (a `mod   ` b)", "input": "42", "status": "success", "output": "WriterT (Identity (42,[\"Got number: 42\"]))"}
{"code": "\n-- main = main1_4\n\n(^%^) = \\a b -> a + b\n\nmain1_4 = interact tpText\n\ntpText :: String -> String\ntpText = unlines . transposeMatrix . convertToRectMatrix . lines\n\nconvertToRectMatrix :: [[Char]] -> [[Char]]\nconvertToRectMatrix iss = scanr1 (\\cl _ -> cl ++ ((take (maxLen - length cl)) $ repeat ' ')) $ iss\n  where maxLen = maximum . (map length) $ iss\n\ntransposeMatrix :: [[a]] -> [[a]]\ntransposeMatrix iss \n  | all null iss    = [] \n  | otherwise       = (map head iss) : (transposeMatrix . map tail $ iss)\n\n\n", "input": "\"hello\"", "status": "success", "output": "\"h\\ne\\nl\\nl\\no\\n\""}
{"code": "-- file: ch04/Sum.hs\n\nmySum xs = helper 0 xs\n    where helper acc [] = acc\n          helper acc (x:xs) = helper (acc + x) xs\n\n-- let's re-write mySum using foldl:\n\nfoldlSum xs = foldl step 0 xs\n    where step acc x = acc + x\n\n-- of course, the 'step' function is just taking the sum, so we can do\n\nniceSum :: [Integer] -> Integer\nniceSum xs = foldl (+) 0 xs\n\n-- We can also use currying to make this better. This gives us a function\n-- of the same type!\n\nniceSum' :: [Integer] -> Integer\nniceSum' = foldl (+) 0\n", "input": "[42, 42]", "status": "success", "output": "84"}
{"code": "-- Type annotation (optional)\nfib :: Int -> Integer\n \n-- With self-referencing data\nfib n = fibs !! n\n        where fibs = 0 : scanl (+) 1 fibs\n        -- 0,1,1,2,3,5,...\n \n-- Same, coded directly\nfib n = fibs !! n\n        where fibs = 0 : 1 : next fibs\n              next (a : t@(b:_)) = (a+b) : next t\n \n-- Similar idea, using zipWith\nfib n = fibs !! n\n        where fibs = 0 : 1 : zipWith (+) fibs (tail fibs)\n \n-- Using a generator function\nfib n = fibs (0,1) !! n\n        where fibs (a,b) = a : fibs (b,a+b)", "input": "42", "status": "success", "output": "267914296"}
{"code": "\nimport Data.List\n\nperm :: [Int] -> [[Int]]\nperm [a] = [[a]]\nperm x = \n    concat $ map (\\y -> map (y:) (perm (y `delete` x )) ) x\n\n\nprob68 f = \n    [(a,b,c,\n      d,e,\n       g,h,i,\n        j) | [a,b,c,d,g,h,i,j] <- perms,\n             let sm = a + g + h,\n             let e = 10,\n          --   let f = 2,\n             b + h + i == c + i + j,\n             c + i + j == d + j + f,\n             d + j + f == e + f + g, \n             a + g + h == b + h + i ]\n    where perms = perm (delete f [1..9])\n             \n", "input": "[42, 42]", "status": "success", "output": "[[42,42],[42,42]]"}
{"code": "-- Following allong with LearnYouAHaskell.com tutorial\n-- Chapter II code on types and typefaces\n\nremoveNonUpper :: [Char] -> [Char]\nremoveNonUpper st = [c | c <- st, c `elem` ['A'..'Z']]\n\naddThree :: Int -> Int -> Int -> Int\naddThree x y z = x+y+z\n\n-- Type demonstrations\n\n-- Integer for really big ints, Int for standard Ints\nfactorial :: Integer -> Integer\nfactorial n = product [1..n]\n\n-- Float for single precision decimals, double for double precision\ncircumference :: Float -> Float\ncircumference r = 2*pi*r\n", "input": "['a', 'a']", "status": "success", "output": "\"\""}
{"code": "-- Integers change their size based on the compiler. So for a 64 bit compiler, it's 64 bits. 32 bit gets 32 bits...\nfactorial :: Integer -> Integer\nfactorial n = product [1..n]\n\ncircumference :: Float -> Float\ncircumference r = 2 * pi * r\n\n\n-- polymorphic functions are just functions that use type variables.\n-- THis gets into type-level programming pretty heavily\n\n-- type class = an interface that defines some behavior. This is not an implementation!\n-- | This is haddock documentation. There are lots of things here\n", "input": "42", "status": "success", "output": "1405006117752879898543142606244511569936384000000000"}
{"code": "--A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 \u00d7 99.\r\n\r\n--Find the largest palindrome made from the product of two 3-digit numbers.\r\n\r\nto_tens :: Integer -> [Integer]\r\nto_tens 0 = []\r\nto_tens n = to_tens (n `div` 10) ++ [n `mod` 10] \r\n\r\n\r\nis_palindrome n = to_tens n == reverse (to_tens n)\r\n\r\ndigits = [i*j | i <- [100..999], j <- [100..999]]\r\n\r\n\r\nis_prod_palin (i,j) = is_palindrome (i * j)\r\n\r\nans = maximum $ filter is_palindrome digits\r\n", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "bla = [n | n <- [0..999999], (odd' (show (n + (rev n)))), (length $ show n) == (length $ show $ rev n)]\n\nrev :: Int -> Int\nrev n = read $ reverse $ show n\n\nodd' :: String -> Bool\nodd' [] = True\nodd' n = if (odd $ read $ [head n]) then (odd' $ tail n) else False\n\nhuhu = length bla\n\nenum n \n    | n `mod` 2 == 0 = let n' = n `div` 2\n\t\t       in 20 * 30 ^ (n' - 1)\n    | otherwise = let n' = n `div` 2\n\t\t      n'' = n' `div` 2\n\t\t  in if even n'\n\t\t     then 0\n\t\t     else 5 * 20 * (20 * 25) ^ n''\nresult = sum $ map enum [2..9]\n", "input": "42", "status": "success", "output": "24"}
{"code": "{-\n  --------------------------------------------------------------------------------------------------------------\n   Program     : fact.hs\n   Professor   : Richard Riehle\n   Programmer  : Jigar Gosalia (89753)\n   Description : Learn functions in Haskell.\n   Usage       : Load file in WinGHCi and run \"fact n\" where n is the nth number for Factorial.\n  ---------------------------------------------------------------------------------------------------------------\n-}\n\nfact :: Int -> Int\nfact 0 = 1\nfact n = n * fact (n - 1)", "input": "42", "status": "success", "output": "7538058755741581312"}
{"code": "-- sin wave, triangle wave, etc. to be used for the position of the object\n\nsinWave :: Double -> Double\nsinWave t = sin ( t * 2.0 * pi )\n\nrecWave :: Double -> Double\nrecWave t\n  | m < 0.5 = 1.0\n  | otherwise = -1.0              \n  where m = t - fromIntegral ( floor t )\n\ntriWave :: Double -> Double\ntriWave t\n  | m < 0.5 = 1.0 - m / 0.25\n  | otherwise = (-1.0) + ( m - 0.5 ) / 0.25\n  where m = t - fromIntegral ( floor t )\n\n-- so for instance, if t is in ms and we want a 1Hz pattern:\n-- objectPosition t = triWave ( t / 1000.0 )\n", "input": "2.71", "status": "success", "output": "-0.9685831611286309"}
{"code": "import Data.Ratio\n\ncalcE :: Int -> Rational\ncalcE n = calcE' 0\n  where \n    calcE' :: Int -> Rational\n    calcE' i = cur + next \n        where \n          cur \n            | i == 0 = 2 \n            | (i + 1) `mod` 3 == 0 = fromIntegral ((i + 1) `div` 3) * 2  \n            | otherwise = 1                \n            \n          next = if n == (i + 1) then 0 else 1 / calcE' (i + 1)\n\n\ndigits :: Integer -> [Integer]\ndigits 0 = []\ndigits i = digits (i `div` 10) ++ [i `mod` 10]\n\neuler65 = print $ sum $ digits $ numerator $ calcE 100\n", "input": "42", "status": "success", "output": "163627140912497702175 % 60195061159370501504"}
{"code": "import qualified Data.Map as Map\nimport Data.Char\n\nphoneBook = Map.fromList $ [\n    (\"betty\", \"555-2938\"),\n    (\"bonnie\", \"452-2928\"),\n    (\"patsy\", \"493-2928\"),\n    (\"lucille\", \"205-2928\")]\n\nfindBetty = Map.lookup \"betty\" phoneBook\n\nnewBook = Map.insert \"Grace\" \"800-333-3333\" phoneBook\n\ngetSize = Map.size phoneBook\n\nfindGrace = Map.lookup \"Grace\" phoneBook\n\naddGrace = Map.insert \"Grace\" \"800-444-4444\"\n\nstring2Digits :: String -> [Int]\nstring2Digits = map digitToInt . filter isDigit\n\nintBook = Map.map string2Digits phoneBook\n", "input": "\"hello\"", "status": "success", "output": "[]"}
{"code": "\n-- Reverse factorial in Haskell\n-- Prashanth Babu V V :: 02nd Dec, 2016.\n\nreverseFact :: Integer -> Maybe Integer\nreverseFact m = revFact m 2\n\nrevFact :: Integer -> Integer -> Maybe Integer\nrevFact m n     | rem m n /= 0  = Nothing\n                | factor == 1   = Just m\n                | otherwise     = revFact factor (n+1)\n                where factor    = div m n\n\n\n\n-- ghci reverseFactorial\n    -- reverseFact 479001600    -- > Just 12\n    -- reverseFact 3628800      -- > Just 10\n    -- reverseFact 18           -- > Nothing\n", "input": "42", "status": "success", "output": "Nothing"}
{"code": "-- | Count number times each 'base' shows up in a sequence\n--\n-- >>> \"AGCTTTTCATTCTGACTGCAACGGGCAATATGTCTCTGTGTGGATTAAAAAAAGAGTGTCTGATAGCAGC\"\n-- (20,12,21,17)\n\ntype ACTG = (Int,Int,Int,Int)\n\ncountBase :: [Char] -> ACTG\ncountBase ls = acc ls (0,0,0,0)\n  where acc :: [Char] -> ACTG -> ACTG\n        acc [] result = result\n        acc (x : xs) r@(a,c,t,g) = case x of\n          'A' -> acc xs (a+1,c,t,g)\n          'C' -> acc xs (a,c+1,t,g)\n          'T' -> acc xs (a,c,t+1,g)\n          'G' -> acc xs (a,c,t,g+1)\n          _   -> acc xs r\n", "input": "['a', 'a']", "status": "success", "output": "(0,0,0,0)"}
{"code": "import qualified Data.IntMap.Strict as IntMap\nimport           Data.IntMap.Strict (IntMap)\n\nimport           Data.Char\n\nfromList :: String -> IntMap Int\nfromList = IntMap.fromListWith (+) . flip zip (repeat 1) . map ord\n\nconvert :: IntMap Int -> IntMap String\nconvert = IntMap.foldlWithKey go IntMap.empty\n  where\n    go m k v = IntMap.insertWith (++) v (pure (chr k)) m\n\nencode :: IntMap String -> String\nencode = IntMap.foldlWithKey go []\n  where\n    go m k v = (concatMap (replicate k) v) ++ m\n\nfreqSort = encode . convert . fromList\n", "input": "\"hello\"", "status": "success", "output": "fromList [(101,1),(104,1),(108,2),(111,1)]"}
{"code": "-- sumOfMultiplesUnder numa numb maxVal\n-- Helps calculate\n-- the sum of all the multiples of numa or numb below maxVal\n\nfindN large small = quot large small\n\nmultiplyByN numa numb = numa * numb\n\naggregate :: [Int] -> Int\naggregate = foldr (+) 0\n\nsigma lowerBound upperBound func = aggregate(map func [lowerBound .. upperBound])\n\nsumOfMultiples num max = sigma 1 (findN (max - 1) num) (multiplyByN num)\n\nsumOfMultiplesUnder numa numb maxVal = (sumOfMultiples numa maxVal) + (sumOfMultiples numb maxVal) - (sumOfMultiples(lcm numa numb) maxVal)\n", "input": "[42, 42]", "status": "success", "output": "84"}
{"code": "double :: Integer -> Integer\ndouble x = 2 * x\n\nmapDouble :: [Integer] -> [Integer]\nmapDouble = map double\n\nmapDoubleDouble :: [Integer] -> [Integer]\nmapDoubleDouble = map (double . double)\n\n-- sum :: [Integer] -> Integer\n\n-- sum . map double [x] = sum [2a, 2b, 2c, 2d]\n\n-- sum . map double [x] ==== double . sum [x]\n-- sum . map double ==== double . sum\n\n-- sum [ sumx, sumy sumz] ==== sum( concat(x,y,z) )\n-- sum . map sum ==== sum . concat\n\n-- sum. sort === sum\n\n-- [1] :: Num t => [t]\n-- *Main> :type \"lorem\"\n\n-- *Main> :type 'a'\n-- 'a' :: Char", "input": "42", "status": "success", "output": "84"}
{"code": "import Control.Monad.Writer\n\nlogNumber :: Int -> Writer [String] Int\nlogNumber x = writer (x, [\"Got number: \" ++ show x])\n\nmultWithLog :: Writer [String] Int\nmultWithLog = do\n    a <- logNumber 3\n    b <- logNumber 5\n    tell [\"Gonna multiply these two\"]\n    return (a*b)\n\n-- gcd' is a log version gcd\ngcd' :: Int -> Int -> Writer [String] Int\ngcd' a b\n    | b == 0 = do\n        tell [\"Finished with \" ++ show a]\n        return a\n    | otherwise = do\n        tell [show a ++ \" mod \" ++ show b ++ \" = \" ++ show (a `mod` b)]\n        gcd' b (a `mod` b)\n\n", "input": "42", "status": "success", "output": "WriterT (Identity (42,[\"Got number: 42\"]))"}
{"code": "-- Thinking Functionall with Haskell\n-- Chapter 05 Homework F\n-- Implement words\n\nimport Data.List\n\n-- whiteSpace tests a Char is white space or not\nwhiteSpace :: Char -> Bool\nwhiteSpace ' ' = True\nwhiteSpace '\\t' = True \nwhiteSpace '\\n' = True\nwhiteSpace '\\r' = True\nwhiteSpace _ = False\n\nwords' :: [Char] -> [[Char]]\nwords' s = helper (dropWhile whiteSpace s)\n    where helper [] = [] \n          helper ss = let (prefix, suffix) = span (not . whiteSpace) (dropWhile whiteSpace ss) \n                      in prefix : helper (dropWhile whiteSpace suffix)\n", "input": "'a'", "status": "success", "output": "False"}
{"code": "import Data.Char\n\nsafeRecip :: Double -> Maybe Double\nsafeRecip = \\x -> case x of\n\t0 -> Nothing\n\t_ -> Just $ 1 / x\n\ncheckAnswer :: Char -> Maybe Bool\ncheckAnswer c = case toLower c of\n\t'y' -> Just True\n\t'n' -> Just False\n\t_ -> Nothing\n\ndiffRecip :: Double -> Double -> Maybe Double\ndiffRecip x y = case x - y of\n\t0 -> Nothing\n\td\t| d > 0 -> Just $ recip d\n\t\t| otherwise -> Just $ recip (- d)\n\nformat :: String -> [(String, Int)] -> String\nformat k d = case lookup k d of\n\tJust n -> replicate (5 - length s) ' ' ++ reverse s\n\t\twhere s = show n\n\tNothing -> \"NO VALUE\"\n", "input": "2.71", "status": "success", "output": "Just 0.36900369003690037"}
{"code": "\n---------------------------------\n--- Type\n---------------------------------\n\n-- Char\nremoveNonUppercase :: [Char] -> [Char]\nremoveNonUppercase st = [c | c <- st, c `elem` ['A'..'Z']]\n\n-- Int\naddThree :: Int -> Int -> Int -> Int\naddThree x y z = x + y + z\n\n-- Integer\nfactorial :: Integer -> Integer\nfactorial n = product [1..n]\n\n-- Float\ncircumference :: Float -> Float\ncircumference r = 2 * pi * r\n\n-- Double\ncircumference' :: Double -> Double\ncircumference' r = 2 * pi * r\n\n\n---------------------------------\n-- Typeclass\n---------------------------------\n\n-- Eq\n\n", "input": "['a', 'a']", "status": "success", "output": "\"\""}
{"code": "test1 = [] -- this test make error, need Maybe data to fix it\ntest2 = [2,1,2,1,0,1,2]\ntest3 = [1]\ntest4 = [7,1,5,3,6,4]\ntest5 = [2,4,1]\n\nmaxProfit :: [Integer] -> Integer\nmaxProfit (x:xs) = let reL = [0,x,0] in\n     maxProfit' xs reL where\n     maxProfit' (x:xs) reL = maxProfit' xs (innerMP x reL)\n     maxProfit' [] reL     = last reL\n\n\n-- () = (minv maxv result)\ninnerMP :: Integer -> [Integer] -> [Integer]\ninnerMP a (maxv:minv:result)\n  | a < minv = [maxv,a] ++ result\n  | (a - minv) > (head result) = [a,minv] ++ [(a - minv)]\n  | otherwise = [maxv,minv] ++ result\n", "input": "[42, 42]", "status": "success", "output": "0"}
{"code": "{-- snippet upperCase --}\nimport Data.Char (toUpper)\n\nupperCase :: String -> String\n\nupperCase (x:xs) = toUpper x : upperCase xs\nupperCase []     = []\n{-- /snippet upperCase --}\n\n{-- snippet square --}\nsquare :: [Double] -> [Double]\n\nsquare (x:xs) = x*x : square xs\nsquare []     = []\n{-- /snippet square --}\n\n{-- snippet map2 --}\nsquare2 xs = map squareOne xs\n    where squareOne x = x * x\n\nupperCase2 xs = map toUpper xs\n{-- /snippet map2 --}\n\n{-- snippet myMap --}\nmyMap :: (a -> b) -> [a] -> [b]\n\nmyMap f (x:xs) = f x : myMap f xs\nmyMap _ _      = []\n{-- /snippet myMap --}\n", "input": "\"hello\"", "status": "success", "output": "\"HELLO\""}
{"code": "doubleMe x = x + x\n\ndoubleUs x y = x * 2 + y * 2\n\ndoubleUs2 x y = doubleMe x + doubleMe y\n\ndoubleSmalls x =  if x > 100 then x else x * 2\n\ndoubleSmalls' x = (if x > 100 then x else x * 2) + 20\n\nconanO'Brien = \"It's a-me, Conan O'Brien!\"\n\n\nlength' xs = sum [1 | _ <- xs]\n\n--removeNonUpperCase :: [Char] -> [Char]\n--equivalent to:\nremoveNonUpperCase :: String -> String\nremoveNonUpperCase st = [c | c <- st, c `elem` ['A'..'Z']]\n\n--we can use the fact that characters are Ordered too\nremoveNonUpperCase2 :: String -> String\nremoveNonUpperCase2 st = [c | c <- st, c >= 'A', c <= 'Z']\n\n\n", "input": "\"hello\"", "status": "success", "output": "\"\""}
{"code": "toDigits :: Integer -> [Integer]\ntoDigits x\n    | x > 0 = toDigits (div x 10) ++ [mod x 10]\n    | otherwise = []\n\ntoDigitsRev :: Integer -> [Integer]\ntoDigitsRev = reverse . toDigits\n\ndoubleEven :: Integer -> Integer -> Integer\ndoubleEven i x\n    | even i = x * 2\n    | otherwise = x\n\ndoubleEveryOther :: [Integer] -> [Integer]\ndoubleEveryOther = zipWith doubleEven [1..]\n\nsumDigits :: [Integer] -> Integer\nsumDigits = sum . map (sum . toDigits)\n\nvalidate :: Integer -> Bool\nvalidate num = \n    sum' num `mod` 10 == 0\n    where\n        sum' = sumDigits . doubleEveryOther . toDigitsRev\n\n", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "import Data.List(foldl')\n\nfEvenSum :: [Integer] -> Integer\nfEvenSum l = foldl mySum 0 (filter even l)\n             where  mySum acc x = acc + x  \n\nmyFoldl f z [] = z\nmyFoldl f z (x:xs) = myFoldl f (f z x) xs\t\n\nfEvenSum' :: [Integer] -> Integer\nfEvenSum' l = myFoldl mySum 0 (filter even l)\n             where  mySum acc x = acc + x  \n\nfEvenSum'' :: [Integer] -> Integer\nfEvenSum'' l = foldl (\\x y -> x + y) 0 (filter even l)\n\nfEvenSum''' :: [Integer] -> Integer\nfEvenSum''' l = foldl (+) 0 (filter even l)\n\nfEvenSum'''' :: [Integer] -> Integer\nfEvenSum'''' l = foldl' (+) 0 (filter even l)\n", "input": "[42, 42]", "status": "success", "output": "84"}
{"code": "-- construct complete binary tree\n-- and iscompletetree function\n\ndata Tree a = Empty | Branch a (Tree a) (Tree a) deriving Show\n\np63 :: Int -> Tree Char\np63 n = p63' 1 where\n        p63' x\n                | x > n = Empty\n                | otherwise = Branch 'x' (p63' (2*x)) (p63' (2*x+1))\n\n\n-- iscompletetree\n\np63' :: Tree a -> Bool\np63' t = equal t (p63 (nodes t)) where\n        nodes Empty = 0\n        nodes (Branch _ l r) = 1 + nodes l + nodes r\n        equal Empty Empty = True\n        equal (Branch _ l1 r1) (Branch _ l2 r2) = (equal l1 l2) && (equal r1 r2)\n        equal _ _ = False\n", "input": "42", "status": "success", "output": "Branch 'x' (Branch 'x' (Branch 'x' (Branch 'x' (Branch 'x' (Branch 'x' Empty Empty) (Branch 'x' Empty Empty)) (Branch 'x' (Branch 'x' Empty Empty) (Branch 'x' Empty Empty))) (Branch 'x' (Branch 'x' (Branch 'x' Empty Empty) (Branch 'x' Empty Empty)) (Branch 'x' (Branch 'x' Empty Empty) (Branch 'x' Empty Empty)))) (Branch 'x' (Branch 'x' (Branch 'x' (Branch 'x' Empty Empty) (Branch 'x' Empty Empty)) (Branch 'x' (Branch 'x' Empty Empty) Empty)) (Branch 'x' (Branch 'x' Empty Empty) (Branch 'x' Empty Empty)))) (Branch 'x' (Branch 'x' (Branch 'x' (Branch 'x' Empty Empty) (Branch 'x' Empty Empty)) (Branch 'x' (Branch 'x' Empty Empty) (Branch 'x' Empty Empty))) (Branch 'x' (Branch 'x' (Branch 'x' Empty Empty) (Branch 'x' Empty Empty)) (Branch 'x' (Branch 'x' Empty Empty) (Branch 'x' Empty Empty))))"}
{"code": "import Data.Ratio\r\n\r\n\r\ntoIntegerList :: Integer -> [Integer]\r\ntoIntegerList n = map toInt (show n)\r\n\twhere toInt c = read (c:\"\") :: Integer\r\n\r\nhasCondition r = let\r\n\tnumDigits = length $ toIntegerList $ numerator r\r\n\tdenomDigits = length $ toIntegerList $ denominator r\r\n\tin numDigits > denomDigits\r\n\r\nsquareExpans :: Integer -> Ratio Integer\r\nsquareExpans n = 1 + 1/(x n)\r\n\twhere\r\n\t\tx 1 = 2\r\n\t\tx n = (2 + 1/(x (n-1)))\r\n\r\n\r\nans' = filter hasCondition [squareExpans n | n <- [1..1000]]\r\nans = length ans'\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "-- Two men, for every man, every year, the probability of death is 1/2\n-- Averagely, how long will it take for both the two men to die\n-- result is 8/3\n-- Use Mathematic Techniques to calculate it\n\n-- probability that both two persons die at or before this year\ndieBefore :: Integer -> Float\ndieBefore n = (1 - 0.5^n) ^ 2\n\n\n-- probability that both persons die at this year\ndieAt = map (\\x -> dieBefore x - dieBefore (x-1)) [1..]\n\nevery :: [Float]\nevery = map (\\x -> (fromInteger x::Float) * (dieBefore x - dieBefore (x-1))) [1..]\n\n\ntotal :: Int -> Float\ntotal n = foldl (+) 0 (take n every)\n\n", "input": "42", "status": "success", "output": "1.0"}
{"code": "sommeDeXaY x y = if x > y\n then 0\n else x + sommeDeXaY (x+1) y\n\nsomme :: [Int] -> Int\nsomme [] = 0\nsomme (x:xs) = x + somme xs\n\nlast' :: [a] -> a\nlast' xs = head (reverse xs)\n\ninit' :: [a] -> [a]\ninit' xs = reverse (tail (reverse xs))\n\n-- Function !!\n(!!!) :: [a] -> Int -> a\n(!!!) [] n = error \"Index too large\"\n(!!!) (x:xs) n = if (n == 0)\n then x\n else (!!!) xs (n -1)\n   \n-- Function ++\nplus' :: [a] -> [a] -> [a]\nplus' [] ys = ys\nplus' (x:xs) ys = x:(plus' xs ys)  \n\n-- Function concat\nconcate' :: [[a]] -> [a]\nconcate' [] = []\nconcate' [[]] = []\nconcate' (xs:xss) = xs ++ concate' xss \n\n\n", "input": "[42, 42]", "status": "success", "output": "84"}
{"code": "primeFactors :: Int -> [Int]\nprimeFactors n = primeFactors' n 2\n\nprimeFactors' :: Int -> Int -> [Int]\nprimeFactors' n p\n\t| isFactor n p && n' > 1 = p : primeFactors' n' p\n\t| not $ isFactor n p && n > 1 = primeFactors' n (p + 1)\n\t| otherwise = [p]\n\t\twhere\n\t\t\tn' = n `div` p\n\nisFactor n p = n `mod` p == 0\n\nnextPrime :: Int -> Int\nnextPrime n\n\t| isPrime (n + 1) = n + 1\n\t| otherwise = nextPrime (n + 1)\n\nisPrime :: Int -> Bool\nisPrime n = isPrime' n 2\n\nisPrime' :: Int -> Int -> Bool\nisPrime' 2 _ = True\nisPrime' n k\n\t| (n - 1) == k = True\n\t| n `mod` k == 0 = False\n\t| otherwise = isPrime' n (k + 1)\n", "input": "42", "status": "success", "output": "[2,3,7]"}
{"code": "-- :t max === (Ord a) = > a -> (a -> a)\n\nmaxWith10 :: Integer -> Integer\nmaxWith10 = max 10\n\nmulThree :: Int -> (Int -> (Int -> Int))\nmulThree x y z = x * y * z\n\ncallMulThree :: Integer\ncallMulThree = 3 * ( 4 * 5 )\n\nmulThreeSix :: Int -> (Int -> Int)\nmulThreeSix = mulThree 6\n\nmulThreeSixFive :: Int -> Int\nmulThreeSixFive = mulThreeSix 5\n\nmulThreeSixFiveTen :: Int\nmulThreeSixFiveTen = mulThreeSixFive 10\n\ndivideByTen :: Double -> Double\ndivideByTen = (/10)\n\ninvByTen = (10/)\n\nisUpperAlphaNum :: Char -> Bool\nisUpperAlphaNum = (`elem` ['A'..'Z'])\n\ncontainsFour :: [Integer] -> Bool\ncontainsFour  = (4 `elem`)\n", "input": "42", "status": "success", "output": "42"}
{"code": "{- #############################################################################\n   Sample code from:\n      Miran Lipova\u010da - Learn You a Haskell for Great Good!, 2011\n      ++++ no starch press ++++\n      http://www.nostarch.com/lyah.htm\n############################################################################# -}\n\nremoveNonUppercase :: [Char] -> [Char]\nremoveNonUppercase s = [ch | ch <- s , ch `elem` ['A'..'Z']]\n\naddThree :: Int -> Int -> Int -> Int\naddThree m n p = m + n + p\n\nfactorial :: Integer -> Integer\nfactorial n = product [1..n]\n\ncircumference :: Float -> Float\ncircumference r = 2 * pi * r\n", "input": "['a', 'a']", "status": "success", "output": "\"\""}
{"code": "import           Data.List (sortBy)\nimport           Data.Ord (comparing)\n\ncollatz :: Integer -> [Integer]\ncollatz n \n    | n == 1            = [1]\n    | n `mod` 2 == 0    = n : collatz (n `div` 2)\n    | otherwise         = n : collatz (3 * n + 1)\n    \ncollatzSequences :: Integer -> [[Integer]]\ncollatzSequences n = map collatz [1..n]\n\ncollatzSequenceLengths :: Integer -> [(Integer, Int)] \ncollatzSequenceLengths n = zip [1..n] (map length (collatzSequences n))\n\nsolution = last $ sortBy (comparing snd ) $ collatzSequenceLengths 999999\n--solution = maximumBy . comparing . snd $ collatzSequenceLengths 999999", "input": "42", "status": "success", "output": "[42,21,64,32,16,8,4,2,1]"}
{"code": "import Data.Char\n\ntoDigits :: Integer -> [Integer]\ntoDigits 0 = []\ntoDigits n\n  | n < 0 = []\n  | otherwise = map fromIntegral $ map digitToInt $ show n\n\ntoDigitsRev :: Integer -> [Integer]\ntoDigitsRev 0 = []\ntoDigitsRev n\n  | n < 0 = []\n  | otherwise = map fromIntegral $ map digitToInt $ reverse . show $ n\n\ndoubleEveryOtherForward :: [Integer] -> [Integer]\ndoubleEveryOtherForward [] = []\ndoubleEveryOtherForward (x:y:zs) = [x,y*2] ++ doubleEveryOtherForward zs\ndoubleEveryOtherForward [x] = [x]\n\ndoubleEveryOther :: [Integer] -> [Integer]\ndoubleEveryOther list = reverse .doubleEveryOtherForward . reverse $ list\n", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "isPalindromeString :: String -> Bool\nisPalindromeString []  = True\nisPalindromeString [x] = True\nisPalindromeString s\n  | head s == last s = isPalindromeString . init . tail $ s\n  | otherwise        = False\n\nanswer :: Int\nanswer = maximum [x * y | x <- [0..999], y <- [0..999], isPalindromeString . show $ x * y]\n\nanswer' :: Int\nanswer' = maximum [x * y | x <- [0..999], y <- [0..999], (reverse . show $ x * y) == (show $ x * y)]\n\n-- Solution from https://wiki.haskell.org/Euler_problems/1_to_10\nanswer'' :: Int\nanswer'' = maximum [x | y <- [100..999], z <- [100..999], let x = y * z, let s = show x, s == reverse s]\n", "input": "\"hello\"", "status": "success", "output": "False"}
{"code": "fac :: Integer -> Integer\nfac 0 = 1\nfac n = n * (fac (n - 1))\n\nfacList :: Integer -> [Integer]\nfacList n = map fac [0..n]\n\nisEven :: Int -> Bool\nisEven n = ((mod n 2) == 0)\n\nretainEven :: [Int] -> [Int]\nretainEven l = filter isEven l\n\nretainEvenTuple, retainEvenTupleBetter :: [(Int, Int)] -> [Int]\nretainEvenTuple l  = [fst n | n <- l, isEven (snd n)]\nretainEvenTupleBetter l = [x | (x,y) <- l, isEven y]\n\nreturnDiv :: Int -> [Int] -> [Int]\nreturnDiv 0 _ = error \"div by zero\"\nreturnDiv n l = [x | x <- l, (mod x n) == 0]\n\nlistTails :: [[Int]] -> [[Int]]\nlistTails l = [tail x | x <- l, (length x) > 0, (head x) > 5]\n", "input": "42", "status": "success", "output": "1405006117752879898543142606244511569936384000000000"}
{"code": "-- \ud835\udc4e\ud835\udc58 = \ud835\udc4e\ud835\udc58\u22121 + \ud835\udc4e\ud835\udc58\u22122 \u2212 2\ud835\udc4e\ud835\udc58\u22123, \ud835\udc58\u2208\u2115, \ud835\udc58>3\nseqA :: Integer -> Integer\nseqA 0 = 1\nseqA 1 = 2\nseqA 2 = 3\nseqA n =\n  let\n    k1' = seqA 2\n    k2' = seqA 1\n    k3' = seqA 0\n    acc' = k1' + k2' - 2 * k3'\n    go acc k2 k3 m\n      | m /= 0 = go (acc + k2 - (2 * k3)) (acc) (k2) (m - 1)\n      | otherwise = acc\n  in\n    go acc' k1' k2' (n - 3)\n\n-- better from mathematical notation point of view in my opinion :)\nseqA' :: Integer -> Integer\nseqA' n =\n  let\n    seq k0 k1 k2 n\n                 | n == 0 = k0\n                 | otherwise = seq k1 k2 (k1 + k2 - 2 * k0) (n - 1)\n  in\n    seq 1 2 3 n\n", "input": "42", "status": "success", "output": "-72069"}
{"code": "{-- snippet splitLines.type --}\nsplitLines :: String -> [String]\n{-- /snippet splitLines.type --}\n\n{-- snippet splitLines --}\nsplitLines [] = []\nsplitLines cs =\n    let (pre, suf) = break isLineTerminator cs\n    in  pre : case suf of \n                ('\\r':'\\n':rest) -> splitLines rest\n                ('\\r':rest)      -> splitLines rest\n                ('\\n':rest)      -> splitLines rest\n                _                -> []\n\nisLineTerminator c = c == '\\r' || c == '\\n'\n{-- /snippet splitLines --}\n\n{-- snippet fixLines --}\nfixLines :: String -> String\nfixLines input = unlines (splitLines input)\n{-- /snippet fixLines --}\n", "input": "\"hello\"", "status": "success", "output": "[\"hello\"]"}
{"code": "{-- snippet rootMeanSquare --}\nrootMeanSquare :: [Double] -> Double\n\nrootMeanSquare xs = sqrt (sum (map square xs) / fromIntegral (length xs))\n    where square x = x * x\n{-- /snippet rootMeanSquare --}\n\nrootMeanSquare_explicit xs = sqrt (meanSquare xs 0 0)\n    where meanSquare [] i ms     = ms / fromIntegral i\n          meanSquare (x:xs) i ms = meanSquare xs (i+1) (ms + x**2)\n\n{-- snippet rootMeanSquare_foldl --}\nrootMeanSquare_foldl xs =\n    let (count, sumOfSquares) = foldl step (0,0) xs\n    in sqrt (sumOfSquares / fromIntegral count)\n  where step (cnt,sumSq) x = (cnt + 1, sumSq + x*x)\n{-- /snippet rootMeanSquare_foldl --}\n", "input": "[2.71, 2.71]", "status": "success", "output": "2.71"}
{"code": "-- A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 \u00d7 99.\n-- Find the largest palindrome made from the product of two 3-digit numbers\n\n-- Checks if a number is paliandrome\n-- http://stackoverflow.com/a/26316718/5154397\n\npalindrome :: Integer -> Bool\npalindrome x = reversal x == x\n\nreversal :: Integral a => a -> a\nreversal = go 0\n  where go a 0 = a\n        go a b = let (q,r) = b `quotRem` 10 in go (a*10 + r) q\n\n-- http://codereview.stackexchange.com/a/67292\nlargestPal = maximum[x*y | x <- [800 .. 999], y <- [800 .. x], reverse(show(x*y)) ==show(x*y)]\n\n", "input": "42", "status": "success", "output": "False"}
{"code": "\n\nupperCase :: [Char] -> [Char]\nupperCase (x:xs) = toUpper' x : upperCase xs\nupperCase []     = []\n\n\ntoUpper' :: Char -> Char\ntoUpper' 'a' = 'A'\ntoUpper' 'b' = 'B'\ntoUpper' 'c' = 'C'\ntoUpper' 'd' = 'D'\ntoUpper' 'e' = 'E'\ntoUpper' 'f' = 'F'\ntoUpper' 'g' = 'G'\ntoUpper' 'h' = 'H'\ntoUpper' 'i' = 'I'\ntoUpper' 'j' = 'J'\ntoUpper' 'k' = 'K'\ntoUpper' 'l' = 'L'\ntoUpper' 'm' = 'M'\ntoUpper' 'n' = 'N'\ntoUpper' 'o' = 'O'\ntoUpper' 'p' = 'P'\ntoUpper' 'q' = 'Q'\ntoUpper' 'r' = 'R'\ntoUpper' 's' = 'S'\ntoUpper' 't' = 'T'\ntoUpper' 'u' = 'U'\ntoUpper' 'v' = 'V'\ntoUpper' 'w' = 'W'\ntoUpper' 'x' = 'X'\ntoUpper' 'y' = 'Y'\ntoUpper' 'z' = 'Z'\ntoUpper'  u  = u\n", "input": "['a', 'a']", "status": "success", "output": "\"AA\""}
{"code": "import Data.Char\n\ninc x = x + 1\n\nsumList :: [Int] -> Int\nsumList [] = 0\nsumList (x:xs) = x + sumList xs\n\nfact :: Int -> Int\nfact 0 = 1\nfact n = n * fact (n - 1)\n\nfirst :: [a] -> a\nfirst (x:_) = x\n\nmember y [] = False\nmember y (x:xs) = y == x || member y xs\n\nmakeName :: String -> String -> String\nmakeName family first = concat [first, \" \", family]\n\nnakovit :: String -> String\nnakovit = makeName \"Nakov\"\n\nmap2 :: (a -> b) -> [a] -> [b]\nmap2 _ [] = []\nmap2 f (x:xs) = f x : map2 f xs\n\nconfIt names = map (\\name -> name ++ \"Conf\") names\n\ntrimLeft = dropWhile isSpace\n\ntrim = reverse . trimLeft . reverse . trimLeft\n\ntrimLines = map trim\n\n", "input": "[42, 42]", "status": "success", "output": "84"}
{"code": "import Data.Char\n\ncap :: [Char] -> [Char]\ncap xs = map toUpper xs\n\nrev :: [Char] -> [Char]\nrev xs = reverse xs\n\n\n-- function composition\ncomposed :: [Char] -> [Char]\ncomposed = rev . cap\n\n-- function is an instance of Monoid\ncombined :: [Char] -> [Char]\ncombined = cap `mappend` rev\n\n-- function is an instance of Functor\n-- for function, fmap is .\nfmapped :: [Char] -> [Char]\nfmapped = fmap rev cap\n\n-- function is an instance of Applicative\ntuppled :: [Char] -> ([Char], [Char])\ntuppled = (,) <$> cap <*> rev\n\n-- function is an instance of Monad\ntuppled' :: [Char] -> ([Char], [Char])\ntuppled' = do\n  a <- cap\n  b <- rev\n  return (a, b)\n", "input": "['a', 'a']", "status": "success", "output": "\"AA\""}
{"code": "import qualified Data.Map.Strict as Map\nimport Data.Maybe\n\nvalues = Map.fromList([(1000, \"M\"), (900, \"CM\"), (500, \"D\"), \n                        (400, \"CD\"), (100, \"C\"), (90, \"XC\"), \n                        (50, \"L\"), (40, \"XL\"), (10, \"X\"), \n                        (9, \"IX\"), (5, \"V\"), (4, \"IV\"), (1, \"I\")])\n\ntoRoman :: Int -> [Char]\ntoRoman 0 = []\ntoRoman a\n  | isJust exactValue = fromJust exactValue\n  | otherwise = highestVal ++ toRoman(remainder)\n  where exactValue  = Map.lookup a values\n        remainder   = a - (fst nextHighest)\n        highestVal  = snd nextHighest\n        nextHighest = fromMaybe (0, \"\") $ Map.lookupLT a values", "input": "42", "status": "success", "output": "\"XLII\""}
{"code": "--The sum of the squares of the first ten natural numbers is,\n\n--12 + 22 + ... + 102 = 385\n--The square of the sum of the first ten natural numbers is,\n\n--(1 + 2 + ... + 10)2 = 552 = 3025\n--Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 \u2212 385 = 2640.\n\n--Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum\n\nsumOfSqs :: Int -> Int\nsumOfSqs n =  quot (n * (n + 1) * ((2 * n) + 1))  6\n\nsqSums :: Int -> Int\nsqSums n = (quot (n * (n + 1)) 2) ^ 2\n\nsqDiff :: Int -> Int\nsqDiff n = (sqSums n) - (sumOfSqs n)\n\n", "input": "42", "status": "success", "output": "25585"}
{"code": "decompress :: String -> String\ndecompress ('(':xs) =\n  let [(chars, 'x':xs')] = reads xs\n      [(times, ')':xs'')] = reads xs'\n  in concat (replicate times $ take chars xs'') ++ decompress (drop chars xs'')\ndecompress (x:xs) = [x] ++ decompress xs\ndecompress [] = []\n\ndecompress_v2 :: String -> Int\ndecompress_v2 ('(':xs) =\n  let [(chars, 'x':xs')] = reads xs\n      [(times, ')':xs'')] = reads xs'\n  in times * (decompress_v2 $ take chars xs'') + decompress_v2 (drop chars xs'')\ndecompress_v2 (x:xs) = 1 + decompress_v2 xs\ndecompress_v2 [] = 0\n\npart1 :: String -> Int\npart1 = length . decompress\n\npart2 :: String -> Int\npart2 = decompress_v2\n", "input": "\"hello\"", "status": "success", "output": "\"hello\""}
{"code": "-- Problem 14\n-- (5.35 secs, 3,261,834,784 bytes)\n\nimport Data.Array\nimport Data.List (maximumBy)\nimport Data.Ord (comparing)\n \ncollatz :: Integer -> [(Integer, Int)]\ncollatz n = assocs arr\n    where\n        arr = listArray (1, n) (1 : [collatz i i 0 | i <- [2..n]])\n        collatz n m l\n            | m < n     = (arr ! m) + l\n            | even m    = collatz n (m `div` 2) (l + 1)\n            | otherwise = collatz n (m * 3 + 1) (l + 1)\n\ne014 = print . fst . maximumBy (comparing snd) . collatz $ 1000000\n\n\n-- Sources\n\n-- Algorithm modified from \n-- http://stackoverflow.com/questions/26184613/haskell-list-v-array-difference-in-performance", "input": "42", "status": "success", "output": "[(1,1),(2,2),(3,8),(4,3),(5,6),(6,9),(7,17),(8,4),(9,20),(10,7),(11,15),(12,10),(13,10),(14,18),(15,18),(16,5),(17,13),(18,21),(19,21),(20,8),(21,8),(22,16),(23,16),(24,11),(25,24),(26,11),(27,112),(28,19),(29,19),(30,19),(31,107),(32,6),(33,27),(34,14),(35,14),(36,22),(37,22),(38,22),(39,35),(40,9),(41,110),(42,9)]"}
{"code": "square x = x * x\n\nminusOne x = x - 1\n\naddOne x = x + 1\n\ngetMax x y = max x y\n\ngetMin x y = min x y\n\ncrazy x y = addOne (minusOne (addOne(succ x + (getMax x y))))\n\nisGreaterThan100 x = if x > 100\n\t\t\t\t\tthen True\n\t\t\t\t\telse False\n\nisSmallerThan0 x = if x < 0\n\t\t\t\t\tthen True\n\t\t\t\t\telse False\n\nmyName = \"My Name is khan and i am cool\"\n\nboomx xs = [if x > 10 then \"BOOM\" else \"BANG\" | x <- xs, odd x]\n\n\nlength' cs = sum [1 | a <- cs]\n\ngetAllEvent :: Int -> [Int]\ngetAllEvent a = [cs | cs <- [1..10]]\n\nremoveAllUpperCase :: [Char] -> [Char]\nremoveAllUpperCase a = [z | z <- a, z `elem` ['A'..'Z']]\n\nsomeFunction :: Int -> Int -> Int -> Bool\nsomeFunction a b c = True", "input": "42", "status": "success", "output": "[1,2,3,4,5,6,7,8,9,10]"}
{"code": "import Data.List (sort)\n\ndigits n = if a == 0 then [b] else digits a ++ [b]\n    where (a, b) = divMod n 10\n\npandigital n = n > 10 ^ 8 && n < 10 ^ 9 && sort (digits n) == [1..9]\n\nconcatNum :: [Int] -> Int\nconcatNum = read . concatMap show\n\npand2 = filter pandigital $ map (\\x -> concatNum (map (* x) [1..2])) [1000..10000]\npand3 = filter pandigital $ map (\\x -> concatNum (map (* x) [1..3])) [100..333]\npand4 = filter pandigital $ map (\\x -> concatNum (map (* x) [1..4])) [10..100]\npand5 = filter pandigital $ map (\\x -> concatNum (map (* x) [1..5])) [10..100]\n\nmaxPand = maximum $ concat [pand2, pand3, pand4, pand5]\n-- 932718654 = concatNum $ 9327 * [1, 2]\n", "input": "[42, 42]", "status": "success", "output": "4242"}
{"code": "-- | Returns a pair of consecutive Fibonacci numbers a b,\n--   where (a*b) is equal to the input, or proofs that the\n--   number isn't a product of two consecutive Fibonacci\n--   numbers.\nproductFib :: Integer -> (Integer, Integer, Bool)\nproductFib n = locationProductFibN n 2\n\n-- i must >= 2\nlocationProductFibN :: Integer -> Integer -> (Integer, Integer, Bool)\nlocationProductFibN n i\n  | fib (i-1) * fib (i) == n = ( fib (i-1) , fib (i), True)\n  | fib (i) * fib (i+1) > n = ( fib (i) , fib (i+1) , False)\n  | otherwise = locationProductFibN n (i+1)\n\n\n\nfib :: Integer -> Integer\nfib n\n  | n == 0 = 0\n  | n == 1 = 1\n  | otherwise = fib (n - 1) + fib (n - 2)\n", "input": "42", "status": "success", "output": "(8,13,False)"}
{"code": "import Control.Monad\n\n-- 32.1.1 The `guard` function\nevensGuard :: Int -> [Int]\nevensGuard n = do\n  value <- [1 .. n]\n  guard (even value)\n  return value\n  \n\n{-\nfrom \"32.1.1 The `guard` function\":\nTo understand `guard`, it helps tremendously to translate\nfrom `do`-notation back to `>>=`, `>>`, and lambdas. Learning\nabout `guard` will also teach you a lot about the subtleties of\n`>>`.\n-}\n\n{-\n do notation de-sugar syntax at: http://www.haskellforall.com/2014/10/how-to-desugar-haskell-code.html\n-} \n\nevensGuard2 :: Int -> [Int]\nevensGuard2 n = \n  [1 .. n] >>= (\\value -> (guard (even value)) >> [value]) \n  \n-- but how does this work???\n-- see opposite page\n", "input": "42", "status": "success", "output": "[2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42]"}
{"code": "nthTriangleNumber :: Integer -> Integer\nnthTriangleNumber n = n * (n - 1) `div` 2\n\ntriangleNumbers :: [Integer]\ntriangleNumbers = map nthTriangleNumber [1..]\n\nintSqrt :: Integer -> Integer\nintSqrt n = floor . sqrt $ (fromIntegral n :: Float)\n\nisSquare :: Integer -> Bool\nisSquare n = n == intSqrt n * intSqrt n\n\nnumFactors :: Integer -> Integer\nnumFactors n = fromIntegral $ (2 * length [f | f <- [1..(intSqrt n)], n `mod` f == 0]) - (if isSquare n then 1 else 0)\n\ntriangularFactorNums :: [(Integer, Integer)]\ntriangularFactorNums = zip (map numFactors triangleNumbers) triangleNumbers\n\nsolution = snd $ head $ dropWhile (\\ (f, s) -> f <= 500) triangularFactorNums", "input": "42", "status": "success", "output": "861"}
{"code": "-- file: ch04/SplitLines.hs\n\n-- | Split a string on any (system independant) newlines, i.e. \\r or \\r\\n\nsplitLines :: String -> [String]\nsplitLines [] = []\nsplitLines cs =\n    let (pre, suf) = break isLineTerminator cs\n    in pre : case suf of\n               ('\\r':'\\n':rest) -> splitLines rest\n               ('\\r':rest)      -> splitLines rest\n               ('\\n':rest)      -> splitLines rest\n               _                -> []\n\nisLineTerminator c = c == '\\r' || c == '\\n'\n\n-- | This function splits input using your improved splitLines, then\n-- re-attaches them into the original format.\nfixLines :: String -> String\nfixLines input = unlines (splitLines input)\n", "input": "\"hello\"", "status": "success", "output": "[\"hello\"]"}
{"code": "--Factorial implementation using Tail recursion\nfact :: Int -> Int\nfact n = facTail n 1\nfacTail :: (Int) -> (Int) -> (Int)\nfacTail 0 r = r\nfacTail n r = facTail (n-1) (n*r)\n--Fibonnaci implementation using Tail Recursion\nfib :: Int -> Int \nfib n \n\t| n == 0  =0\n\t| n < 0 =0\n\t| otherwise = fibTail n 1 0\n\nfibTail :: Int -> Int -> Int -> Int\nfibTail n result previous\n\t|n==0 =result\n\t|otherwise = fibTail (n-1) (result +previous) result\n-- Sum of the first Integers\t\nsumInteger :: Int -> Int\nsumInteger n \n\t\t|n < 0 =0\n\t\t|n== 0 = 0\n\t\t|otherwise = sumTail n 0\n\t\t\nsumTail :: Int -> Int -> Int\nsumTail n result \n\t|n == 0 = result\n\t|otherwise = sumTail (n-1) (n+result)\n\t\t\n\t\n\n\n", "input": "42", "status": "success", "output": "7538058755741581312"}
{"code": "-- Short Exercise: Warming Up\n\nimport Data.Char\n\ncap :: [Char] -> [Char]\ncap xs = map toUpper xs\n\nrev :: [Char] -> [Char]\nrev xs = reverse xs\n\ncomposed :: [Char] -> [Char]\ncomposed = cap . rev\n\nfmapped :: [Char] -> [Char]\nfmapped = cap <$> rev\n\n-- Got a little help here because I was using xs in the monadic stucture making\n-- my types come out wrong:\n-- https://github.com/MattMSumner/haskell-progamming/blob/master/chapter22/short_exercises.hs\ntupled :: [Char] -> ([Char], [Char])\ntupled xs = (do\n  a <- rev\n  b <- cap\n  return (a, b)) xs\n\ntupled' :: [Char] -> ([Char], [Char])\ntupled' xs = (rev >>= (\\a ->\n              cap >>= (\\b ->\n              return (a, b)))) xs\n", "input": "['a', 'a']", "status": "success", "output": "\"AA\""}
{"code": "toDigits :: Integer -> [Integer]\ntoDigits n = reverse (toDigitsRev n)\n\ntoDigitsRev :: Integer -> [Integer]\ntoDigitsRev n\n  |n <= 0 = []\n  |mod n 10 == n = reverse[n]\n  |otherwise = mod n 10: toDigitsRev (div n 10)\n\n\ndoubleEveryOther :: [Integer] -> [Integer]\ndoubleEveryOther [] = []\ndoubleEveryOther (x:[]) = [x]\ndoubleEveryOther (x:y:xs) = x:y*2:doubleEveryOther xs\n\n\nsumDigits :: [Integer] -> Integer\nsumDigits [] = 0\nsumDigits (x:xs) = sum (toDigits x)+sumDigits xs\n\nvalidate :: Integer -> Bool\nvalidate n\n  |sumDigits (reverse (doubleEveryOther (toDigitsRev n))) `mod` 10 == 0 = True\n  |sumDigits (reverse (doubleEveryOther (toDigitsRev n))) `mod` 10 /= 0 = False\n\n\n\n\n\n\n\n", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "-- file: ch4/exB2.hs\n-- A safe function that converts a `String` to an `Int`\n-- Daniel Brice\n\nimport Data.Char (digitToInt)\n\ntype ErrorMessage = String\n\nsafeAsInt :: String -> Either ErrorMessage Int\nsafeAsInt \"\" = Left \"Empty input.\"\nsafeAsInt digs | nonDigits digs = Left \"Non-digits.\"\n               | infixSubt digs = Left \"Infixed negative sign\"\n               | otherwise      = Right $ safeAsInt' digs\n  where\n    nonDigits             = not . all (`elem` \"-0123456789\")\n    infixSubt             = ('-' `elem`) . tail\n    safeAsInt' ('-' : xs) = (- 1) * (safeAsInt' xs)\n    safeAsInt' xs         = foldl step 0 xs\n    step acc dig          = acc * 10 + (digitToInt dig)\n", "input": "\"hello\"", "status": "success", "output": "Left \"Non-digits.\""}
{"code": "-- Problem 4 : Largest pallindrome product\n--\n-- A palindromic number reads the same both ways. \n-- The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 \u00d7 99.\n--\n-- Find the largest palindrome made from the product of two 3-digit numbers.\n\nimport Data.List\n\neuler4 = take 1 $ [x | x <- reverse products, isPalindromic x]\n    where products = sort [x * y | x<-[100..999], y <- [100..999]]\n\nisPalindromic :: Int -> Bool \nisPalindromic n = n == reverseInt n\n\nreverseInt :: Int -> Int \nreverseInt x = reverseInt' x 0\n\nreverseInt' :: Int -> Int -> Int\nreverseInt' o r\n    | o /= 0 = reverseInt' (o `div` 10) $ (r * 10) + (o `mod` 10)\n    | otherwise = r\n", "input": "42", "status": "success", "output": "False"}
{"code": "-- sum of integers from 1 to n\n-- takes an integer as i, yields an integer as o\ns::Integer -> Integer\ns 0 = 0\ns n = n + s (n-1)\n\nh::Integer -> String\nh 5 = \"5 is my magical number\"\nh n\n  | mod n 2 == 0 = \"even\"\n  | otherwise = \"not even\"\n\nfoo::Integer -> Integer\nfoo 1\n  | \"Haskell\" > \"C++\" = 3\n  | otherwise = 4\nfoo n\n  | n < 0 = 0\n  | n `mod` 17 == 2 = -43\n  | otherwise = n + 3\n\nisEven::Integer -> Bool\nisEven n\n  | mod n 2 == 0 = True\n  | otherwise = False\n\n-- a function taking 3 integers as arguments\n-- and returning an integer as result\nf::Int -> Int -> Int -> Int\nf x y z = x + y + z\n\n-- how to define an operator\na |& b = (a || b) && not (a && b)\ntest = True |& False\n", "input": "42", "status": "success", "output": "903"}
{"code": "to_tens :: Integer -> [Integer]\r\nto_tens 0 = []\r\nto_tens n = to_tens (n `div` 10) ++ [n `mod` 10] \r\n\r\n\r\nfrom_tens xs = sum $ map (\\(a,b) -> (10^a) * b) $ zip [0..] $ reverse xs\r\n\r\n\r\nshift xs 0 = xs\r\nshift (x:xs) 1 = xs ++ [x]\r\nshift (x:xs) n = (shift (xs ++ [x]) (n-1))\r\n\r\nshift_number numb n = from_tens $ shift (to_tens numb) n\r\n\r\n\r\nisPrime :: Integer -> Bool\r\nisPrime 1 = False\r\nisPrime k\r\n\t\t| k <= 0 = False \r\n\t\t|otherwise = null [ x | x <- [2..(truncate $ sqrt $ fromIntegral k)], k `mod` x  == 0]\r\n\r\n\r\nis_circular_prime n = \tlet l = length $ to_tens n\r\n\t\t\t\t\t\tin\r\n\t\t\t\t\t\tand $ map isPrime $ map (shift_number n) [1..l]\r\n\r\n\r\ncirc_primes = filter is_circular_prime [1..1000000]", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "\r\nimport Data.List\r\n\r\n\r\nto_tens :: Integer -> [Integer]\r\nto_tens 0 = []\r\nto_tens n = to_tens (n `div` 10) ++ [n `mod` 10] \r\n\r\nto_tens' n k = let tens = to_tens n in\r\n\t\t\tif length tens < k then [0] ++ tens else tens\r\n\r\ndigits = [0,1,2,3,4,5,6,7,8,9]\r\n\r\nis_valid number perma = (intersect perma $ to_tens' number $ length perma) == perma\r\n\r\n\r\n\r\nlexo_order_test = filter (flip is_valid [0,1,2]) [012..210]\r\n\r\n\r\nlexo_order = filter (flip is_valid [0,1,2,3,4,5,6,7,8,9]) [0123456789..9876543210]\r\n-- 123456678\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nquicksort [] = []\r\nquicksort (x:xs) = quicksort [y | y <- xs, y <= x] ++ [x] ++ quicksort [y | y <- xs, y > x]\r\n\r\n\r\nans = quicksort $ permutations \"0123456789\"", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "import Data.List (permutations)\nimport qualified Data.Set as Set\n\ndata Value = Value { multiplicand :: Int, multiplier :: Int, prod :: Int } deriving (Show, Eq)\n\np = permutations [1..9]\n\ntoInt :: [Int] -> Int\ntoInt = foldl1 (\\acc v -> 10 * acc + v)\n\ngetValues :: [Int] -> [Value]\ngetValues xs = filter (\\v -> multiplier v * multiplicand v == prod v) [\n  Value (toInt $ take 1 xs) (toInt $ take 4 $ drop 1 xs) (toInt $ drop 5 xs),\n  Value (toInt $ take 2 xs) (toInt $ take 3 $ drop 2 xs) (toInt $ drop 5 xs)\n        ]\n\nallValues :: [Value]\nallValues = foldl (\\acc v -> acc ++ getValues v) [] p\n\npandigitalProducts :: Int\npandigitalProducts = sum $ Set.fromList $ map prod allValues\n\n", "input": "[42, 42]", "status": "success", "output": "462"}
{"code": "import Data.Maybe\n\ndoubleFun x = x * 2\nfailureFun x = Nothing\n\ntoStringFun :: Integer -> String\ntoStringFun x = show x\n\n\npyramidOfChecks :: Maybe String\npyramidOfChecks = let val = Just 42 in\n  if isJust val then\n    let maybeVal = failureFun (doubleFun (fromJust val)) in\n      if isJust maybeVal then\n        Just (toStringFun (fromJust maybeVal))\n      else\n        Nothing\n  else\n    Nothing\n\nbetterVersion :: Maybe String\nbetterVersion = do\n  val <- Just 42\n  maybeVal <- failureFun (doubleFun (val))\n  return (toStringFun maybeVal)\n\ndesugaredVersion :: Maybe String\ndesugaredVersion = (Just 42) >>= (\\val -> failureFun (doubleFun(val))) >>= (\\val -> Just (toStringFun (val)))\n", "input": "42", "status": "success", "output": "\"42\""}
{"code": "su :: String -> Bool\nsu \"\uff08\u00b4\u30fb\u03c9\u30fb\uff09 \uff7d\" = True\nsu x          = False\n\n-- su \"\uff08\u00b4\u30fb\u03c9\u30fb\uff09 \uff7d\" -- True\n-- su \"foobar\" -- False\n\n\n-- pattern in recursive function\nfactorial :: Int -> Int\nfactorial 0 = 1\nfactorial n = n * factorial(n - 1)\n\n-- factorial 0 -- 1\n-- factorial 1 -- 1\n-- factorial 2 -- 2\n-- factorial 3 -- 6\n\n\n-- pattern with tuple\naddVectors :: (Double, Double) -> (Double, Double) -> (Double, Double)\naddVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)\n\n-- addVectors (0, 1) (2, 3) -- (2.0,4.0)\n\n\n-- as-pattern\nsuffix :: String -> String\nsuffix \"\"         = \"Empty string\"\nsuffix all@(x:xs) = all ++ \" = \" ++ [x] ++ \" ++ \" ++ xs\n\n-- suffix \"abc\" -- \"abc = a ++ bc\"\n", "input": "\"hello\"", "status": "success", "output": "False"}
{"code": "data BiTree a = EmptyTree | BiTree a (BiTree a) (BiTree a) deriving(Show, Read, Eq)\n\ndata Maybe1 a = Just1 a | Nothing1 deriving(Show, Read, Eq)\n\ninstance Functor Maybe1 where\n\tfmap f (Just1 x) = Just1 (f x)\n\tfmap f Nothing1 = Nothing1\n\ndiv2 :: Int -> Int\ndiv2 x = div x 2\n\ntreeVal :: BiTree a -> Maybe1 a\ntreeVal EmptyTree = Nothing1\ntreeVal (BiTree x t1 t2) = Just1 x\n\nbiTreeAdd ::(Ord a) => BiTree a -> a -> BiTree a\nbiTreeAdd (EmptyTree) x = BiTree x EmptyTree EmptyTree\nbiTreeAdd (BiTree v t1 t2) x = if x > v then BiTree v (biTreeAdd t1 x) t2 else BiTree v t1 (biTreeAdd t2 x)\n\ntoBiTree ::(Ord a) => [a] -> BiTree a\ntoBiTree [] = EmptyTree\ntoBiTree x = foldl (biTreeAdd) EmptyTree x\n", "input": "42", "status": "success", "output": "21"}
{"code": "sum'n'count :: Integer -> (Integer, Integer)\nsum'n'count x = (sum str, toInteger $ length str)\n  where\n    str = show $ abs x\n    sum = foldl (\\acc x -> acc + (read [x] :: Integer)) 0\n\n-- like previous one, but a bit more structured\nsum'n'count' :: Integer -> (Integer, Integer)\nsum'n'count' x =\n  let\n    numbers = map (\\x -> read [x] :: Integer) $ show $ abs x\n  in\n    (sum numbers, toInteger $ length numbers)\n\n-- more verbose, but without introducing string (redundant conversion)\nsum'n'count'' :: Integer -> (Integer, Integer)\nsum'n'count'' x = go (0, 0, abs(x))\n  where\n    go (n, sum, x)\n      | x < 10 = (x + sum, n + 1)\n      | otherwise = go(n + 1, sum + x `mod` 10, x `div` 10)\n", "input": "42", "status": "success", "output": "(6,2)"}
{"code": "import Data.Monoid\n\n-- isBigGang is used to explain Writer monad\nisBigGang :: Int -> (Bool, String)\nisBigGang x = (x > 9, \"Compared gang size to 9.\")\n\n-- if we want to feed the (Bool, String) value to isBigGang, we have to do extra work\n-- here we create a function called \"applyLog\", just similar to \"applyMaybe\" created previously\napplyLog :: (Monoid m) => (a, m) -> (a -> (b, m)) -> (b, m)\napplyLog (x, log) f = let (y, newLog) = f x in (y, log `mappend` newLog)\n\n\n-- addDrink is used to explain Monoid tuple\ntype Food = String\ntype Price = Sum Int\naddDrink :: Food -> (Food, Price)\naddDrink \"beans\" = (\"milk\", Sum 25)\naddDrink \"jerky\" = (\"whiskey\", Sum 99)\naddDrink _ = (\"beer\", Sum 30)\n", "input": "42", "status": "success", "output": "(True,\"Compared gang size to 9.\")"}
{"code": "{-\nEjemplos de funciones b\u00e1sicas con listas y compresi\u00f3n... \n-}\n-- Devuelve TODOS los n\u00fameros primos \nprime = filterPrime [2..]\n  where filterPrime (p:xs) =\n          p : filterPrime[x | x <- xs, mod x p /=0 ]\n\n-- Devuelve n primos\ngive_prime :: Int -> [Integer]\ngive_prime n = take n prime\n\n\n-- Devuelve el primer elemento que cumple una condici\u00f3n concreta\ngive a n = head ( dropWhile (a n) prime)\n\n\n-- DIVISORES DE UN N\u00daMERO\n\n-- versi\u00f3n por comprensi\u00f3n de listas \ndivisoresC :: Int -> [Int]\ndivisoresC n = [ x | x <- [1..(n-1)], mod n x == 0]\n\n\n-- versi\u00f3n por filtro\n\n\ndivisoresF :: Int -> [Int]\ndivisoresF n = filter (divisible n ) [1..(n-1)]\n  where divisible a b = mod a b == 0\n\n", "input": "42", "status": "success", "output": "[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181]"}
{"code": "-- Exercise G\n\ntype Date = (Int, Int, Int)\n\nmonths = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\",\n         \"September\", \"October\", \"November\", \"December\"]\n\nsuffix :: Int -> String\nsuffix n\n  | n == 11 || n == 21 || n == 31 = \"st\"\n  | n == 12 || n == 22 = \"nd\"\n  | otherwise = \"th\"\n\nshowDate :: Date -> String\nshowDate (d, m, y) = show d ++ suffix d ++ \" \" ++ months!!(m - 1) ++ \", \" ++ show y\n\n-- Exercise H\n\ntype CIN = String\n\ngetDigit :: Char -> Int\ngetDigit c = read [c]\n\naddSum :: CIN -> CIN\naddSum xs = xs ++ show (dsum xs)\n  where\n    dsum :: CIN -> Int\n    dsum = sum . map getDigit\n\nvalid :: CIN -> Bool\nvalid xs = xs == addSum raw\n  where raw = take 8 xs\n", "input": "42", "status": "success", "output": "\"th\""}
{"code": "import Data.Char\n\ntoDigits :: Integer -> [Integer]\ntoDigits 0 = []\ntoDigits n\n  | n < 0 = []\n  | otherwise = map fromIntegral $ map digitToInt $ show n\n\ntoDigitsRev :: Integer -> [Integer]\ntoDigitsRev n = reverse . toDigits $ n\n\ndoubleSecond :: [Integer] -> [Integer]\ndoubleSecond [] = []\ndoubleSecond (x:y:zs) = [x,y*2] ++ doubleSecond zs\ndoubleSecond [x] = [x]\n\ndoubleEveryOther :: [Integer] -> [Integer]\ndoubleEveryOther list = reverse . doubleSecond . reverse $ list\n\nsumDigits :: [Integer] -> Integer\nsumDigits nums = foldl (+) 0 $ concat . map toDigits $ nums\n\nvalidate :: Integer -> Bool\nvalidate n = (==0) $ (sumDigits . concat . map toDigits . doubleEveryOther . toDigits $ n) `mod` 10\n", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "oddNumbers :: Int -> [Int]\noddNumbers maxNumber = [1, 3..maxNumber]\n\n\nsort2 :: Ord a => a -> a -> (a, a)\nsort2 x y = if x <= y then (x,y) else (y,x)\n\nsort2' :: Ord a => a -> a -> (a, a)\nsort2' x y | x <= y    = (x,y) \n           | otherwise = (y,x)\n\n\nthrd :: (a, b, c) -> c\nthrd (_, _, x) = x\n\nalmostEqual (x1, y1) (x2, y2)\n  | (x1 == x2) && (y1 == y2) = True\n  | (x1 == y2) && (y1 == x2) = True\n  | otherwise                = False\n\nisLower :: Char -> Bool\nisLower x \n  | elem x ['a'..'z'] = True\n  | otherwise = False\n\nmangle :: String -> String\nmangle (x:xs) = xs ++ [x]\nmangle [] = \"\"\n\ndivide :: Int -> Int -> Int\ndivide x y = length (multiples y x)\n  where\n    multiples x max = [x,x+x..max]\n", "input": "42", "status": "success", "output": "[1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41]"}
{"code": "type Matrix = [[Integer]]\n\ncreateMatrix :: Integer -> Matrix\ncreateMatrix n = [ createRow (x * n) n | x <-[0..(n - 1)] ]\n\ncreateRow :: Integer -> Integer -> [Integer]\ncreateRow i l = [ x | x <-[(i + 1)..(i + l)] ]\n\nright :: Matrix -> [Integer]\nright = head\n\nleft :: Matrix -> [Integer]\nleft = reverse . init . last\n\nup :: Matrix -> [Integer]\nup =  reverse . tail . init . map head\n\ndown :: Matrix -> [Integer]\ndown = tail . map last\n\nborder :: Matrix -> [Integer]\nborder m = right m ++ down m ++ left m ++ up m\n\nsubmatrix :: Matrix -> Matrix\nsubmatrix m = map (tail . init) ((tail . init) m)\n\nsnail :: Matrix -> [Integer]\nsnail [] = []\nsnail [[a]] = [a]\nsnail m = border m ++ (snail $ submatrix m)\n", "input": "42", "status": "success", "output": "[[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42],[43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84],[85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126],[127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168],[169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210],[211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252],[253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294],[295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336],[337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378],[379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420],[421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462],[463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504],[505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546],[547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588],[589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630],[631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672],[673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714],[715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756],[757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798],[799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840],[841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882],[883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924],[925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966],[967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999,1000,1001,1002,1003,1004,1005,1006,1007,1008],[1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049,1050],[1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092],[1093,1094,1095,1096,1097,1098,1099,1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134],[1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149,1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176],[1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199,1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218],[1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249,1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260],[1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299,1300,1301,1302],[1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344],[1345,1346,1347,1348,1349,1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386],[1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399,1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428],[1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449,1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470],[1471,1472,1473,1474,1475,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499,1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512],[1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549,1550,1551,1552,1553,1554],[1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,1595,1596],[1597,1598,1599,1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1636,1637,1638],[1639,1640,1641,1642,1643,1644,1645,1646,1647,1648,1649,1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1660,1661,1662,1663,1664,1665,1666,1667,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1679,1680],[1681,1682,1683,1684,1685,1686,1687,1688,1689,1690,1691,1692,1693,1694,1695,1696,1697,1698,1699,1700,1701,1702,1703,1704,1705,1706,1707,1708,1709,1710,1711,1712,1713,1714,1715,1716,1717,1718,1719,1720,1721,1722],[1723,1724,1725,1726,1727,1728,1729,1730,1731,1732,1733,1734,1735,1736,1737,1738,1739,1740,1741,1742,1743,1744,1745,1746,1747,1748,1749,1750,1751,1752,1753,1754,1755,1756,1757,1758,1759,1760,1761,1762,1763,1764]]"}
{"code": "\n-- Credit Card validation\n\ntoDigits :: Integer -> [Integer]\ntoDigits n = toDigits' n [] where\n    toDigits' :: Integer -> [Integer] -> [Integer]\n    toDigits' n acc =\n        case n `div` 10 of\n            0 -> n `mod` 10 : acc\n            _ -> toDigits' (n `div` 10) (n `mod` 10 : acc)\n\ntoDigitsRev :: Integer -> [Integer]\ntoDigitsRev = reverse . toDigits\n\ndoubleEveryOther :: [Integer] -> [Integer]\ndoubleEveryOther [] = []\ndoubleEveryOther [x] = [x]\ndoubleEveryOther (y:x:xs) = y : 2 * x : doubleEveryOther xs\n\nsumDigits :: [Integer] -> Integer\nsumDigits xs = sum $ concat $ map toDigits xs\n\nvalidate :: Integer -> Bool\nvalidate n = (sumDigits $ doubleEveryOther $ toDigitsRev n) `mod` 10 == 0\n\n", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "{-\nlet w = \"white\"\nlet b = \"blue\"\nlet o = \"orange\"\nlet g = \"green\"\nlet r = \"red\"\nlet y = \"yellow\"\n\nlet u = \"up\"\nlet d = \"down\"\nlet f = \"front\"\nlet x = \"back\"\nlet l = \"left\"\nlet t = \"right\"\n\nlet colors = (\"white\", \"blue\", \"orange\", \"green\", \"red\", \"yellow\")\nlet sides = (\"up\", \"down\", \"front\", \"back\", \"left\", \"right\")\nlet axes = (\"x\", \"y\", \"z\")\n\nlet side_order = (u, d, f, x, l, t)\n\n-- let positions = ( (u, f, l), (u, x, l), (u, f, t), (u, x, t), (d, f, l), (d, x, l), (d, f, t), (d, x, t), (u, f), (u, x), (u, l), (u, t), (d, f), (d, x), (d, l), (d, t)) \n\n-}\ncapital :: String -> String  \ncapital \"\" = \"Empty string, whoops!\"  \ncapital all@(x:xs) = \"The first letter of \" ++ all ++ \" is \" ++ [x]  \n", "input": "\"hello\"", "status": "success", "output": "\"The first letter of hello is h\""}
{"code": "-- The task is to refactor given functions into more Haskell idiomatic style\n\n------------------------ (1) ----------------------------\n-- Before:\nfun1 :: [Integer] -> Integer\nfun1 [] = 1\nfun1 (x:xs)\n   | even x = (x - 2) * fun1 xs\n   | otherwise = fun1 xs\n\n-- After:\nfun1' :: [Integer] -> Integer\nfun1' = product . map (subtract 2) . (filter even)\n\n------------------------ (2) ----------------------------\n-- Before:\nfun2 :: Integer -> Integer\nfun2 1 = 0\nfun2 n | even n = n + fun2 (n `div` 2) \n       | otherwise = fun2 (3 * n + 1)\n\n-- After\nfun2' :: Integer -> Integer\nfun2' = sum\n         .filter even\n         .takeWhile (>1)\n         .iterate (\\x -> if (even x) then (x `div` 2) else (3*x + 1))\n", "input": "[42, 42]", "status": "success", "output": "1600"}
{"code": "removeLowercase :: [Char] -> [Char]\nremoveLowercase st = [c | c <- st, elem c ['A'..'Z']]\nremoveUppercase :: [Char] -> [Char]\nremoveUppercase st = [c | c <- st, elem c ['a'..'z']]\nmakeEnumeratedType :: (Num a, Enum a) => [t] -> [(a, t)]\nmakeEnumeratedType xs = zip [1..] xs\naddThree :: Int -> Int -> Int -> Int\naddThree x y z = x + y + z\nfactorial :: Integer -> Integer\nfactorial n = product [1..n]\naddVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)\nfirst (x, _, _) = x\nsecond (_, y, _) = y\nthird (_, _, z) = z\nletRightTriangles x =\n        [(a,b,c) | a <- [1..x],\n                                b <- [1..x],\n                                c <- [1..x],\n                                a^2 + b^2 == c^2]\n", "input": "['a', 'a']", "status": "success", "output": "\"\""}
{"code": "--(**) Run-length encoding of a list (direct solution).\n\n--Implement the so-called run-length encoding data compression method directly. \n--I.e. don't explicitly create the sublists containing the duplicates, \n--as in problem 9, but only count them. \n--As in problem P11, simplify the result list by replacing the singleton lists (1 X) by X. \n\ndata Frequency =  Single Char | Multiple Int Char deriving Show\n\nfrequency :: [Char] -> Frequency\nfrequency xs\n    |length xs  == 1 = Single $ head xs\n    | otherwise      = Multiple (length xs)  (head xs)\n\nencodeDirect :: [Char] -> [Frequency]  \nencodeDirect [] = []\nencodeDirect (x:xs) = frequency (x:(takeWhile (==x) xs)) : encodeDirect (dropWhile (==x) xs)\n", "input": "['a', 'a']", "status": "success", "output": "Multiple 2 'a'"}
{"code": "{-\n\nProblem 45\n\nTriangle, pentagonal, and hexagonal numbers are generated by the following formulae:\nTriangle        Tn=n(n+1)/2         1, 3, 6, 10, 15, ...\nPentagonal      Pn=n(3n\u22121)/2        1, 5, 12, 22, 35, ...\nHexagonal       Hn=n(2n\u22121)      1, 6, 15, 28, 45, ...\n\nIt can be verified that T285 = P165 = H143 = 40755.\n\nFind the next triangle number that is also pentagonal and hexagonal.\n-}\n\nimport Data.List\n\n-- All triangle numbers are hexagonal numbers, so we can ignore\n-- triangles\neuler45 = find (isPentagonal) $ map (\\n -> (2 * n^2) - n) [144..]\n\nisPentagonal :: Int -> Bool\nisPentagonal p = \n    n == (fromIntegral .truncate) n \n    where n = (sqrt ((24 * (fromIntegral p)) + 1) + 1.0) / 6.0\n\n", "input": "42", "status": "success", "output": "False"}
{"code": "import Data.Char\n\ntoDigits :: Integer -> [Integer]\ntoDigits 0 = []\ntoDigits n\n  | n < 0 = []\n  | otherwise = map fromIntegral $ map digitToInt $ show n\n\ntoDigitsRev :: Integer -> [Integer]\ntoDigitsRev 0 = []\ntoDigitsRev n\n  | n < 0 = []\n  | otherwise = map fromIntegral $ map digitToInt $ reverse . show $ n\n\ndoubleEveryOtherForward :: [Integer] -> [Integer]\ndoubleEveryOtherForward [] = []\ndoubleEveryOtherForward (x:y:zs) = [x,y*2] ++ doubleEveryOtherForward zs\ndoubleEveryOtherForward [x] = [x]\n\ndoubleEveryOther :: [Integer] -> [Integer]\ndoubleEveryOther list = reverse .doubleEveryOtherForward . reverse $ list\n\nsumDigits :: [Integer] -> Integer\nsumDigits nums = foldl (+) 0 $ concat . map toDigits $ nums\n", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "fac :: Integer -> Integer\nfac 0 = 1\nfac n = n * fac (n - 1)\n\nquicksort :: (a -> a -> Bool) -> [a] -> [a]\nquicksort _ [] = []\nquicksort before (x : xs) = quicksort before [y | y <- xs, before y x]\n\t\t++ [x]\n\t\t++ quicksort before [y | y <- xs, not (before y x)]\n\nevens [] = []\nevens (x:xs) = x : odds xs\nodds [] = []\nodds (x:xs) = evens xs\n\nmerge :: (a -> a -> Bool) -> [a] -> [a] -> [a]\nmerge _ x [] = x\nmerge _ [] x = x\nmerge before (x:xs) (y:ys)\n\t| before x y = x : merge before xs (y:ys)\n\t| otherwise = y : merge before (x:xs) ys\n\nmergesort :: (a -> a -> Bool) -> [a] -> [a]\nmergesort _ [] = []\nmergesort _ [x] = [x]\nmergesort before l  = merge before (mergesort before (evens l)) (mergesort before (odds l))\n\n\n", "input": "42", "status": "success", "output": "1405006117752879898543142606244511569936384000000000"}
{"code": "toDigitsRev :: Integer -> [Integer]\ntoDigitsRev n\n    |  n == 0 = [0]\n    |  n >= 0 = (n `mod` 10) : ( if m == 0 then [] else toDigitsRev m)\n    | otherwise = error \" error lower than 0\"\n        where m =  n `div` 10\n\ntoDigits :: Integer -> [Integer]\ntoDigits n\n    | n == 0  = [0]\n    | n < 0 = error \" error lower than 0 \" \n    | otherwise = reverse $ toDigitsRev n\n\n\ndoubleSecond :: [Integer] -> [Integer]\ndoubleSecond [] = []\ndoubleSecond [x] = [x]\ndoubleSecond (x:y:xs) = x : (*) y 2 : [] ++ doubleSecond xs\n\nsumDigits :: [Integer] -> Integer\nsumDigits n = sum $ map(\\x -> sum $ toDigits x) n\n\nisValid :: Integer -> Bool\nisValid n = r == 0\n    where r = (sumDigits $ doubleSecond $ toDigitsRev n) `mod` 10\n\n", "input": "42", "status": "success", "output": "[2,4]"}
{"code": "not' :: Bool -> Bool\nnot' True = False\nnot' False = True\n\nand' :: Bool -> Bool -> Bool\nand' False y = False\nand' True y = y\n\nmax' :: Integer ->Integer ->Integer\nmax' a b \n    | a>=b = a\n    | otherwise = b\n\nfactorial :: Integer ->Integer\nfactorial 0 = 1\nfactorial x = x * factorial(x-1)\n\nfactorial' :: (Integral a) => a -> a\nfactorial' n = product [1..n]\n\nisCloseEnough :: Double -> Double -> Bool\nisCloseEnough a b\n    | diff<=0.0001 = True\n    | otherwise = False\n    where \n      diff = abs (a-b)\n\nsqrt_guess :: Double ->Double ->Double\nsqrt_guess x g\n    | isCloseEnough x (g*g) = g\n    | otherwise             = sqrt_guess x g'\n    where\n      g' = (g+x/g)/2\n\nsqrt' :: Double ->Double\nsqrt' x = sqrt_guess x 1\n", "input": "True", "status": "success", "output": "False"}
{"code": "import Data.Char\nimport Data.List\n\ncapitalizeWord :: String -> String\ncapitalizeWord \"\" = \"\"\ncapitalizeWord (c:cs) = toUpper c : cs\n\ncapitalizeWordTuple :: String -> (String, String)\ncapitalizeWordTuple \"\" = (\"\", \"\")\ncapitalizeWordTuple s@(c:cs) = (s, toUpper c : cs)\n\ncapitalizeWords :: String -> [(String, String)]\ncapitalizeWords = map capitalizeWordTuple . words\n\ncapitalizeHelper :: Bool -> [String] -> [String]\ncapitalizeHelper _ [] = []\ncapitalizeHelper firstWord (s : ss) = s' : (capitalizeHelper firstWord' ss)\n  where s' = if firstWord then (capitalizeWord s) else s\n        firstWord' = isSuffixOf \".\" s\n\ncapitalizeParagraph :: String -> String\ncapitalizeParagraph = unwords . (capitalizeHelper True) . words", "input": "\"hello\"", "status": "success", "output": "\"Hello\""}
{"code": "{--\r\n - Problem 36\r\n(**) Determine the prime factors of a given positive integer.\r\n    Construct a list containing the prime factors and their multiplicity.\r\n\r\n    Example:\r\n    * (prime\u2010factors\u2010mult 315)\r\n    ((3 2) (5 1) (7 1))\r\n\r\n    Example in Haskell:\r\n    *Main> primeFactorsMult 315\r\n    [(3,2),(5,1),(7,1)]\r\n --}\r\n\r\nprimeFactors :: Int -> [Int]\r\nprimeFactors 1 = []\r\nprimeFactors n = k : primeFactors (n `quot` k) where\r\n    k = head $ filter (\\a -> n `mod` a == 0) [2, 3 .. n] \r\n\r\nencode :: [Int] -> [(Int, Int)]\r\nencode [] = []\r\nencode (x:xs) = (x, (+1) $ length $ takeWhile (== x) xs) : encode (dropWhile (== x) xs)\r\n\r\nprimeFactorsMult :: Int -> [(Int, Int)]\r\nprimeFactorsMult n = encode $ primeFactors n\r\n", "input": "42", "status": "success", "output": "[2,3,7]"}
{"code": "-- Problem 6\n--\n-- The sum of the squares of the first ten natural numbers is,\n-- 1^2 + 2^2 + ... + 10^2 = 385\n--\n-- The square of the sum of the first ten natural numbers is,\n-- (1 + 2 + ... + 10)^2 = 552 = 3025\n--\n-- Hence the difference between the sum of the squares of the first ten\n-- natural numbers and the square of the sum is 3025 \u2212 385 = 2640.\n--\n-- Find the difference between the sum of the squares of the first one\n-- hundred natural numbers and the square of the sum.\n\n\neuler6 = result 100\n    where result n =  ((sumFrom1To n) ^ 2) - sumOfSquares1To n\n\nsumFrom1To :: Int -> Int\nsumFrom1To n = (n * (n + 1)) `div` 2\n\nsumOfSquares1To :: Int -> Int\nsumOfSquares1To n = (n * (n + 1) * ((2 * n) + 1)) `div` 6\n", "input": "42", "status": "success", "output": "903"}
{"code": "-- pattern match\n\nlucky :: Int -> String\nlucky 7 = \"LUCKY NUMBER SEVEN!\"\nlucky x = \"Sorry, you're out of luck, pal!\"\n\nfactorial :: Int -> Int\nfactorial 0 = 1\nfactorial n = n * factorial(n - 1)\n\n-- 'Num a =>' a is instance of Num class\naddVectors :: Num a => (a, a) -> (a, a) -> (a, a)\naddVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)\n\nhead' :: [a] -> a\nhead' []    = error \"Can't call head on an empty list, dummy!\"\nhead' (x:_) = x\n\ntell :: (Show a) => [a] -> String\ntell [] = \"The list is empty\"\ntell (x:[]) = \"The list has one element: \" ++ show x\ntell (x:y:[]) = \"The list has two elements: \" ++ show x ++ \" and \" ++ show y\ntell (x:y:_) = \"This list is long. The first two elements are: \" ++ show x ++ \" and \" ++ show y\n", "input": "42", "status": "success", "output": "\"Sorry, you're out of luck, pal!\""}
{"code": "-- contigHead(\"aaabbbaaa\") -> \"aaa\"\n-- chop(\"aaabbbaaa\") -> \"aaa\", \"bbbaaa\"\n-- first((a, b)) -> a\n-- pack(\"aaabbbaaa\") -> \"aaa\", \"bbb\", \"aaa\"\n\ncontigHead :: [Char] -> [Char]\ncontigHead str\n    | length str == 0 = \"\"\n    | otherwise =\n        if length ts == 0 then [h]\n        else\n            if h == head ts\n            then h : contigHead ts\n            else [h]\n    where h : ts = str\n\nchop :: [Char] -> ([Char], [Char])\nchop str\n    | length str == 0 = (\"\", \"\")\n    | length str == 1 = (str, \"\")\n    | otherwise = (hs, ts)\n    where\n        hs = contigHead str\n        ts = drop (length hs) str\n\npack :: [Char] -> [[Char]]\npack str\n    | length str == 0 = []\n    | otherwise = [hs] ++ pack ts\n    where (hs, ts) = chop str\n", "input": "['a', 'a']", "status": "success", "output": "\"aa\""}
{"code": "-- \u73fe\u5728\u884c\u3092\u8fd4\u3059\n-- \\ \u306b\u3088\u308b\u30a8\u30b9\u30b1\u30fc\u30d7\u304c\u3042\u308b\u884c\u672b\u306f2\u6587\u5b57\u4ee5\u4e0a\u306e\\n \u3092\u542b\u3080\u5834\u5408\u304c\u3042\u308b\n-- \u884c\u672b\u306e\u5834\u5408\u306f\\n \u3092\u542b\u307e\u306a\u3044\u5834\u5408\u304c\u3042\u308b\n-- \u7a7a\u6587\u5b57\u5217\u3092\u8fd4\u5374\u3057\u305f\u3089\u6587\u5b57\u5217\u306e\u7d42\u7aef\ncCurrentLine :: String -> String\ncCurrentLine [] = []\ncCurrentLine ('\\\\':x:xs) = '\\\\':x:(cCurrentLine xs)\ncCurrentLine ('\\n':xs)   = ['\\n']\ncCurrentLine (x:xs)      = x:(cCurrentLine xs)\n\n\ncNextLine :: String -> String\ncNextLine x = let len = (length (cCurrentLine x))\n             in drop len x\n\ncSplitLine :: String -> (String, String)\ncSplitLine [] = ([], [])\ncSplitLine x = let cr = (cCurrentLine x)\n              in case cr of [] -> ([], [])\n                            nl -> (nl, (drop (length nl) x))\n", "input": "\"hello\"", "status": "success", "output": "\"hello\""}
{"code": "-- goldbach's conjectue\n-- find two primes that sum up to a given even number\n-- do this for all even numbers in a given interval\n\np40 :: Int -> (Int,Int)\np40 n = let primes = sieve [2..] where\n                sieve (x:xs) = x : sieve [ z | z <- xs, mod z x /= 0 ]\n            isPrime n = n == (head . dropWhile (<n) $ primes)\n            m = head . filter f . takeWhile (<=n) $ primes where\n                f x = isPrime (n-x)\n        in (n-m,m)\n\np41 :: Int -> Int -> [(Int,Int)]\np41 a b = map p40 . filter even $ [a..b]\n\n-- extension to that \n-- find all element where \n-- both goldbach conjectures are bigger than 50\n-- which happens rarely\n\np41' :: Int -> Int -> [(Int,Int)]\np41' a b = filter (\\(a,b) -> a > 50 && b > 50) (p41 a b)\n", "input": "42", "status": "success", "output": "(37,5)"}
{"code": "{-\nUna funci\u00f3n de order superior es una funci\u00f3n que puede tomar como par\u00e1metros\notras funciones o regresar funciones. Antes hay que entender una regla b\u00e1sica de\nHaskell: solo toma un valor y le aplica la funci\u00f3n. El -> significa que dates\nregresa y decidir poner otra vez 'a' significa que con el resultado anterior al\nnuevo valor le aplica la funci\u00f3n\n-}\nisUpperCase :: Char -> Bool\n\nisUpperCase = (`elem` ['A'..'Z'])\n\n--Esta que viene es una funci\u00f3n de order superior\ndosVeces :: (a -> a) -> a -> a\n\ndosVeces f x = f (f x)\n\n--Aplicados al quicksort\n\nqt :: (Ord a) => [a] -> [a]\nqt [] = []\nqt (x:xs) =\n    let smallerSorted = qt (filter (<=x) xs)\n        biggerSorted = qt (filter (>x) xs)\n    in  smallerSorted ++ [x] ++ biggerSorted\n", "input": "'a'", "status": "success", "output": "False"}
{"code": "\n-- stolen from http://www.haskell.org/haskellwiki/The_Fibonacci_sequence\n\nfib 0 = 0\nfib 1 = 1\nfib n | even n         = f1 * (f1 + 2 * f2)\n      | n `mod` 4 == 1 = (2 * f1 + f2) * (2 * f1 - f2) + 2\n      | otherwise      = (2 * f1 + f2) * (2 * f1 - f2) - 2\n   where k = n `div` 2\n         f1 = fib k\n         f2 = fib (k-1)\n\n\n-- stolen from http://projecteuler.net/index.php?section=forum&id=20\ncountDigits :: Integer -> Integer \ncountDigits 0 = 0 \ncountDigits n = 1 + countDigits (n `div` 10)\n\n--tec 517-721-2837\n\n-- We are one off because testLT only graps the one just before it\n-- finds the number of digits\nproblem25 n = (1 +) $ length $  takeWhile (testLT  (n - 1))  $ map (fib ) [ 1..]\n\twhere testLT = (\\ n x -> ( (countDigits x) <= n ))\n", "input": "42", "status": "success", "output": "2"}
{"code": "triangle :: Integer -> Integer\ntriangle 0 = 0\ntriangle n = n + triangle (n - 1)\n\ncount :: Eq a => a -> [a] -> Integer\ncount k [] = 0\ncount k (x:xs) = if k == x then 1 + count k xs else count k xs\n\neuclid :: (Integer, Integer) -> Integer\neuclid (a, b) | a == b     = a\n              | a > b     = euclid (a - b, b)\n              | otherwise = euclid (b - a, a)\n\nfunkyMap :: (a -> b) -> (a -> b) -> [a] -> [b]\n\n-- split list into two : (odds, evens)\nsplit :: [a] -> ([a], [a])\nsplit []   = ([], [])\nsplit [x]  = ([x], [])\nsplit (x: y: xs) = (x : xp, y : yp) where (xp, yp) = split xs\n\n-- f applied to even positions, g applied to odd positions\nfunkyMap f g [] = []\nfunkyMap f g [x] = [(f x)]\nfunkyMap f g (x:y:xs) = (f x) : (g y) : (funkyMap f g xs)\n\n", "input": "42", "status": "success", "output": "903"}
{"code": "sieve :: Int -> [Int]\nsieve n = takeWhile lessThan (till n)\n    where lessThan x = x<=n\n          till n = removeUntil (intSqrt n) [2..]\n\n\n--intSqrt :: Int -> Int\nintSqrt x\n        | x <=0 = 0\n        | otherwise = maximum $ takeWhile square [1..x]\n        where square y = y*y <= x\n\n--removeUntil :: Int -> [Int] -> [Int]\nremoveUntil num list = tailremoveUntil num [] list\n\n--tailremoveUntil :: Int -> [Int] -> [Int] -> [Int]\ntailremoveUntil num header rest@(x:xs)\n    | num >= x = tailremoveUntil num (x:header) (removeMults x xs)\n    | otherwise = (reverse header) ++ rest\n    \n--removeMults :: Int -> [Int] -> [Int]\nremoveMults x xs = filter (notMultipleOf x) xs\n\n--notMultipleOf :: Int -> (Int -> Bool)\nnotMultipleOf x = \\y -> (y `mod` x) /= 0\n", "input": "42", "status": "success", "output": "[2,3,5,7,11,13,17,19,23,29,31,37,41]"}
{"code": "import Data.List\n\nprimeFactorsMult :: Int -> [(Int, Int)]\nprimeFactorsMult = map encoder . group . primeFactors\n\twhere\n\t\tencoder xs = (head xs, length xs)\n\nprimeFactors :: Int -> [Int]\nprimeFactors n = primeFactors' n 2\n\nprimeFactors' :: Int -> Int -> [Int]\nprimeFactors' n p\n\t| isFactor n p && n' > 1 = p : primeFactors' n' p\n\t| not $ isFactor n p && n > 1 = primeFactors' n (p + 1)\n\t| otherwise = [p]\n\t\twhere\n\t\t\tn' = n `div` p\n\nisFactor n p = n `mod` p == 0\n\nnextPrime :: Int -> Int\nnextPrime n\n\t| isPrime (n + 1) = n + 1\n\t| otherwise = nextPrime (n + 1)\n\nisPrime :: Int -> Bool\nisPrime n = isPrime' n 2\n\nisPrime' :: Int -> Int -> Bool\nisPrime' 2 _ = True\nisPrime' n k\n\t| (n - 1) == k = True\n\t| n `mod` k == 0 = False\n\t| otherwise = isPrime' n (k + 1)\n", "input": "42", "status": "success", "output": "[(2,1),(3,1),(7,1)]"}
{"code": "third :: String -> String\nthird \"\" = \"Empty string, how fuggin lame\"\nthird ltrs@(x:y:_) = [ltrs !! 2] ++ \" is the 3rd letter of \" ++ ltrs \n\nfug :: (RealFloat a) => a -> a -> String\nfug weight height\n\t| weight / height ^ 2 <= 18.5 \t= \"Shiiiiit you skinny\"\n\t| weight / height ^ 2 <= 25.0 \t= \"Perfect, fuggin showoff\"\n\t| weight / height ^ 2 <= 30.0 \t= \"Grand stand chunky monkey\"\n\t| otherwise \t\t\t= \"Not even light can escape your pull\"\n\nfug' :: (RealFloat a) => a -> a -> String\nfug' weight height\n\t| bmi <= skinny\t= \"Shiiiiit you skinny\"\n\t| bmi <= normal\t= \"Perfect, fuggin showoff\"\n\t| bmi <= fat \t= \"Grand stand chunky monkey\"\n\t| otherwise\t= \"Not even light can escape your pull\"\n\twhere \tbmi = weight / height ^ 2\n\t\tskinny = 18.5\n\t\tnormal= 25.0\n\t\tfat = 30.0\n", "input": "\"hello\"", "status": "success", "output": "\"l is the 3rd letter of hello\""}
{"code": "queens 0 = [[]]\nqueens n = [board ++ [pos] | board <- queens (n-1),\n                              pos <- [1..8],\n                              safeconfig board pos]\n      where safeconfig board pos = all (safepos (n,pos)) -- all is true is the expressions are true for all values. safepos will be applied to each pair of zip...\n                                       (zip [1..n-1] board) --we write zip as we want to combine rows and columns now. Until now we just had a list with column numbers.\n            safepos (n1,pos1) (n,pos) = pos /= pos1 &&\n                                       abs (n-n1) /= abs (pos-pos1)\n-------------------------------X------------------------------\ntwice f x = f (f x)\nsq :: Int->Int\nsq x = x*x\n\n--(twice twice sq) 2 = 65536", "input": "42", "status": "success", "output": "1764"}
{"code": "-- Thinking Functionally with Haskell\n-- chapter 03 Homework E\n--\n-- what is isqrt: https://en.wikipedia.org/wiki/Integer_square_root\n\n\n-- bound get a pair of Integers [m, n) \n-- so that x >= m && x < n\nbound :: Float -> (Integer, Integer)\nbound x \n     |y > 1 = (div y 2, y) \n     |otherwise = (0, 1)\n      where y = upper x\n\nupper :: Float -> Integer\nupper x = until ((>x) . (\\i -> i * i) . fromInteger)  (*2) 1\n\nhalfNum :: Float -> (Integer, Integer) -> (Integer, Integer)\nhalfNum x (m,n) = if qf <= x \n                  then (q, n)\n                  else (m, q)\n                  where q = div (m + n) 2\n                        qf = (\\i -> i * i) (fromInteger q :: Float)\n\n\nisqrt :: Float -> Integer\nisqrt x = fst (until (\\(m,n) -> m+1==n) (halfNum x) (bound x))\n\n", "input": "3.14", "status": "success", "output": "(1,2)"}
{"code": "-- Problem 37\n-- (18.57 secs, 9,445,859,232 bytes)\n\nimport Data.List (tails)\n\nprimes = 2 : filter (null . tail . primeFactors) [3,5..]\n\nprimeFactors n = factor n primes\n  where\n    factor n (p:ps) \n        | p*p > n        = [n]\n        | n `mod` p == 0 = p : factor (n `div` p) (p:ps)\n        | otherwise      =     factor n ps\n\nisPrime 0 = False\nisPrime 1 = False\nisPrime n = primeFactors n == [n]\n\nlTruncatable :: Integer -> Bool\nlTruncatable = all isPrime . map read . init . tails . show\n\nrTruncatable :: Integer -> Bool\nrTruncatable = all isPrime . map (read . reverse) . init . tails . reverse . show \n\ne037 = print . sum . take 11 . filter lTruncatable . filter rTruncatable . dropWhile (<10) $ primes\n\n-- Optimization: List based, only add primes [2,3,5,7] \n\n\n\n", "input": "42", "status": "success", "output": "False"}
{"code": "import Data.Char\n\n--let2int :: Char -> Int\n--let2int c = ord c - ord 'a'\n--\n--int2let :: Int -> Char\n--int2let n = chr (ord 'a' + n)\n--\n--shift :: Int -> Char -> Char\n--shift n c\n--  | isLower c = int2let ((let2int c + n) `mod` 26)\n--  | otherwise = c\n--\n--encode :: Int -> String -> String\n--encode n xs = [shift n x | x <- xs]\n\nlet2int :: Char -> Int\nlet2int c = ord c - ord 'a'\n\ncap2int :: Char -> Int\ncap2int c = ord c - ord 'A'\n\nint2let :: Int -> Char\nint2let n = chr (ord 'a' + n)\n\nint2cap :: Int -> Char\nint2cap n = chr (ord 'A' + n)\n\nshift :: Int -> Char -> Char\nshift n c\n  | isLower c = int2let ((let2int c + n) `mod` 26)\n  | isUpper c = int2cap ((cap2int c + n) `mod` 26)\n  | otherwise = c\n\nencode :: Int -> String -> String\nencode n xs = [shift n x | x <- xs]\n", "input": "'a'", "status": "success", "output": "0"}
{"code": "import Prelude hiding ((||))\n\n-- lambda expression\nodds :: Int -> [Int]\nodds n = map f [0..n-1]\n  where\n    f x = x * 2 + 1\n\n--pattern matching\nsafetail :: [a] -> [a]\nsafetail [] = []\nsafetail (x:xs) = xs\n\n-- guarded equations\nsafetail' :: [a] -> [a]\nsafetail' a | null a    = []\n            | otherwise = tail a\n\n-- conditional expression\nsafetail'' :: [a] -> [a]\nsafetail'' a = if length a == 0 then [] else tail a\n\n-- 3 def for logical or (||) using pattern matching\n-- || :: Bool -> Bool -> Bool\n--False || False = False\n--_ || _ = True\n\na || b\n  | a == b = a\n  | otherwise = True\n\n--False || a = a\n--True || _ = True\n\n-- and operator\na && b = if a then b else False\na && b = if b then a else False\n\n\nremove :: Int -> [a] -> [a]\nremove n xs = take n xs ++ drop (n+1) xs\n\n\n\n", "input": "42", "status": "success", "output": "[1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,55,57,59,61,63,65,67,69,71,73,75,77,79,81,83]"}
{"code": "-- This function should print a single digit number as English text, or \"unknown\" if it's out of the range 0-9\nenglishDigit :: Int -> String\nenglishDigit 0 = \"Zero\"\nenglishDigit 1 = \"One\"\nenglishDigit 2 = \"Two\"\nenglishDigit 3 = \"Three\"\nenglishDigit 4 = \"Four\"\nenglishDigit 5 = \"Five\"\nenglishDigit 6 = \"Six\"\nenglishDigit 7 = \"Seven\"\nenglishDigit 8 = \"Eight\"\nenglishDigit 9 = \"Nine\"\nenglishDigit _ = \"Unknown\"\n\n-- given a tuple, divide fst by snd, using pattern matching.\n-- it should return undefined for division by zero\ndivTuple :: (Eq a, Fractional a) => (a, a) -> a\ndivTuple (_, 0) = undefined\ndivTuple (x, y) = x / y\n\n-- if the first three numbers in a list are all zero, return True\nthreeZeroList :: [Int] -> Bool\nthreeZeroList (0:(0:(0:_))) = True\nthreeZeroList _ = False\n", "input": "42", "status": "success", "output": "\"Unknown\""}
{"code": "sumtorial :: Integer -> Integer\nsumtorial 0 = 0\nsumtorial n = n + sumtorial (n -1)\n\n\n-- extra guards\nhailstone :: Integer -> Integer\nhailstone n \n\t| mod n 2 == 0 = div n 2\n\t| otherwise \t = (3 * n) + 1\n\t\n-- you can also mix and match guard statements\nfoo :: Integer -> Integer\nfoo 0 = 16\nfoo 1 \n  | \"Haskell\" > \"C++\" = 3\n  | otherwise         = 4\nfoo n\n  | n < 0            = 0\n  | n `mod` 17 == 2  = -43\n  | otherwise        = n + 3\n  \nisEven :: Integer -> Bool\nisEven n = mod n 2 == 0\n\n-- Tuples(?)/Pairs\np :: (Int, Char)\np = (3, 'x')\n\n-- takes a tuple/pair as an argument set. Interesting.\n-- Different from multiple arguments, I think(?)\nsumPair :: (Int, Int) -> Int\nsumPair (x,y) = x + y\n\n--multiple arguments\nthreeAdd :: Int -> Int -> Int -> Int\nthreeAdd x y z = x + y + z\n", "input": "42", "status": "success", "output": "903"}
{"code": "som :: [Int] -> Int\nsom [] = 0\nsom (x:xs) = x+(som xs)\n\nmijn_product :: [Int] -> Int\nmijn_product [] = 1\nmijn_product (x:xs) = x*(mijn_product xs)\n\nvouw :: (b->a->b) -> b -> [a] -> b\nvouw f b [] = b\nvouw f b (a:as) = vouw f (f b a) as\n\nontkoppel :: [(a,b)] -> ([a],[b])\nontkoppel [(a,b)] = ([a],[b])\nontkoppel (x:xs) = ontkoppel_h (x:xs) ([],[])\n\nontkoppel_h :: [(a,b)] -> ([a],[b]) -> ([a],[b])\nontkoppel_h [] t = t\nontkoppel_h ((x1,x2):xs) (as,bs) = ontkoppel_h xs (as++[x1],bs++[x2])\n\ntranspose :: [[a]] -> [[a]]\ntranspose [] = []\ntranspose (r:rs) = transpose_h (r:rs) []\n\ntranspose_h :: [[a]] -> [[a]] -> [[a]]\ntranspose_h [] l = l\ntranspose_h (x:xs) [] = transpose_h xs [ [a] | a<-x]\ntranspose_h (x:xs) (y:ys) = transpose_h xs [ ((y:ys)!!i)++[(x!!i)] | i <- [0..((length x)-1)]]\n", "input": "[42, 42]", "status": "success", "output": "84"}
{"code": "import Data.List\n\nwordList = words \"hey these are the words in this sentence\"\n\ngroupStuff1 = group [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]\ngroupStuff2 = group [\"boom\",\"bip\",\"bip\",\"boom\",\"boom\"]\nsortStuff3 = sort [5,4,3,7,2,1]\nsortStuff4 = sort [\"haskell\", \"totall\", \"kicks\", \"ass\"]\n\nwordNums :: String -> [(String, Int)] \nwordNums = map (\\ws -> (head ws, length ws)) . group . sort . words\n\nwordNums2 xs = map (\\ws -> (head ws, length ws)) (group (sort (words xs)))\n\ngetTails = tails \"party\"\n\nisStartWith = \"Volka\" `isPrefixOf` \"Volkan Ozcelik\"\n\ncheckAny1 = any (>4) [1,2,3,4,5]\ncheckAny2 = any (\\x -> x > 5 && x < 10) [1,4,11]\n\nisIn :: (Eq a) => [a] -> [a] -> Bool \nneedle `isIn` haystack = any (needle `isPrefixOf`) (tails haystack)\n\nisIn2 :: Eq a => [a] -> [a] -> Bool\nisIn2 = isInfixOf\n\n", "input": "\"hello\"", "status": "success", "output": "[(\"hello\",1)]"}
{"code": "toDigitsRev :: Integer -> [Integer]\ntoDigitsRev x \n  | x > 0 = x `mod` 10 : toDigitsRev (x `div` 10)\n  | otherwise = []  \n\ntoDigits :: Integer -> [Integer]\ntoDigits = reverse . toDigitsRev\n\ndoubleEveryOther' :: Integer -> [Integer] -> [Integer]\ndoubleEveryOther' _ [] = []\ndoubleEveryOther' i (x:xs)\n  | even i = x : (doubleEveryOther' (i+1) xs )\n  | otherwise = 2*x : (doubleEveryOther' (i+1) xs)\n\ndoubleEveryOther :: [Integer] -> [Integer]\ndoubleEveryOther = reverse . (doubleEveryOther' 0) . reverse\n\nsumDigit :: Integer -> Integer\nsumDigit x = x `div` 10 + x `mod` 10\n\nsumDigits :: [Integer] -> Integer\nsumDigits [] = 0\nsumDigits (x:xs) = sumDigit x + sumDigits xs\n\nsumCCNum = sumDigits . doubleEveryOther . toDigits\n\nvalidate :: Integer -> Bool\nvalidate n = sumCCNum n `mod` 10 == 0\n\n", "input": "42", "status": "success", "output": "[2,4]"}
{"code": "-- Thinking Functionally with Haskell\n-- Chapter 3 floor in O(lgN)\n--\n-- Examples:\n-- Input: -2.5, Output: -3\n-- Input: 0   , Output: 0\n-- Input: 1.3 , Output: 1\n\n\n-- bound get a pair of Integers [m, n) \n-- so that x >= m && x < n\nbound :: Float -> (Integer, Integer)\nbound x = (lower x, upper x)\n\nlower :: Float -> Integer\nlower x = until ((<=x) . fromInteger)  (*2) (-1)\n\nupper :: Float -> Integer\nupper x = until ((>x) . fromInteger)  (*2) 1\n\nhalfNum :: Float -> (Integer, Integer) -> (Integer, Integer)\nhalfNum x (m,n) = if qf <= x \n                  then (q, n)\n                  else (m, q)\n                  where q = div (m + n) 2\n                        qf = fromInteger q :: Float\n\nmyfloor :: Float -> Integer\nmyfloor x = fst ( until (\\ (m,n) -> m+1 == n) (halfNum x)  (bound x))\n", "input": "3.14", "status": "success", "output": "(-1,4)"}
{"code": "{-# OPTIONS_GHC -Wall #-}\n\nimport Data.List\n\n-- | @xor@ performs XOR logic operation on a list of booleans\nxor :: [Bool] -> Bool\nxor = foldr (\\ x y -> not (x==y)) False \n\n-- | @map'@ is an alternate implementation of map using foldr\nmap' :: (a->b) -> [a] -> [b]\nmap' f = foldr (\\ x y -> (f x) : y) []\n\n-- | @sieveSundaram@ produces a list of odd primes upto 2n + 1\n--   Refer https://en.wikipedia.org/wiki/Sieve_of_Sundaram\nsieveSundaram :: Integer -> [Integer]\nsieveSundaram = (map multiplier).filterer\n\n-- | @filterer@ is a helper for sieveSundaram\nfilterer :: Integer -> [Integer]\nfilterer n = [1..n] \\\\ \n            [(i+j+2*i*j) | i<-[1..n], j<-[1..n], i<=j, j<=n, i+j+2*i*j <= n]\n\n-- | @multiplier@ is a helper for sieveSundaram\nmultiplier :: Integer -> Integer\nmultiplier x = 2*x + 1\n", "input": "[True, True]", "status": "success", "output": "False"}
{"code": "{- Chapter 2\n-}\n\n-- What is the difference between -> and <-?\nremoveNonUppercase :: [Char] -> [Char]\nremoveNonUppercase st = [s | s <- st, elem s ['A'..'Z']]\n\naddThree :: Int -> Int -> Int -> Int\naddThree x y z = x + y + z\n\n-- The difference between Integer and Int is that Integer has BIG numbers...\nfactorial :: Integer -> Integer\nfactorial n = product [1..n]\n\n-- OK.. The difference between Float and Double is that Float is a real floating\n-- point has single point precision but Double has double.. (?!)\ncircumference :: Float -> Float\n-- circumference :: Double -> Double\ncircumference r = 2 * pi * r\n\n-- show is a function that takes a parameter that is of typeclass Show and\n-- return it in String\n--show 3\n--show 5.334\n\n-- read is a function that takes a String and returns a Read typeclass\n", "input": "['a', 'a']", "status": "success", "output": "\"\""}
{"code": "import Data.List\r\nimport Data.Map (toList, fromListWith)\r\n\r\nmakePalindrome :: String -> Maybe String\r\nmakePalindrome str | length oddChars > 1   = Nothing\r\n                   | str == reverse str    = Just str\r\n                   | length oddChars == 1  = Just $ halfPalindrome ++ [(fst . head) oddChars] ++ reverse halfPalindrome\r\n                   | otherwise             = Just $ halfPalindrome ++ reverse halfPalindrome\r\n     where \r\n        charList            = toList $ fromListWith (+) [ (c, 1) | c <- str ]\r\n        oddChars            = filter ((/=) 0 . flip mod 2 . snd) charList\r\n        charListOddsToEvens = map (\\(ch, n) -> if mod n 2 /= 0 then (ch, n-1) else (ch, n)) charList\r\n        halfPalindrome      = (concat . map (\\(ch, n) -> replicate (n `div` 2) ch)) charListOddsToEvens\r\n", "input": "\"hello\"", "status": "success", "output": "Nothing"}
{"code": "-- Takes an integer are returns a list with the individual digits, reversed\ntoDigitsRev :: Integer -> [Integer]\ntoDigitsRev n \n  | n < 10 = [n]\n  | otherwise =  (n `mod` 10) : (toDigitsRev (n `div` 10))\n\n-- Take an integer and returns a list with the individual digits in the\n-- order they were suplied\ntoDigits :: Integer -> [Integer]\ntoDigits n = reverse (toDigitsRev n) \n\ndoubleEveryOther :: [Integer] -> [Integer]\ndoubleEveryOther [] = []\ndoubleEveryOther [x] = [2*x]\n--doubleEveryOther (x:y) = (2*x) : y\ndoubleEveryOther (x:(y:z)) = x : (2*y) : doubleEveryOther z\n\nsumDigits :: [Integer] -> Integer\nsumDigits [] = 0\nsumDigits [x] = sum(toDigits x)\nsumDigits (x:y) = sum(toDigits x) + sumDigits y\n\nvalidate :: Integer -> Bool\nvalidate n = (sumDigits (doubleEveryOther (toDigitsRev n)) `mod` 10) == 0 ", "input": "42", "status": "success", "output": "[2,4]"}
{"code": "-- 1. Write a recursive function named replaceThe which takes a text/string,\n-- breaks it into words and replaces each instance of \u201cthe\u201d with \u201ca\u201d.\n-- It\u2019s intended only to replace exactly the word \u201cthe\u201d. notThe is a\n-- suggested helper function for accomplishing this.\n\n-- example GHCi session above the functions\n-- >>> notThe \"the\"\n-- Nothing\n-- >>> notThe \"blahtheblah\"\n-- Just \"blahtheblah\"\n-- >>> notThe \"woot\"\n-- Just \"woot\"\n\nnotThe :: String -> Maybe String\nnotThe \"the\" = Nothing\nnotThe \"The\" = Nothing\nnotThe w     = Just w\n\n-- >>> replaceThe \"the cow loves us\"\n-- \"a cow loves us\"\nreplaceThe :: String -> String\nreplaceThe s = unwords $ map (replace.notThe) (words s)\n                            where replace Nothing  = \"a\"\n                                  replace (Just w) = w\n\n", "input": "\"hello\"", "status": "success", "output": "Just \"hello\""}
{"code": "toDigits:: Integer -> [Integer]\ntoDigits number\n  | number <= 0 = []\n  | otherwise  = toDigits(number `div` 10) ++ [number `mod` 10]\n\ntoDigitsRev:: Integer -> [Integer]\ntoDigitsRev number\n  | number <= 0 = []\n  | otherwise  =  number `mod` 10 : toDigitsRev(number `div` 10)\n\n\ndoubleEveryOther :: [Integer] -> [Integer]\ndoubleEveryOther(xs)\n  | length(xs) `mod` 2 == 0 = zipWith ($) (cycle([(*2),(*1)])) xs\n  | otherwise = zipWith ($) (cycle([(*1),(*2)])) xs\n\nsumDigits :: [Integer] -> Integer\nsumDigits [] = 0\nsumDigits [x]\n  | x > 10 = sumDigits(toDigits(x))\n  | otherwise = x\nsumDigits (x:xs) = sumDigits(toDigits(x)) + sumDigits(xs)\n\nvalidate :: Integer -> Bool\nvalidate x\n  | sumOfAllDigits `mod` 10 == 0 = True\n  | otherwise = False\n  where sumOfAllDigits = sumDigits $ doubleEveryOther $ toDigits x\n", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "import Data.Char\n\ncap :: [Char] -> [Char]\ncap xs = map toUpper xs\n\nrev :: [Char] -> [Char]\nrev xs = reverse xs\n\ncomposed :: [Char] -> [Char]\ncomposed = cap . rev\n\nfmapped :: [Char] -> [Char]\nfmapped = fmap cap rev\n\ntupled :: [Char] -> ([Char], [Char])\ntupled = (,) <$> cap <*> rev\n\ntupled' :: [Char] -> ([Char], [Char])\ntupled' = do\n  a <- rev\n  b <- cap\n  return (a, b)\n\ntupled'' :: [Char] -> ([Char], [Char])\ntupled'' = (rev . cap) >>= (,)\n\n\nnewtype Reader r a = Reader { runReader :: r -> a }\n\ninstance Functor (Reader r) where\n--  fmap :: (a -> b) -> Reader r a -> Reader r b\n  fmap f (Reader ra) = Reader $ \\r -> f (ra r)\n\nask :: Reader a a\nask = Reader id\n\nmyLiftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c\nmyLiftA2 f a b = f <$> a <*> b\n\nasks :: (r -> a) -> Reader r a\nasks f = Reader f\n\n", "input": "['a', 'a']", "status": "success", "output": "\"AA\""}
{"code": "{-\nLargest palindrome product\nProblem 4\nA palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 \u00d7 99.\n\nFind the largest palindrome made from the product of two 3-digit numbers.\n-}\n\nisPalindrome :: Integer -> Bool\nisPalindrome n = n == reversed n\n\nreversed :: Integer -> Integer\nreversed n = revHlp n 0\n\twhere\n\t\trevHlp n r\n\t\t\t| n == 0 = r\n\t\t\t| otherwise = revHlp (n `div` 10) (r * 10 + n `mod` 10)\n\neuler4 = maximum [p*q | p <- [100..999], q <- [p..999], isPalindrome (p*q)]\n\n--\n\n{- One easy improvement\n\nIf P is palindromic then:\nP=100000x+10000y+1000z+100z+10y+x\nP=100001x+10010y+1100z\nP=11(9091x+910y+100z)\nSo one of the factors must be divisible by 11\n-}\n\neuler4' = maximum [p*q | p <- [11,22..999], q <- [p..999], isPalindrome (p*q)]\n", "input": "42", "status": "success", "output": "False"}
{"code": "-- Aufgabe 12.14\n-- a)\n-- `filter2 [-1,0,1,6666,-5555]`\n\nfilter2 :: [Int] -> [Int]\nfilter2 []\t\t= []\nfilter2 (x:xs)\n\t| x < 0 \t= filter2 xs\n\t| otherwise = [x] ++ (filter2 xs)\n\n-- b)\n-- `count [-1,0,1,6666,-5555]`\n\ncount :: [a] -> Int\ncount []\t\t= 0\ncount (x:xs)\t= 1 + (count xs)\n\n-- c)\n-- `check [-1,0,1,6666,-5555,2,3]`\n-- this would be True\n\ncheck :: [Int] -> Bool\ncheck l\n\t| count (filter2 l) >= 5\t= True\n\t| otherwise \t\t\t\t= False\n\n-- d)\n\ndata Tree a = Node (Tree a) (Tree a) | Leaf a deriving Show\n\n-- An example\n-- (Node (Leaf [1,2]) (Node (Leaf [2,3]) (Leaf [3,4])))\n-- The number of elements in the list can also vary\n\n-- e)\n-- `trans (Node (Leaf [1,2]) (Node (Leaf [2,3]) (Leaf [3,4,4,4,5])))`\n\ntrans :: Tree [Int] -> Tree Bool\ntrans (Leaf l)\t\t= Leaf (check l)\ntrans (Node t1 t2)\t= Node (trans t1) (trans t2)\n", "input": "[42, 42]", "status": "success", "output": "[42,42]"}
{"code": "eratosSieve :: [Integer] -> [Integer]\neratosSieve (n:ns)\n  | n*n > last ns = n:ns\neratosSieve (n:ns) = n:eratosSieve [ i | i<-ns, i `mod` n /= 0]\n\n\nprimeList' :: Integer -> [Integer]\nprimeList' n = eratosSieve [2..n]\n\n\nprimeFactorizeCount :: Integer -> Integer -> Integer\nprimeFactorizeCount n p\n  | n `mod` p == 0 = 1 + primeFactorizeCount (n `div` p) p\n  | otherwise = 0\n\n\nprimeFactorizeWoker :: Integer -> [Integer] -> [Integer]\nprimeFactorizeWoker n [] = []\nprimeFactorizeWoker n (p:px) = [primeFactorizeCount n p] ++ primeFactorizeWoker n px\n\n\nprimeFactorizeList :: Integer -> [(Integer, Integer)]\nprimeFactorizeList n = zip ( primeList' n ) (primeFactorizeWoker n ( primeList' n))\n\n\nprimeFactorize :: Integer -> [(Integer, Integer)]\nprimeFactorize n = [ tuple | tuple <- primeFactorizeList n, snd tuple /= 0 ]\n\n", "input": "[42, 42]", "status": "success", "output": "[42,42]"}
{"code": "-- Problem 1\nisMatching :: Int -> Bool\nisMatching x \n\t| x `rem` 3 == 0 = True\n\t| x `rem` 5 == 0 = True\n\t| otherwise = False\n\nmultiples :: Int\nmultiples = sum $ takeWhile (<1000) $ filter isMatching [1..]\n\n-- Problem 2\ngenerateFibos :: [Int] -> [Int]\ngenerateFibos xs\n\t| (head xs) > 4000000 = xs\n\t| otherwise = generateFibos (((head xs) + (head (tail xs))) : xs)\n\nfibonaccied :: Int\nfibonaccied = sum $ filter (even) $ generateFibos [2,1]\n\n-- Problem 4\nisPalindrome :: Int -> Bool\nisPalindrome x \n\t| (length $ show x) < 2 = False\n\t| x == (read $ reverse $ show x :: Int) = True\n\t| otherwise = False\n\npalindromes :: Int -> Int\npalindromes x = last $ filter (isPalindrome)  $ foldr (\\y acc -> acc ++ [(x * y)]) [11] [100..999]\n\nlargestPalindrome :: Int\nlargestPalindrome = maximum $ map (\\x -> palindromes x) [100..999]\n", "input": "42", "status": "success", "output": "True"}
{"code": "toDigits :: Integer -> [Integer]\ntoDigits x\n\t\t| x <= 0 \t= []\n\t\t| otherwise = (toDigits (x `div` 10)) ++ ((x `mod` 10) : [])\n\ntoDigitsRev :: Integer -> [Integer]\ntoDigitsRev x\n        | x <= 0    = []\n        | otherwise = (x `mod` 10) : (toDigitsRev (x `div` 10))        \n\ndoubleEveryOther :: [Integer] -> [Integer]\ndoubleEveryOther [] = []\ndoubleEveryOther l = reverse (doubleEveryOther' (reverse l) )\n\ndoubleEveryOther' :: [Integer] -> [Integer]\ndoubleEveryOther' [] = []\ndoubleEveryOther' [x] = [x]\ndoubleEveryOther' [x,y] = [x, (2 * y)]\ndoubleEveryOther' (x:y:zs) = x : (2 * y) : (doubleEveryOther' zs)\n\nsumDigits :: [Integer] -> Integer\nsumDigits [] = 0\nsumDigits (x:xs) = x `div` 10 + x `mod` 10 + (sumDigits xs)\n\nvalidate :: Integer -> Bool\nvalidate l = 0 == sumDigits (doubleEveryOther (toDigits l)) `mod` 10\n\n", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "-- Problem 92\n-- (60.21 secs, 63,127,877,496 bytes)\n\nimport Data.Array\nimport Data.Char (digitToInt)\n\nssd :: Int -> Int\nssd n = sum . map ((^2) . digitToInt) . show $ n\n\n-- ssd 0 = 0\n-- ssd n = (n `rem` 10) * (n `rem` 10) + ssd (n `div` 10)\n\nnc n = assocs arr\n    where\n        arr = listArray (1, n) [chain i i | i <- [1..n]]\n        chain _ 1 = 1\n        chain _ 89 = 89\n        chain n m\n            | m < n = (arr ! m)\n            | otherwise = chain n (ssd m)\n\ne092 = print . length . filter ((==89) . snd) $ nc 10000000\n\n\n-- arr =  [a:b:c:d:e:f:g:[] | a <- [0..9], \n--                            b <- [0..a], \n--                            c <- [0..b], \n--                            d <- [0..c],\n--                            e <- [0..d],\n--                            f <- [0..e],\n--                            g <- [0..f]]", "input": "42", "status": "success", "output": "20"}
{"code": "example :: String -> String\nexample str = str ++ \" says hello, World!\"\n\nexample2 :: String -> String\nexample2 n = if n == \"JD\"\n                 then \"JD says Hello, World!\"\n                 else n ++ \" says Haskell is neat.\"\n\nexample3 :: String -> String\nexample3 n = case n of\n                \"JD\"     -> \"JD says Hello, World!\"\n                \"Travis\" -> \"Travis says What's up, trumper?\"\n                _        -> n ++ \" says 38 sure was great.\"\n\nexample4 :: String -> String\nexample4 \"JD\"     = \"JD says Hello, World!\"\nexample4 \"Travis\" = \"Travis says What's up, trumper?\"\nexample4 n        = n ++ \" says 38 sure was great.\"\n\neboard = [\"Sauce\",\"Jeff\",\"Lynch\",\"Tal\",\"Jackie\",\"Travis\",\"Gambogi\",\"Derek\"]\n\nexamplelist = [1..10]\n\nexample5 :: [String] -> [String]\nexample5 [] = []\nexample5 (h:t) = (h ++ \" is dumb!\"):(example5 t)\n", "input": "\"hello\"", "status": "success", "output": "\"hello says hello, World!\""}
{"code": "-- The Collatz sequence takes in a number, and either\n-- divides by 2 if it is even, or\n-- multiplies it by 3 and adds 1 if it is odd.\n-- The famous Collatz conjecture asks whether the sequence,\n-- from any positive initial value, will reach 1.\n\n-- a guard expression is used for the 'collatz' variable,\n-- used for finding the next number in a sequence. This is\n-- neater than if / else if.\ncollatz :: Int -> Int\ncollatz n\n    | even n = n `div` 2\n    | otherwise = 3 * n + 1\n\n-- another guard expression, this time for the variable that\n-- generates whole sequences. it is recursive, and takes \n-- advantage of the 'collatz' variable too.\ncltzList :: Int -> [Int]\ncltzList n\n    | n <= 0 = error \"conjecture.cltzList: The number must be positive.\"\n    | n == 1 = [1]\n    | otherwise = n:cltzList (collatz n) -- else, recursive-call\n", "input": "42", "status": "success", "output": "21"}
{"code": "toDigitsRev :: Integer -> [Integer]\ntoDigitsRev 0 = []\ntoDigitsRev n = (n `mod` 10) : toDigitsRev (n `div` 10)\n\nrevList :: [a] -> [a]\nrevList [] = []\nrevList (x : xs) = (revList xs) ++ [x]\n\ntoDigits :: Integer -> [Integer]\ntoDigits n = revList (toDigitsRev n)\n\ndoubleEveryOtherHelper :: [Integer] -> [Integer]\ndoubleEveryOtherHelper [] = []\ndoubleEveryOtherHelper (x : []) = [2 * x]\ndoubleEveryOtherHelper (x : y : xs) = [2 * x] ++ [y] ++ (doubleEveryOtherHelper xs)\n\ndoubleEveryOther :: [Integer] -> [Integer]\ndoubleEveryOther [] = []\ndoubleEveryOther (x : xs) =\n\t\t if length xs `mod` 2 == 1\n\t\t    then (doubleEveryOtherHelper (x : xs))\n\t\t    else x : (doubleEveryOtherHelper xs)\n\nsumDigits :: [Integer] -> Integer\nsumDigits [] = 0\nsumDigits (x : []) = foldl (+) 0 (toDigits(x))\nsumDigits (x : xs) = sumDigits(toDigits x) + sumDigits(xs)\n\n", "input": "42", "status": "success", "output": "[2,4]"}
{"code": "\nremoveNonUppercase :: [Char] -> [Char]\nremoveNonUppercase st = [c | c <- st, c `elem` ['A' .. 'Z']]\n\naddThree :: Int -> Int -> Int -> Int\naddThree x y z = x + y + z\n\n-- TYPES:\n-- Int: fixed size\n-- Integer: arbitrary size\n-- Float\n-- Double\n-- Bool\n-- Char\n\n\n-- TYPECLASSES:\n-- Eq: interface for equalities (ex: ==)\n-- Ord: \" for ordering (ex: >)\n-- Show: \" for representing stuff as strings (ex: show)\n-- Read: \" for parsing strings as stuff (ex: read)\n-- Enum: \" for sequentially ordered types\n-- Bounded: \" for stuff with lower and upper bounds\n-- Num : \" for stuff that behaves like numbers (Integrals + Floatings) (check: *)\n-- Integral: only integral numbers: Int, Integer\n-- Floating: only floating point numbers: Double, Float\n\nx1 = read \"5\" :: Int\ny1 = read \"(5, 'a')\" :: (Int, Char)\n\n-- fromIntegral: convert from Integral to Num\n\n", "input": "['a', 'a']", "status": "success", "output": "\"\""}
{"code": "toDigits :: Integer -> [Integer]\ntoDigits i\n    | i < 0     = []\n    | i == 0    = []\n    | i <  10   = [i]\n    | otherwise = toDigits (i `div` 10) ++ [i `mod` 10]\n\ntoDigitsRev :: Integer -> [Integer]\ntoDigitsRev = reverse . toDigits\n\ndoubleEveryOther :: [Integer] -> [Integer]\ndoubleEveryOther [] = []\ndoubleEveryOther (x:[]) = [x]\ndoubleEveryOther (x:y:zs)\n    | odd (length zs) = x : y*2 : doubleEveryOther zs\n    | otherwise       = x*2 : y : doubleEveryOther zs\n\nsumDigits :: [Integer] -> Integer\nsumDigits = foldl (+) 0 . concat . map toDigits\n\nvalidate :: Integer -> Bool\nvalidate x = (sumDigits . doubleEveryOther . toDigits) x `mod` 10 == 0\n\ntype Peg = String\ntype Move = (Peg, Peg)\n\nhanoi :: Integer -> Peg -> Peg -> Peg -> [Move]\nhanoi 0 _ _ _ = []\nhanoi disks a b c = (hanoi (disks-1) a c b) ++ [(a, c)] ++ (hanoi (disks-1) b a c)\n", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "mnr = [1,2,3,4,5,6,7] :: [Integer]; {-Matrikelnummer-}\nname = \"Mustermann, Max\" :: String; {- Familienname, Vorname(n) -}\nknz = \"E033 534\" :: String {- Kennzahl -}\n\nt1 = (\"p1\", (take 2.reverse.show)mnr, (head.words.(\\n o ->o:name)'-')'+');\n\nt2 = (\\x y z -> y.x.y); {- hier nur allgemeinster Typ! -}\nt21 = (\\x y z -> y);\nt22 = (\\x y z -> y.x);\nt23 = (\\x y z -> x.y);\nt24 = (\\x y z -> x);\n\nt3 = t2 (take 3) (\\x -> x++x) reverse mnr;\n\nt4 = ( [i|i<-mnr, i>2], [(i, i`mod`3)|i<-mnr] );\n\nt5 = [(sum([i..5]),i)|i<-(tail mnr)];\n\ntls xs = case xs of _:ys -> tls ys; _ -> [];\n\nt6 = ((tls.take 3)mnr, take 5[j|0:j:_<-tls mnr]);\n\np (a:l) = p l + a + p l;\np (a:b:l) | a <= b = p (b:l);\np [e] = 200000;\np _ = 0;\nt7 = ( (p.drop 4)mnr, p mnr);\n\nt8 :: [Integer] -> Integer\nt8 n=case n of \t[] -> 0\n\t\t[x] -> 1\n\t\t[x,y] -> 2\n\t\t(_) -> 100\n\np2 (a:x) = 1\np2 (a:x:y) = 2\n", "input": "[42, 42]", "status": "success", "output": "2"}
{"code": "-- Exercise 1\n\ntoDigits :: Integer -> [Integer]\ntoDigits n\n  | n <= 0 = []\n  | n < 10 = [n]\n  | otherwise = toDigits (n `div` 10) ++ [n `mod` 10]\n\ntoDigitsRev :: Integer -> [Integer]\ntoDigitsRev = reverse . toDigits\n\n\n-- Exercise 2\n\ndoubleEveryOther :: [Integer] -> [Integer]\ndoubleEveryOther xs = map f (zip xs [(len - 1), (len - 2)..0])\n  where\n    len = length xs\n    f (x, i) = if i `mod` 2 == 1 then (2 * x) else x\n\n\n-- Exercise 3\n\nsumDigits :: [Integer] -> Integer\nsumDigits = sum . (concatMap toDigits)\n\n\n-- Exercise 4\n\nvalidate :: Integer -> Bool\nvalidate = (\\x -> x `mod` 10 == 0) . sumDigits . doubleEveryOther . toDigits\n\n\n-- Exercise 5\n\ntype Peg = String\ntype Move = (Peg, Peg)\n\nhanoi :: Integer -> Peg -> Peg -> Peg -> [Move]\nhanoi 0 _ _ _ = []\nhanoi 1 a b _ = [(a, b)]\nhanoi n a b c = hanoi (n-1) a c b ++ [(a, b)] ++ hanoi (n-1) c b a\n", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "import Data.List\n\nremoveDash :: String -> String\nremoveDash = filter $ \\c -> c /= '-'\n\nsectorIdOrZero :: String -> Int\nsectorIdOrZero room =\n  let (']':c5:c4:c3:c2:c1:'[':d3:d2:d1:xs) = reverse $ removeDash room\n      top5 = map head $ take 5 $ reverse $ sortOn length $ group $ reverse $ sort xs\n  in if [c1,c2,c3,c4,c5] == top5\n  then read [d1,d2,d3]\n  else 0\n\nrotate :: Int -> Char -> Char\nrotate _ '-' = ' '\nrotate id c =\n  let i = fromEnum c - fromEnum 'a'\n      i' = (i + id) `mod` 26\n  in toEnum (i' + fromEnum 'a')\n\ndecrypt :: String -> (String, Int)\ndecrypt room =\n  let (']':_:_:_:_:_:'[':d3:d2:d1:xs) = reverse room\n      id = read [d1,d2,d3]\n  in (map (rotate id) $ reverse xs, id)\n\npart1 :: String -> Int\npart1 = sum . map sectorIdOrZero . lines\n\npart2 :: String -> [(String, Int)]\npart2 = filter (isInfixOf \"north\" . fst) . map decrypt . lines\n", "input": "\"hello\"", "status": "success", "output": "\"hello\""}
{"code": "--In England the currency is made up of pound, \u00a3, and pence, p, and there are eight coins in general circulation:--\n\n--1p piece\n--2p piece\n--5p piece\n--10p piece\n--20p piece\n--50p piece\n--1 euro (100p)\n--2 euro (200p)--\n\n--It is possible to make \u00a32 in the following way:--\n\n--1 * \u00a31 + 1 * 50p + 2 * 20p + 1 * 5p + 1 * 2p + 3 * 1p\n--How many different ways can \u00a32 be made using any number of coins?--\n\n--example usage of `makeChange`:--\n\n-- aka, there's only one way to make 1p. that's with a single 1p piece\n--makeChange(1) === 1\n-- aka, there's only two ways to make 2p. that's with two, 1p pieces or with a single 2p piece\n--makeChange(2) === 2\n\nmakeChange :: (Int, [Int]) -> Int\nmakeChange (total, coins)\n  | total == 0 = 1\n  | total < 0 = 0\n  | length coins == 0 = 0\n  | otherwise = makeChange(total, tail coins) + makeChange(total - coins!!0, coins)\n", "input": "(42, [42, 42])", "status": "success", "output": "2"}
{"code": "-- Experiments using Haskell, from \"Learn you a Haskell for Great Good\"\n-- Author : Thomas Minier\n\n-- Very basic stuff\ndoubleMe x = x * 2\ndoubleUs x y = x*2 + y*2\ndoubleSmallNum x = if x > 100 then x else x*2\ndoubleSmallNum' x = (doubleSmallNum x) - 1\n\nremoveNonUppercase :: [Char] -> [Char]\nremoveNonUppercase str = [ c | c <- str, elem c ['A'..'Z']]\n\nrightTriangle :: Int -> [ (Int, Int, Int)]\nrightTriangle n = [ (a,b,c) | c <- [1..n], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2, a+b+c == 24]\n\n-- pattern matching\nlucky :: (Integral a) => a -> String\nlucky 7 = \"Lucky number\"\nlucky x = \"out of luck\"\n\nfactorial :: (Integral a) => a -> a\nfactorial 0 = 1\nfactorial n = n * factorial (n - 1)\n\n-- higher-order functions\nzipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]\nzipWith' _ [] _ = []\nzipWith' _ _ [] = []\nzipWith' f (x:tx) (y:ty) = f x y : zipWith' f tx ty\n", "input": "['a', 'a']", "status": "success", "output": "\"\""}
{"code": "{-\nProblem 31\n\nIn England the currency is made up of pound, \u00a3, and pence, p, \nand there are eight coins in general circulation:\n\n    1p, 2p, 5p, 10p, 20p, 50p, \u00a31 (100p) and \u00a32 (200p).\n\nIt is possible to make \u00a32 in the following way:\n\n    1\u00d7\u00a31 + 1\u00d750p + 2\u00d720p + 1\u00d75p + 1\u00d72p + 3\u00d71p\n\nHow many different ways can \u00a32 be made using any number of coins?\n-}\n\n    \nimport Data.List\nimport Data.Array.ST\nimport Control.Monad.ST\nimport Control.Monad\nimport Data.Array.Unboxed\n\neuler21 = last $ elems $ calcWays 200\n\ncalcWays :: Int -> UArray Int Int\ncalcWays n = runSTUArray $ do \n    change <- newArray (0, 200) 1\n    forM_ coins $ \\c -> do\n        forM_ [c..200] $ \\n -> do\n            a <- readArray change n\n            b <- readArray change (n - c)\n            writeArray change n (a + b)\n    return change\n        where coins = [2, 5, 10, 20, 50, 100, 200]\n", "input": "42", "status": "success", "output": "array (0,200) [(0,1),(1,1),(2,2),(3,2),(4,3),(5,4),(6,5),(7,6),(8,7),(9,8),(10,11),(11,12),(12,15),(13,16),(14,19),(15,22),(16,25),(17,28),(18,31),(19,34),(20,41),(21,44),(22,51),(23,54),(24,61),(25,68),(26,75),(27,82),(28,89),(29,96),(30,109),(31,116),(32,129),(33,136),(34,149),(35,162),(36,175),(37,188),(38,201),(39,214),(40,236),(41,249),(42,271),(43,284),(44,306),(45,328),(46,350),(47,372),(48,394),(49,416),(50,451),(51,473),(52,508),(53,530),(54,565),(55,600),(56,635),(57,670),(58,705),(59,740),(60,793),(61,828),(62,881),(63,916),(64,969),(65,1022),(66,1075),(67,1128),(68,1181),(69,1234),(70,1311),(71,1364),(72,1441),(73,1494),(74,1571),(75,1648),(76,1725),(77,1802),(78,1879),(79,1956),(80,2064),(81,2141),(82,2249),(83,2326),(84,2434),(85,2542),(86,2650),(87,2758),(88,2866),(89,2974),(90,3121),(91,3229),(92,3376),(93,3484),(94,3631),(95,3778),(96,3925),(97,4072),(98,4219),(99,4366),(100,4563),(101,4710),(102,4907),(103,5054),(104,5251),(105,5448),(106,5645),(107,5842),(108,6039),(109,6236),(110,6495),(111,6692),(112,6951),(113,7148),(114,7407),(115,7666),(116,7925),(117,8184),(118,8443),(119,8702),(120,9038),(121,9297),(122,9633),(123,9892),(124,10228),(125,10564),(126,10900),(127,11236),(128,11572),(129,11908),(130,12337),(131,12673),(132,13102),(133,13438),(134,13867),(135,14296),(136,14725),(137,15154),(138,15583),(139,16012),(140,16553),(141,16982),(142,17523),(143,17952),(144,18493),(145,19034),(146,19575),(147,20116),(148,20657),(149,21198),(150,21873),(151,22414),(152,23089),(153,23630),(154,24305),(155,24980),(156,25655),(157,26330),(158,27005),(159,27680),(160,28514),(161,29189),(162,30023),(163,30698),(164,31532),(165,32366),(166,33200),(167,34034),(168,34868),(169,35702),(170,36723),(171,37557),(172,38578),(173,39412),(174,40433),(175,41454),(176,42475),(177,43496),(178,44517),(179,45538),(180,46777),(181,47798),(182,49037),(183,50058),(184,51297),(185,52536),(186,53775),(187,55014),(188,56253),(189,57492),(190,58983),(191,60222),(192,61713),(193,62952),(194,64443),(195,65934),(196,67425),(197,68916),(198,70407),(199,71898),(200,73682)]"}
{"code": "import Data.List\n\nphi   :: Int -> Int\nphi n =  product xs\n\twhere\n\t\txs = map (\\(p, m) ->  (p - 1) * p ^ (m - 1)) (primeFactorsMult n)\n\nprimeFactorsMult :: Int -> [(Int, Int)]\nprimeFactorsMult = map encoder . group . primeFactors\n\twhere\n\t\tencoder xs = (head xs, length xs)\n\nprimeFactors :: Int -> [Int]\nprimeFactors n = primeFactors' n 2\n\nprimeFactors' :: Int -> Int -> [Int]\nprimeFactors' n p\n\t| isFactor n p && n' > 1 = p : primeFactors' n' p\n\t| not $ isFactor n p && n > 1 = primeFactors' n (p + 1)\n\t| otherwise = [p]\n\t\twhere\n\t\t\tn' = n `div` p\n\nisFactor n p = n `mod` p == 0\n\nnextPrime :: Int -> Int\nnextPrime n\n\t| isPrime (n + 1) = n + 1\n\t| otherwise = nextPrime (n + 1)\n\nisPrime :: Int -> Bool\nisPrime n = isPrime' n 2\n\nisPrime' :: Int -> Int -> Bool\nisPrime' 2 _ = True\nisPrime' n k\n\t| (n - 1) == k = True\n\t| n `mod` k == 0 = False\n\t| otherwise = isPrime' n (k + 1)\n", "input": "42", "status": "success", "output": "12"}
{"code": "fac :: Integer -> Integer\nfac 0 = 1\nfac n = n * fac (n - 1)\n\nquicksort :: (a -> a -> Bool) -> [a] -> [a]\nquicksort _ [] = []\nquicksort before (x : xs) = quicksort before [y | y <- xs, before y x]\n\t\t++ [x]\n\t\t++ quicksort before [y | y <- xs, not (before y x)]\n\nevens [] = []\nevens (x:xs) = x : odds xs\nodds [] = []\nodds (x:xs) = evens xs\n\nmerge :: (a -> a -> Bool) -> [a] -> [a] -> [a]\nmerge _ x [] = x\nmerge _ [] x = x\nmerge before (x:xs) (y:ys)\n\t| before x y = x : merge before xs (y:ys)\n\t| otherwise = y : merge before (x:xs) ys\n\nmergesort :: (a -> a -> Bool) -> [a] -> [a]\nmergesort _ [] = []\nmergesort _ [x] = [x]\nmergesort before l  = merge before (mergesort before (evens l)) (mergesort before (odds l))\n\nintegrate s = zipWith (/) s [1,2 ..]\n\nfunny = 1 : integrate funny\n\nsums s = (head s) : map ((+) (head s)) (sums (tail s)) \n\npowers x = 1 : map (* x) (powers x)\n\n", "input": "42", "status": "success", "output": "1405006117752879898543142606244511569936384000000000"}
{"code": "{-# OPTIONS_GHC -Wall #-}\n\n-- Ex.1\ntoDigits    :: Integer -> [Integer]\ntoDigits n\n  | n <= 0    = []\n  | otherwise = toDigits (n `div` 10) ++ [n `mod` 10]\n\ntoDigitsRev :: Integer -> [Integer]\ntoDigitsRev n\n  | n <= 0 = []\n  | otherwise = n `mod` 10 : toDigitsRev (n `div` 10)\n\n-- Ex.2\ndoubleEveryOther :: [Integer] -> [Integer]\ndoubleEveryOther xs = fst $ foldr f ([], False) xs\n  where f x (acc, True)  = (2 * x : acc, False)\n        f x (acc, False) = (    x : acc, True)\n\n-- Ex.3\nsumDigits :: [Integer] -> Integer\nsumDigits = sum . concat . map toDigits\n\n-- Ex.4\nvalidate :: Integer -> Bool\nvalidate = (==0) . (`mod` 10) . sumDigits . doubleEveryOther . toDigits\n\n-- Ex.5\ntype Peg  = String\ntype Move = (Peg, Peg)\n\nhanoi :: Integer -> Peg -> Peg -> Peg -> [Move]\nhanoi 0 _ _ _ = []\nhanoi n a b c = concat [(hanoi (n - 1) a c b), [(a, b)], (hanoi (n - 1) c a b)]\n\n-- Ex.6\n", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "-- 1a) Given \"text\" return \"text!\"\n\nfunc1 text = text ++ \"!\"\n\n-- 2a) Given \"text1 text2\" return \"1\"\n\nfunc2 text = word !! (length word - 1) : \"\"\n    where   tokens = words text\n            word = tokens !! 0\n\n-- 2c) Given \"text1 text2\" return \"text2\"\n\nfunc3 text = lastWord\n    where   tokens = words text\n            lastWord = tokens !! (length tokens - 1)\n\n-- 3)\n\nthirdLetter :: String -> Char\nthirdLetter x = x !! 3\n\n-- 4)\n\nletterIndex :: Int -> Char\nletterIndex x = \"Curry is awesome!\" !! x\n\n-- 5) \n\nrvrs :: String -> String\nrvrs text = concat $ reverseArray tokens\n    where   tokens = words text\n            reverseArray :: [String] -> [String]\n            reverseArray arr = do\n                if len == 1 then\n                    take 1 arr\n                else\n                    reverseArray(drop 1 arr) ++ [\" \", arr !! 0]\n\n                where len = length arr\n", "input": "\"hello\"", "status": "success", "output": "'l'"}
{"code": "-- The sequence of triangle numbers is generated by adding the natural numbers\n-- So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28\n-- The first ten terms would be:\n\n-- 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...\n\n-- Let us list the factors of the first seven triangle numbers:\n\n--  1: 1\n--  3: 1,3\n--  6: 1,2,3,6\n-- 10: 1,2,5,10\n-- 15: 1,3,5,15\n-- 21: 1,3,7,21\n-- 28: 1,2,4,7,14,28\n-- We can see that 28 is the first triangle number to have over five divisors\n\n-- What is the value of the first triangle number\n-- to have over five hundred divisors?\n\n-- http://stackoverflow.com/a/32172277\ntriangulars = scanl (+) 1 [2 ..]\n\nisqrt :: Int -> Int\nisqrt = floor . sqrt . fromIntegral\n\nnumDivisors :: Int -> Int\nnumDivisors num = (length [x | x <- [1 .. isqrt num], num `mod` x == 0]) * 2\n\nfirsTriangleWithNDivisors n = takeWhile (==n) (map numDivisors triangulars)\n", "input": "42", "status": "success", "output": "6"}
{"code": "import Data.Char\n\ndata Logger a = Logger [String] a deriving Show\n\ntoCode :: Char -> Logger Int\n-- toCode c = Logger [\"toCode \" ++ show c] (ord c)\n-- toCode c = tell (\"toCode \" ++ show c) >> return (ord c)\ntoCode c = ord c <$ tell (\"toCode \" ++ show c)\n\ndouble :: Int -> Logger Int\n-- double n = Logger [\"double \" ++ show n] (n * 2)\n-- double n = tell (\"double \" ++ show n) >> return (n * 2)\ndouble n = n * 2 <$ tell (\"double \" ++ show n)\n\nretL :: a -> Logger a\nretL = Logger []\n\nbindL :: Logger a -> (a -> Logger b) -> Logger b\nLogger l x `bindL` f = let Logger l' y = f x in Logger (l ++ l') y\n\ninstance Functor Logger where\n\tfmap f m = m `bindL` (retL . f)\n\ninstance Applicative Logger where\n\tpure = retL\n\tmf <*> mx = mf `bindL` \\f -> mx `bindL` \\x -> retL $ f x\n\ninstance Monad Logger where\n\treturn = retL\n\t(>>=) = bindL\n\ntell :: String -> Logger ()\ntell l = Logger [l] ()\n", "input": "'a'", "status": "success", "output": "Logger [\"toCode 'a'\"] 97"}
{"code": "-- Laatste element van een lijst\nlaatste::[Int]->Int\nlaatste [a] = a\nlaatste (a:tail) = laatste tail\n\n-- Herhaal n keer het getal x in een lijst\nherhaal::Int->Int->[Int]\nherhaal 1 x = [x]\nherhaal n x = (x:(herhaal (n-1) x))\n\n-- Metalijst -> Platte lijst\nlineariseer::[[Int]]->[Int]\nlineariseer [l] = l\nlineariseer (la:lb:tail) = lineariseer ((append la lb):tail)\nappend::[Int]->[Int]->[Int]\nappend [] l = l\nappend (h:t) l = (h:(append t l))\n\n-- Lijst van getallen tussen 2 gegeven getallen\nbereik::Int->Int->[Int]\nbereik a b = if a==b then [b]\n             else if a<b then (a:(bereik (a+1) b))\n             else bereik b a\n-- Verwijder veelvouden van een getal uit een lijst\nverwijderVeelvouden::Int->[Int]->[Int]\nverwijderVeelvouden a [] = []\nverwijderVeelvouden a (b:t) = if (mod b a)==0 then verwijderVeelvouden a t\n                            else b:(verwijderVeelvouden a t)\n", "input": "[42, 42]", "status": "success", "output": "42"}
{"code": "-- exercice address:\n-- https://leetcode.com/problems/nim-game/\n\n-- explanation\n-- You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.\n-- Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.\n-- For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend. \n\ncanIwin :: Int -> Bool\ncanIwin n\n    | n <= 3 = True\n    | n `mod` 4 /= 0 = True\n    | otherwise = False\n\ntries :: [Int]\ntries = [1..15]\n\nrun = do\n    [(try, canIwin try) | try <- tries]\n", "input": "42", "status": "success", "output": "True"}
{"code": "-- file ch03/ex03.hs\n-- Write a function that computes the mean of a list, i.e. the sum of all\n-- elements in the list divided by its length. (You may need to use the\n-- fromIntegral function to convert the length of the list from an integer\n-- into a floating point number.)\n\n-- 1) tuples and laziness\nmean :: [Double] -> Double\nmean [] = error \"mean: empty list\"\nmean val = snd(inner val) / fst(inner val)\n  where inner [] = (0, 0)\n        inner (x:xs) = (fst(inner xs) + 1, snd(inner xs) + x)\n-- This looks like double recursion (and would become exponential),\n-- but the lazy evaluation makes it into two travesals. One could\n-- create two separate functions as well, though...\n\n-- 2) List comprehension, though it uses built in function\nlistMean :: [Double] -> Double\nlistMean [] = error \"listMean: empty list\"\nlistMean xs = sum xs / length' xs where length' xs = sum [1 | _ <- xs]", "input": "[2.71, 2.71]", "status": "success", "output": "2.71"}
{"code": "{--\r\n - Problem 40\r\n(**) Goldbach's conjecture.\r\n    Goldbach's conjecture says that every positive even number greater than 2 is the sum of two prime\r\n    numbers. Example: 28 = 5 + 23. It is one of the most famous facts in number theory that has not been\r\n    proved to be correct in the general case. It has been numerically confirmed up to very large numbers\r\n    (much larger than we can go with our Prolog system). Write a predicate to find the two prime numbers\r\n    that sum up to a given even integer.\r\n\r\n    Example:\r\n    * (goldbach 28)\r\n    (5 23)\r\n    \r\n    Example in Haskell:\r\n    *goldbach 28\r\n    (5, 23)\r\n --}\r\n\r\nisPrime :: Int -> Bool\r\nisPrime 1 = False\r\nisPrime n = 0 `notElem` map (n `mod`) [2, 3 .. m]\r\n    where m = floor . sqrt $ fromIntegral n \r\n\r\ngoldbach :: Int -> (Int, Int)\r\ngoldbach n = (k, n-k) where k = head $ filter (\\a -> isPrime a && isPrime (n-a)) [2 .. n]\r\n\r\n", "input": "42", "status": "success", "output": "False"}
{"code": "--Ejercio 1-a\n\nesCero :: Int -> Bool\nesCero x = x == 0\n\n--Ejercicio 1-b\n\nesPositivo :: Int -> Bool\nesPositivo x = x > 0\n\n--Ejercicio 1-c\n\nesVocal :: Char -> Bool\nesVocal x = x == 'a' || x == 'e' || x == 'i' || x == 'o' || x == 'u'\n\n--Ejercicio 1-d\n\nfactorial :: Int -> Int\nfactorial 0 = 1\nfactorial n = n * (factorial (n-1))\n\n--Ejercicio 1-e\n\npromedio :: [Int] -> Int\npromedio [] = error \"No se puede dividir por 0\"\npromedio (x:xs) = div (sumatoria (x:xs)) (length (x:xs))\n\n--Ejercicio 2-a\n\nparaTodo :: [Bool] -> Bool\nparaTodo [] = True\nparaTodo (x:xs) = x && paraTodo xs\n\n--Ejercicio 2-b\n\nsumatoria :: [Int] -> Int\nsumatoria [] = 0\nsumatoria (x:xs) = x + sumatoria xs\n\n--Ejercicio 2-c\n\nproductoria :: [Int] -> Int\nproductoria [] = 1\nproductoria (x:xs) = x * productoria xs\n\n--Ejercicio 3\n\npertenece :: Int -> [Int] -> Bool\npertenece _ [] = False \npertenece n (x:xs) = n == x || (pertenece n xs)\n\n\n\n\n", "input": "42", "status": "success", "output": "False"}
{"code": "import qualified Data.Char as Char\n\ntoDigits :: Integer -> [Integer]\ntoDigits i\n    | i <= 0 = []\n    | otherwise = f $ show i\n    where f (x:[]) = (toInteger $ Char.digitToInt x) : []\n          f (x:xs) = (toInteger $ Char.digitToInt x) : f xs\n\ntoDigitsRev :: Integer -> [Integer]\ntoDigitsRev i = reverse $ toDigits i\n\ndoubleEveryOther :: [Integer] -> [Integer]\ndoubleEveryOther x = reverse [ if snd x == True then fst x * 2 else fst x | x <- zip (reverse x) (take (length x) $ cycle [False, True])]\n\nsumDigits :: [Integer] -> Integer\nsumDigits x = sum $ map (sum . toDigits) x\n\nvalidate :: Integer -> Bool\nvalidate x = f $ (sumDigits . doubleEveryOther . toDigits) x `mod` 10\n    where f y = if y == 0 then True else False\n\ntype Peg = String\ntype Move = (Peg, Peg)\n\nhanoi :: Integer -> Peg -> Peg -> Peg -> [Move]\nhanoi 0 _ _ _ = []\nhanoi n a b c = hanoi (n-1) a c b ++ [(a,b)] ++ hanoi (n-1) c b a\n\n", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "maxArea3 :: (Int, Int, Int) -> Double\nmaxArea3 (a', b', c') = maxArea3' (fromIntegral a') (fromIntegral b') (fromIntegral c') where\n    maxArea3' :: Double -> Double -> Double -> Double\n    maxArea3' a b c = pi * (r1_2 + r2_2 + rFinal_2) where\n        p = (a + b + c) / 2\n        sin2a = (a^2 - (b - c)^2) / (4 * b * c)\n        cos2a = ((b + c)^2 - a^2) / (4 * b * c)\n        sin2b = (b^2 - (c - a)^2) / (4 * c * a)\n        cos2b = ((c + a)^2) / (4 * c * a)\n        sina = sqrt sin2a\n        cosa = sqrt cos2a\n        radicand2_a = (1 - sina) / (1 + sina)\n        radicand2_b = (1 - sinb) / (1 + sinb)\n        sinb = sqrt sin2b\n        cosb = sqrt cos2b\n        r1_2 = (p - a) * (p - b) * (p - c) / p\n        r2_2 = r1_2 * (1 - sina)^2 / cos2a * radicand2_a\n        r3_2 = r1_2 * (1 - sinb)^2 / cos2b * radicand2_b\n        r4_2 = r2_2 * (1 - 2 * sina / cosa * sqrt(radicand2_a))^2\n        rFinal_2 = max r3_2 r4_2", "input": "(42, 42, 42)", "status": "success", "output": "551.6113100928079"}
{"code": "import Data.Char\nimport Data.Maybe\nimport Data.List\n\ntoDigits :: Integer -> [Integer]\ntoDigits i\n    | i <= 0    = []\n    | otherwise = map (toInteger . digitToInt) (show i)\n\ntoDigitsRev :: Integer -> [Integer]\ntoDigitsRev = reverse . toDigits\n\ndoubleEveryOther :: [Integer] -> [Integer]\ndoubleEveryOther = foldr doubleEv []\n    where doubleEv i ls\n            | (length ls) `mod` 2 /= 0  = (i * 2) : ls\n            | otherwise                 = i : ls\n\nsumDigits :: [Integer] -> Integer\nsumDigits = sum . concat . (map toDigits)\n\nvalidate :: Integer -> Bool\nvalidate n = (sumDigits . doubleEveryOther . toDigits $ n) `mod` 10 == 0\n\n--------------------------------------------------\n\ntype Peg = String\ntype Move = (Peg, Peg)\n\nhanoi :: Integer -> Peg -> Peg -> Peg -> [Move]\nhanoi 0 _ _ _ = []\nhanoi n s d t = (hanoi (n - 1) s t d) ++ ((s, d) : (hanoi (n - 1) t d s))\n\n--------------------------------------------------", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "doubleMe :: Double -> Double\ndoubleMe x = 2.0*x\ndoubleUs :: Double -> Double -> Double\ndoubleUs x y = doubleMe x + doubleMe y\ndoubleSmallNumbers :: Double -> Double\ndoubleSmallNumbers x = if x > 100 then x else doubleMe x\n\nlucky :: (Integral a) => a -> String\nlucky 7 = \"Gg\"\nlucky x = \"Sorry\"\n\nreplicate' :: (Num i, Ord i) => i -> a -> [a]\nreplicate' 0 x = []\nreplicate' n x = x:replicate' (n-1) x\n\ntake' :: (Num i, Ord i) => i -> [a] -> [a]\ntake' n (x:xs)\n\t| n <= 0 \t= []\n\t| otherwise = x:take' (n-1) xs\n\nelem' :: (Eq a) => a -> [a] -> Bool\nelem' e = foldr (\\x acc -> if x == e then True else (acc || False)) False\n\nquicksort :: (Ord a) => [a] -> [a]\nquicksort [] = []\nquicksort (x:xs) = \n\tlet smallerSorted = quicksort [a | a <- xs, a <= x];\n\t\tbiggerSorted = quicksort [a | a <- xs, a > x]\n\tin smallerSorted ++ [x] ++ biggerSorted\n\nmaximum' :: (Ord a) => [a] -> a\nmaximum' = foldr1 (\\x acc -> if x > acc then x else acc)", "input": "2.71", "status": "success", "output": "5.42"}
{"code": "not'      :: Bool -> Bool\nnot' True  = False\nnot' False = True\n\nsignum :: Int -> Int\nsignum n | n < 0      = -1\n         | n == 1     =  0 \n         | otherwise  =  1\n\n\nhalve :: [a] -> ([a], [a])\nhalve xs = (take n xs, drop n xs)\n\twhere n = length xs `div` 2         \n\nhalve2 xs = splitAt (length xs `div` 2) xs\n\nhalve3 xs = splitAt (div (length xs) 2) xs\n\nsafetail\n  = \\ xs ->\n      case xs of\n      \t  [] -> []\n      \t  (_: xs) -> xs\n\n\n--bit of sanity type checking,...\n\n(|||) :: Bool -> Bool -> Bool\na ||| False = a\na ||| True  = True\n\nremove :: Int -> [a] -> [a]\nremove n xs = take n xs ++ drop (n + 1) xs\n\n\ninta :: Integer\ninta = 2\n\nintb :: Num b => [[b]]\nintb = [[1,2], [3,4]]\n\nintc :: Num a => [[[a]]]\nintc = [[[1,2,3]], [[4,5,6]]]\n\nintd :: Integer -> Integer\nintd x = x * 2\n\ninte :: Num a => a -> a\ninte x = x * 2\n\nintf x = x * 2\n\ne4 (x, y) = x\n\ne6 [x, y] = (x, True)\n\ne11 = ('\\a', True) -- '\\a' is an escaped ALERT\n", "input": "True", "status": "success", "output": "False"}
{"code": "import Data.Maybe\r\n\r\n\r\n\r\n\r\n\r\nis_composite :: Int -> Bool\r\nis_composite n = or $ map (\\x -> n `mod` x == 0) [2..(truncate $ sqrt $ fromIntegral n)]\r\n\r\n\r\nis_prime = not . is_composite\r\n\r\n\r\nis_composite_odd n = odd n && is_composite n\r\n\r\nclosest_prime n = head $ filter is_prime [n-1,n-2..2]\r\n\r\nremainder t n s\r\n\t\t\t| n + 2*s*s > t \t=\tNothing\r\n\t\t\t| n + 2*s*s == t\t=\tJust s\r\n\t\t\t| otherwise\t\t\t= \tremainder t n (s+1) \r\n\r\n\r\n\r\nbest_combo t 2 = Nothing\r\nbest_combo t p = \tlet \r\n\t\t\t\t\t\tp' = closest_prime p\r\n\t\t\t\t\t\tres = remainder t p 0\r\n\t\t\t\t\tin\r\n\t\t\t\t\t\tif res == Nothing then best_combo t p'\r\n\t\t\t\t\t\telse Just (t,p, fromJust res)\r\n\r\ngoldbach_triple n = best_combo n (n-1)\r\n\r\n\r\ngolds = [(x,y) | x <- [9..], let y = goldbach_triple x, is_composite_odd x]\r\n\r\nfailed = filter (\\(x,y) -> y ==Nothing) golds\r\n\r\n\r\n\r\n\r\n\r\n\r\n--ans = head $ filter (Nothing==) [y | x <- [1..], let y = map (\\z -> remainder z (closest_prime z) 0) x, is_composite_odd x]", "input": "42", "status": "success", "output": "True"}
{"code": "-- exercise 1\n\nimport Data.Char\n\ntoDigits :: Integer -> [Integer]\ntoDigits n\n  | n > 0 = map ((\\n -> n - 48) . toInteger . ord) $ show n\n  | otherwise = []\n\ntoDigitsRev :: Integer -> [Integer]\ntoDigitsRev = reverse . toDigits\n\n-- exercise 2\n\ndoubleEveryOther :: [Integer] -> [Integer]\ndoubleEveryOther xs = fst $ foldr (\\x (acc, flag) -> if flag then (2 * x : acc, not flag)\n                                                     else (x : acc, not flag)) ([], False) xs\n-- exercise 3\n\nsumDigits :: [Integer] -> Integer\nsumDigits xs = sum $ map (sum . toDigits) xs\n\n-- exercise 4\n\nwholeSum :: Integer -> Integer\nwholeSum = sumDigits . doubleEveryOther . toDigits\n\nvalidate :: Integer -> Bool\nvalidate n = (mod (wholeSum n) 10) == 0\n\n-- exercise 5\n\ntype Peg = String\ntype Move = (Peg, Peg)\nhanoi :: Integer -> Peg -> Peg -> Peg -> [Move]\nhanoi 0 _ _ _ = []\nhanoi n a b c = (hanoi (n - 1) a c b) ++ [(a, b)] ++ (hanoi (n - 1) c b a)\n", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "\nimport Data.List\nisempty :: ([Char],[Char],[Char])->Bool\nisempty (_,[],[]) = False\nisempty _  = True\n\nfirstf :: (String,String,String)->String\nfirstf (a,b,c) = a\n\ntransbit :: Char -> Char\ntransbit '0' = '1'\ntransbit '1' = '0'\ntransbit c = c\n\nmainf :: ([Char],[Char],[Char]) -> Char -> ([Char],[Char],[Char])\nmainf  (xs,[],[]) _ = (xs,[],[])\nmainf  (xs,[x],ys) '1' = (xs,[transbit x],ys)\nmainf  (xs,[x],[]) '0' = (xs ++ [x],[],[])\nmainf  (xs,[x],y:ys) '0' = (xs ++ [x],[y],ys)\n\nflowf :: Bool -> [Char] -> [Char] ->[([Char],[Char],[Char])]\nflowf False _ _ = error\"undefined\"\nflowf True l \"\" = [([],[],[])]\nflowf True l [x] = scanl mainf ([],[x],[])  (cycle l)\nflowf True l (x:xs) = scanl mainf ([],[x],xs)  (cycle l)\n\n\nextractf :: [([Char],[Char],[Char])] -> String\nextractf xs= firstf $ head (dropWhile isempty xs)\n\ninterpreter :: String -> String -> String\ninterpreter tape array  = extractf ( flowf (elem '0' tape) tape array )\n\n\n", "input": "(['a', 'a'], ['a', 'a'], ['a', 'a'])", "status": "success", "output": "True"}
{"code": "import Data.Char\n\ntoDigits :: Integer -> [Integer]\ntoDigits = map (toInteger . digitToInt) . show\n\neval xs = foldl (\\x y -> y + (10 * x)) 0 xs\n-- Checks\ncheckEval n = n == eval (toDigits n)\ncheckAll n = all (\\d -> d >= 0 && d < 10) (toDigits n)\n\ntoDigitsRev :: Integer -> [Integer]\ntoDigitsRev = reverse . toDigits\n\nevalRev xs = foldr (\\x y -> x + (10 * y)) 0 xs\n-- Checks\ncheckEvalRev n = evalRev (toDigitsRev n) == n\ncheckAllRev n = all (\\d -> d >= 0 && d < 10) (toDigitsRev n)\n\ndoubleSecond :: [Integer] -> [Integer]\ndoubleSecond  = zipWith (*) (cycle [1,2])\n\n-- Checks\ncheckDoubleSecond = doubleSecond [8, 7, 6, 5] == [8, 14, 6, 10]\n\nsumDigits :: [Integer] -> Integer\nsumDigits xs = sum (map (uncurry (+) . (`divMod` 10)) xs)\n\n-- Checks\ncheckSumDigits1 = sumDigits [8,14,6,10] == 20\ncheckSumDigits2 = sumDigits [3,9,4,15,8] == 30\n\nisValid :: Integer -> Bool\nisValid = (0 ==) . (`mod` 10) . sumDigits . doubleSecond . toDigitsRev", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "inc :: Int -> Int\ninc n = n + 1\n\n{-\nstrict evaluation:\ninc (2*3)\ninc 6\n6+1\n7\n\nlazy evaluation:\ninc (2*3)\n(2*3)+1\n6+1\n7\n-}\n\nmult = \\x -> \\y -> x * y\n\ninf = 1 + inf\n\n{-\nStrict:\nfst (0, inf)\nfst (0, 1+inf)\nfst (0, 1+(1+inf))\nfst (0, 1+(1+(1+inf)))\n... (never terminates)\n\nLazy:\nfst (0, inf)\n0\n-}\n\nones = 1:ones\n\n-- head ones\n-- head (tail ones)\n-- take 3 ones\n\n-- WARNING!!!\n\n-- filter (<=5) [1..] --> Never returns\n-- takeWhile (<=5) [1..] --> [1,2,3,4,5]\n\nprime = sieve [2..]\n\nsieve (p:xs) = p : sieve (filter (\\x -> x `mod` p /= 0) xs) \n--[ x | x <- xs, x `mod` p /= 0 ]\n\n-- Lazy (the accumulator variable v doesn't work as intended because of lazy evaluation)\nsumWith :: Int -> [Int] -> Int\nsumWith v [] = v\nsumWith v (x:xs) = sumWith (v+x) xs\n\n-- sumWith 0 [1,2,3]\n-- (((0+1)+2)+3)\n\n-- Strict (force the evaluation of (v+x) with $! before it)\nsumWith' :: Int -> [Int] -> Int\nsumWith' v [] = v\nsumWith' v (x:xs) = (sumWith' $! (v+x)) xs\n", "input": "42", "status": "success", "output": "43"}
{"code": "{- Exercise 1 -}\ntoDigitsRev :: Integer -> [Integer]\ntoDigitsRev x\n    | x <= 0        = []\n    | otherwise     = x `mod` 10 : toDigitsRev (x `div` 10)\n\ntoDigits :: Integer -> [Integer]\ntoDigits x = reverse $ toDigitsRev x\n\n\n{- Exercise 2 -}\ndoubleEveryOther :: [Integer] -> [Integer]\ndoubleEveryOther x = reverse $ doubleFlipped (reverse x) False\n\ndoubleFlipped :: [Integer] -> Bool -> [Integer]\ndoubleFlipped [] _ = []\ndoubleFlipped (x:xs) True  = 2 * x : doubleFlipped xs False\ndoubleFlipped (x:xs) False = x : doubleFlipped xs True\n\n{- Exercise 3 -}\nsumDigits :: [Integer] -> Integer\nsumDigits x = sum $ concat $ map toDigits x\n\n{- Exercise 4 -}\nvalidate :: Integer -> Bool\nvalidate x = (sumDigits . doubleEveryOther . toDigits $ x) `mod` 10  == 0\n\n{- Exercise 5 -}\ntype Peg = String\ntype Move = (Peg, Peg)\nhanoi :: Integer -> Peg -> Peg -> Peg -> [Move]\nhanoi 0 _ _ _ = []\nhanoi x a b c = hanoi (x-1) a c b ++ [(a,b)] ++ hanoi (x-1) c b a\n", "input": "42", "status": "success", "output": "[2,4]"}
{"code": "--\u043c\u0430\u043b\u0435\u043d\u044c\u043a\u0438\u0439 \u044f\u0437\u044b\u043a \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u0443\u043c\u0435\u0435\u0442 \u0442\u043e\u043b\u044c\u043a\u043e \u043f\u0435\u0447\u0430\u0442\u0430\u0442\u044c\nimport Control.Applicative\nimport Control.Monad\n\ndata Writer a = Writer a String\n              deriving (Show, Eq)\n\ninstance Functor Writer where\n  fmap f (Writer a str) = Writer (f a) str\n\ninstance Monad Writer where\n  return a = Writer a \"\"\n  (Writer a str) >>= f = let Writer b str' = f a\n                        in Writer b (str ++ str')\n\ninstance Applicative Writer where\n  pure = return\n  (<*>) = ap\n\nprint' :: String -> Writer ()\nprint' str = Writer () str\n\nprintLn' :: String -> Writer ()\nprintLn' str = print' (str ++ \"\\n\")\n\neval :: Writer a -> IO a\neval (Writer a str) = do\n  putStr str\n  return a\n\nfib :: Integer -> Writer Integer\nfib n = do\n  printLn' (show n)\n  fib' n\n\n  where fib' 0 = return 0\n        fib' 1 = return 1\n        fib' n = do\n          a <- fib (n - 1)\n          b <- fib (n - 2)\n          return (a + b)", "input": "\"hello\"", "status": "success", "output": "Writer () \"hello\""}
{"code": "myAnd :: [Bool] -> Bool\nmyAnd = foldr (&&) True\n\nmyOr :: [Bool] -> Bool\nmyOr = foldr (||) False\n\nmyAny :: (a -> Bool) -> [a] -> Bool\nmyAny f = myOr . (map f)\n\nmyElem :: Eq a => a -> [a] -> Bool\nmyElem x = myAny (== x)\n\nmyReverse :: [a] -> [a]\nmyReverse = foldl (\\xs x -> x : xs) []\n\nsquish :: [[a]] -> [a]\nsquish = foldr (++) []\n\nsquishMap :: (a -> [b]) -> [a] -> [b]\nsquishMap f = squish . (map f)\n\nsquishAgain :: [[a]] -> [a]\nsquishAgain = squishMap id\n\nmyMaximumBy :: (a -> a -> Ordering) -> [a] -> a\nmyMaximumBy _ [] = error \"cannot max empty list!\"\nmyMaximumBy f (x:xs) =\n  let f' = \\a b -> if f a b == GT then a else b\n  in foldr f' x xs\n\nmyMinimumBy :: (a -> a -> Ordering) -> [a] -> a\nmyMinimumBy _ [] = error \"cannot min empty list!\"\nmyMinimumBy f (x:xs) =\n  let f' = \\a b -> if f a b == LT then a else b\n  in foldr f' x xs\n\nmyMaximum :: (Ord a) => [a] -> a\nmyMaximum = myMaximumBy compare\n\nmyMinimum :: (Ord a) => [a] -> a\nmyMinimum = myMinimumBy compare", "input": "[True, True]", "status": "success", "output": "True"}
{"code": "-- 29/03/16\n-- Lorenzo Jose Lamas\n-- Algebra I\n-- Labo\n--\n\n\ndoble :: Integer -> Integer\ndoble x = x + x\n\ncuadruple :: Integer -> Integer\ncuadruple x = doble (doble x)\n\ndist :: Float -> Float -> Float -> Float -> Float\ndist x1 y1 x2 y2 = sqrt ((x2 - x1)^2 + (y2 - y1)^2)\n\ndist1 :: (Float, Float) -> (Float, Float) -> Float\ndist1 p1 p2 = sqrt ((fst p1 - fst p2)^2 + (snd p1 - snd p2)^2)\n\ncrearPar :: a -> b -> (a, b)\ncrearPar a b = (a,b)\n\ninvertir :: (a, b) -> (b, a)\ninvertir p = (snd p , fst p)\n\nraices :: Float -> Float -> Float -> (Float,Float)\n--raices :: Floating a => a -> a -> a -> (a,a)\nraices a b c | (b^2 -4*a*c) < 0 = error \"No hay ninguna raiz real\"\n\t\t\t | (b^2 -4*a*c) >= 0 = ( ( (-b) + sqrt(b^2 - 4*a*c) ) / (2*a) , ( (-b) - sqrt(b^2 - 4*a*c) ) / (2*a) ) \n\n\nite :: Bool -> a -> a -> a\nite a x y | a == True = x\n\t\t  | a == False = y\n\n\n-- eager ( ansioso) de adentro hacia afuera (Estricto)\n\n-- lazy (peresoso) va de afuera hacia adentro (No estricto)\n\n\n\n", "input": "42", "status": "success", "output": "84"}
{"code": "-- Credit Card Validator\n-- Exercise-1\n\ntoDigits :: Integer -> [Integer]\ntoDigits n\n  | n <= 0 = []\n  | otherwise = toDigits (quot n 10) ++ [(mod n 10)]\n\ntoDigitsRev :: Integer -> [Integer]\ntoDigitsRev n = reverse (toDigits n)\n    \n-- Exercise-2\n\ndoubleEveryOther :: [Integer] -> [Integer]\ndoubleEveryOther [] = []\ndoubleEveryOther [x] = [x]\ndoubleEveryOther zs = doubleEveryOther (init . init $ zs) ++ [(*2) . last .init $ zs, last zs]\n\n-- Exercise-3\n\nsumDigits :: [Integer] -> Integer\nsumDigits [] = 0\nsumDigits (x:xs) = (sum (toDigits x)) + (sumDigits xs)\n\n-- Exercise-4\n\nvalidate :: Integer -> Bool\nvalidate n = (mod (sumDigits (doubleEveryOther (toDigits n))) 10) == 0\n\n-- Exercise-5\n\n-- Towers of Hanoi Problem\n\ntype Peg = String\ntype Move = (Peg, Peg)\n\nhanoi :: Integer -> Peg -> Peg -> Peg -> [Move]\nhanoi 1 first last temp = [(first,last)]\nhanoi n first last temp = (hanoi (n-1) first temp last) ++ (hanoi 1 first last temp) ++ (hanoi (n-1) temp last first)\n", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "-- Thinking Functionally with Haskell\n-- Example 1.3 (High Frequency Words)\n-- \nimport Data.List\nimport Data.Char\n\n-- sortWords is a special case for sort\nsortWords :: [String] -> [String]\nsortWords = sort\n\ncomparePair :: (Int, String) -> (Int, String) -> Ordering\ncomparePair (x, _) (y, _) \n    | x > y = LT\n    | x==y = EQ\n    | otherwise = GT\n\n-- sortRuns\nsortRuns :: [(Int, String)] -> [(Int, String)]\nsortRuns = sortBy comparePair\n\n-- countRuns \ncountRuns :: [String] -> [(Int, String)]\ncountRuns [] = []\ncountRuns [x] = [(1, x)]\ncountRuns (x:xs)\n    | x == item = (count+1,item):rems\n    | otherwise = (1, x):items\n    where items@((count, item):rems) = countRuns xs\n\n-- showRun export a (Int, String) pair into a string\nshowRun :: (Int, String) -> String\nshowRun (x, y) = show x ++ \": \" ++ show y ++ \"\\n\"\n\ncommonWords :: Int -> String -> String\ncommonWords n = concat . map showRun . take n . sortRuns . countRuns . \n                sortWords . words . map toLower", "input": "[\"hello\", \"hello\"]", "status": "success", "output": "[\"hello\",\"hello\"]"}
{"code": "-- Functions from http://learnyouahaskell.com/types-and-typeclasses\n\n-- Giving explicit type declaration\nremoveNonUppercase :: [Char] -> [Char]  \nremoveNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]\n-- It maps from a string to a string (a string is a list of Characters)\n\n-- Parameters are separated with -> and are not differentiated \n-- from the return type\naddThree :: Int -> Int -> Int -> Int  \naddThree x y z = x + y + z\n\n\n\n-- Integer is the same type as Int but larger\n-- (and less efficient)\nfactorial :: Integer -> Integer  \nfactorial n = product [1..n]\n\n-- [1..0] is [] and product [] is 0 by definition\n\n\n-- Float is a real floating point with single precision.\ncircumference :: Float -> Float  \ncircumference r = 2 * pi * r\n--  ghci> circumference 4.0  \n--  25.132742  \n\n-- Double is a real floating point with double the precision!\ncircumference' :: Double -> Double  \ncircumference' r = 2 * pi * r  \n--  ghci> circumference' 4.0  \n--  25.132741228718345  \n\n", "input": "['a', 'a']", "status": "success", "output": "\"\""}
{"code": "-- If we list all the natural numbers below 10 that are multiples of 3 or 5,\n-- we get 3, 5, 6 and 9. The sum of these multiples is 23\n-- ------------------------------------------------------------------------\n-- Find the sum of all the multiples of 3 or 5 below 1000\n\nfindN large small = quot large small\n\nnoOfThrees = findN 999 3\nnoOfFives = findN 999 5\nnoOfFifteens = findN 999 15\n\nsumOfFirstN n = (n * (n + 1)) / 2\n\nmultiplyThree n = n * 3\nmultiplyFive n = n * 5\nmultiplyFifteens n = n * 15\n\naggregate :: [Int] -> Int\naggregate = foldr (+) 0\n\n-- Implement sigma operation\nsigma lowerBound upperBound func = aggregate(map func [lowerBound .. upperBound])\n\nfindSumOfMultiplesOfThree = sigma 1 noOfThrees multiplyThree\nfindSumOfMultiplesOfFive = sigma 1 noOfFives multiplyFive\nfindSumOfMultiplesOfFifteens = sigma 1 noOfFifteens multiplyFifteens\n\n-- http://math.stackexchange.com/a/9305\nans = findSumOfMultiplesOfThree + findSumOfMultiplesOfFive - findSumOfMultiplesOfFifteens\n", "input": "[42, 42]", "status": "success", "output": "84"}
{"code": "-- Here we take `foldl` as example, and check the memory usage\n\n-- > foldl (+) 0 [1..1000000]\n-- > 500000500000\n-- > (1.12 secs, 161,338,640 bytes)\n\n-- > foldr (+) 0 [1..1000000]\n-- > 500000500000\n-- > (0.14 secs, 161,632,384 bytes)\n\nimport Data.List\n\n-- mean , sumlen1\n-- sumlen1 is the easist to implement, but with performance issue\nsumlen1 xs = (sum xs, length xs)\n\n-- sumlen2\nsumlen2 [] = (0, 0)\nsumlen2 xs = foldr f (0,0) xs where f x (s, n) = (s+x, n+1)\n\n-- sumlen3\nsumlen3 [] = (0, 0)\nsumlen3 xs = foldl' g (0,0) xs where g (s, n) x = (s+x, n+1)\n\n-- sumlen4 : O(n) memory\nsumlen4 :: [Float] -> (Float, Int)\nsumlen4 = foldl' g (0,0) where g (s, n) x = s `seq` n `seq` (s+x, n+1)\n\n-- Cartesian product\n-- sum $ map sum $ cp1 [[1..10] | j <- [1..6]]\ncp1 [] = [[]]\ncp1 (xs:xss) = [x:ys | x <- xs, ys <- cp1 xss]\n\n-- cp2, performance better\n-- sum $ map sum $ cp2 [[1..10] | j <- [1..6]]\ncp2 :: [[a]] -> [[a]]\ncp2 = foldr op [[]]\n  where op xs yss = [x:ys | x <- xs, ys <- yss]\n", "input": "[3.14, 3.14]", "status": "success", "output": "(6.28,2)"}
{"code": "fac :: Integer -> Integer\nfac 0 = 1\nfac n = n * fac (n - 1)\n\nones = 1 : ones\n\nquicksort :: (a -> a -> Bool) -> [a] -> [a]\nquicksort _ [] = []\nquicksort before (x : xs) = quicksort before [y | y <- xs, before y x]\n\t\t++ [x]\n\t\t++ quicksort before [y | y <- xs, not (before y x)]\n\nevens [] = []\nevens (x:xs) = x : odds xs\nodds [] = []\nodds (x:xs) = evens xs\n\n\nmerge :: (a -> a -> Bool) -> [a] -> [a] -> [a]\nmerge _ x [] = x\nmerge _ [] x = x\nmerge before (x:xs) (y:ys)\n\t| before x y = x : merge before xs (y:ys)\n\t| otherwise = y : merge before (x:xs) ys\n\nmergesort :: (a -> a -> Bool) -> [a] -> [a]\nmergesort _ [] = []\nmergesort _ [x] = [x]\nmergesort before l  = merge before (mergesort before (evens l)) (mergesort before (odds l))\n\nsquare x = x * x\n\nisPrime :: [Integer] -> Integer -> Bool\nisPrime primesSoFar n \n\t| square (head primesSoFar) > n = True\n\t| mod n (head primesSoFar) == 0 = False\n\t| otherwise = isPrime (tail primesSoFar) n\n\nprimes = 2 : [n | n <- [3,5 ..], isPrime primes n] \n\n\n", "input": "42", "status": "success", "output": "1405006117752879898543142606244511569936384000000000"}
{"code": "import Data.Char\n-- ex4\na = [(x,y) | x <- [1,2,3], y <- [4,5,6]]\n\nb = [z | z <- [[(x,y) | y <- [4,5,6]] | x <- [1,2,3]]]\n\nc = concat [[(x,y) | y <- [4,5,6]] | x <- [1,2,3]]\n\n-- ex6\n-- scalarproduct xs ys = sum [x * y | x <- xs, y <- ys] -- wrong\nscalarproduct xs ys = sum [x * y | (x, y) <- zip xs ys ]\n\n-- ex7\n\nlet2int :: Char -> Int\nlet2int c = ord c - ord 'a'\n\nint2let :: Int -> Char\nint2let n = chr (ord 'a' + n)\n\nshift :: Int -> Char -> Char\nshift n c\n        | isLower c = int2let ((let2int c + n) `mod` 26)\n        | isUpper c = toUpper (shift n (toLower c))\n        | otherwise = c\n\nencode :: Int -> String -> String\nencode n xs = [shift n x | x <- xs]\n\nex7 = (encode 13 \"Think like a Fundamentalist Code like a Hacker\")\n\n-- ex8\nex8 = [(x,y) | x <- [1,2], y <- [1,2]]\n\n-- ex9\nex9 = [x| x <- [1,2,3], y <- [1..x]]\n\n-- ex10\nex10 = sum [x | x <- [1..10], even x]\n\n-- ex11\nxs = 1 : [x + 1 | x <- xs]\n\n-- ex12\nriffle xs ys = concat [[x,y] | (x,y) <- zip xs ys]\nex12 = riffle [1, 2, 3] [4, 5, 6]\n", "input": "'a'", "status": "success", "output": "0"}
{"code": "import qualified Data.Char as Char\n\n-- >>> notThe \"the\"\n-- Nothing\n-- >>> notThe \"blahtheblah\"\n-- Just \"blahtheblah\"\n-- >>> notThe \"woot\"\n-- Just \"woot\"\nnotThe :: String -> Maybe String\nnotThe \"the\" = Nothing\nnotThe s = Just s\n\n-- >>> replaceThe \"the cow loves us\"\n-- \"a cow loves us\"\nreplaceThe :: String -> String\nreplaceThe = unwords . go . (map notThe) . words\n  where\n    go [] = []\n    go (Nothing : ws) = \"a\" : go ws\n    go (Just w : ws) = w : go ws\n\nisVowel :: Char -> Bool\nisVowel c = elem (Char.toLower c) \"aeiou\"\n\n-- >>> countTheBeforeVowel \"the cow\"\n-- 0\n-- >>> countTheBeforeVowel \"the evil cow\"\n-- 1\ncountTheBeforeVowel :: String -> Integer\ncountTheBeforeVowel = go . words\n  where\n    go [] = 0\n    go (_ : []) = 0\n    go (\"the\" : ws)\n      | isVowel (head (head ws)) = 1 + go ws\n      | otherwise = go ws\n    go (_ : ws) = go ws\n\n-- >>> countVowels \"the cow\"\n-- 2\n-- >>> countVowels \"Mikolajczak\"\n-- 4\ncountVowels :: String -> Integer\ncountVowels = fromIntegral . length . filter isVowel", "input": "\"hello\"", "status": "success", "output": "Just \"hello\""}
{"code": "import Data.Char\nimport Data.List\n\nsquare :: Int -> Int\nsquare x \n  = x * x\n\npyth :: Int -> Int -> Int\npyth x y \n  = square x + square y\n\nisTriple :: Int -> Int -> Int -> Bool\nisTriple a b c \n  = pyth a b == square c\n\nisTripleAny :: Int -> Int -> Int -> Bool\nisTripleAny a b c \n  = isTriple a b c || isTriple a c b || isTriple b c a\n\nhalfEvens :: [Int] -> [Int]\nhalfEvens xs \n  = map f xs\n  where\n  \tf x | even x    = x `div` 2\n  \t    | otherwise = x\n\ninRange :: Int -> Int -> [Int] -> [Int]\ninRange a b xs \n  = [x | x <- xs,  x >= a, x <= b]\n\ncountPositives :: [Int] -> Int\ncountPositives xs \n  = sum [1 | x <- xs, x > 0]\n\ncapitalised :: String -> String\ncapitalised (x : xs) \n  = toUpper x : [toLower y | y <- xs]\n\nstringLower :: String -> String\nstringLower xs \n  = [toLower x | x <- xs]\n\nassessString :: String -> String\nassessString xs\n  | length xs >= 4 = capitalised xs \n  | otherwise      = stringLower xs\n\ntitle :: [String] -> [String]\ntitle [] \n  = []\ntitle xxs \n  = [assessString xs | xs <- xxs]\n", "input": "42", "status": "success", "output": "1764"}
{"code": "-- Since Steven mostly took his nanoparser from the \"Funcitonal Pearls\" paper,\n--  I'm typing in their parser here. But without the newtype and possibly with \n--  a few other modifications.\n\n-- I'll use this to confirm my derivations and conclusions from CharlieWipNano.hs.\n\n-- All parsers are functions of type String -> [(a, String)], except possibly specialized.\nitem :: String -> [(Char, String)]\nitem = (\\cs -> case cs of \n    \"\"          -> []\n    (c:cs)      -> [(c, cs)])\n\nmyReturn :: a -> (String -> [(a, String)])\nmyReturn a = (\\cs -> [(a, cs)])\n\nmyBind :: (String -> [(a, String)]) -> (a -> (String -> [(b, String)])) -> (String -> [(b, String)])\np `myBind` f = (\\cs -> concat [(f a) cs' |\n    (a, cs') <- p cs])\n\n-- That is all it takes to see the core in action and confirm my findings.\n\nexample1 = item `myBind` \\c -> \n    myReturn c\n\nresult1 = example1 \"bar\" -- CONFIRMED!\n\nexample2 = item `myBind` \\c -> \n    item `myBind` \\d -> \n        myReturn (c, d)\n\nresult2 = example2 \"bar\"  -- CONFIRMED!\n\n\n\n\n\n", "input": "\"hello\"", "status": "success", "output": "[('h',\"ello\")]"}
{"code": "factorial :: Integer -> Integer\nfactorial n = product [1..n]\naddThree :: Int -> Int -> Int -> Int\naddThree x y z = x + y + z\n-- (type constraint) => (type definition)\n-- :t (==) = (Eq a) => a -> a -> Bool -- Eq = same type\n-- :t (>) = (Ord a) => a -> a -> Bool -- Ord = Ordinal type\ncomp1 = \"Abrakadabra\" < \"Zebra\"\ncomp2 = 5 `compare` 3\n-- :t show = show :: Show a => a -> String\nshowEx1 = show 3 -- types that are intsatnces of the show type class are converted to Strings\n-- :t read = read :: Read a => String -> a\n-- note it needs a type so read \"1\" + 1 and read \"1\" :: Int is good but read \"1\" is not because the type can not be figured out\nreadEx1 = read \"[1,2,3,4]\" ++ [5] -- types that are instances of the read type class can be coverted from strings\n-- Instances of boundType have minBound and maxBound\nminInt = minBound :: Int\nmaxChar = maxBound :: Char\ndiffMaxes = maxBound :: (Bool, Int, Char)\n-- Integral type class is an Int or Integer\n-- :t fromIntegral = fromIntegral :: (Integral a, Num b) => a -> b\n", "input": "42", "status": "success", "output": "1405006117752879898543142606244511569936384000000000"}
{"code": "import Data.List\nimport Data.Char\n\npower = 10\n\ndigitList :: Integer -> [Integer]\ndigitList n = toIntList $ show n\n  where\n    toIntList :: [Char] -> [Integer]\n    toIntList (n:ns)\n      | null ns = (toInteger $ digitToInt n):[]\n      | otherwise = (toInteger $ digitToInt n):toIntList ns\n\ndigitSumSeq :: Integer -> [Integer]\ndigitSumSeq n\n  | n < 2 = n:[]\n  | otherwise = n:digitSumSeq (digitSum n)\n\ndigitSum :: Integer -> Integer\ndigitSum ns = foldl1' (\\x y -> x + y^power) $ digitList ns    \n\ncutBrachets :: (Show a, Show b) => [(a,b)] -> String\ncutBrachets (x:xs)\n  | null xs = show (fst x) ++ \" \" ++ show (snd x)\n  | otherwise = show (fst x) ++ \" \" ++ show (snd x) ++ \"\\n\" ++ cutBrachets xs\n\nmultiList :: [Integer] -> [Integer] -> [Integer]\nmultiList xx@(x:xs) yy@(y:ys)\n  | null xx = []\n  | null yy = []\n  | otherwise = x*y : multiList xs ys\n\n--m = 153\n--n = 1000\n\n--main = putStrLn $ cutBrachets $ zip [m..n] $ fmap length $ fmap calcDigitRoot [m..n]\n--main = putStrLn $ cutBrachets $ zip [1..] $ calcDigitRoot m\n", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "-------------------------------------------------------------------------------\n-- Project Euler\n-- Author: Samuel Jackson\n-- Date: 25/09/13\n-- Description: Solutions to problems listed on the project euler website.\n-------------------------------------------------------------------------------\n\n-- Problem 1\n-- Find the sum of all the multiples of a list of terms between 1 and n\nsumMulti :: Int -> Int\t\nsumMulti n = foldl (+) 0 (multiples n)\n\twhere\n\t\tmultiples n = filter (isMultiple) [1..n-1]\n\t\tisMultiple x | x `mod` 3 == 0 = True\n\t\t\t\t\t | x `mod` 5 == 0 = True\n\t\t\t\t\t | otherwise = False\n\n-- More effcient solution\nsumMulti' :: Int -> Int\nsumMulti' n = (sumDivBy 3 n) + (sumDivBy 5 n) - (sumDivBy 15 n)\n\twhere\n\t\tsumDivBy x n = x * ((n `div` x) * ((n `div` x) +1)) `div` 2 \n\n-- Problem 2\n-- Summation of the even valued terms of the fibonacci sequence\n--sumEvenFib :: Int -> Int\nsumEvenFib n = sum (filter (isEven) (takeWhile (<n) fibs))\n\twhere\n\t\tisEven x = x `mod` 2 == 0\n\t\tfibs = 0 : 1 : zipWith (+) fibs (tail fibs)", "input": "42", "status": "success", "output": "408"}
{"code": "-- Exercise 1:\n\ntoDigits :: Integer -> [Integer]\ntoDigits n\n\t| n <= 0    = []\n\t| n <= 9    = [n]\n\t| otherwise = concat [toDigits(div n 10), [mod n 10]] \n\ntoDigitsRev :: Integer -> [Integer]\ntoDigitsRev n = reverseList (toDigits n)\n\nreverseList :: [a] -> [a]\nreverseList [] = []\nreverseList (x:xs) = concat [reverseList(xs), [x]]\n\n-- Exercise 2:\n\ndoubleEveryOther :: [Integer] -> [Integer]\ndoubleEveryOther [] = []\ndoubleEveryOther [n] = [n]\ndoubleEveryOther (n:m:xs) = n:m*2:doubleEveryOther(xs)\n\n-- Exercise 3:\n\nsumDigits :: [Integer] -> Integer\nsumDigits [] = 0\nsumDigits [n] \n\t| n <= 9    = n\n\t| otherwise = sumDigits(toDigits n)  \nsumDigits (x:xs) = sumDigits(toDigits x) + sumDigits xs\n\n-- Exercise 4:\n\nvalidate :: Integer -> Bool\nvalidate n =\n\tsumDigits (doubleEveryOther (toDigits (n))) `mod` 10 == 0\t\n\n-- Towers of Hanoi!\n\n-- Exercise 5:\n\ntype Peg = String\ntype Move = (Peg, Peg)\nhanoi :: Integer -> Peg -> Peg -> Peg -> [Move]\nhanoi 0 _ _ _ = []\nhanoi n a b c = hanoi (n-1) a c b ++ [(a,b)] ++ hanoi (n-1) c b a\n", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "--The following iterative sequence is defined for the set of positive integers:\n\n--n \u2192 n/2 (n is even)\n--n \u2192 3n + 1 (n is odd)\n\n--Using the rule above and starting with 13, we generate the following sequence:\n\n--13 \u2192 40 \u2192 20 \u2192 10 \u2192 5 \u2192 16 \u2192 8 \u2192 4 \u2192 2 \u2192 1\n--It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at 1.\n\n--Which starting number, under one million, produces the longest chain?\n\n--NOTE: Once the chain starts the terms are allowed to go above one million\n\n--Reference: http://notes-on-haskell.blogspot.in/2007/06/solving-collatz-sequences.html\ncollatz :: Int -> Int\ncollatz 1 = 1\ncollatz n = if (odd n)\n              then ((3 * n) + 1)\n              else n `div` 2\n\ncollatzSeries :: Int -> [Int]\ncollatzSeries = terminate . iterate collatz\n                where\n                  terminate (1:_) = [1]\n                  terminate (x:xs) = x:terminate xs\n", "input": "42", "status": "success", "output": "21"}
{"code": "addStuff :: Int -> Int  \naddStuff = do  \n    a <- (*2)  \n    b <- (+10)  \n    return (a+b)  \n\naddStuff1 = (*2) >>= \\a -> (+10) >>= \\b -> return (a+b)\n\n{-\n    (*2) >>= \\a -> (+10) >>= \\b -> return (a+b)\n\n == \\w -> (\\a -> (+10) >>= \\b -> return (a+b)) (w*2) w \n\n == \\w -> ((+10) >>= \\b -> return (w*2+b)) w\n\n == \\w -> (\\w' -> (\\b->return (w*2+b)) (w'+10) w') w\n\n == \\w -> (\\w' -> (return (w*2 +(w'+10))) w') w\n\n == \\w -> (\\w' -> (\\_ -> (w*2+(w'+10))) w') w\n\n == \\w -> (\\w' -> (w*2+ (w'+10)) ) w \n\n == \\w -> (w*2 + (w+10))\n\n-}\n\n{-\n   a <- (*2)\n   return (1+a)\n\n   (*2) >>= \\a -> return (1+a)\n\n== (*2) >>= \\a -> (\\_ -> (1+a))\n\n== \\w -> (\\a -> (\\_ -> (1+a))) (w*2) w\n\n== \\w -> (\\_ -> (1+w*2)) w\n\n== \\w -> 1 + 2*w\n\n-}\n\n-- > addStuff 3\n-- 19\n-- > addStuff1 3\n-- 19\n\n\n{-\n   h >>= f = \\w -> f (h w) w\n\n   f = (\\a -> (+10) >>= \\b -> return (a+b))\n\n   f (h w) = (+10) >>= \\b -> return ((h w) +b)\n \n   (\\w' -> (\\b->return ((h w) + b)) (h' w') ) w\n   (\\w' -> return ((h w) + (h' w')) w' ) w\n   return ((h w) + (h' w)) w  = (h w) + (h' w)\n\n-}\n", "input": "42", "status": "success", "output": "136"}
{"code": "toDigitsRev :: Integer -> [Integer]\ntoDigitsRev n | n <= 0 = []\ntoDigitsRev n =\n    remainder : toDigitsRev quotient \n    where\n      remainder = mod n 10 \n      quotient = fromIntegral (div n 10) \n\ntoDigits :: Integer -> [Integer]\ntoDigits = reverse . toDigitsRev\n\ndoubleEveryOtherLeft :: [Integer] -> [Integer]\ndoubleEveryOtherLeft (x:y:xs) = x : y * 2 : doubleEveryOtherLeft xs\ndoubleEveryOtherLeft a = a\n\ndoubleEveryOther :: [Integer] -> [Integer]\ndoubleEveryOther = reverse . doubleEveryOtherLeft . reverse\n\nsumDigits :: [Integer] -> Integer\nsumDigits [] = 0\nsumDigits (x:xs) =\n    firstDigit + lastDigit + sumDigits xs\n    where\n      firstDigit = if div x 10 == 0 then 0 else div x 10 \n      lastDigit = if mod x 10 == x then x else mod x 10\n\nvalidate :: Integer -> Bool\nvalidate = (== 0) . (\\x -> mod x 10) . sumDigits . doubleEveryOther . toDigits\n\ntype Peg = String\ntype Move = (Peg, Peg)\nhanoi :: Integer -> Peg -> Peg -> Peg -> [Move]\nhanoi 0 _ _ _ = []\nhanoi n a b c = hanoi (n-1) a c b ++ [(a,b)] ++ hanoi (n-1) c b a\n", "input": "42", "status": "success", "output": "[2,4]"}
{"code": "-- Problem 21\n-- \n-- Let d(n) be defined as the sum of proper divisors of n (numbers less\n-- than n which divide evenly into n).\n-- If d(a) = b and d(b) = a, where a \u2260 b, then a and b are an amicable pair\n-- and each of a and b are called amicable numbers.\n--\n-- For example, the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22,\n-- 44, 55 and 110; therefore d(220) = 284. The proper divisors of 284 are\n-- 1, 2, 4, 71 and 142; so d(284) = 220.\n--\n-- Evaluate the sum of all the amicable numbers under 10000.\n\n                                                           \neuler21 = sum [n | n <- [1..9999], amicable n]\n    where amicable n = n /= n2 && \n            n == (sumProperDivisors) n2\n            where n2 = sumProperDivisors n\n          \n\nsumProperDivisors n \n    | n == 1    = 0\n    | otherwise = (sum factors) - n\n        where factors = concatMap (\\(x,y)-> [x,y]) $ factorPairs n\n     \nfactorPairs :: Int -> [(Int, Int)]\nfactorPairs x = [ (y, x `div` y) | y <- [1..truncate (sqrt (fromIntegral x))], x `mod` y == 0]\n\n", "input": "42", "status": "success", "output": "[(1,42),(2,21),(3,14),(6,7)]"}
{"code": "import Data.Char (isControl, isDigit)\nimport Data.List (groupBy)\n\nhalveEvens :: [Integer] -> [Integer]\nhalveEvens [] = []\nhalveEvens xs = [x `div` 2| x <- xs, (x `mod` 2) == 0]\n\nsafeString :: String -> String\nsafeString [] = []\nsafeString cs = map check cs\n  where\n    check :: Char -> Char\n    check c = if isControl c then '_' else c\n\n\nholes :: [a] -> [[a]]\nholes [] = []\nholes xs = [select i | i <- [1 .. length xs]]\n  where\n    select i = [x | (i', x) <- enumerate, i /= i'] \n    enumerate = zip [1..] xs\n\nlongestText :: Show a => [a] -> a\nlongestText = foldl1 go\n  where\n    go acc x = if length (show x) > length (show acc) then x else acc\n\nadjacents :: [a] -> [(a,a)]\nadjacents xs = zip xs (drop 1 xs)\n\ncommas :: [String] -> String\ncommas [] = []\ncommas xs = foldl1 (\\acc x -> acc ++ \", \" ++ x) xs\n\naddPolynomials :: [[Integer]] -> [Integer]\naddPolynomials  = foldl1 (\\acc x -> zipWith (+) acc x)\n\nsumNumbers :: String -> Integer\nsumNumbers xs = sum [read x | x <- groupBy (\\a b -> (isDigit a) == (isDigit b)) xs, all isDigit x]\n\n", "input": "[42, 42]", "status": "success", "output": "[21,21]"}
{"code": "{-\nRunlength encoding\ni.e. 'aaabbaaa' -> [('a',3), ('b',2), ('a', 3)]\n-}\n\n-- Single function taking strings to lists of tuples of chars and ints\n\n-- ------- FROM 9 -----------\n-- contigHead(\"aaabbbaaa\") -> \"aaa\"\n-- chop(\"aaabbbaaa\") -> \"aaa\", \"bbbaaa\"\n-- first((a, b)) -> a\n-- pack(\"aaabbbaaa\") -> \"aaa\", \"bbb\", \"aaa\"\n\ncontigHead :: [Char] -> [Char]\ncontigHead str\n    | length str == 0 = \"\"\n    | otherwise =\n        if length ts == 0 then [h]\n        else\n            if h == head ts\n            then h : contigHead ts\n            else [h]\n    where h : ts = str\n\nchop :: [Char] -> ([Char], [Char])\nchop str\n    | length str == 0 = (\"\", \"\")\n    | length str == 1 = (str, \"\")\n    | otherwise = (hs, ts)\n    where\n        hs = contigHead str\n        ts = drop (length hs) str\n\npack :: [Char] -> [[Char]]\npack str\n    | length str == 0 = []\n    | otherwise = [hs] ++ pack ts\n    where (hs, ts) = chop str\n\nlenStr :: [Char] -> (Char, Int)\nlenStr str = (head str, length str)\n\nencode :: [Char] -> [(Char, Int)]\nencode str = map lenStr (pack str)\n", "input": "['a', 'a']", "status": "success", "output": "\"aa\""}
{"code": "import Data.Char (digitToInt)\n\n{- only intended for positive numbers -}\ntoDigits :: Int -> [Int]\ntoDigits = map digitToInt . show\n\ntoDigitsRev :: Int -> [Int]\ntoDigitsRev = map digitToInt . reverse . show\n\n{- # double every other value from the right # -}\n-- 1. pattern matching\ndoubleP :: [Int] -> [Int]\ndoubleP [] = []\ndoubleP (x:[]) = [x]\ndoubleP (x:y:xs) = x:(y * 2): (doubleP xs)\n\n-- 2. more expressive with zipWith\ndoubleZ :: [Int] -> [Int]\ndoubleZ = zipWith (*) (cycle [1, 2])\n\n{- # Another way for doubleZ\n - doubleZ = zipWith ($) (cycle [id, (*2)]) #\n - Found this particular method on StackOverflow -}\n\n{- # very ineficient way # -}\ndoubleCard :: [Int] -> [Int]\ndoubleCard = reverse . doubleZ . reverse\n\nsumDigits :: [Int] -> Int\nsumDigits = foldl1 (+) . concat . map toDigits\n\nvalidate :: Int -> Bool\nvalidate n = mod (sumDigits . doubleCard $ toDigits n) 10 == 0\n\n\n{- links to challenge: https://www.seas.upenn.edu/~cis194/spring13/hw/01-intro.pdf\n - Blogpost about it : https://mohamedhayibor.github.io/blog/post/Credit-Card-Numbers\n -}", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "{-# OPTIONS_GHC -Wall #-}\n\n-- Exercise 1\ntoDigits :: Integer -> [Integer]\ntoDigits n\n  | n <= 0 = []\n  | otherwise = toDigits (n `div` 10) ++ ((n `mod` 10) : [])\n\ntoDigitsRev :: Integer -> [Integer]\ntoDigitsRev n = reverse (toDigits n)\n\n-- Exercise 2\ndoubleEveryOtherAux :: [Integer] -> [Integer]\ndoubleEveryOtherAux [] = []\ndoubleEveryOtherAux (x : []) = x : []\ndoubleEveryOtherAux (x : y : zs) = x : y * 2 : (doubleEveryOtherAux zs)\n\ndoubleEveryOther :: [Integer] -> [Integer]\ndoubleEveryOther l = reverse (doubleEveryOtherAux (reverse l))\n\n-- Exercise 3\nsumDigits :: [Integer] -> Integer\nsumDigits [] = 0\nsumDigits (x : ys) = sum (toDigits x) + (sumDigits ys)\n\n-- Exercise 4\nvalidate :: Integer -> Bool\nvalidate n = sumDigits (doubleEveryOther (toDigits n)) `mod` 10 == 0\n\n-- Exercise 5\ntype Peg = String\ntype Move = (Peg, Peg)\nhanoi :: Integer -> Peg -> Peg -> Peg -> [Move]\nhanoi 0 _ _ _ = []\nhanoi n a b c = (hanoi (n - 1) a c b) ++ ((a, b) : []) ++ (hanoi (n - 1) c b a)\n\n-- Exercise 6\n-- hanoi4 :: Integer -> Peg -> Peg -> Peg -> Peg -> [Move]\n", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "data Cow = Cow\n  { name   :: String\n  , age    :: Int\n  , weight :: Int\n  } deriving (Eq, Show)\n\nnoEmpty :: String -> Maybe String\nnoEmpty \"\" = Nothing\nnoEmpty str = Just str\n\nnoNegative :: Int -> Maybe Int\nnoNegative n | n >= 0    = Just n\n             | otherwise = Nothing\n\nweightCheck :: Cow -> Maybe Cow\nweightCheck c =\n    let w = weight c\n        n = name c\n    in  if n == \"Bess\" && w > 499\n        then Nothing\n        else Just c\n\nmkSphericalCow :: String -> Int -> Int -> Maybe Cow\nmkSphericalCow name' age' weight' =\n    case noEmpty name' of\n      Nothing -> Nothing\n      Just nammy ->\n        case noNegative age' of\n          Nothing -> Nothing\n          Just agey ->\n            case noNegative weight' of\n              Nothing -> Nothing\n              Just weighty ->\n                weightCheck (Cow nammy agey weighty)\n\nmkSphericalCow' :: String -> Int -> Int -> Maybe Cow\nmkSphericalCow' name' age' weight' = do\n    nammy <- noEmpty name'\n    agey <- noNegative age'\n    weighty <- noNegative weight'\n    weightCheck (Cow nammy agey weighty)\n\n\n", "input": "\"hello\"", "status": "success", "output": "Just \"hello\""}
{"code": "-- STILL WORKING\n\n--findNb :: Integer -> Integer\n--findNb m =\n--  case squareRoot m of\n--    Nothing -> -1\n--    Just k ->\n--      case rectangleRoot $ 2 * k of\n--        Nothing -> -1\n--        Just n -> n\n\n--squareRoot :: Integer -> Maybe Integer\n--squareRoot 0 = Just 0\n--squareRoot n =\n--  if y == n\n--    then Just x\n--    else Nothing\n--  where\n--    (_, (x, y) : _) = break (\\(x, y) -> y >= n) squares\n--    squares = [(k, k^2) | k <- [1..]]\n\n--rectangleRoot :: Integer -> Maybe Integer\n--rectangleRoot 0 = Just 0\n--rectangleRoot n =\n--  if y == n\n--    then Just x\n--    else Nothing\n--  where\n--    (_, (x, y) : _) = break (\\(x, y) -> y >= n) rectangles\n--    rectangles = [(k, k * (k + 1)) | k <- [1..]]\n\nimport Control.DeepSeq\n\nfindNb :: Integer -> Integer\nfindNb m = helper 0\n  where\n    helper k = k `deepseq`\n      let\n        s0 = id $! (k * (k + 1)) ^ 2\n        s1 = id $! 4 * m\n      in\n        if (s0 == s1) `deepseq` (s0 == s1)\n        then k\n        else\n          if (s0 > s1) `deepseq` (s0 > s1)\n          then -1\n          else helper (k + 1)\n", "input": "42", "status": "success", "output": "-1"}
{"code": "{-\nProblem 44\n\nPentagonal numbers are generated by the formula, \n    Pn=n(3n\u22121)/2. The first ten pentagonal numbers are:\n\n    1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...\n\nIt can be seen that P4 + P7 = 22 + 70 = 92 = P8. \nHowever, their difference, 70 \u2212 22 = 48, is not pentagonal.\n\nFind the pair of pentagonal numbers, Pj and Pk, \nfor which their sum and difference are pentagonal \nand D = |Pk \u2212 Pj| is minimised; what is the value of D?\n-}\n\nimport Data.List\nimport Data.Maybe\n\neuler44 = a - b\n        where (a,b) = fromJust $ find (\\(a,b) -> \n                differencePentagonal a b && sumPentagonal a b)\n                [(pentagonal a, pentagonal b) | a <- [1..], b <- [1..a]]\n\nsumPentagonal a b = isPentagonal (a + b)\n\ndifferencePentagonal a b = isPentagonal (a - b)\n\npentagonal :: Int -> Int\npentagonal n = (n * (3 * n - 1)) `div` 2\n\nisPentagonal :: Int -> Bool\nisPentagonal p = \n    n == (fromIntegral .truncate) n \n    where n = (sqrt ((24 * (fromIntegral p)) + 1) + 1.0) / 6.0\n\npentagonalGen :: [Int]\npentagonalGen = map (\\n -> (n * (3 * n - 1)) `div` 2) [1..]\n", "input": "42", "status": "success", "output": "2625"}
{"code": "-- Joe Loser\n-- CS4450 HW1\n-- 10/4/14\n\n-- 1. Factorial\nfact :: Int  -> Int\nfact n \n  | (n <= 0) = 1\n  | otherwise = product [1..n]\n\n-- 2. nth number in Fibonacci sequence \nfib :: Int -> Int\nfib n\n  | n <= 0= 0\n  | n == 1 = 1\n  | n > 1 = fib' 0 1 2 n\n\n-- Tail-recursive helper function.\nfib' :: Int -> Int -> Int -> Int -> Int\nfib' p'' p' i end\n      | i == end = p'' + p'\n      | otherwise = fib' p' (p'' + p') (i + 1) end\n\n-- 3. Accepts two functions f and g and an int\nmunge :: (Int->Int) -> (Int -> Int) -> Int -> Int\nmunge f g x\n  | ((x `mod` 2) == 0) = f x\n  | otherwise = g x\n\n-- 4. Determine whether monotonically increasing over [a, b]\nmono :: (Int->Int) -> Int -> Int -> Bool\nmono f a b \n  | (b <= a)  = True\n  | f a > f(a + 1) = False\n  | otherwise = mono f (a + 1) (b)\n\n-- 5.\nrunAgain :: Int -> (a -> a) -> (a -> a)\nrunAgain n f\n  | n <= 0 = id \n  -- could also user iterate\n  | otherwise = foldr (.) id (replicate n f)\n\n-- 6. Use stutter to call runAgain and print a string n times\nstutter :: Int -> String -> String\nstutter n words = runAgain n (++ words) words\n", "input": "42", "status": "success", "output": "7538058755741581312"}
{"code": "-- Solutions for Homework #1 from the CIS 194 - Haskell course\n-- http://www.seas.upenn.edu/%7Ecis194/spring13/lectures\n--\n-- Description:\n-- http://www.seas.upenn.edu/%7Ecis194/spring13/hw/01-intro.pdf\n--\n-- Author: Tamas Gal\n\n\n-- Create a list from each digit of an Int\ntoDigits x = reverse (toDigitsRev x)\n\ntoDigitsRev :: Integer -> [Integer]\ntoDigitsRev x \n  | x <= 0    = []\n  | otherwise = (x `mod` 10) : toDigitsRev (x `div` 10)\n\n\n-- Double the value of every second digit\ndoubleEveryOther :: [Integer] -> [Integer]\ndoubleEveryOther [] = []\ndoubleEveryOther (x:[]) = [2*x]\ndoubleEveryOther (x:y:zs) = x : 2*y : doubleEveryOther zs\n\n\n-- Add the digits of an Int\ndigitSum :: Integer -> Integer\ndigitSum x\n  | x < 10    = x\n  | otherwise = (x `mod` 10) + digitSum (x `div` 10)\n\n\n-- Return the sum of digits for all integers in a list\nsumDigits :: [Integer] -> Integer\nsumDigits [x] = digitSum x\nsumDigits (x:xs) = digitSum x + sumDigits xs\n\n\n-- Validate credit card number\nvalidate :: Integer -> Bool\nvalidate x = sumDigits (doubleEveryOther (toDigitsRev x)) `mod` 10 == 0\n", "input": "42", "status": "success", "output": "[2,4]"}
{"code": "firstOne :: [Int] -> Maybe Integer\nfirstOne x = trackIndex x 0\n\ntrackIndex :: [Int] -> Integer -> Maybe Integer\ntrackIndex [] _ = Nothing\ntrackIndex (x:xs) index\n                    | x == 1 = Just index\n                    | otherwise = trackIndex xs (index + 1)\n\nfindChanges :: [Int] -> [Integer]\nfindChanges [] = []\nfindChanges (x:xs) = reverse $ findChangesAcc xs x 1 []\n\nfindChangesAcc :: [Int] -> Int -> Integer -> [Integer] -> [Integer]\nfindChangesAcc [] _ _ acc = acc\nfindChangesAcc (y:ys) x index acc\n                    | x == y = findChangesAcc ys y (index + 1) acc\n                    | otherwise = findChangesAcc ys y (index + 1) (index:acc)\n\ncombineTwo :: Maybe Integer -> [Integer] -> [Integer]\ncombineTwo Nothing xs = xs\ncombineTwo (Just x) [] = [x]\ncombineTwo (Just x) (y:ys)\n                    | x == y = y:ys\n                    | otherwise = x:(y:ys)\n\ngetRLE :: [Int] -> ([Integer], Integer)\ngetRLE xs = (combineTwo firstone changes, toInteger $ length xs)\n            where\n                firstone = firstOne xs\n                changes  = findChanges xs\n", "input": "[42, 42]", "status": "success", "output": "Nothing"}
{"code": "import Data.List\n\nlongest_non_repeat str = let sequences n xs = filter ((==n) . length) $ takeWhile (not . null) $ map (take n) $ iterate (drop 1) xs                             \n                             allSequences = map (\\n -> sequences n str) [1..(length str)]                             \n                             nonRepeats = filter (not . null) $ map (\\xs -> filter (\\x -> x == nub x) xs) allSequences\n                             longest xs = head $ filter (\\x -> length x == (maximum $ map length xs)) xs\n                             longestStr = longest $ map longest nonRepeats\n                         in longestStr\n\n\nlongest_non_repeat2 :: [Char] -> [Char]\nlongest_non_repeat2 str = let next string char = if char `elem` string then [char] else string ++ [char]\n                              longest new prev = if length new > length prev then new else prev\n                              select (new, prev) = longest new prev\n                              f (new,prev) char = (next new char, longest new prev)\n                          in select $ foldl f (\"\", \"\") str\n", "input": "['a', 'a']", "status": "success", "output": "\"a\""}
{"code": "to_tens :: Integer -> [Integer]\r\nto_tens 0 = []\r\nto_tens n = to_tens (n `div` 10) ++ [n `mod` 10] \r\n\r\nisPrime :: Integer -> Bool\r\nisPrime 1 = False\r\nisPrime k\r\n\t\t| k <= 0 = False \r\n\t\t|otherwise = null [ x | x <- [2..(truncate $ sqrt $ fromIntegral k)], k `mod` x  == 0]\r\n\r\n\r\nfrom_tens xs = sum $ map (\\(a,b) -> 10^a * b) $ zip [0..] $ reverse xs\r\n\r\n\r\ntruncate_left' xs 0 = xs\r\ntruncate_left' (x:[]) _ = []\r\ntruncate_left' (x:xs) 1 = xs\r\ntruncate_left' (x:xs) n = (truncate_left' (xs) (n-1))\r\ntruncate_left num n = from_tens $ truncate_left' (to_tens num) n\r\n\r\n\r\ntruncate_right num n = \tlet xs = to_tens num\r\n\t\t\t\t\t\tin from_tens $ reverse $ truncate_left' (reverse xs) n \r\n\r\n\r\n\r\nis_truncatable_prime 2 = False\r\nis_truncatable_prime 3 = False\r\nis_truncatable_prime 5 = False\r\nis_truncatable_prime 7 = False\r\nis_truncatable_prime n = \tlet \r\n\t\t\t\t\t\t\t\tl = length $ to_tens n\r\n\t\t\t\t\t\t\tin\r\n\t\t\t\t\t\t\tand $ map isPrime $ map (truncate_left n) [0..(l-1)] ++ map (truncate_right n) [0..(l-1)]\r\n\r\n-- ++ ((truncate_left n) [0..(l-1)]))\r\n\r\n\r\nans = filter is_truncatable_prime [x| x <- [11,13..739397], isPrime x]", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "type Bit = Int\nint2bin :: Int -> [Bit]\n\nint2bin 0 = []\nint2bin n = n `mod` 2 : int2bin (n `div` 2)\n\n-- unfold generate a list using predicate, head func, tail func and x seed\nunfold p h t x\n  | p x = []\n  | otherwise = h x : unfold p h t (t x)\n\n-- unfold if predicate p is true, returns empty list\n-- otherwise it generates list of which\n--   head is generated applying h function on seed x\n--   tail is generated by applying t function on seed x and that is passed recursively to unfold\n\nint2bin' :: Int -> [Bit]\nint2bin' = unfold (==0) (`mod` 2) (`div` 2)\n\nchop8 :: [Bit] -> [[Bit]]\nchop8 [] = []\nchop8 bits = take 8 bits : chop8 (drop 8 bits)\n\n--chop8' :: [Bit] -> [[Bit]]\n--chop8' [] = []\n--chop8' = unfold null (take 8) (drop 8)\n\n-- implement map (a -> b) -> [a] -> [b] using unfold\nmap' f = unfold null (f . head) tail\n\n-- iterate is a function that takes a function and starting value. Then it applies the function to the starting value, then it applies the same function to the last result, and so on.\n-- implement iterate\niterate' :: (a -> a) -> a -> [a]\niterate' f = unfold (const False) id f\n", "input": "42", "status": "success", "output": "[0,1,0,1,0,1]"}
{"code": "-- tip: 135 div 10 = 10\n-- tip: 135 mod 10 = 5\n\n-- toDigits 1234 == [1,2,3,4]\ntoDigits::Integer -> [Integer]\ntoDigits n\n  | n < 0 = []\n  | n == 0 = []\n  | otherwise = toDigits (div n 10) ++ [mod n 10]\n\n-- toDigits 1234 == [4,3,2,1]\ntoDigitsRev::Integer -> [Integer]\ntoDigitsRev n\n  | n < 0 = []\n  | n == 0 = []\n  | otherwise = mod n 10: toDigits (div n 10)\n\n-- for this exercice\n-- we should reverse the input, then reverse the output\n-- reverse(doubleEveryOther (reverse([8,7,6,5])))\n-- doubleEveryOther [8,7,6,5] == [16,7,12]\n-- doubleEveryOther [1,2,3] == [1,4,3]\ndoubleEveryOther::[Integer] -> [Integer]\ndoubleEveryOther (x:y:z) = x : (2*y) : doubleEveryOther z\ndoubleEveryOther x = x\n\n\n-- sumDigits [16,7,12,5] = 1 + 6 + 7 + 1 + 2 + 5 = 22\nsumDigits::[Integer] -> Integer\nsumDigits [] = 0\nsumDigits (x:y) = x `div` 10 + x `mod` 10 + (head y) `div` 10 + (head y) `mod` 10 + sumDigits (tail y)\n\n-- validate 4012888888881881 = True\n-- validate 4012888888881882 = False\nvalidate::Integer -> Bool\nvalidate n\n  | sumDigits(reverse(doubleEveryOther(toDigitsRev(n)))) `mod` 10 == 0 = True\n  | otherwise = False\n", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "\nfoo :: Int -> Int\nfoo i = i*2\n\nfn = map foo\n\napplyTwice :: (a -> a) -> a -> a\napplyTwice f x = f (f x)\n\nmax' x y\n    | x > y = x\n    | otherwise = y\n\ncompare' :: (Ord a) => a -> a -> Ordering\ncompare' x y\n    | x > y = GT\n    | x < y = LT\n    | otherwise = EQ\n\ndescList x = case x of [] -> \"Empty List\"\n                       (_:[]) -> \"With one element\"\n                       xs -> \"with more than one element\"\n\ndescList' x = xs x\n    where xs [] = \"Empty List\"\n          xs [x] = \"With one element\"\n          xs x = \"with more than one element\"\n\ndescList'' [] = \"Empty List\"\ndescList'' [x] = \"With one element\"\ndescList'' x = \"With more than one element\"\n\nmaximum' :: (Ord a) => [a] -> a\nmaximum' [] = error \"What's wrong with you, it's an empty array\"\nmaximum' [x] = x\nmaximum' (x: xs)\n    | x > maximum' xs = x\n    | otherwise = maximum' xs\n\n\ntake' :: (Ord a, Num a) => a -> [b] -> [b]\ntake' n _ | n <= 0 = []\ntake' _ [] = []\ntake' n (x:xs) = x:take' (n-1) xs\n\n\nfilter' :: (a -> Bool) -> [a] -> [a]\nfilter' _ [] = []\nfilter' f (x:xs)\n    | f x = x : remaining\n    | otherwise = remaining\n    where remaining = filter' f xs\n", "input": "42", "status": "success", "output": "84"}
{"code": "isRight :: (Integer, Integer, Integer) -> Bool\nisRight (a, b, c)\n   | (a ^ 2) + (b ^ 2) == (c ^ 2) = True\n   | otherwise                    = False\n\nperimeter :: (Integer, Integer, Integer) -> Integer\nperimeter (a, b, c) = a + b + c\n\nallRightTrianglesSmallerThan11 = [(a, b, c) | c <- [1..10], b <- [1..c], a <- [1..b], isRight (a,b,c)]\nallRightTrianglesSmallerThan11AndPerimeter24 = [(a, b, c) | (a, b, c) <- allRightTrianglesSmallerThan11, perimeter (a,b,c) == 24]\n\nsurfaceArea r h =\n   let sideArea = 2 * pi * r * h\n       topArea  = pi * r^2\n   in sideArea + 2 * topArea \n\nelem' :: (Eq a) => a -> [a] -> Bool\nelem' a [] = False\nelem' a (x:xs) \n   | a == x    = True\n   | otherwise = elem' a xs\n\nquicksort :: (Ord a) => [a] -> [a]\nquicksort [] = []\nquicksort (x:xs) =\n   let smallerElems = [a | a <- xs, a <= x]\n       largerElems  = [a | a <- xs, a > x]\n   in quicksort smallerElems ++ [x] ++ quicksort largerElems\n\nquicksort' :: (Ord a) => [a] -> [a]\nquicksort' [] = []\nquicksort' (x:xs) = \n  let smallerElems = quicksort (filter (<= x) xs)\n      largerElems  = quicksort (filter (> x) xs)\n  in smallerElems ++ [x] ++ largerElems", "input": "(42, 42, 42)", "status": "success", "output": "False"}
{"code": "n = a `div` length xs\n    where a = 10\n          xs = [1, 2, 3, 4, 5]\n\n\nmproduct :: [Int] -> Int\nmproduct []     = 1\nmproduct (x:xs) = x * mproduct xs\n\nqsort :: Ord a => [a] -> [a]\nqsort []     = []\nqsort (x:xs) = qsort smaller ++ [x] ++ qsort larger\n    where smaller = [y | y <- xs, y < x]\n          larger  = [z | z <- xs, z > x]\n\nrsort :: Ord a => [a] -> [a]\nrsort []     = []\nrsort (x:xs) = rsort larger ++ [x] ++ rsort smaller\n    where smaller = [y | y <- xs, y <= x]\n          larger  = [z | z <- xs, z >  x]\n\nrqsort :: Ord a => [a] -> [a]\nrqsort []     = []\nrqsort (x:xs) = reverse (rqsort smaller ++ [x] ++ rqsort larger)\n    where smaller = [y | y <- xs, y <= x]\n          larger  = [z | z <- xs, z >  x]\n\nrrsort :: Ord a => [a] -> [a]\nrrsort []     = []\nrrsort (x:xs) = reverse (reverse (rrsort smaller) ++ [x] ++ reverse (rrsort larger))\n    where smaller = [y | y <- xs, y <= x]\n          larger  = [z | z <- xs, z >  x]\n\nmsort :: Ord a => [a] -> [a]\nmsort []     = []\nmsort xs = msort larger ++ msort smaller ++ [x]\n    where x       = minimum xs\n          smaller = [y | y <- xs, y <= x]\n          larger  = [z | z <- xs, z >  x]", "input": "[42, 42]", "status": "success", "output": "1764"}
{"code": "{-# OPTIONS_GHC -Wall #-}\n\n-- converts Integer to list of digits\ntoDigits :: Integer -> [Integer]\ntoDigits = reverse . toDigitsRev\n\n-- converts Integer to list of digits in reverse order\ntoDigitsRev :: Integer -> [Integer]\ntoDigitsRev n\n  | n <= 0    = []\n  | otherwise = digit : toDigitsRev remaining\n      where digit     = mod n 10\n            remaining = div n 10\n\n-- applies a function to an item if the associated boolean is True\nmapIfTrue :: (a -> a) -> [(a, Bool)] -> [a]\nmapIfTrue f xs = map (\\x -> if snd x then f (fst x) else fst x) xs\n\n-- double every other number starting from the right\n-- [8,7,6,5] -> [16,7,12,5], [1,2,3] -> [1,4,3]\ndoubleEveryOther :: [Integer] -> [Integer]\ndoubleEveryOther n = mapIfTrue (*2) $ zip n $ cycle rep\n  where\n    rep = [even len, odd len]\n    len = length n\n\n-- sum of all digits\nsumDigits :: [Integer] -> Integer\nsumDigits = sum . map (sum . toDigits)\n\n-- checks whether Integer is a multiple of 10\nisMultipleOf10 :: Integer -> Bool\nisMultipleOf10 n = mod n 10 == 0\n\n-- validates a credit card number\nvalidate :: Integer -> Bool\nvalidate = isMultipleOf10 . sumDigits . doubleEveryOther . toDigits\n", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "-- ex\n\n{-\nimport Control.Monad\n\nnewtype Maybe' a = Maybe' (Maybe a)\n\ninstance Monad Maybe' where\n  return x = Maybe' (Just x)\n  m >>= f = case m of\n              Maybe' Nothing -> Maybe' Nothing\n              Maybe' (Just x) -> f x\n-}\n\nnumberItemsByPurchaseId :: Integer -> Maybe Integer\nnumberItemsByPurchaseId _ = return 2\n\nproductIdByPurchaseId :: Integer -> Maybe Integer\nproductIdByPurchaseId _ = return 39283\n\npriceByProductId :: Integer -> Maybe Double\npriceByProductId _ = return 29394.2\n\nthenDo :: Maybe a -> (a -> Maybe b) -> Maybe b\nthenDo Nothing _ = Nothing\nthenDo (Just x) f = f x\n\npurchaseValue' :: Integer -> Maybe Double\npurchaseValue' purchaseId =\n  numberItemsByPurchaseId purchaseId `thenDo` (\\n ->\n    productIdByPurchaseId purchaseId `thenDo` (\\productId ->\n      priceByProductId productId     `thenDo` (\\price ->\n        Just $ (fromInteger n) * price)))\n\npurchaseValue :: Integer -> Maybe Double\npurchaseValue purchaseId =\n  numberItemsByPurchaseId purchaseId >>= (\\n ->\n    productIdByPurchaseId purchaseId >>= (\\productId ->\n      priceByProductId productId     >>= (\\price ->\n        Just $ (fromInteger n) * price)))", "input": "42", "status": "success", "output": "Just 2"}
{"code": "doubleMe x=x+x\n\ndoubleUs x y = doubleMe x+doubleMe y\n\ndobleNumerosPeque\u00f1os x= if x<100 then x else x*2\n\ntama\u00f1o xs=sum[1|_<-xs]\n\nfactorial::Int->Int\nfactorial 0=1\nfactorial n=n*factorial(n-1)\n\ntama\u00f1oRecursivo :: [Int]->Int\ntama\u00f1oRecursivo []=0\ntama\u00f1oRecursivo(_:xs)=1+tama\u00f1oRecursivo xs\n\nsumaRecursiva::[Int]->Int\nsumaRecursiva[]=0\nsumaRecursiva(x:xs)=x+sumaRecursiva xs\n\nfibo::Int->Int\nfibo 0=0\nfibo 1=1\nfibo n=n+fibo(n-1)\n\nmaximoLista::[Int]->Int\nmaximoLista []=error\"Error Lista Vacia\"\nmaximoLista[x]=x\nmaximoLista (x:xs)\n            | x>maxTail=x\n            |otherwise=maxTail\n            where maxTail=maximoLista xs\n\nreplicar::Int->Int->[Int]\nreplicar n x\n        |n<=0 = []\n        |otherwise =x:replicar(n-1) x\n\ntomar::Int->[Int]->[Int]\ntomar n _\n      |n<=0 =[]\ntomar n []=[]\ntomar n (x:xs)= x :tomar (n-1) xs\n\nreversa:: [Int]->[Int]\nreversa []=[]\nreversa (x:xs)=reversa xs ++ [x]\n\ndescomposicion::Int->[Int]\ndescomposicion n = if n < 10 then [n]\n                else descomposicion(div n 10) ++ [mod n 10]\n\nsumaDigitos::[Int]->Int\nsumaDigitos[]=0\nsumaDigitos(x:xs)=if mod x 5==0 then x+sumaDigitos xs\n                  else sumaDigitos xs\n", "input": "42", "status": "success", "output": "7538058755741581312"}
{"code": "-- HW 1 solutions for cis198 course\n-- http://www.seas.upenn.edu/~cis194/hw/01-intro.pdf\n\ntoDigits :: Integer -> [Integer]\ntoDigits = toDigits' []\n    where\n       toDigits' acc n\n          | n <= 0      = acc\n          | otherwise   = toDigits' ((mod n 10):acc) (div n 10)\n\ntoDigitsRev :: Integer -> [Integer]\ntoDigitsRev = reverse . toDigits\n\ndoubleEveryOther :: [Integer] -> [Integer]\ndoubleEveryOther = reverse . f . reverse\n    where\n        f (x:y:zs) = x:(2*y):(f zs)\n        f a        = a\n        \nsumDigits :: [Integer] -> Integer\nsumDigits = foldl (\\acc x -> acc + (sum $ toDigits x)) 0\n\nvalidate :: Integer -> Bool\nvalidate a = (mod det 10) == 0\n    where det = sumDigits . doubleEveryOther $ toDigits a\n\n-- Normal function f g h x -> (((f g) h) x)\n-- Want (sumDigits ( doubleEveryOther (toDigits a)))\n-- sumDigits . doubleEveryOther . toDigits a is close\n-- but toDigits a has higher precedence\n\n\ntype Peg = String\ntype Move = (Peg, Peg)\nhanoi :: Integer -> Peg -> Peg -> Peg -> [Move]\nhanoi 0 _ _ _ = []\nhanoi n a b c = first ++ second ++ third\n    where first  = hanoi (n-1) a c b\n          second = [(a,b)]\n          third  = hanoi (n-1) c b a\n", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "import Control.Monad -- MonadPlus\n\n\npairs   :: Int  ->  [(Int,  Int)]\npairs n   = [(i,j) | i <- [1..n], j <- [(i+1)..n]]\n\n-- - Equivalently\npairsWithDo  :: Int  ->  [(Int, Int)]\npairsWithDo n  = do {\n              i <- [1..n];\n              j <- [(i+1)..n];\n              return (i,j)\n            }\n\n-- -- - With Guard\n\npairsGuard   :: Int  ->  [(Int,  Int)]\npairsGuard n   = [(i,j) | i <- [1..n], j <- [1..n], i < j]\n\n-- MonadPlus is a monad with extra structure\n{-\n-- MonadPlus\nclass Monad m => MonadPlus m where\n  mzero :: m a\n  mplus :: m a -> m a -> m a\n\n\ninstance MonadPlus [] where\n  mzero = []\n  mplus = (++)\n\n\nguard :: MonadPlus m => Bool -> m ()\nguard False   = mzero       -- non-deterministic result; 'mzero = [] = no possible result'\nguard True    = return ()   -- 'return () = [()] = one possible result'\n\nmsum :: MonadPlus m => [m a] -> m a\nmsum  = foldr mplus mzero   -- generalization of concat\n-}\n\n-- - Equivalently\npairsWithDoGuard  :: Int  ->  [(Int, Int)]\npairsWithDoGuard n  = do {\n                        i <- [1..n];\n                        j <- [1..n];\n                        guard (i < j);\n                        return (i,j)\n                      }\n", "input": "42", "status": "success", "output": "[(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12),(1,13),(1,14),(1,15),(1,16),(1,17),(1,18),(1,19),(1,20),(1,21),(1,22),(1,23),(1,24),(1,25),(1,26),(1,27),(1,28),(1,29),(1,30),(1,31),(1,32),(1,33),(1,34),(1,35),(1,36),(1,37),(1,38),(1,39),(1,40),(1,41),(1,42),(2,3),(2,4),(2,5),(2,6),(2,7),(2,8),(2,9),(2,10),(2,11),(2,12),(2,13),(2,14),(2,15),(2,16),(2,17),(2,18),(2,19),(2,20),(2,21),(2,22),(2,23),(2,24),(2,25),(2,26),(2,27),(2,28),(2,29),(2,30),(2,31),(2,32),(2,33),(2,34),(2,35),(2,36),(2,37),(2,38),(2,39),(2,40),(2,41),(2,42),(3,4),(3,5),(3,6),(3,7),(3,8),(3,9),(3,10),(3,11),(3,12),(3,13),(3,14),(3,15),(3,16),(3,17),(3,18),(3,19),(3,20),(3,21),(3,22),(3,23),(3,24),(3,25),(3,26),(3,27),(3,28),(3,29),(3,30),(3,31),(3,32),(3,33),(3,34),(3,35),(3,36),(3,37),(3,38),(3,39),(3,40),(3,41),(3,42),(4,5),(4,6),(4,7),(4,8),(4,9),(4,10),(4,11),(4,12),(4,13),(4,14),(4,15),(4,16),(4,17),(4,18),(4,19),(4,20),(4,21),(4,22),(4,23),(4,24),(4,25),(4,26),(4,27),(4,28),(4,29),(4,30),(4,31),(4,32),(4,33),(4,34),(4,35),(4,36),(4,37),(4,38),(4,39),(4,40),(4,41),(4,42),(5,6),(5,7),(5,8),(5,9),(5,10),(5,11),(5,12),(5,13),(5,14),(5,15),(5,16),(5,17),(5,18),(5,19),(5,20),(5,21),(5,22),(5,23),(5,24),(5,25),(5,26),(5,27),(5,28),(5,29),(5,30),(5,31),(5,32),(5,33),(5,34),(5,35),(5,36),(5,37),(5,38),(5,39),(5,40),(5,41),(5,42),(6,7),(6,8),(6,9),(6,10),(6,11),(6,12),(6,13),(6,14),(6,15),(6,16),(6,17),(6,18),(6,19),(6,20),(6,21),(6,22),(6,23),(6,24),(6,25),(6,26),(6,27),(6,28),(6,29),(6,30),(6,31),(6,32),(6,33),(6,34),(6,35),(6,36),(6,37),(6,38),(6,39),(6,40),(6,41),(6,42),(7,8),(7,9),(7,10),(7,11),(7,12),(7,13),(7,14),(7,15),(7,16),(7,17),(7,18),(7,19),(7,20),(7,21),(7,22),(7,23),(7,24),(7,25),(7,26),(7,27),(7,28),(7,29),(7,30),(7,31),(7,32),(7,33),(7,34),(7,35),(7,36),(7,37),(7,38),(7,39),(7,40),(7,41),(7,42),(8,9),(8,10),(8,11),(8,12),(8,13),(8,14),(8,15),(8,16),(8,17),(8,18),(8,19),(8,20),(8,21),(8,22),(8,23),(8,24),(8,25),(8,26),(8,27),(8,28),(8,29),(8,30),(8,31),(8,32),(8,33),(8,34),(8,35),(8,36),(8,37),(8,38),(8,39),(8,40),(8,41),(8,42),(9,10),(9,11),(9,12),(9,13),(9,14),(9,15),(9,16),(9,17),(9,18),(9,19),(9,20),(9,21),(9,22),(9,23),(9,24),(9,25),(9,26),(9,27),(9,28),(9,29),(9,30),(9,31),(9,32),(9,33),(9,34),(9,35),(9,36),(9,37),(9,38),(9,39),(9,40),(9,41),(9,42),(10,11),(10,12),(10,13),(10,14),(10,15),(10,16),(10,17),(10,18),(10,19),(10,20),(10,21),(10,22),(10,23),(10,24),(10,25),(10,26),(10,27),(10,28),(10,29),(10,30),(10,31),(10,32),(10,33),(10,34),(10,35),(10,36),(10,37),(10,38),(10,39),(10,40),(10,41),(10,42),(11,12),(11,13),(11,14),(11,15),(11,16),(11,17),(11,18),(11,19),(11,20),(11,21),(11,22),(11,23),(11,24),(11,25),(11,26),(11,27),(11,28),(11,29),(11,30),(11,31),(11,32),(11,33),(11,34),(11,35),(11,36),(11,37),(11,38),(11,39),(11,40),(11,41),(11,42),(12,13),(12,14),(12,15),(12,16),(12,17),(12,18),(12,19),(12,20),(12,21),(12,22),(12,23),(12,24),(12,25),(12,26),(12,27),(12,28),(12,29),(12,30),(12,31),(12,32),(12,33),(12,34),(12,35),(12,36),(12,37),(12,38),(12,39),(12,40),(12,41),(12,42),(13,14),(13,15),(13,16),(13,17),(13,18),(13,19),(13,20),(13,21),(13,22),(13,23),(13,24),(13,25),(13,26),(13,27),(13,28),(13,29),(13,30),(13,31),(13,32),(13,33),(13,34),(13,35),(13,36),(13,37),(13,38),(13,39),(13,40),(13,41),(13,42),(14,15),(14,16),(14,17),(14,18),(14,19),(14,20),(14,21),(14,22),(14,23),(14,24),(14,25),(14,26),(14,27),(14,28),(14,29),(14,30),(14,31),(14,32),(14,33),(14,34),(14,35),(14,36),(14,37),(14,38),(14,39),(14,40),(14,41),(14,42),(15,16),(15,17),(15,18),(15,19),(15,20),(15,21),(15,22),(15,23),(15,24),(15,25),(15,26),(15,27),(15,28),(15,29),(15,30),(15,31),(15,32),(15,33),(15,34),(15,35),(15,36),(15,37),(15,38),(15,39),(15,40),(15,41),(15,42),(16,17),(16,18),(16,19),(16,20),(16,21),(16,22),(16,23),(16,24),(16,25),(16,26),(16,27),(16,28),(16,29),(16,30),(16,31),(16,32),(16,33),(16,34),(16,35),(16,36),(16,37),(16,38),(16,39),(16,40),(16,41),(16,42),(17,18),(17,19),(17,20),(17,21),(17,22),(17,23),(17,24),(17,25),(17,26),(17,27),(17,28),(17,29),(17,30),(17,31),(17,32),(17,33),(17,34),(17,35),(17,36),(17,37),(17,38),(17,39),(17,40),(17,41),(17,42),(18,19),(18,20),(18,21),(18,22),(18,23),(18,24),(18,25),(18,26),(18,27),(18,28),(18,29),(18,30),(18,31),(18,32),(18,33),(18,34),(18,35),(18,36),(18,37),(18,38),(18,39),(18,40),(18,41),(18,42),(19,20),(19,21),(19,22),(19,23),(19,24),(19,25),(19,26),(19,27),(19,28),(19,29),(19,30),(19,31),(19,32),(19,33),(19,34),(19,35),(19,36),(19,37),(19,38),(19,39),(19,40),(19,41),(19,42),(20,21),(20,22),(20,23),(20,24),(20,25),(20,26),(20,27),(20,28),(20,29),(20,30),(20,31),(20,32),(20,33),(20,34),(20,35),(20,36),(20,37),(20,38),(20,39),(20,40),(20,41),(20,42),(21,22),(21,23),(21,24),(21,25),(21,26),(21,27),(21,28),(21,29),(21,30),(21,31),(21,32),(21,33),(21,34),(21,35),(21,36),(21,37),(21,38),(21,39),(21,40),(21,41),(21,42),(22,23),(22,24),(22,25),(22,26),(22,27),(22,28),(22,29),(22,30),(22,31),(22,32),(22,33),(22,34),(22,35),(22,36),(22,37),(22,38),(22,39),(22,40),(22,41),(22,42),(23,24),(23,25),(23,26),(23,27),(23,28),(23,29),(23,30),(23,31),(23,32),(23,33),(23,34),(23,35),(23,36),(23,37),(23,38),(23,39),(23,40),(23,41),(23,42),(24,25),(24,26),(24,27),(24,28),(24,29),(24,30),(24,31),(24,32),(24,33),(24,34),(24,35),(24,36),(24,37),(24,38),(24,39),(24,40),(24,41),(24,42),(25,26),(25,27),(25,28),(25,29),(25,30),(25,31),(25,32),(25,33),(25,34),(25,35),(25,36),(25,37),(25,38),(25,39),(25,40),(25,41),(25,42),(26,27),(26,28),(26,29),(26,30),(26,31),(26,32),(26,33),(26,34),(26,35),(26,36),(26,37),(26,38),(26,39),(26,40),(26,41),(26,42),(27,28),(27,29),(27,30),(27,31),(27,32),(27,33),(27,34),(27,35),(27,36),(27,37),(27,38),(27,39),(27,40),(27,41),(27,42),(28,29),(28,30),(28,31),(28,32),(28,33),(28,34),(28,35),(28,36),(28,37),(28,38),(28,39),(28,40),(28,41),(28,42),(29,30),(29,31),(29,32),(29,33),(29,34),(29,35),(29,36),(29,37),(29,38),(29,39),(29,40),(29,41),(29,42),(30,31),(30,32),(30,33),(30,34),(30,35),(30,36),(30,37),(30,38),(30,39),(30,40),(30,41),(30,42),(31,32),(31,33),(31,34),(31,35),(31,36),(31,37),(31,38),(31,39),(31,40),(31,41),(31,42),(32,33),(32,34),(32,35),(32,36),(32,37),(32,38),(32,39),(32,40),(32,41),(32,42),(33,34),(33,35),(33,36),(33,37),(33,38),(33,39),(33,40),(33,41),(33,42),(34,35),(34,36),(34,37),(34,38),(34,39),(34,40),(34,41),(34,42),(35,36),(35,37),(35,38),(35,39),(35,40),(35,41),(35,42),(36,37),(36,38),(36,39),(36,40),(36,41),(36,42),(37,38),(37,39),(37,40),(37,41),(37,42),(38,39),(38,40),(38,41),(38,42),(39,40),(39,41),(39,42),(40,41),(40,42),(41,42)]"}
{"code": "lucky :: Int -> String\nlucky 7 = \"Seven\"\nlucky x = \"Sorry, you are out of luck.\"\n\nfactorial :: Int -> Int\nfactorial 0 = 1\nfactorial n = n * factorial (n - 1)\n\naddVectors :: (Double, Double) -> (Double, Double) -> (Double, Double)\naddVectors a b = (fst a + fst b, snd a + snd b)\n\naddVectors2 :: (Double, Double) -> (Double, Double) -> (Double, Double)\naddVectors2 (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)\n\nfirst :: (a, b, c) -> a\nfirst (x, _, _) = x\n\nsecond :: (a, b, c) -> b\nsecond (_, y, _) = y\n\nthird :: (a, b, c) -> c\nthird (_, _, z) = z\n\nxs = [(1,2), (3,4)]\n\nsums = [a+b | (a,b) <- xs]\n\nhead' :: [a] -> a\nhead' [] = error \"Can\u2019t call head on an empty list.\"\nhead' (x:_) = x\n\ntell :: (Show a) => [a] -> String\ntell [] = \"The list is empty\"\ntell (x:[]) = \"The list has one element and it is '\" ++ show x ++ \"'.\"\ntell (x:y:[]) = \"The list has two elements and they are '\" ++ show x ++ \"' and '\" ++ show y ++ \"'.\"\ntell (x:y:_) = \"The list is too long. The first two elements and they are '\" ++ show x ++ \"' and '\" ++ show y ++ \"'.\"\n\nfirstLetter :: String -> String\nfirstLetter \"\" = \"Empty string, whoops!\"\nfirstLetter all@(x:xs) = \"The first letter of \" ++ all ++ \" is \" ++ [x] ++ \".\"", "input": "42", "status": "success", "output": "\"Sorry, you are out of luck.\""}
{"code": "import Data.List\r\n\r\nto_tens :: Integer -> [Integer]\r\nto_tens 0 = []\r\nto_tens n = to_tens (n `div` 10) ++ [n `mod` 10] \r\n\r\n\r\ncancel_like_digits (a,b) = let \t\r\n\t\t\t\t\t\t\t\ttop = to_tens a\r\n\t\t\t\t\t\t\t\tbot = to_tens b\r\n\t\t\t\t\t\t\t\tsame = intersect top bot\r\n\t\t\t\t\t\t\t\tnew_top = top \\\\ same\r\n\t\t\t\t\t\t\t\tnew_bot = bot \\\\ same\r\n\t\t\t\t\t\t\tin \r\n\t\t\t\t\t\t\t\tif length same > 0 && length new_top > 0 && length new_bot > 0\r\n\t\t\t\t\t\t\t\tthen (head new_top, head new_bot)\r\n\t\t\t\t\t\t\t\telse (a,b)\r\n\r\n\r\nnormalize_frac (a,b) = let g = gcd a b in (a `div` g, b `div` g)\r\n\r\nis_frac_equal (a',b') (c',d') = let\r\n\t\t\t\t\t\t\t\t\t(a,b) = normalize_frac (a',b')\r\n\t\t\t\t\t\t\t\t\t(c,d) = normalize_frac (c',d')\r\n\t\t\t\t\t\t\t\tin a==c && b==d \r\n\r\n\r\nis_cancelled_correct (a,b) = \tlet (q,w) = cancel_like_digits (a,b) \r\n\t\t\t\t\t\t\t\tin if (q==a && w == b) \r\n\t\t\t\t\t\t\t\t\tthen False\r\n\t\t\t\t\t\t\t\t\telse is_frac_equal (q,w) (a,b)\r\n\r\n\r\ncombs = [(a,b) | a <- [1..100], b <- [1..100], b > a]\r\n\r\n\r\n\r\ncurious_fracs = filter (\\(a,b) -> (a `mod` 10) /= 0 && (b `mod` 10) /= 0 )  $ filter is_cancelled_correct combs\r\n\r\n\r\nlowest_gryffindor_common_room = map normalize_frac curious_fracs\r\n\r\nans = foldr (\\(a,b) (c,d) -> (a*c,b*d)) (1,1) lowest_gryffindor_common_room\r\n\r\n\r\n-- normalize_frac $ ", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "import Data.Char\n\ntoDigits :: Integer -> [Integer]\ntoDigits x\n    | x <= 0    = []\n    | otherwise = map (toInteger) (map (digitToInt) (show x))\n\ntoDigitsRev :: Integer -> [Integer]\ntoDigitsRev x = reverse (toDigits x)\n\nmapEveryOtherLeft :: (a -> a) -> [a] -> [a]\nmapEveryOtherLeft f []       = []\nmapEveryOtherLeft f [x]      = [f x]\nmapEveryOtherLeft f (x:y:zs) = (f x) : y : mapEveryOtherLeft f zs\n\ndoubleEveryOther :: Num a => [a] -> [a]\ndoubleEveryOther xs = reverse (mapEveryOtherLeft (*2) (reverse xs))\n\nsumDigits :: [Integer] -> Integer\nsumDigits []     = 0\nsumDigits [x]    = sum (toDigits x)\nsumDigits (x:ys) = sum (toDigits x) + sumDigits ys\n\nflatten :: [[a]] -> [a]\nflatten []      = []\nflatten [xs]    = xs\nflatten (xs:ys) = xs ++ flatten ys\n\nsingleDigitList xs = flatten (map (toDigits) xs)\n\nvalidate x = (sumDigits (doubleEveryOther (toDigitsRev x)) `mod` 10) == 0\n\ntype Peg = String\ntype Move = (Peg, Peg)\n\nhanoi :: Integer -> Peg -> Peg -> Peg -> [Move]\nhanoi disks peg1 peg2 peg3\n    | disks <= 1 = [(peg1, peg3)]\n    | otherwise  = (hanoi (disks - 1) peg1 peg3 peg2)\n        ++ ((peg1, peg3) : (hanoi (disks - 1) peg2 peg1 peg3))\n\nhanoiMoveLength disks = disks ^ 2 - 1\n\n", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "-- Aufgabe 12.15\n-- a)\n-- `trans [(1,2),(444,444),(1,-2)]`\n\ntrans :: [(Int,Int)] -> [Int]\ntrans []\t\t\t= []\ntrans ((x,y):xys)\n\t| x > y \t\t= (x - y) : [] ++ (trans xys)\n\t| y > x \t\t= (y - x) : [] ++ (trans xys)\n\t| otherwise \t= [(x + y)] ++ (trans xys)\n\n-- b)\n-- This one is a bit tricky because of the last case, when there is no x \n-- higher than n. That is the 'liste n []' case.\n-- `liste (a) [0,1,2,3,4,5,6]` for a, try lower number, than contained \n-- in the list, number contained in the list and number higher than \n-- contained in the list\n\nliste :: Int -> [Int] -> [Int]\nliste n []\t\t= [n]\nliste n (x:xs)\n\t| n < x \t= [n] ++ [x] ++ xs\n\t| n == x\t= []  ++ xs\n\t| n > x\t\t= [x] ++ (liste n xs) \n\n-- c)\n-- `transtree (Node (Leaf 1) (Node (Leaf 2) (Leaf 3) False) False)`\n\ndata Tree a = Node (Tree a) (Tree a) Bool | Leaf a deriving Show\n\ntranstree :: Tree a -> Tree a\ntranstree (Leaf a)\t\t\t= Leaf a\ntranstree (Node t1 t2 b)\n\t| (number_leafs t1) == (number_leafs t2)\t= Node (transtree t1) (transtree t2) True\n\t| otherwise\t\t\t\t\t\t\t\t\t= Node (transtree t1) (transtree t2) False\n\nnumber_leafs :: Tree a -> Int\nnumber_leafs (Leaf a)\t\t= 1\nnumber_leafs (Node t1 t2 b)\t= (number_leafs t1) + (number_leafs t2)\n", "input": "[(42, 42), (42, 42)]", "status": "success", "output": "[84,84]"}
{"code": "-- Caesar's Cipher \n-- Jeremy.Singer@glasgow.ac.uk\n-- great example for QuickCheck\n\nimport Data.Char\n\n\nshouldcipher :: Char -> Bool\n-- is this a letter to be ciphered?\nshouldcipher c = isLetter(c) && isAscii(c)\n\n\n\ncipherchar :: Int -> Char -> Char\n-- enciphers single char at a time - NO WRAPPING\ncipherchar shift c\n | shouldcipher c = chr(ord(c)+shift)\n | otherwise      = c\n\n\n\n-- encipher a whole string\ncipher :: Int -> [Char] -> [Char]\ncipher shift plaintext = map (bettercipherchar shift) plaintext\n\n\n\n\ndecipher :: Int -> [Char] -> [Char]\n-- inverse of cipher function\ndecipher shift ciphertext = cipher (-shift) ciphertext\n\n\n\nwraparound shift c \n-- should we wrap around the alphabet, if we shift past Z?\n | isLower(c) && ord(c)+shift > ord 'z' = True\n | isUpper(c) && ord(c)+shift > ord 'Z' = True\n | otherwise = False\n\n\nbettercipherchar :: Int -> Char -> Char\n-- implementation of character substitution with wrapping\nbettercipherchar shift c\n | shouldcipher c =  chr(ord(c) + adjustedshift)\n | otherwise      = c\n where adjustedshift = let shift' = shift `mod` 26\n                       in if (wraparound shift' c)\n                          then shift'-26\n                          else shift'\n", "input": "'a'", "status": "success", "output": "True"}
{"code": "import Data.Char\n\nlet2int :: Char -> Int\nlet2int c\n    | isLower c = ord c - ord 'a'\n    | isUpper c = ord c - ord 'A'\n    | otherwise = ord c - ord 'a'\n\nint2lower :: Int -> Char\nint2lower n = chr (ord 'a' + n)\n\nint2upper :: Int -> Char\nint2upper n = chr (ord 'A' + n)\n\nshift :: Int -> Char -> Char\nshift n c\n    | isLower c = int2lower ((let2int c + n) `mod` 26)\n    | isUpper c = int2upper ((let2int c + n) `mod` 26)\n    | otherwise = c\n\nencode :: Int -> String -> String\nencode n xs = [shift n x | x <- xs]\n\nceasar = do\n    print(encode 13 \"Think like a Fundamentalist Code like a Hacker\")\n\nriffle :: [a] -> [a] -> [a]\n--riffle xs ys = concat [[x,y] | x <- xs, y<-ys]\nriffle xs ys = concat [[x,y] | (x,y) <- xs `zip` ys]\n--riffle xs ys = [x, y | (x, y) <- xs `zip` ys]\n--riffle xs ys = [x : [y] | x <- xs, y <- ys]\n\nrif = do\n    riffle [1,2,3] [4,5,6]\n\ndivides :: Int -> Int -> Bool\ndivides x y = mod x y == 0\n\ndivisors :: Int -> [Int]\ndivisors x = [d | d <- [1..x], x `divides` d]\n--divisors x = [d | d <- [1..x], d `divides` x]\n--divisors x = [d | d <- [2..x], x `divides` d]\n--divisors x = [d | d <- [1..x], x divides d]\n\nldiv = do\n    print(divides 15 2)\n    print(divides 15 3)\n    print(divisors 15)\n\n", "input": "'a'", "status": "success", "output": "0"}
{"code": "removeNonUppercase :: [Char] -> [Char]\nremoveNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]\n\nremoveNonUppercase' :: String -> String\nremoveNonUppercase' st = [ c | c <- st, c `elem` ['A'..'Z']]\n\nfactorial :: Integer -> Integer\nfactorial n = product [ 1 .. n ]\n\nfactorial' :: Int -> Int\nfactorial' n = product [ 1 .. n ]\n\ncircumference :: Float -> Float\ncircumference r = 2 * pi * r\n\ncircumference' :: Double -> Double\ncircumference' r = 2 * pi * r\n\n-- Typeclass\n--\n-- It is a representation, interface of certain behaviour. Typeclasses are used\n-- to annotate functions with certain class constraints like:\n--\n-- ghci> :t (==)\n-- (==) :: (Eq a) => a -> a -> Bool\n--\n-- It means that '==' is a function which has two arguments of the same type 'a',\n-- returns a Bool and type 'a' should be somehow able to test equality between values.\n--\n-- - Eq - equality testing.\n-- - Ord - compatable concept.\n-- - Read - converting from string.\n-- - Show - converting to string.\n-- - Enum - enumerating all representats of such type.\n-- - Bounded - all bounded types (like Bool, Int and so on).\n-- - Num - all numeric types have this behaviour.\n--\n-- And many, many more.\n\nexplicitTypeAnnotationTest = (read \"5\" :: Float) * 4", "input": "['a', 'a']", "status": "success", "output": "\"\""}
{"code": "import Data.Char\n\nfactors :: Int -> [Int] \nfactors n = [ x | x <- [1..n], n `mod` x == 0 ]\n\nprime :: Int -> Bool\nprime n = factors n == [1, n]\n\nprimes :: Int -> [Int]\nprimes n = [ x | x <- [2..n], prime x ] \n\nsorted :: Ord a => [a] -> Bool\nsorted xs = and [ x <= y | (x, y) <- zip xs (tail xs) ]\n\npositions :: Eq a => a -> [a] -> [Int]\npositions x xs = [i | (x', i) <- zip xs [0..], x == x']\n\nsum100 :: Int\nsum100 = sum [x ^ 2 | x <- [1..100]]\n\npyths :: Int -> [(Int, Int, Int)]\npyths n = [(x,y,z) | x <- [1..n], y <- [1..n], z <- [1..n], x^2 + y^2 == z^2]\n\nperfects :: Int -> [Int]\nperfects n = [x | x <- [1..n], isPerfect x]\n  where isPerfect m = sum (init (factors m)) == m\n\n--Cypher\nlet2int :: Char -> Int\nlet2int c = ord c - ord 'a'\n\ncap2int :: Char -> Int\ncap2int c = ord c - ord 'A'\n\nint2let :: Int -> Char\nint2let n = chr (ord 'a' + n)\n\nint2cap n = chr (ord 'A' + n)\n\nshift :: Int -> Char -> Char\nshift n c\n  | isLower c = int2let ((let2int c + n) `mod` 26)\n  | otherwise = int2cap ((cap2int c + n) `mod` 26)\n\nencode :: Int -> String -> String\nencode n xs = [shift n x | x <- xs]\n\n\n--Devides\ndivides :: Int -> Int -> Bool\ndivides n m = n `mod` m == 0\n\ndivisors :: Int -> [Int]\ndivisors n = [x | x <- [1..n], n `divides` x]\n\n", "input": "42", "status": "success", "output": "[1,2,3,6,7,14,21,42]"}
{"code": "-- Caesar cipher program\n\nimport Data.Char\n\nlet2int :: Char -> Int\nlet2int c = ord c - ord 'a'\n\nint2let :: Int -> Char\nint2let n = chr(n + ord 'a')\n\nshift :: Int -> Char -> Char\nshift n c\n  | isLower c = int2let ((let2int c + n) `mod` 26)\n  | isUpper c = int2let ((let2int c + n))\n  | otherwise = c\n\nencode :: Int -> String -> String\nencode n xs = [shift n x | x <- xs]\n\ndecode :: Int -> String -> String\ndecode n xs = [shift (-n) x | x <- xs]\n\n-----------------\n-- Reverse Sort\n-- ----------------------\nqsort [] = []\nqsort (x:xs) = qsort larger ++ [x] ++ qsort smaller\n  where smaller = [a | a <- xs, a < x]\n        larger  = [a | a <- xs, a > x]\n\n---------- Merge Sort\nmerge :: Ord a =>  ([a], [a]) -> [a]\nmerge ([], ys) = ys\nmerge (xs, []) = xs\nmerge ((x:xs), (y:ys)) =\n  if x <= y then x : merge (xs, (y: ys)) else y : merge ((x: xs), ys)\n\nhalve :: [a] -> ([a], [a])\nhalve xs = splitAt (length xs `div` 2) xs\n\nmsort :: Ord a => [a] -> [a]\nmsort [] = []\nmsort [x] = [x]\nmsort xs = merge ((msort yss), (msort xss))\n  where (xss, yss) = halve xs\n\n(!!!) :: [a] -> Int -> a\n(!!!) (x:_) 0 = x\n(!!!) (_:xs) n = xs !! (n-1)\n\nelem' :: Eq a => a -> [a] -> Bool\nelem' _ [] = False\nelem' x (y:ys)\n  | x == y = True\n  | otherwise = elem' x ys\n", "input": "'a'", "status": "success", "output": "0"}
{"code": "{--\r\n - Problem 37\r\n(**) Calculate Euler's totient function phi(m) (improved).\r\n    See problem 34 for the definition of Euler's totient function. If the list of the prime factors of a number\r\n    m is known in the form of problem 36 then the function phi(m) can be efficiently calculated as follows:\r\n    Let ((p1 m1) (p2 m2) (p3 m3) ...) be the list of prime factors (and their multiplicities) of a given number\r\n    m. Then phi(m) can be calculated with the following formula:\r\n\r\n    phi(m) = (p1 \u2010 1) * p1 ** (m1 \u2010 1) *\r\n    (p2 \u2010 1) * p2 ** (m2 \u2010 1) *\r\n    (p3 \u2010 1) * p3 ** (m3 \u2010 1) * ...\r\n\r\n    Note that a ** b stands for the b'th power of a.\r\n --}\r\n\r\nprimeFactors :: Int -> [Int]\r\nprimeFactors 1 = []\r\nprimeFactors n = k : primeFactors (n `quot` k) where\r\n    k = head $ filter (\\a -> n `mod` a == 0) [2, 3 .. n] \r\n\r\nencode :: [Int] -> [(Int, Int)]\r\nencode [] = []\r\nencode (x:xs) = (x, (+1) $ length $ takeWhile (== x) xs) : encode (dropWhile (== x) xs)\r\n\r\nprimeFactorsMult :: Int -> [(Int, Int)]\r\nprimeFactorsMult n = encode $ primeFactors n\r\n\r\npow :: Int -> Int -> Int\r\npow a k = product $ map (const a) [1, 2 .. k]\r\n\r\nphi :: Int -> Int\r\nphi n = product $ map (\\a -> (fst a -1) * pow (fst a) (snd a - 1)) $ primeFactorsMult n\r\n", "input": "42", "status": "success", "output": "[2,3,7]"}
{"code": "{-# OPTIONS_GHC -Wall #-}\n\n-- Given an Integer return list of its digits in reverse order\n-- Example: 1234 -> [4,3,2,1]\ntoDigitsRev :: Integer -> [Integer]\ntoDigitsRev n\n    | n <= 0    = []\n    | otherwise = (n `mod` 10) : toDigitsRev (n `div` 10)\n\n-- Given an Integer return list of its digits in direct order\n-- Example: 1234 -> [1,2,3,4]\ntoDigits :: Integer -> [Integer]\ntoDigits = reverse . toDigitsRev\n\n-- Given a list of Integers, double every even starting from the end of the list\n-- Example: [1,2,3,4] -> [2,2,6,4]\ndoubleEveryOther :: [Integer] -> [Integer]\ndoubleEveryOther n = reverse . doubleEven $ reverse n\n\n-- Given a list of Integers, double every even\n-- Example: [1,2,3,4] -> [1,4,3,8]\ndoubleEven :: [Integer] -> [Integer]\ndoubleEven []         = []\ndoubleEven [x]        = [x]\ndoubleEven (x:(y:ys)) = x : (y*2) : doubleEven ys\n\n-- Given a list of Integers, sum up every digit\n-- Example: [12,34,56] = 1+2+3+4+5+6 = 21\nsumDigits :: [Integer] -> Integer\nsumDigits []     = 0\nsumDigits (x:xs) = (sum . toDigits $ x) + (sumDigits xs)\n\n-- Given an Integer, validate it as a correct credit card number.\nvalidate :: Integer -> Bool\nvalidate n = (sumDigits . doubleEveryOther . toDigits $ n) `mod` 10 == 0\n\n-- vim: expandtab: ts=4: sw=4:\n", "input": "42", "status": "success", "output": "[2,4]"}
{"code": "doubleMe x = x + x\ntripleMe x = doubleMe x + x\n\ndoubleSmallNumbers x = if x < 100\n                          then doubleMe x\n                          else x\n\nboomBang xs = [if x < 10 then \"Boom\" else \"Bang\" | x <- xs, odd x]\n\ntmp :: Int->Int\n\ntmp x = x * 4\n\nlucky :: (Integral a) => a -> String\nlucky 7 = \"LUCKY NUMBER SEVEN!\"\nlucky x = \"Sorry, you're out of luck, pal!\"\n\nfactorial :: (Integral a) => a -> a\nfactorial 0 = 1\nfactorial n = n * factorial(n - 1)\n\npie \"pi\" = \"Pie is delicious\"\npie \"ab\" = \"This is not right\"\n\naddVector :: (Num a) => (a,a) -> (a,a) -> (a,a)\naddVector (a1, b1)(a2, b2)  = (a1 + a2, b1 + b2)\n\nheadAlt :: [a] -> a\nheadAlt [] = error \"Cannot call head on empty list\"\nheadAlt (x:_) = x\n\nlengthAlt :: (Num b) => [a] -> b\nlengthAlt [] = 0\nlengthAlt (_:xs) = 1 + lengthAlt xs\nbmiTell bmi\n  | bmi <= 18.5 = \"God damn emo!\"\n  | bmi <= 25.0 = \"Normal? Boring\"\n  | bmi <= 30.0 = \"OVERWEIGHT!\"\n  | otherwise = \"WHALE\"\n\ndivideByTen :: (Floating a) => a -> a\ndivideByTen = (/10)\n\nisUpperAlphanum :: Char -> Bool\nisUpperAlphanum = (`elem` ['A'..'Z'])\n\nquick :: (Ord a) => [a] -> [a]\nquick [] = []\nquick (x:xs) =\n  let smallBound = quick [a | a <- xs, a <= x]\n      bigBound = quick [a | a <- xs, a > x]\n   in smallBound ++ [x] ++ bigBound\n", "input": "42", "status": "success", "output": "168"}
{"code": "fun1 :: [Integer] -> Integer\nfun1 [] = 1\nfun1 (x:xs)\n  | even x = (x - 2) * fun1 xs\n  | otherwise = fun1 xs\n\nfun1' :: [Integer] -> Integer\nfun1' = foldr (\\x y -> (x - 2) * y ) 1 . filter (even)\n\nfun2 :: Integer -> Integer\nfun2 1 = 0\nfun2 n | even n = n + fun2 (n `div` 2)\n       | otherwise = fun2 (3 * n + 1)\n                     \nfun2' :: Integer -> Integer               \nfun2' = sum . filter (even) . takeWhile (> 1) . iterate (\\x -> if (even x) then (x `div` 2) else (3 * x + 1))\n\ndata Tree a = Leaf\n            | Node Integer (Tree a) a (Tree a)\n        deriving (Show, Eq)\n                 \nfoldTree :: [a] -> Tree a                 \nfoldTree = foldr addNode Leaf\n\naddNode :: a -> Tree a -> Tree a\naddNode x Leaf = Node 0 Leaf x Leaf\naddNode x (Node h left value right)\n  | hl < hr = Node h (addNode x left) value right\n  | hl > hr = Node h left value newRight \n  | otherwise = Node (hnr + 1) left value newRight\n where hl = height left\n       hr = height right\n       newRight = addNode x right\n       hnr = height newRight\n    \nheight :: Tree a -> Integer\nheight Leaf = -1\nheight (Node h _ _ _) = h\n\nxor :: [Bool] -> Bool\nxor = odd . foldr (\\x y -> if x then (y + 1) else y) 0\n\nmap' ::  (a -> b) -> [a] -> [b] \nmap' f  = foldr (\\x l -> f x : l) []", "input": "[42, 42]", "status": "success", "output": "1600"}
{"code": "import Data.Array (accumArray, Array, (!))\nimport Data.List ((\\\\), partition)\nimport Data.Array.ST (runSTArray, writeArray, newArray)\n\n-- solution 1: performance issues\nminfreeRaw :: [Integer] -> Integer\nminfreeRaw xs = head([0..] \\\\ xs)\n\n-- solution 2: rely on accumArray\nchecklist :: [Int] -> Array Int Bool\nchecklist xs =  accumArray (||) False (0,n)\n                (zip (filter (<= n) xs)(repeat True))\n                where n = length xs\n\ncountlist :: [Int] -> Array Int Int\ncountlist xs = accumArray (+) 0 (0,n) (zip xs (repeat 1))\n               where n = length xs\n\nfirstFalse xs = length $ takeWhile (\\i -> xs!i) [0..]\n\n-- solution 3: write by yourself (use monad, a procedual program in functional clothing)\nchecklistm xs = runSTArray(do\n        { a <- newArray(0,n) False;\n        sequence_ [writeArray a x True | x <- xs, x <= n];\n        return a})\n    where n = length xs\n\n-- solution 4: divide and conquer\nminfree xs = minfrom 0 (length xs, xs)\nminfrom a (n, xs) | n == 0     = a\n                  | m == b - a = minfrom b (n-m, vs)\n                  | otherwise = minfrom a (m, us)\n                    where b        = a + 1 + n `div` 2\n                          (us, vs) = partition (<b) xs\n                          m        = length us\n", "input": "[42, 42]", "status": "success", "output": "0"}
{"code": "\n\nremoveNonUppercase :: [Char] -> [Char]\nremoveNonUppercase xs = [ x | x<-xs, elem x ['A'..'Z'] ]\n\nlucky :: Int -> String\nlucky 7 = \"Lucky number seven\"\nlucky x = \"Sorry,you are out of lucky\"\n\nfactorial :: Int -> Int\nfactorial 0 = 1\nfactorial x = x * factorial (x -1)\n\nhead' :: [a] -> a\nhead' [] = error \"Can't call head on a empty list!\"\nhead' (x:_) = x\n\ntell [] = 1\ntell (x:[]) = 2\ntell (x:y:[]) = 3\ntell (x:y:_) = 4\n\ntell' [] = 1\ntell' [x] = 2\ntell' [x, y] = 3\ntell' (x:y:_) = 4\n\nfirstString :: String -> String\nfirstString \"\" = \"Empty string, whoops\"\nfirstString all@(x:xs) = \"The first letter of \" ++ all ++ \" is \" ++ [x] ++ \" and \" ++ xs\n\nbmiTell :: Double -> Double -> String\nbmiTell weight height\n    | weight / height ^ 2 <= 18.5 = \"You're underweight, you emo, you!\"\n    | weight / height ^ 2 <= 25.0 = \"You're normal\"\n    | weight / height ^ 2 <= 30.0 = \"You're fat\"\n    | otherwise = \"You're a whole\"\n\nbmiTell' :: Double -> Double -> String\nbmiTell' weight height\n    | bmi <= skinny = \"You're underweight, you emo, you!\"\n    | bmi <= normal = \"You're normal\"\n    | bmi <= fat    = \"You're fat\"\n    | otherwise     = \"You're a whale\" \n    where bmi = weight / height ^ 2\n          skinny = 18.5\n          normal = 25.0\n          fat    = 30.0\n\n\n", "input": "['a', 'a']", "status": "success", "output": "\"\""}
{"code": "-- toDigitsRev 1234 == [4,3,2,1]\ntoDigitsRev :: Integer -> [Integer]\ntoDigitsRev x\n    | x > 0     = x `mod` 10 : toDigitsRev (x `div` 10)\n    | otherwise = []\n\n-- toDigits 1234 == [1,2,3,4]\n-- toDigits 0 == []\n-- toDigits (-17) == []\ntoDigits :: Integer -> [Integer]\ntoDigits = reverse . toDigitsRev\n\n-- doubleEveryOther [8,7,6,5] == [16,7,12,5]\n-- doubleEveryOther [1,2,3] == [1,4,3]\ndoubleEveryOther :: [Integer] -> [Integer]\ndoubleEveryOther = reverse . doubleEveryOtherRev . reverse\n\ndoubleEveryOtherRev :: [Integer] -> [Integer]\ndoubleEveryOtherRev []         = []\ndoubleEveryOtherRev (x:[])     = [x]\ndoubleEveryOtherRev (x:y:rest) = x : (y * 2) : doubleEveryOtherRev rest\n\n-- sumDigits [16,7,12,5] == 22\nsumDigits :: [Integer] -> Integer\nsumDigits = sum . (>>= toDigits)\n\n-- validate 4012888888881881 == True\n-- validate 4012888888881882 == False\nvalidate :: Integer -> Bool\nvalidate x = (sumDigits . doubleEveryOther . toDigits) x `mod` 10 == 0\n\n-- hanoi 2 \"a\" \"b\" \"c\" == [(\"a\",\"c\"), (\"a\",\"b\"), (\"c\",\"b\")]\ntype Peg  = String\ntype Move = (Peg, Peg)\nhanoi :: Integer -> Peg -> Peg -> Peg -> [Move]\nhanoi 0 _ _ _    = []\nhanoi 1 p1 p2 _  = [(p1, p2)]\nhanoi n p1 p2 p3 =\n    hanoi (n - 1) p1 p3 p2 ++\n    hanoi 1 p1 p2 p3 ++\n    hanoi (n - 1) p3 p2 p1\n\n", "input": "42", "status": "success", "output": "[2,4]"}
{"code": "-- Intermission: Exercises\n\n-- 1. Given the above, how might we write a filter function that would give us\n-- all the multiples of 3 out of a list from 1-30?\n\nnum1 = filter (\\x -> mod x 3 == 0) [1..30]\n\n-- 2. Recalling what we learned about function composition, how could we compose\n-- the above function with the length function to tell us *how many* multiples\n-- of 3 there are between 1 and 30?\n\nnum2 = length $ filter (\\x -> mod x 3 == 0) [1..30]\n\n-- 3. Next we\u2019re going to work on removing all articles (\u2019the\u2019, \u2019a\u2019, and \u2019an\u2019)\n-- from sentences. You want to get to something that works like this:\n-- myFilter \"the brown dog was a goof\" =>  [\"brown\",\"dog\",\"was\",\"goof\"]\n\nmyFilter :: String -> [String]\nmyFilter xs = filter notAllowed $ words xs\n  where notAllowed word = case word of\n                            \"the\" -> False\n                            \"a\" -> False\n                            \"an\" -> False\n                            _ -> True\n\n-- You may recall that earlier in this chapter we asked you to write a function\n-- that separates a string into a list of strings by separating them at spaces.\n-- That is a standard library function called words. You may consider starting\n-- this exercise by using words (or your version, of course).\n", "input": "\"hello\"", "status": "success", "output": "[\"hello\"]"}
{"code": "import Control.Monad.Writer\nimport Control.Monad.Reader\nimport Control.Monad.State\n\nhalf x = x `div` 2\n\n-- applicatives\nhalfv2 x = if even x\n          then Just (x `div` 2)\n          else Nothing\n  \n-- Writer monad        \nhalfWithWriter :: Int -> Writer String Int\nhalfWithWriter x = do\n                tell (\"I just halved \" ++ (show x) ++ \"!\")\n                return (x `div` 2)\n                \n\n-- Writer monad take 2 from\n-- http://learnyouahaskell.com/for-a-few-monads-more#writer\n\nlogNumber :: Int -> Writer [String] Int  \nlogNumber x = writer (x, [\"Got number: \" ++ show x])  \n  \nmultWithLog :: Writer [String] Int  \nmultWithLog = do  \n    a <- logNumber 3  \n    b <- logNumber 5 \n    tell [\"Gonna multiply these two\"] \n    return (a*b)\n    \n\ngcd' :: Int -> Int -> Writer [String] Int  \ngcd' a b  \n    | b == 0 = do  \n        tell [\"Finished with \" ++ show a]  \n        return a  \n    | otherwise = do  \n        tell [show a ++ \" mod \" ++ show b ++ \" = \" ++ show (a `mod` b)]  \n        gcd' b (a `mod` b)  \n\n\n-- Reader monad\ngreeter :: Reader String String\ngreeter = do\n    name <- ask\n    return (\"hello, \" ++ name ++ \"!\")\n    \n\n\n-- State monad\ngreeter2 :: State String String\ngreeter2 = do\n    name <- get\n    put \"tintin\"\n    return (\"hello, \" ++ name ++ \"!\")", "input": "42", "status": "success", "output": "WriterT (Identity (21,\"I just halved 42!\"))"}
{"code": "--http://english.stackexchange.com/questions/111765/how-to-write-out-numbers-in-compliance-with-british-usage\nimport Data.Maybe\n\nknownNumbers = [\n  (0, 0),\n  (1, length \"one\"),\n  (2, length \"two\"),\n  (3, length \"three\"),\n  (4, length \"four\"),\n  (5, length \"five\"),\n  (6, length \"six\"),\n  (7, length \"seven\"),\n  (8, length \"eight\"),\n  (9, length \"nine\"),\n  (10, length \"ten\"),\n  (11, length \"eleven\"),\n  (12, length \"twelve\"),\n  (13, length \"thirteen\"),\n  (14, length \"fourteen\"),\n  (15, length \"fifteen\"),\n  (16, length \"sixteen\"),\n  (17, length \"seventeen\"),\n  (18, length \"eighteen\"),\n  (19, length \"nineteen\"),\n  (20, length \"twenty\"),\n  (30, length \"thirty\"),\n  (40, length \"forty\"),\n  (50, length \"fifty\"),\n  (60, length \"sixty\"),\n  (70, length \"seventy\"),\n  (80, length \"eighty\"),\n  (90, length \"ninety\")]\n\ncountLetters :: Int -> Int\ncountLetters num\n  | num == 0 = 0\n  | num < 20 = known num\n  | num < 100 = known ((num `div` 10)*10) + known (num `mod` 10)\n  | num < 1000 = known (num `div` 100) + hundred + andWord + countLetters (num `mod` 100)\n  | num == 1000 = length \"onethousand\"\n  where\n    known num = fromJust $ lookup num knownNumbers\n    hundred = length \"hundred\"\n    andWord = if num `mod` 100 /= 0 then length \"and\" else 0\n\n--sum $ map countLetters [1..1000]\n", "input": "42", "status": "success", "output": "8"}
{"code": "--Joe Loser\n--CS4450 HW0\n--9/14/14\n\nimport Data.Char\n\n-- takes letter of alphabet and returns the letter immediately after it (A is considered after Z)\n-- if argument is not a letter, returns the argument unchanged\nnextlet :: Char -> Char\nnextlet 'z' = 'a'\nnextlet 'Z' = 'A'\nnextlet c\n\t| isAlpha(c) = succ(c)\n\t| otherwise = c\n\n-- converts a digit char (0-9) to its corresponding numerical value\n-- if arg isn't a digit characters, returns -1\ndigitval :: Char -> Int\ndigitval c\n\t| isDigit(c) = digitToInt(c)\n\t| otherwise  = -1\n\n-- accepts two functions (say, f and g) and \"twines\" them together into a\n-- function that accepts a single argument and constructs a tuple of type\n-- (b, c) from the result of applying the two functions to the argument\ntwine :: (a -> b) -> (a -> c) -> a -> (b, c)\ntwine f g a = (f a, g a)\n\n-- function cond where it returns x if p is true or y otherwise\ncond :: Bool -> a -> a -> a\ncond p x y \n\t| p == True = x\n\t| otherwise = y\n\n-- date is represented by a tuple (day, month, year)\n-- first tuple is birthday and second tuple is current dates\n-- returns age of individual in whole years\nage :: (Int, Int, Int) -> (Int, Int, Int) -> Int\nage (d, m, y) (d', m', y')\n      | m' > m = y' - y\n      | m' < m = y' - y - 1\n      | m' == m && d' >= d = y' - y\n      | m' == m && d' < d = y' - y - 1\n", "input": "'a'", "status": "success", "output": "'b'"}
{"code": "-- Problem 32 \n--\n-- We shall say that an n-digit number is pandigital if it makes use of all\n-- the digits 1 to n exactly once; for example, the 5-digit number, 15234,\n-- is 1 through 5 pandigital.\n--\n-- The product 7254 is unusual, as the identity, 39 \u00d7 186 = 7254,\n-- containing multiplicand, multiplier, and product is 1 through\n-- 9 pandigital.\n--\n-- Find the sum of all products whose multiplicand/multiplier/product\n-- identity can be written as a 1 through 9 pandigital.\n-- HINT: Some products can be obtained in more than one way so be sure to\n-- only include it once in your sum.\n\nimport Data.List\n\n-- 9 digit pandigital only generated by 2 x 3 digit numbers and\n-- 1 x 4 digit numbers\n\neuler32 = sum $ nub $ get1By4 ++ get2By3\n    where get1By4 = getPandigital9 [1..9] [1000..9999]\n          get2By3 = getPandigital9 [10..99] [100..999]\n\ngetPandigital9 xs ys = [x * y | x <- xs, y <- ys, isPandigital x y]\n\nisPandigital x y = allDigits == nub allDigits\n                && length allDigits == 9\n    where \n          allDigits = (digitsP ++ digitsX ++ digitsY)\n          digitsP = digits (x * y)\n          digitsX = digits x\n          digitsY = digits y\n\n-- Obtain digits from number until 0 is reached or end of number\ndigits :: Int -> [Int]\ndigits n = takeWhile (> 0) $ map (`mod` 10) $ iterate (`div` 10) n\n", "input": "42", "status": "success", "output": "[2,4]"}
{"code": "scoreToLetter :: Int -> Char\nscoreToLetter n\n    | n > 90 = 'A'\n    | n > 80 = 'B'\n    | n > 70 = 'C'\n    | otherwise = 'F'\n\nlen [] = 0\nlen (x:s) = 1 + len s\n\nlistCopy [] = []\nlistCopy (x:s) = x : listCopy s\n\nones = 1 : ones\n\nfront :: Int -> [a] -> [a]\nfront _ [] = []\nfront 0 (x:s) = []\nfront n (x:s) = x : front (n-1) s\n\ntB :: [String] -> [Int] -> [(String, Int)]\ntB [] _ = []\ntB (f:fs) (b:bs) = (f,b) : tB fs bs\n\ntimeBonuses finishers =\n  tB finishers ([20, 12, 8] ++ cycle[0])\n\nzipOp :: (a -> b -> c) -> [a] -> [b] -> [c]\nzipOp f [] _ = []\nzipOp f _ [] = []\nzipOp f (a:as) (b:bs) = (f a b) : zipOp f as bs\n\nmyZip = zipOp (\\ a b -> (a,b))\n\nfibs = 1 : 1 : zipOp (+) fibs (tail fibs)\n\ntype Identifier = String\ntype Value = Int\n\ntype Env = [(Identifier, Value)]\ndata WAE = Num Int\n         | Add WAE WAE\n         | Id Identifier\n         | With Identifier WAE WAE\n\nmlookup :: Identifier -> Env -> Value\nmlookup var ((i,v):r)\n  | (var == i) = v\n  | otherwise = mlookup var r\n\nextend :: Env -> Identifier -> Value -> Env\nextend env i v = (i,v):env\n\n--interp :: WAE -> Env -> Value\ninterp (Num n) env = n\ninterp (Add lhs rhs) env = interp lhs env + interp rhs env\ninterp (Id i) env = mlookup i env\ninterp (With bound_id named_expr bound_body) env =\n           interp bound_body\n           (extend env bound_id (interp named_expr env))\n", "input": "42", "status": "success", "output": "'F'"}
{"code": "\ndoubleMe x = x + x\n\ndoubleUs x y = x * 2 + y * 2\n\ndoubleUs' x y = doubleMe x + doubleMe y\n\ndoubleSmallNumber x = if x > 100\n                        then x\n                        else x * 2\n\ndoubleSmallNumber' x = (if x > 100 then x else x*2) + 1\n\nlength' xs = sum [ 1 | _ <- xs ]\n\nremoveNonUppercase :: [Char] -> [Char]\nremoveNonUppercase xs = [ x | x <- xs, elem x ['A'..'Z'] ]\n\nlucky :: Int -> String\nlucky 7 = \"Lucky number seven\"\nlucky x = \"Sorry, you're out of luck, pal\"\n\nfactorial :: Int -> Int\nfactorial 0 = 1\nfactorial x = x * factorial (x-1)\n\nhead' :: [a] -> a\nhead' [] = error \"Can't call head on an empty list,dummy!\"\nhead' (x:_) = x\n\ntell :: Show a => [a] -> [Char]\ntell []       = \"empty\"\ntell (x:[])   = \"one \" ++ show x\ntell (x:y:[]) = \"two \" ++ show x ++ \" \" ++ show y\ntell (x:y:_)  = \"too long\"\n\nfirstLetter :: String -> String\nfirstLetter \"\" = \"Empty string, whoops\"\nfirstLetter all@(x:xs) = \"The first letter of \" ++ all ++ \" is \" ++ [x]\n\ngardTest :: Int -> String\ngardTest int \n  | int == 1 = show int :: [Char]\n  | int == 2 = show int :: String\n  | otherwise = \"Nothing\"\n\nmax' :: (Ord a) => a -> a -> a\nmax' a b \n  | a > b = a\n  | otherwise = b\n\nbmiTell :: Double -> Double -> Int\nbmiTell weight height\n  | bmi <= 18.5 = 1\n  | bmi <= 50.0 = 2\n  | otherwise   = 3\n  where bmi = weight / height ^ 2\n\n\n\n\n\n\n\n\n\n\n\n\n", "input": "['a', 'a']", "status": "success", "output": "\"\""}
{"code": "bmiTell :: Double -> String\nbmiTell bmi\n    | bmi <= 18.5 = \"Thin\"\n    | bmi <= 25.0 = \"Normal\"\n    | bmi <= 30   = \"Fat\"\n    | otherwise   = \"Whale\"\n\nbmiTellWH :: Double -> Double -> String\nbmiTellWH weight height\n    | weight / height ^ 2 <= 18.5 = \"Thin\"\n    | weight / height ^ 2 <= 25.0 = \"Normal\"\n    | weight / height ^ 2 <= 30   = \"Fat\"\n    | otherwise                   = \"Whale\"\n\nmax' :: (Ord a) => a -> a -> a\nmax' a b\n    | a <= b    = b\n    | otherwise = a\n\nmyCompare :: (Ord a) => a -> a -> Ordering\na `myCompare` b\n    | a == b    = EQ\n    | a <= b    = LT\n    | otherwise = GT\n\nbmiTellWHWhere :: Double -> Double -> String\nbmiTellWHWhere weight height\n    | bmi <= skinny = \"Thin\"\n    | bmi <= normal = \"Normal\"\n    | bmi <= fat    = \"Fat\"\n    | otherwise     = \"Whale\"\n    where bmi = weight / height ^ 2\n          skinny = 18.5\n          normal = 25.0\n          fat    = 30.0\n\ninitials :: String -> String -> String\ninitials firstName lastName = [f] ++ \". \" ++ [l] ++ \".\"\n    where (f:_) = firstName\n          (l:_) = lastName\n\ncalculateBmis :: [(Double, Double)] -> [Double]\ncalculateBmis xs = [bmi w h | (w, h) <- xs]\n    where bmi weight height = weight / height ^ 2\n\ncylinder :: Double -> Double -> Double\ncylinder r h =\n    let sideArea = 2 * pi * r * h\n        topArea = pi * r ^ 2\n    in sideArea + 2 * topArea", "input": "2.71", "status": "success", "output": "\"Thin\""}
{"code": "\nimport Data.List\n\nfact :: Integer -> Integer\nfact n\n    | n == 0 = 1\n    | otherwise = n * fact (n-1)\n\nminimum' :: (Ord a) => [a] -> a\nminimum' [] = error \"minimum in a empty list\"\nminimum' (x:[]) = x\n-- minimum' (x:xs) = min x (minimum' xs)\nminimum' (x:y:s) = if x < y\n                    then minimum' (x:s)\n                    else minimum' (y:s)\n\nlength' :: Num b => [a] -> b\nlength' [] = 0\nlength' (_:xs) = 1 + length' xs\n\nqsort :: (Ord a) => [a] -> [a]\nqsort [] = []\nqsort (x:[]) = [x]\nqsort (x:xs) = connecQ (partition x xs)\n  where connecQ (a, k, b) = (qsort a) ++ [k] ++ (qsort b)\n        partition x xs = ([u | u<-xs, u < x], x,\n                          [v | v<-xs, v >= x])\n\n\nmsort :: (Ord t) => [t] -> [t]\nmsort [] = []\nmsort (x:[]) = [x]\nmsort s = let m = length s `div` 2\n           in merge (msort $ take m s) (msort $ drop m s)\n              where merge xs ys =\n                      case (xs, ys) of\n                        (xs, []) -> xs\n                        ([], ys) -> ys\n                        (x:xs, y:ys) -> if x < y\n                                        then x:y:merge xs ys\n                                        else y:x:merge xs ys\n\n\n{-\ncfrac :: Num t => t -> [Integer]\n  -- cfrac: continued fraction\ncfrac n\n  | p == 0 = [m]\n  | otherwise = m : cfrac (1/p)\n  where p = n - floor n\n        m = floor n\n-}\n\n", "input": "42", "status": "success", "output": "1405006117752879898543142606244511569936384000000000"}
{"code": "import Data.Char (isLower, ord)\n\nlowerToCode :: Char -> Maybe Int\nlowerToCode c\n\t| isLower c = Just $ ord c\n\t| otherwise = Nothing\n\nevenDiv2 :: Int -> Maybe Int\nevenDiv2 n\n\t| even n = Just $ n `div` 2\n\t| otherwise = Nothing\n\nlowerToCodeDiv2 :: Char -> Maybe Int\nlowerToCodeDiv2 c = case lowerToCode c of\n\tJust n -> evenDiv2 n\n\tNothing -> Nothing\n\nlowerToCodeDiv4 :: Char -> Maybe Int\nlowerToCodeDiv4 c = case lowerToCode c of\n\tJust n -> case evenDiv2 n of\n\t\tJust n' -> evenDiv2 n'\n\t\tNothing -> Nothing\n\tNothing -> Nothing\n\npipeM :: (a -> Maybe b) -> (b -> Maybe c) -> (a -> Maybe c)\n(f `pipeM` g) v = case f v of\n\tJust x -> g x\n\tNothing -> Nothing\n\nlowerToCodeDiv4' :: Char -> Maybe Int\nlowerToCodeDiv4' = lowerToCode `pipeM` evenDiv2 `pipeM` evenDiv2\n\nmul3 :: Int -> Int\nmul3 = (* 3)\n\narrM :: (a -> b) -> (a -> Maybe b)\narrM f = Just . f\n\nlowerToCodeDiv2Mul3 :: Char -> Maybe Int\nlowerToCodeDiv2Mul3 = lowerToCode `pipeM` evenDiv2 `pipeM` arrM mul3\n\nbindM :: Maybe a -> (a -> Maybe b) -> Maybe b\nJust x `bindM` f = f x\nNothing `bindM` _ = Nothing\n\nretM :: a -> Maybe a\nretM = Just\n\nlowerToCodeDiv2Mul3' :: Char -> Maybe Int\nlowerToCodeDiv2Mul3' c = lowerToCode c `bindM` evenDiv2 `bindM` (retM . mul3)\n\nlowerToCodeDiv2Mul3'' :: Char -> Maybe Int\nlowerToCodeDiv2Mul3'' c =\n\tlowerToCode c `bindM` \\n ->\n\tevenDiv2 n `bindM` \\n' ->\n\tretM $ mul3 n'\n", "input": "'a'", "status": "success", "output": "Just 97"}
{"code": "import Data.Char\nimport Control.Applicative\n\nhurr = (*2)\ndurr = (+10)\n\nm :: Integer -> Integer\nm = hurr . durr\n\nm' :: Integer -> Integer\nm' = fmap hurr durr\n\nm2 :: Integer -> Integer\nm2 = (+) <$> hurr <*> durr\n\nm3 :: Integer -> Integer\nm3 = liftA2 (+) hurr durr\n\n---\n\ncap :: [Char] -> [Char]\ncap xs = map toUpper xs\n\nrev :: [Char] -> [Char]\nrev xs = reverse xs\n\n-- Two simple functions with the same type, taking the same type of input. We\n-- could compose them, using (.) or fmap:\ncomposed :: [Char] -> [Char]\ncomposed = cap . rev\n\nfmapped :: [Char] -> [Char]\nfmapped = fmap cap rev\n\n-- Prelude> composed \"Julie\"\n-- \"EILUJ\"\n-- Prelude> fmapped \"Chris\"\n-- \"SIRHC\"\n\n--Now we want to return the results of cap and rev both, as a tuple, like this:\n-- Prelude> tupled \"Julie\"\n--(\"JULIE\",\"eiluJ\")\n---- or\n-- Prelude> tupled' \"Julie\"\n--(\"eiluJ\",\"JULIE\")\n\n-- We will want to use an applicative here. The type will look like this:\ntupled :: [Char] -> ([Char], [Char])\ntupled = (,) <$> cap <*> rev\n--tupled = liftA2 (,) cap rev\n\ntupled' :: [Char] -> ([Char], [Char])\ntupled' = do\n  a <- cap\n  b <- rev\n  return (a, b)\n\n-- There is no special reason such a function needs to be monadic, but let\u2019s do\n-- that, too, to get some practice. Do it one time using do syntax; then try\n-- writing a new version using (>>=). The types will be the same as the type for\n-- tupled.\n", "input": "42", "status": "success", "output": "104"}
{"code": "-- (*) :: Int -> Int -> Int\n-- m * 0 = 0 \n-- m * n = m + (m *(n-1))\n\n-- drop :: Int -> [a] -> [a]\n-- drop 0 xs = xs\n-- drop _ [] = []\n-- drop n (_:xs) = drop (n-1) xs\n\n\n-- 6.1\nfac :: Int -> Int\nfac 0 = 1\nfac n | n > 0 = n * fac (n-1)\n      | n < 0 = 0\n\n-- 6.2\nsumdown :: Int -> Int\nsumdown 0 = 0\nsumdown x = x + sumdown (x-1)\n\n-- 6.3\n(^) :: Int -> Int -> Int\nm ^ 0 = 1\nm ^ n = m * (m Main.^ (n-1))\n\n-- 6.4\neuclid :: Int -> Int -> Int\neuclid a b | a == b = a\n           | a < 0 = a\n           | b < 0 = b\n           | a > b = euclid (a-b) b\n           | a < b = euclid a (b-a)\n\n-- 6.5\n{-\nlength [1,2,3]\n1 + length [2,3]\n1 + 1 + length [3]\n1 + 1 + 1 + length []\n1 + 1 + 1 + 0\n= 3\n\ndrop 3 [1,2,3,4,5]\ndrop 2 [2,3,4,5]\ndrop 1 [3,4,5]\ndrop 0 [4,5]\n= [4,5]\n\ninit [1,2,3]\n1 : init [2,3]\n1 : 2 : init [3]\n1 : 2 : []\n= [1,2]\n\n-}\n\n-- 6.6\nand :: [Bool] -> Bool\nand (x:xs) | null xs = if (x == True) then True else False\n           | x == True = Main.and xs\n           | otherwise = False\n\n--concat :: [[a]] -> [a]\n-- concat [[x],[xs]] = [x] : Main.concat [xs]   \n-- concat xss = [x | xs <- xss, x <- xs]\n--concat (x:xss) = x : Main.concat xss\n\nreplicate :: Int -> a -> [a]\nreplicate 0 x = []\nreplicate n x = x : Main.replicate (n-1) x\n\n(!!!) :: [a] -> Int -> a\n--(!!!) (x:_) 0 = x \n-- (!!!) (x:y) a = (!!!) y (a-1)\n(!!!) (x:y) a | a <= 0 = x\n              | otherwise = (!!!) y (a-1)\n", "input": "42", "status": "success", "output": "7538058755741581312"}
{"code": "import Data.Char\nimport Data.Int\n\nlowers :: String -> Int\nlowers xs = length [x | x <- xs, isLower x]\n\ncount :: Char -> String -> Int\ncount x xs = length [x' | x' <- xs, x == x']\n\npositions :: Eq a => a -> [a] -> [Int]\npositions x xs = [i | (x', i) <- zip xs [0..n], x == x']\n                 where n = length xs - 1\n\nlet2int :: Char -> Int\nlet2int c = ord c - ord 'a'\n\nint2let :: Int -> Char\nint2let n = chr(ord 'a' + n)\n\nshift :: Int -> Char -> Char\nshift n c | isLower c =  int2let ((let2int c + n) `mod` 26)\n          | otherwise = c\n\nencode :: Int -> String -> String\nencode n xs = [shift n x | x <- xs]\n\ntable :: [Float]\ntable = [ 8.2, 1.5, 2.8, 4.3, 12.7, 2.2, 2.0, 6.1, 7.0, 0.2, 0.8, 4.0, 2.4,\n          6.7, 7.5, 1.9, 0.1, 6.0, 6.3, 9.1, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1 ]\n\npercent :: Int -> Int -> Float\npercent n m = (fromIntegral n / fromIntegral m) * 100\n\nfreqs :: String -> [Float]\nfreqs xs = [percent (count x xs) n | x <- ['a'..'z']]\n           where n = lowers xs\n\nchisqr :: [Float ] -> [Float ] -> Float\nchisqr os es = sum[((o - e) ^ 2)/e | (o,e) <- zip os es]\n\nrotate :: Int -> [a] -> [a]\nrotate n xs = drop n xs ++ take n xs\n\ncrack :: String -> String\ncrack xs = encode (-factor) xs\n           where factor = head (positions (minimum chitab) chitab)\n                 chitab = [chisqr (rotate n table') table | n <- [0..25]]\n                 table' = freqs xs\n", "input": "\"hello\"", "status": "success", "output": "5"}
{"code": "{-\nCredit card number validation steps:\n1. Convert card number to a string of integers\n2. Reverse it\n3. Double the digits at even locations\n4. Calculate sum of individual digits\neg. [2,12,3,10,2,16] should be evaluated as 2+1+2+3+1+0+2+1+6\n5. If sum is a multiple of 10, then the card number is valid\n-}\n\n-- Entry function\n-- Input: 16 digit card number\n-- Ouput: True or False indicating validity\nvalidateCC :: Integer -> Bool\nvalidateCC = validateCCImpl.toDigitsRev\n\n-- Convert integer to a list (reverse order)\ntoDigitsRev :: Integer -> [Integer]\ntoDigitsRev x\n   | x <= 0    = []\n   | x < 10    = [x]\n   | otherwise = extractLSD x : toDigitsRev (x `div` 10)\n\n-- Extract the least significant digit from a number\nextractLSD :: Integer -> Integer\nextractLSD x = x `mod` 10\n\n-- Perform validation steps as mentioned at top\nvalidateCCImpl :: [Integer] -> Bool\nvalidateCCImpl xs = (mod (sumDigits(doubleEveryOther xs) ) 10) == 0\n\n-- Double every even positioned number in a list\ndoubleEveryOther :: [Integer] -> [Integer]\ndoubleEveryOther = zipWith (*) (cycle[1,2])\n\n-- Find sum of integers is a list (with each digit summed up internally)\nsumDigits :: [Integer] -> Integer\nsumDigits [] = 0\nsumDigits (x:xs) = innerSumDigits x + sumDigits xs\n\n-- Find sum of all digits in an an Integer\ninnerSumDigits :: Integer -> Integer\ninnerSumDigits 0 = 0\ninnerSumDigits x = extractLSD x + innerSumDigits ( x `div` 10 )\n", "input": "42", "status": "success", "output": "True"}
{"code": "import Data.Monoid\nimport Control.Monad.Writer\n\n-- page 569\n \nisBigGang :: Int -> (Bool, String)\nisBigGang x = (x > 9, \"Compared gang size to 9.\")\n \napplyLog :: (Monoid m) => (a, m) -> (a -> (b, m)) -> (b, m)\n--applyLog (x, log) f = \n--  let (y, newLog) = f x \n--  in (y, log `mappend` newLog)\napplyLog (x, log) f = \n  let (y, newLog) = f x \n  in (y, log <> newLog)  \n\n\ntestMonoid :: (Monoid m) => m -> m\ntestMonoid a = mempty\n\ntype Food = String\ntype Price = Sum Int\n\naddDrink :: Food -> (Food, Price)\naddDrink \"beans\"  = (\"milk\", Sum 25)\naddDrink \"jerky\"  = (\"whiskey\", Sum 99)\naddDrink  _       = (\"beer\", Sum 30)\n\n-- page 231\n\n-- data Car = Car String String Int deriving (Show) \ndata Car = Car {company :: String,\n                model :: String,\n                year :: Int\n                } deriving (Show)\n\n        \ndata AlternativeCar = SpecialConstructorCar {\n                company' :: String,\n                model' :: String,\n                year' :: Int\n                } deriving (Show)\n-- page 574\n\n--instance (Monoid w) => Monad (Writer w) where \n--  return x = Writer (x, mempty)\n--  (Writer (x, v)) >>= f = \n--    let (Writer (y, v')) = f x\n--    in Writer (y, v `mappend` v')\n\nlogNumber :: Int -> Writer [String] Int\nlogNumber x = writer (x, [\"Got number: \" ++ show x])\n\nmultWithLog :: Writer [String] Int\nmultWithLog = do\n  a <- logNumber 3\n  b <- logNumber 5\n  return (a * b)\n  \n  \n    \n\n\n", "input": "42", "status": "success", "output": "(True,\"Compared gang size to 9.\")"}
{"code": "-- See https://github.com/Jakehp/PLC/blob/master/pdfs/hwk4.pdf\n\nnum_digits :: Int -> Int\nnum_digits x\n    | x <= 9 = 1\n    | otherwise = 1 + num_digits (x `div` 10)\n\nmax_digits :: [Int] -> Int\nmax_digits (x:xs)\n    | null xs = num_digits x\n    | num_digits x > max_digits xs = num_digits x\n    | otherwise = max_digits xs\n\nright_digit :: Int -> Int\nright_digit x\n    | num_digits x == 1 = x\n    | otherwise = right_digit $ x - 10 ^ (num_digits x - 1)\n\nnth_digit :: (Int, Int) -> Int\nnth_digit (x, n)\n    | (n-1) <= 0 = right_digit x\n    | otherwise = nth_digit (x `div` 10, n-1)\n\nbucket :: (Int, Int, [Int]) -> [Int]\nbucket (d, n, l)\n    | null l = []\n    | nth_digit(head l, n) == d = head l : bucket (d, n, tail l)\n    | otherwise = bucket (d, n, tail l)\n\nsort_nth_digit_helper :: (Int, Int, [Int]) -> [Int]\nsort_nth_digit_helper (count, n, l)\n    | count >= 9 = []\n    | otherwise = bucket (count, n, l) ++ sort_nth_digit_helper (succ count, n, l)\n\nsort_nth_digit :: (Int, [Int]) -> [Int]\nsort_nth_digit (n, l) = sort_nth_digit_helper(0, n, l)\n\nradix_sort_max_helper :: (Int, Int, [Int]) -> [Int]\nradix_sort_max_helper (max, count, l)\n    | max+1 == count = l\n    | otherwise = radix_sort_max_helper (max, succ count, sort_nth_digit(count, l))\n\nradix_sort_max :: (Int, [Int]) -> [Int]\nradix_sort_max (max, l) = radix_sort_max_helper (max, 1, l)\n\nradix_sort :: [Int] -> [Int]\nradix_sort l = radix_sort_max (max_digits l, l)\n", "input": "42", "status": "success", "output": "2"}
{"code": "biggestInt, smallestInt :: Int\n\nbiggestInt = maxBound\nsmallestInt = minBound\n\nsumtorial :: Integer -> Integer\nsumtorial 0 = 0\nsumtorial n = n + sumtorial (n-1)\n\nhailstone :: Integer -> Integer\nhailstone n\n  | n `mod` 2 == 0 = n `div` 2\n  | otherwise      = 3*n + 1\n\nfoo :: Integer -> Integer\nfoo 0 = 16\nfoo 1\n  | \"Haskell\" > \"C++\" = 3\n  | otherwise         = 4\nfoo n\n  | n < 0             = 0\n  | n `mod` 17 == 2   = -43\n  | otherwise         = n + 3\n\nisEven :: Integer -> Bool\nisEven n\n  | n `mod` 2 == 0 = True\n  | otherwise      = False\n\np :: (Int, Char)\np = (3, 'x')\n\nsumPair :: (Int,Int) -> Int\nsumPair (x, y) = x + y\n\nf :: Int -> Int -> Int -> Int\nf x y z = x + y + z\nex17 = f 3 17 8 :: Int\n\nnums, range, range2, range3, range20, range7 :: [Integer]\nnums = [1,2,3,19]\nrange = [1..100]\nrange2 = [2,6..100]\nrange3 = [3,8..20]\nrange20 = [20, 19..1]\nrange7 = [7,9..100] \n\nhello1 :: [Char]\nhello1 = ['h','e','l','l','o']\n\nhello2 :: String\nhello2 = \"hello\"\n\nhelloSame = hello1 == hello2\n\nhailstoneSeq :: Integer -> [Integer]\nhailstoneSeq 1 = [1]\nhailstoneSeq n = n : hailstoneSeq (hailstone n)\n\nintListLength :: [Integer] -> Integer\nintListLength []     = 0\nintListLength (x:xs) = 1 + intListLength xs\n\nsumEveryTwo :: [Integer] -> [Integer]\nsumEveryTwo []         = []\nsumEveryTwo (x:[])     = [x]\nsumEveryTwo (x:(y:zs)) = (x + y) : sumEveryTwo zs\n\nhailstoneLen :: Integer -> Integer\nhailstoneLen n = intListLength (hailstoneSeq n) -1\n", "input": "42", "status": "success", "output": "903"}
{"code": "{--\r\n - Problem 41\r\n(**) Given a range of integers by its lower and upper limit, print a list of all even numbers and their\r\n    Goldbach composition.\r\n    In most cases, if an even number is written as the sum of two prime numbers, one of them is very small.\r\n    Very rarely, the primes are both bigger than say 50. Try to find out how many such cases there are in the\r\n    range 2..3000.\r\n\r\n    Example:\r\n    * (goldbach\u2010list 9 20)\r\n    10 = 3 + 7\r\n    12 = 5 + 7\r\n    14 = 3 + 11\r\n    16 = 3 + 13\r\n    18 = 5 + 13\r\n    20 = 3 + 17\r\n    * (goldbach\u2010list 1 2000 50)\r\n    992 = 73 + 919\r\n    1382 = 61 + 1321\r\n    1856 = 67 + 1789\r\n    1928 = 61 + 1867\r\n    \r\n    Example in Haskell:\r\n    *Exercises> goldbachList 9 20\r\n    [(3,7),(5,7),(3,11),(3,13),(5,13),(3,17)]\r\n    *Exercises> goldbachList' 4 2000 50\r\n    [(73,919),(61,1321),(67,1789),(61,1867)]\r\n --}\r\n\r\nisPrime :: Int -> Bool\r\nisPrime 1 = False\r\nisPrime n = 0 `notElem` map (n `mod`) [2, 3 .. m]\r\n    where m = floor . sqrt $ fromIntegral n \r\n\r\ngoldbach :: Int -> [(Int, Int)]\r\ngoldbach n = map (\\k -> (k, n-k)) $ filter (\\a -> isPrime a && isPrime (n-a)) [2 .. (n `quot` 2)]\r\n\r\ngoldbachList :: Int -> Int -> [(Int, Int)]\r\ngoldbachList l r = map (head . goldbach) $ filter even [l .. r]\r\n\r\ngoldbachList' :: Int -> Int -> Int -> [(Int, Int)]\r\ngoldbachList' l r start = map head $ filter (not . null) $ map (filter (\\a -> fst a >= start) . goldbach) $ filter even [l .. r]\r\n", "input": "42", "status": "success", "output": "False"}
{"code": "import Data.Char\nimport Data.List\nimport Data.Ord\n\nsumEven :: [Integer] -> Integer\nsumEven = sum . map snd . filter (even . fst) . zip [0..]\n\nfilterWords :: [String] -> String -> String\nfilterWords ws = unwords . filter (`notElem` ws) . words\n\ninitials3 :: String -> (String -> Bool) -> String -> String\ninitials3 d p = intercalate d . map ((:[]) . toUpper . head) . filter p . words\n\nmaxDiff :: [Int] -> Int\nmaxDiff xs@(_:y) = maximum . map (abs . (uncurry (-))) $ zip xs y\n\nstudentsPassed :: [(String, Double)] -> [String]\nstudentsPassed xs = map fst $ filter ((>= pola_m) . snd) xs\n  where pola_m = realToFrac(maximum $ map snd xs) / 2\n  \nisTitleCased :: String -> Bool\nisTitleCased xs = and . map (isUpper . head) $ words xs\n\nsortPairs :: Ord b => [(a, b)] -> [(a,b)]\nsortPairs = sortBy (comparing snd)\n\nfilename :: String -> String\nfilename xs = reverse $ take 9 $ reverse xs\n\nmaxElemIndices :: Ord a => [a] -> [Int]\nmaxElemIndices xs = map snd $ filter (\\x -> fst x == max) $ zip xs [0..]\n  where max = maximum xs\n\nelem' :: Eq a => a -> [a] -> Bool\nelem' y = foldr (\\x a -> x == y || a) False\n\nreverse' :: [a] -> [a]\nreverse' = foldr (\\x a -> a ++ [x]) []\n\nnubRuns :: Eq a => [a] -> [a]\nnubRuns xs =\n  foldr (\\x a@(y:ys) -> if x == y then a else x:a) [last xs] (init xs)\n  \nreverse'' :: [a] -> [a]\nreverse'' = foldl (\\a x -> x:a) []\n\nsumEven' :: [Int] -> Int\nsumEven' = foldl (\\a (x,y) -> if even x then a + y else a) 0 . zip [0..]", "input": "[42, 42]", "status": "success", "output": "42"}
{"code": "import qualified Data.ByteString.Lazy.Char8 as BS8\nimport qualified Data.ByteString.Lazy as BS\nimport Data.Word\nimport Data.Bits(shift)\n\ndata ETerm = SmallIntegerExt Int\n             | IntegerExt Int\n             deriving (Show)\n\nload_bytes = BS.readFile\n\nsample_small_int =\n    BS.pack x\n  where x = [131 :: Word8, 97 :: Word8, 4 :: Word8]\n\nsample_int =\n    BS.pack x\n  where x = [131 :: Word8, 98 :: Word8, 0 :: Word8, 18 :: Word8, 216 :: Word8, 217 :: Word8]\n\nterm_decode0 :: [Char] -> (Char, [Char])\nterm_decode0 (x:xs) = (x, xs)\n\nterm_decode :: BS.ByteString -> Maybe ETerm\nterm_decode term =\n    case fromIntegral tag :: Int of\n      97 -> Just $ parse_small_int rest\n      98 -> Just $ parse_int rest\n      _ -> Nothing\n  where term' = BS.unpack term\n        (131:tag:rest) = term'\n  -- where 131 = BS.head term\n  --       tag = BS.head $ BS.tail term\n  --       rest = BS.unpack $ BS.tail $ BS.tail term\n--  where (131:tag:rest) = term\n\n-- DONE: assert \"\" == BS.tail(xs)\n-- TODO: how to handle non exhaustive case?\n-- parse_small_int :: [Word8] -> Maybe ETerm\nparse_small_int :: [Word8] -> ETerm\nparse_small_int (x:[]) =\n    SmallIntegerExt $ fromIntegral x\n-- parse_small_int _ = Nothing\n\nparse_int :: [Word8] -> ETerm\nparse_int xs =\n  IntegerExt $ bytes_to_int xs\n\nbytes_to_int :: [Word8] -> Int\nbytes_to_int [] = 0\nbytes_to_int (x:xs) =\n    x' `shift` width + bytes_to_int(xs)\n  where width = length(xs) * 8\n        x' = fromIntegral x\n", "input": "['a', 'a']", "status": "success", "output": "('a',\"a\")"}
{"code": "scoreToLetter :: Int -> Char\nscoreToLetter n\n    | n > 90 = 'A'\n    | n > 80 = 'B'\n    | n > 70 = 'C'\n    | otherwise = 'F'\n\nlen [] = 0\nlen (x:s) = 1 + len s\n\nlistCopy [] = []\nlistCopy (x:s) = x : listCopy s\n\nones = 1 : ones\ntwos = 2 : twos\n\nlists = [ones, twos]\n\nfront :: Int -> [a] -> [a]\nfront _ [] = []\nfront 0 (x:s) = []\nfront n (x:s) = x : front (n-1) s\n\ntB :: [String] -> [Int] -> [(String, Int)]\ntB [] _ = []\ntB (f:fs) (b:bs) = (f,b) : tB fs bs\n\ntimeBonuses finishers =\n  tB finishers ([20, 12, 8] ++ cycle[0])\n\nzipOp :: (a -> b -> c) -> [a] -> [b] -> [c]\nzipOp f [] _ = []\nzipOp f _ [] = []\nzipOp f (a:as) (b:bs) = (f a b) : zipOp f as bs\n                        \nmyZip = zipOp (\\ a b -> (a,b))\n\nseed = [1, 1]\nouput = zipOp (+) seed (tail seed)\n        \nfibs = 1 : 1 : zipOp (+) fibs (tail fibs)\n\ntype Identifier = String\ntype Value = Int\n\ntype Env = [(Identifier, Value)]\ndata WAE = Num Int\n         | Add WAE WAE\n         | Id Identifier\n         | With Identifier WAE WAE\n\nmlookup :: Identifier -> Env -> Value\nmlookup var ((i,v):r)\n  | (var == i) = v\n  | otherwise = mlookup var r\n\nextend :: Env -> Identifier -> Value -> Env\nextend env i v = (i,v):env\n\n--interp :: WAE -> Env -> Value\ninterp (Num n) env = n\ninterp (Add lhs rhs) env = interp lhs env + interp rhs env\ninterp (Id i) env = mlookup i env\ninterp (With bound_id named_expr bound_body) env =\n           interp bound_body\n           (extend env bound_id (interp named_expr env))\n", "input": "42", "status": "success", "output": "'F'"}
{"code": "-- misc.hs\n-- Demontrates miscellaneous concepts of Haskell\n\n-- newtype can have only a single value constructor taking a single\n-- type(more formally only one field inside the constructor). newtype creates a\n-- strict value constructor and type creates a lazy one. \nimport Data.List\n\nnewtype Natural = Natural Integer\n  deriving (Show, Ord, Eq)\n\n-- Num class in not automatic derivable. We need to manually derive it.\n\ntoNatural :: Integer -> Natural\ntoNatural x | x < 0 = error \"Can't convert a negative number\"\n            | otherwise = Natural x\n\nfromNatural :: Natural -> Integer\nfromNatural (Natural n) = n\n\n-- Manual Derivation of Num class\n\ninstance Num Natural where\n  fromInteger = toNatural\n  x + y = toNatural (fromNatural x + fromNatural y)\n  x - y = let r = fromNatural x - fromNatural y\n          in if r < 0\n             then error \"Can't Subtract\"\n             else toNatural r\n\n  x * y = toNatural (fromNatural x * fromNatural y)\n  abs = undefined\n  signum = undefined\n\ndata MCmplx = MCmplx {getReal, getImg :: Float}\n  deriving (Show)\nabsPoint :: MCmplx -> Float\nabsPoint x = sqrt $ getReal x * getReal x + getImg x * getImg x\n\np = MCmplx 4 5\nq = p{getReal=10}\n\n-- getReal, getImg share top level namespace\n\ndata T = C1 {f :: Int, y :: Int}\n  | C2 {f :: Int, g :: Int}\n    deriving (Show)\n\na = C1 3 5              -- Declaration of a\n\nc = Natural 4\n-- Data Structures in Haskell are lazy i.e. components are not evaluated until needed.\n\n", "input": "42", "status": "success", "output": "Natural 42"}
{"code": "-- Exercise 1\n-- p stands for partition\n-- q stands for partition by\n-- d stands for decrement\n-- b stands for by\n-- y is \n\nimport Data.List\nimport Data.Ord\n\nskips a = map (p a) [0 .. length a - 1]\np y b = q y b\n  where q [] _ = []\n        q (x:y) 0 = [x] ++ q y b\n        q (x:y) z = q y $ z - 1\n\n-- Exercise 2\n\n-- f is a helper function that's shorter for recursion.\n-- tail is a safe operation here since if it matches, a tail exists.\n-- If a is less than b, and b is greater than c, then it is a local maximum.\nlocalMaxima :: [Integer] -> [Integer]\nlocalMaxima a = f a\n  where f z@(a:b:c:y) = if a < b && b > c\n                        then [b] ++ f (tail z)\n                        else f (tail z)\n        f _ = []\n\n-- Exercise 3\n-- g adds 1 through 9 to the list, and then sorts and groups it\n-- r takes a list of Integer and turns it into the horizontal equivalent\n-- l is a fn that returns the longest string from a list of strings\n-- p is a fn that pads a string a with spaces, to be b chars long.\nhistogram :: [Integer] -> String\nhistogram b = let q = map r $ g b\n                  l = maximumBy (comparing length) q\n                  p b a = if length a < b\n                          then p b (a ++ \" \")\n                          else a\n              in unlines $ reverse $ transpose $ map (p (length l)) q \ng :: [Integer] -> [[Integer]]\ng a = group . sort $ [1..9] ++ a\nr :: [Integer] -> String\nr z@(a:y) = (show a) ++ \"=\" ++ map (\\_-> '*') y\n\n\n", "input": "[42, 42]", "status": "success", "output": "[]"}
{"code": "\n\n\n\nl = [1,2,4,5,6,7]\n\n\naddone :: Integer -> Integer\naddone = (\\x -> x+1)\n\n\ng( x, y)  = x^2 + 5*y +3\n\n\n{-\n - 7.8 exercises\n -\n -\n -}\n\n\nmf0 :: (a -> b) -> (a -> Bool) -> [a] -> [b]\n\nmf0 f p xs = op\n             where op = [f x | x<-xs , p x]\n\n\nmf1 :: (a -> b) -> (a -> Bool) -> [a] -> [b]\n\nmf1 f p xs = map f (filter p xs)\n\n\n\nall0 :: (a -> Bool) -> [a] -> Bool\nall0 p (x:xs) | null xs   = p x \n              | otherwise = p x && all0 p xs\n\n\nany0 :: (a->Bool) -> [a] -> Bool\nany0 p (x:xs)  | null xs   = p x\n               | otherwise = p x || any0 p xs\n\nall1 p xs = bc p xs (&&)\nany1 p xs = bc p xs (||)\n            \nbc :: (a->Bool) -> [a] -> (Bool -> Bool ->Bool) -> Bool\n\nbc p (x:xs) c | null xs   = p x\n              | otherwise = c (p x) (bc p xs c)\n\n\n\ntakeWhile0 :: (a -> Bool) -> [a] -> [a]\n\ntakeWhile0 p (x:xs) | p x       = x : takeWhile0 p xs\n                    | otherwise = []\n\ndropWhile0 :: (a->Bool) -> [a] -> [a]\n\ndropWhile0 p (x:xs) | p x       = dropWhile0 p xs\n                    | otherwise = x : xs\n\n\n\nmap0 :: (a -> b) -> [a] -> [b]\n\nmap0 f xs = foldr (\\y ys -> f y : ys ) [] xs\n\n\nfilter0 :: (a -> Bool) -> [a] -> [a]\n\n-- | making a list and concatenating isn't very slick\n-- \nfilter0 p xs = foldr (\\y ys -> [a | a <- [y], p y ] ++ ys) [] xs\n\ndec2Int :: [Int] -> Int \ndec2Int xs = foldl (\\c x -> c*10  +x) 0 xs\n\n\n\ncurry0 ::  ((a,b) -> c) -> a -> b -> c\ncurry0 f  = (\\x y -> f(x,y))\n\n\nuncurry0 :: (a -> b -> c) -> (a,b) -> c\n\nuncurry0 f = (\\(x,y) -> f x y)\n\n\n", "input": "42", "status": "success", "output": "43"}
{"code": "import Data.List\n\n-- Exercise 1 \nfun1 :: [Integer] -> Integer\nfun1 []     = 1\nfun1 (x:xs)\n    | even x    = (x - 2)*fun1 xs\n    | otherwise = fun1 xs\n\nfun1' :: [Integer] -> Integer\nfun1' = product . map (\\x -> x - 2) . filter even\n\nfun2 :: Integer -> Integer\nfun2 1 = 0\nfun2 n \n    | even n    = n + fun2 (n `div` 2)\n    | otherwise = fun2 (3*n + 1)\n\nfun2' :: Integer -> Integer\nfun2' = sum . filter even . takeWhile (/=1) .iterate (\\n -> if even n then n `div` 2 else 3 * n + 1)\n\n-- Exercise 2\ndata Tree a = Leaf\n            | Node Integer (Tree a) a (Tree a)\n  deriving (Show, Eq)\n\nheightTree :: Tree a -> Integer\nheightTree Leaf = -1\nheightTree (Node h _ _ _) = h\n\ninsertTree :: a -> Tree a -> Tree a\n-- insert a into tree keeping it balanced\ninsertTree x Leaf = Node 0 Leaf x Leaf\ninsertTree x (Node h left v right)\n  | hL > hR   = Node h left v (insertTree x right)\n  | hL < hR   = Node h (insertTree x left) v right\n  | otherwise = Node (hL'+1) (insertTree x left) v right\n  where hR    = heightTree right\n        hL    = heightTree left\n        left' = insertTree x left\n        hL'   = heightTree left' \n    \nfoldTree :: [a] -> Tree a\nfoldTree = foldr insertTree Leaf\n\n-- Exercise 3\n\nxor :: [Bool] -> Bool\nxor = odd . length . filter id\n\nmap' :: (a -> b) -> [a] -> [b]\nmap' f = foldr (\\x y -> (f x):y) []\n\n-- Exercise 4\nsieveSundaram :: Integer -> [Integer]\nsieveSundaram n = map (\\x -> 2*x + 1) $ [1..n] \\\\ bads\n    where bads = [ i + j + 2*i*j | i <- [1..n], j <- [1..n]]\n\n\n", "input": "[42, 42]", "status": "success", "output": "1600"}
{"code": "-- Thinking Functionally with Haskell\n-- Example 1.4 (Converting number into words)\n-- \n-- Here is the first version, existing problems are:\n-- 1. sometimes we need an \"and\" (hundrend is ZERO)\n-- 2. sometimies we do not need zero\n\nimport Data.List\nimport Data.Char\n\nconvert :: Int -> String\nconvert 0 = \"zero\"\nconvert 1 = \"one\"\nconvert 2 = \"two\"\nconvert 3 = \"three\"\nconvert 4 = \"four\"\nconvert 5 = \"five\"\nconvert 6 = \"six\"\nconvert 7 = \"seven\"\nconvert 8 = \"eight\"\nconvert 9 = \"nine\"\nconvert 10 = \"ten\"\nconvert 11 = \"eleven\"\nconvert 12 = \"twelve\"\nconvert 13 = \"thirteen\"\nconvert 14 = \"fourteen\"\nconvert 15 = \"fifteen\"\nconvert 16 = \"sixteen\"\nconvert 17 = \"seventeen\"\nconvert 18 = \"eighteen\"\nconvert 19 = \"nineteen\"\nconvert 20 = \"twenty\"\nconvert 30 = \"thirty\"\nconvert 40 = \"forty\"\nconvert 50 = \"fifty\"\nconvert 60 = \"sixty\"\nconvert 70 = \"seventy\"\nconvert 80 = \"eighty\"\nconvert 90 = \"ninety\"\nconvert x \n    | x < 100 = convert (x - rem10) ++ \"-\" ++ (convert rem10)\n    | x < 1000 = convert (x `div` 100) ++ \" hundred\" ++ \n                 (if rem100 == 0 \n                     then \"\" \n                    else \" and \" ++ convert rem100)\n    | x < 1000000 = convert (x `div` 1000) ++ \" thousand\" ++ \n                    (if rem1000 == 0 then \"\"\n                        else if rem1000 < 100 then \" and \" ++ convert rem1000\n                        else \" \" ++ convert rem1000)\n    | otherwise = show x\n    where rem10 = x `mod` 10\n          rem100 = x `mod` 100\n          rem1000 = x `mod` 1000", "input": "42", "status": "success", "output": "\"forty-two\""}
{"code": "-- Elementary Haskell/List processing\n-- https://en.wikibooks.org/wiki/Haskell/List_processing\n\n-- Recursive definition of and\nandR :: [Bool] -> Bool\n-- andR (x:xs) = if x then andR xs else False\nandR (x:xs)\n    | x         = andR xs\n    | otherwise = False\nandR []     = True\n\n-- Fold definition of and\nandF :: [Bool] -> Bool\n-- andF xs = foldr (&&) True xs\nandF = foldr (&&) True              -- point free style!\n\n-- Not sure what this does\nhmm xs = foldr (id) True xs\n\n-- Recursive definition of or\norR :: [Bool] -> Bool\norR (x:xs) =\n    if x\n        then True\n        else\n            orR xs\norR [] = False\n\n-- Fold definition of or\norF :: [Bool] -> Bool\norF = foldr (||) False\n\n-- Evaluate to true if all elements in xs are distinct\ndistinct :: Eq a => [a] -> Bool\ndistinct (x:xs) = and (map (x/=) xs) && distinct xs\ndistinct [] = True\n\n-- Filter xs by whether each element is divisible by n\nreturnDivisible :: Int -> [Int] -> [Int]\nreturnDivisible n xs = [ x | x <- xs, x `mod` n == 0]\n\n-- For each list in a list of lists, include the tail of the list if the first\n-- element is greater than 5\ntailHeadGT5 :: [[Int]] -> [[Int]]\ntailHeadGT5 listxs = [ tail xs | xs <- listxs, head xs > 5 ]\n\n-- Recursive definition of scan\nscanlR :: (b -> a -> b) -> b -> [a] -> [b]\nscanlR f i (x:xs) = i : scanlR f (f i x) xs\nscanlR _ i [] = [i]\n\n-- scanlF :: (b -> a -> b) -> b -> [a] -> [b]\n-- scanlF f i xs =\n\n-- Compute a list of the 1..nth factorial\nfactList :: Integer -> [Integer]\nfactList n = scanl1 (*) [1..n]\n\n", "input": "[True, True]", "status": "success", "output": "True"}
{"code": "-- Caeser cipher example from chapter 5 of Programming in Haskell,\n-- Graham Hutton, Cambridge University Press, 2016.\n\nimport Data.Char\n\n-- Encoding and decoding\n\nlet2int :: Char -> Int\nlet2int c = ord c - ord 'a'\n\nint2let :: Int -> Char\nint2let n = chr (ord 'a' + n)\n\nshift :: Int -> Char -> Char\nshift n c | isLower c = int2let ((let2int c + n) `mod` 26)\n          | otherwise = c\n\nencode :: Int -> String -> String\nencode n xs = [shift n x | x <- xs]\n\n-- Frequency analysis\n\ntable :: [Float]\ntable = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0,\n         0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0,\n         6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1]\n\nlowers :: String -> Int\nlowers xs = length [x | x <- xs, x >= 'a' && x <= 'z']\n\ncount :: Char -> String -> Int\ncount x xs = length [x' | x' <- xs, x == x']\n\npercent :: Int -> Int -> Float\npercent n m = (fromIntegral n / fromIntegral m) * 100\n\nfreqs :: String -> [Float]\nfreqs xs = [percent (count x xs) n | x <- ['a'..'z']]\n           where n = lowers xs\n\nchisqr :: [Float] -> [Float] -> Float\nchisqr os es = sum [((o-e)^2)/e | (o,e) <- zip os es]\n\nrotate :: Int -> [a] -> [a]\nrotate n xs = drop n xs ++ take n xs\n\npositions :: Eq a => a -> [a] -> [Int]\npositions x xs = [i | (x',i) <- zip xs [0..n], x == x']\n                 where n = length xs - 1\n\ncrack :: String -> String\ncrack xs = encode (-factor) xs\n           where\n              factor = head (positions (minimum chitab) chitab)\n              chitab = [chisqr (rotate n table') table | n <- [0..25]]\n              table' = freqs xs\n", "input": "'a'", "status": "success", "output": "0"}
{"code": "-- Prelude: is a module with a bunch of standard definitions that gets implicitly imported into every Haskell program.\n-- filter\n-- map\n-- the Data.List module contains many more list functions still.\n\n-- Now, \"Maybe\" maybe makes more sense.\n-- data Maybe a = Nothing | Just a\n-- Also Data.Maybe module has utilities to work with the type \"Maybe\".\n\n-- head tail init last (!!)\n\n-- and Empty list as an input crashes head (i.e. `head` is a \"partial\" function)\n-- if it could have worked for any input, then it would have been a \"total\" function.\n-- Functions that are well defined(*) for all possible inputs are called \"total\" functions.\n--\n-- (*) does not recurse indefinetely, and does not crash.\n\n-- It's better **NOT** to use partial functions, by replacing them with \"total\" functions.\n-- This is a good programming practice, not only in Haskell, but also in other languages too.\n\ndoStuff1 :: [Int] -> Int\ndoStuff1 []  = 0\ndoStuff1 [_] = 0\ndoStuff1 xs  = head xs + head (tail xs)\n\ndoStuff2 :: [Int] -> Int\ndoStuff2 []        = 0\ndoStuff2 [_]       = 0\ndoStuff2 (x1:x2:_) = x1 + x2\n\nsafeHead :: [a] -> Maybe a\nsafeHead []    = Nothing\nsafeHead (x:_) = Just x\n\nemptyStringList = \"\"\n\nsafeHeadTest = print (safeHead emptyStringList, safeHead [\"hello\"])\n\ndata NonEmptyList a = NEL a [a]\n\nnelToList :: NonEmptyList a -> [a]\nnelToList (NEL x xs) = x:xs\n\nlistToNEL :: [a] -> Maybe (NonEmptyList a)\nlistToNEL []     = Nothing\nlistToNEL (x:xs) = Just (NEL x xs)\n\nheadNEL :: NonEmptyList a -> a\nheadNEL (NEL x _) = x\n\ntailNEL :: NonEmptyList a -> [a]\ntailNEL (NEL _ xs) = xs\n", "input": "[42, 42]", "status": "success", "output": "84"}
{"code": "-- Euler discovered the remarkable quadratic formula:\n\n-- n2+n+41n2+n+41\n-- It turns out that the formula will produce 40 primes for the consecutive integer values 0\u2264n\u2264390\u2264n\u226439. However, when n=40,402+40+41=40(40+1)+41n=40,402+40+41=40(40+1)+41 is divisible by 41, and certainly when n=41,412+41+41n=41,412+41+41 is clearly divisible by 41.\n\n-- The incredible formula n2\u221279n+1601n2\u221279n+1601 was discovered, which produces 80 primes for the consecutive values 0\u2264n\u2264790\u2264n\u226479. The product of the coefficients, \u221279 and 1601, is \u2212126479.\n\n-- Considering quadratics of the form:\n\n-- n2+an+bn2+an+b, where |a|<1000|a|<1000 and |b|\u22641000|b|\u22641000\n\n-- where |n||n| is the modulus/absolute value of nn\n-- e.g. |11|=11|11|=11 and |\u22124|=4|\u22124|=4\n-- Find the product of the coefficients, aa and bb, for the quadratic expression that produces the maximum number of primes for consecutive values of nn, starting with n=0n=0.\n\n-- import Data.Numbers.Primes\nimport Data.Function (on)\nimport Data.List (maximumBy)\n\nisPrime :: Int -> Bool\nisPrime n\n    | n <= 1 = False\n    | n == 2 = True\n    | n `rem` 2 == 0 = False\n    | otherwise  = null [x | x <- [3,5..limit], n `rem` x == 0]\n        where limit = floor . sqrt . fromIntegral $ n\n\nthird(_, _, x) = x\nformula n a b = n^2 + a*n + b\n\nformulaResults a b = map (\\x -> formula x a b) [0..] \nprimeIndex a b = length (takeWhile isPrime (formulaResults a b))\ngoodVariants = filter (\\x-> third x > 40) [(x, y, primeIndex x y) | x <- [-1000..1000], y <-[-1000..1000]]\n\nresult = maximumBy (compare `on` third) goodVariants \n", "input": "42", "status": "success", "output": "False"}
{"code": "{-\n\tRecursion examples.\n-}\n\nmaximum' :: [Int] -> Int\nmaximum' [] = error \"List is empty\"\nmaximum' [x] = x\nmaximum' (x:xs)\n\t| x > maxTail = x\n\t| otherwise = maxTail\n\twhere maxTail = maximum' xs\n\n\n{-\nReplicate function that replicates the number into a list number of times\nexample replicate' 5 3 => [5,5,5]\n-}\n\nreplicate' :: Int -> Int -> [Int]\nreplicate' num times \n\t| times <= 0 = []\n\t| otherwise = num : replicate' num (times -1)\n\n{-\nTake function , \n\nreturns that many values from the list, \n-}\n\ntake' :: (Integral a) => [a] -> a -> [a]\ntake' [] a = []\ntake' (x:xs) times\n\t| times == 0 = []\n\t| otherwise = x : take' xs (times - 1)\n\n{-\n\tReverse the array\n-}\n\nreverse' :: (Ord a) => [a] -> [a]\nreverse' [] = []\nreverse' (x:xs) = reverse' xs ++ [x]\n\n\n{-\nCheck if the element exists' in the List\n-}\n\nexists' :: (Ord a) => [a] -> a -> Bool\nexists' [] num = False\nexists' (x:xs) num\n\t| x == num = True\n\t| otherwise = exists' xs num\n\n{-\nGrep the list using two indexes\nexample grep' start end ::  grep' [1,2,4,6] 1 1 => [2]\n-}\n\ngrepNew :: [Int] -> Int -> Int -> [Int]\ngrepNew [] a b = []\ngrepNew [a] _ 0 = []\ngrepNew xs str end\n\t| str > length xs - 1 = [] \n\t| str > end = []\n\t| otherwise = (xs !! str) : (grepNew xs (str + 1) end)\n\n\n{-Filters the largest even in the list-}\n\nfilterLargestEven :: [Int] -> Int\nfilterLargestEven [a] = a\nfilterLargestEven (x:xs)\n\t| ( even x ) &&  ( x > filterLargestEven xs) = x\n\t| otherwise = filterLargestEven xs\n\n\n\ngetHighestPower fn [a] = a\ngetHighestPower fn (x:xs)\n\t| (fn x) > fn (getHighestPower fn xs) = x\n\t| otherwise = getHighestPower fn xs\n\n", "input": "[42, 42]", "status": "success", "output": "42"}
{"code": "\n-- inbuilt types\n-- :t gives the type of a var\n\n--Functions also have types. \n--When writing our own functions, we can choose to give them an explicit type declaration. \n--This is generally considered to be good practice except when writing very short functions. \n--From here on, we'll give all the functions that we make type declarations. \n\nimport Data.Char (toLower)\nconvertToLower :: [Char] -> [Char] \nconvertToLower x = [ toLower c | c <- x ]\n\n--Typeclasses 101\n--A typeclass is a sort of interface that defines some behavior. \n--If a type is a part of a typeclass, that means that it supports and implements the behavior the typeclass describes. \n--A lot of people coming from OOP get confused by typeclasses because they think \n--they are like classes in object oriented languages. Well, they're not. \n--You can think of them kind of as Java interfaces, only better.\n--ghci :t (+)\n-- (+) :: Num a => a -> a -> a\n\n-- User defined types\n-- https://www.haskell.org/tutorial/goodies.html\n\ndata Color    = Red | Green | Blue | Indigo | Violet\n\nprint_color :: Color -> [Char]\n\nprint_color Red = \"chumapu\"\nprint_color Green = \"pacha\"\nprint_color Blue = \"neela\"\nprint_color Indigo = \"koppu\"\nprint_color Violet = \"arinjuda\"\n\ndata Shape = Circle Float Float Float | Rectangle Float Float Float Float\nsurface :: Shape -> Float\nsurface (Circle _ _ r) = pi * r ^ 2  \nsurface (Rectangle x1 y1 x2 y2) = (abs $ x2 - x1) * (abs $ y2 - y1) \n\ncircle1 = Circle 0 0 4\narea_circle1 = surface circle1\n\nprintMe :: Shape -> [Char]\nprintMe (Circle x y r) = \"A circle with center \"\n\n--center_pt :: Shape -> (Float, Float)\n", "input": "['a', 'a']", "status": "success", "output": "\"aa\""}
{"code": "-- using || && and or\n-- || && \u4e0e and or\u7684\u5b9a\u4e49\u662f\u4e0d\u4e00\u6837\u7684\uff0c\u8981\u6ce8\u610f\nusingandorinfixr = True || (False && True)\nusingandor = or [False, and [True, False]]\n\n-----------------------------------------------\nfirstOrEmpty :: [[Char]] -> [Char]\nfirstOrEmpty lst = if not (null lst) then head lst else \"empty\"\n\n(+++) :: [a] -> [a] -> [a]\nlst1 +++ lst2 = if null lst1 then lst2 else head lst1 : tail lst1 +++ lst2\n\nlist1 ++++ list2 = case list1 of\n\t\t\t[] -> list2\n\t\t\tx:xs -> x: xs ++++ list2\n\n--addv3 :: [a] -> [a] -> [a]\naddv3 [] list2 = list2\naddv3 (x:xs) list2 = x:(addv3 xs list2)\n\nreverse2 :: [a] -> [a]\nreverse2 lst = if null lst then lst else reverse2 (tail lst) +++ (head lst:[])\n\n-----------------------------------------------\nyxmaxmin :: Ord a => [a] -> (a, a)\nyxmaxmin list = let h = head list in\n\t\tif null (tail list) then (h, h)\n\t\telse if h > h_max then (h, h_min)\n\t\telse if h < h_min then (h_max, h)\n\t\telse (h_max, h_min) \n\t\twhere\n\t\t\tt = yxmaxmin (tail list)\n\t\t\th_max = fst t\n\t\t\th_min = snd t\n\nmaxmin :: Ord a => [a] -> (a, a)\nmaxmin list = let h = head list in\n\t\tif null (tail list) then (h, h)\n\t\telse (\n\t\tif h > t_max then h else t_max,\n\t\tif h < t_min then h else t_min\n\t\t)\n\t\twhere  t = maxmin (tail list); t_max = fst t; t_min = snd t\n\n--yxversion\nfibonacci 0 = 0\nfibonacci 1 = 1\nfibonacci n = fibonacci ( n - 1) + (fibonacci ( n - 2))\n\n--pattern marching and guard\nmfibonacci 0 = 0\nmfibonacci 1 = 1\nmfibonacci n | otherwise = let (f1, f2) = ( mfibonacci (n-1), mfibonacci (n-2)) in (f1 + f2)\n\n--just guard\nmmfib n\n\t| n == 0 = 0\n\t| n == 1 = 1\n\t| otherwise = mmfib(n-2) + (mmfib(n-1))\n\n\t\n", "input": "[['a', 'a'], ['a', 'a']]", "status": "success", "output": "\"aa\""}
{"code": "-- Char stands for character (ie. 'a'). A String is a list of characters\n-- So [Char] is equalant to String (ie. ['A','n','i'] == \"Ani\").\nremoveNonUpperCase :: String -> String\nremoveNonUpperCase st = [ c | c <- st, c `elem` ['A'..'Z']]\n\n-- Int stands for integer. It\u2019s used for whole numbers. 7 can be an Int but 7.2\n-- cannot. Int is bounded, which means that it has a minimum and a maximum\n-- value. Usually on 32-bit machines the maximum possible Int is 2147483647\n-- and the minimum is -2147483648. On 64-bit it's 9223372036854775807 to\n-- -9223372036854775808\naddThree :: Int -> Int -> Int -> Int\naddThree x y z = x + y + z\n\n-- Integer\n-- stands for, er... also integer. The main difference is that it\u2019s not\n-- bounded so it can be used to represent really really big numbers. I mean like\n-- really big. Int, however, is more efficient.\nfactorial :: Integer -> Integer\nfactorial n = product [1..n]\n\n-- Float is a real floating point with single precision.\ncircumference :: Float -> Float\ncircumference r = 2 * pi * r\n\n-- Double is a real floating point with double the precision\ncircumference' :: Double -> Double\ncircumference' r = 2 * pi * r\n\n-- Bool is a boolean type. It can have only two values: True and False.\n-- Char represents a character. It\u2019s denoted by single quotes. A list of characters is a string.\n\n-- Tuples are types but they are dependent on their length as well as the\n-- types of their components, so there is theoretically an infinite number of tuple\n-- types, which is too many to cover in this tutorial. Note that the empty tuple\n-- () is also a type which can only have a single value: ()\n", "input": "\"hello\"", "status": "success", "output": "\"\""}
{"code": "-- Exercise 1\nfun1 :: [Integer] -> Integer\nfun1 [] = 1\nfun1 (x:xs)\n  | even x = (x - 2) * fun1 xs\n  | otherwise = fun1 xs\n\nfun1' :: [Integer] -> Integer\nfun1' = product . map (subtract 2) . filter even\n\nfun2 :: Integer -> Integer\nfun2 1 = 0\nfun2 n\n  | even n = n + fun2 (n `div` 2)\n  | otherwise = fun2 (3 * n + 1)\n\nfun2' :: Integer -> Integer\nfun2' n = sum $ filter even $ takeWhile (/= 1) $ iterate step n\n\nstep :: Integer -> Integer\nstep n\n  | even n = (div n 2)\n  | otherwise =  (3 * n + 1)\n\n-- Exercise 2\ndata Tree a = Leaf\n            | Node Integer (Tree a) a (Tree a)\n              deriving (Show, Eq)\n\n-- I found this solution online, but it doesn't seem to actually work\n-- correctly.\n\nfoldTree :: [a] -> Tree a\nfoldTree = foldr insertTree Leaf\n\ninsertTree :: a -> Tree a -> Tree a\ninsertTree elem Leaf = (Node 0 Leaf elem Leaf)\ninsertTree insertElem (Node depth l elem r)\n  | hl < hr = Node hl (insertTree insertElem l) elem r\n  | hl > hr = Node hr l elem r\n  | otherwise = Node (hr2 + 1) l elem r2\n  where\n    hl = heightTree l\n    hr = heightTree r\n    r2 = insertTree insertElem r\n    hr2 = heightTree r2\n\nheightTree :: Tree a -> Integer\nheightTree Leaf = 0\nheightTree (Node depth _ _ _) = depth\n              \n\n-- Exercise 3\n\n-- 1\nxor :: [Bool] -> Bool\nxor [True, False] = True\nxor [False, True] = True\nxor [_,_] = False\nxor xs = foldr (\\x y -> xor [x, y]) False xs\n-- I personally like this solution without a fold much better, but\n-- this isn't the point of the exercise\n\n--xor = odd . length . filter (==True)\n\n-- 2\nmap' :: (a -> b) -> [a] -> [b]\nmap' f = foldr (\\x acc -> f x : acc) []\n\n-- 3\n-- Maybe do later.\n", "input": "[42, 42]", "status": "success", "output": "1600"}
{"code": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntwo = 2\n\npie = 3.14159\n\nname = \"haskell\"\n\n\nfullname = forename ++ surname\nforename = \"Haskell \"\nsurname  = \"Curry\"\nnamelen  = length fullname\n\n\n\n\nunknown  = unknown\ninfinity = infinity + 1\ninsanity = unknown * infinity\n\none = two\ntwo2 = one\n\nsleep = \"sheep\" ++ sleep\n\nw = length sleep\nx = length [sleep]\ny = length [insanity]\nz = length [one,two]\n\n\n\n\n\n\n\n\n\n\n\naddOne :: Int -> Int\naddOne x = x+1\n\ntimesTwo :: Int -> Int\ntimesTwo x = x * 2\n\ndoublePlusOne :: Int -> Int\ndoublePlusOne x = addOne (timesTwo x)\n\nlargerOf2 :: Int -> Int -> Int\nlargerOf2 x y = if x > y then x else y\n\nlargerOf3 :: Int -> Int -> Int -> Int\nlargerOf3 a b c = largerOf2 a (largerOf2 b c)\n\nsumTo :: Int -> Int\nsumTo n = sum [1..n]\n\ncountWords :: String -> Int\ncountWords str = length (words str)\n\n\n\n\n\n\n\n\ndouble x    = x + x\n\nquadruple x = double (double x)\n\nfactorial n = product [1..n]\n\naverage ns  = sum ns `div` length ns\n\naverage' fs = sum fs / fromIntegral(length fs)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nn :: Int\nn = a `div` length xs\n        where a  = 10\n              xs = [1,2,3,4,5]\n              \n\nlast2 :: [a] -> a\nlast2 []     = error \"empty list\"\nlast2 [x]    = x\nlast2 (x:xs) = last2 xs\n\nlast3 :: (Eq a) => [a] -> a\nlast3 xs | xs == []       = error \"empty list\"\n         | length xs >  1 = last3 (tail xs)\n         | length xs == 1 = head xs\n\n\n\n\n\n\ninit2 :: [a] -> [a]\ninit2 []       = error \"empty list\"\ninit2 [x]      = []\ninit2 (x:xs)   = x : init2 xs\n\ninit3 :: (Eq a) => [a] -> [a]\ninit3 xs | xs == []        = error \"empty list\"  \n         | length xs == 1  = []\n         | otherwise       = head xs : init3 (tail xs)", "input": "42", "status": "success", "output": "43"}
{"code": "import Data.Char\n\nfUp :: String -> String\nfUp a = filter isUpper a\n\ntitle :: String -> String\ntitle [] = []\ntitle (x:xs) = toUpper x : title xs\n\nhUp :: String -> Char\nhUp (x:xs) = toUpper x\n\nhUp2 :: String -> Char\nhUp2 = toUpper . head\n\nhUp3 :: String -> String\nhUp3 = map toUpper\n\nmyOr :: [Bool] -> Bool\nmyOr [] = False\nmyOr (x:xs) = if x then True else myOr xs\n\nmyAny :: (a -> Bool) -> [a] -> Bool\nmyAny f [] = False\nmyAny f (x:xs) = if f x then True else myAny f xs\n\nmyElem :: Eq a => a -> [a] -> Bool\nmyElem x (y:[]) = x == y\nmyElem x (y:ys) = myElem x [y] || myElem x ys\n\nmyReverse :: [a] -> [a]\nmyReverse (x:[]) = [x]\nmyReverse (x:xs) = myReverse xs ++ [x]\n\nsquish :: [[a]] -> [a]\nsquish (x:[]) = x\nsquish (x:xs) = x ++ squish xs\n\nsquishMap :: (a -> [b]) -> [a] -> [b]\nsquishMap f (x:[]) = f x\nsquishMap f (x:xs) = f x ++ squishMap f xs\n\nsquishAgain :: [[a]] -> [a]\nsquishAgain = squishMap id\n\nmyMaximumBy :: (a -> a -> Ordering) -> [a] -> a\nmyMaximumBy f (x:[]) = x\nmyMaximumBy f' (x:xs) = go f' x xs\n    where\n      go f x (y:[])\n          | f x y == GT = x\n          | f x y == EQ = x\n          | f x y == LT = y\n      go f x (y:ys) = go f (go f x [y]) ys\n\nmyMinimumBy :: (a -> a -> Ordering) -> [a] -> a\nmyMinimumBy f (x:[]) = x\nmyMinimumBy f (x:y:[])\n    | f x y == LT = x\n    | f x y == EQ = x\n    | f x y == GT = y\nmyMinimumBy f (x:x':xs) = myMinimumBy f $ (myMinimumBy f (x:x':[])):xs\n\nmyCompare :: Ord a => [a] -> a\nmyCompare (x:[]) = x\n--myCompare (x:x':[]) = max x x'\nmyCompare (x:x':xs) = myCompare $ max x x':xs\n          \n\nmyMaximum :: (Ord a) => [a] -> a\nmyMaximum = myMaximumBy compare\n\nmyMinimum :: (Ord a) => [a] -> a\nmyMinimum = myMinimumBy compare\n\n\n", "input": "\"hello\"", "status": "success", "output": "\"\""}
{"code": "{-\nReference: \n    http://pages.pacificcoast.net/~cazelais/187/simpson.pdf:\n    http://en.wikipedia.org/wiki/Simpson%27s_rule \n\n  \n -}\nf :: Double -> Double\nf x = x\n\ng x = sqrt(1+x^3)\n\n\nintegratorSimple n f a b  = area        \n        where \n        dx  = (b - a)/n        \n        xi  = map (\\i -> a + i*dx) [0..n]\n        fxi = map f xi\n        area = dx * sum fxi\n\n        \n{- Consecutive Points Patterns\n - [(x0, x1), (x1, x2) ... (xk-1, xk)] \n -}\npairs lst = zip lst (tail lst)  \n\ntriples lst = zip3 lst (tail lst) (tail $ tail lst) \n\n\n\n{-   Trapezius Rule Integration\n -\n -}\nintegratorTrapezius n f a b = area\n        where\n        dx = (b - a)/n\n        xi  = map (\\i -> a + i*dx) [0..n]\n        fxiPairs = pairs $ map f xi\n        area =  1/2*dx * (  sum $ map (\\(a, b) -> a+b) fxiPairs)\n\n--{-\nintegratorSimpson ns f a b = area\n        where \n        n = fromIntegral ns\n        dx = (b - a)/n\n        xi  = map (\\i -> a + i*dx) [0..n]\n        fxi = map f xi\n        area2y = (*2) $ sum $ map (\\i -> fxi !! i)  (filter even [1..(ns-1)]) \n        area4y = (*4) $ sum $ map (\\i -> fxi !! i)  (filter odd  [1..(ns-1)]) \n        area = dx/3*( area2y + area4y + ( head fxi) + (last fxi))\n\n\nserieConvergence tol maxit serie = (snd converged, iterations)                    \n                    where                    \n                    testError = (\\(a, b) -> abs(a-b) > tol)\n                    sequence = take maxit $ takeWhile testError  (pairs serie) \n                    converged = last sequence\n                    iterations = length(sequence)\n     \n\ninteg1 n = integratorSimple    n g 2 6\ninteg2 n = integratorTrapezius n g 2 6\ninteg3 n = integratorSimpson   n g 2 6\n\n\n\n\n", "input": "2.71", "status": "success", "output": "2.71"}
{"code": "data Date = DMY Int Int Int\n\ninstance Show Date where\n        show (DMY d m y) = show d ++ \" \" ++ show m ++ \" \" ++ show y\n\nisLeapYear :: Int -> Bool\nisLeapYear y = y `mod` 4==0 && (y `mod` 100/=0 || y`mod`400==0)\n\nmonthLength :: Int -> Int -> Int\nmonthLength y m\n        | m==1 || m==3 || m==5 || m==7 || m==8 || m==10 || m==12 = 31\n        | m==4 || m==6 || m==9 || m==11 = 30\n        | m==2 && isLeapYear y = 29\n        | otherwise = 28\n\nmonthLengthDate :: Date -> Int\nmonthLengthDate (DMY _ m y) = monthLength y m\n\nyearLength y = if isLeapYear y then 366 else 365\n\nnextDay :: Date -> Date\nnextDay (DMY d m y) = (DMY d' m' y')\n        where lastDayMonth = (d == monthLength y m)\n              lastDayYear = (m == 12 && lastDayMonth)\n              d' = if lastDayMonth then 1 else d+1\n              m' = if lastDayYear then 1 else if lastDayMonth then m+1 else m\n              y' = if lastDayYear then y+1 else y\n\nnextMonth :: Date -> Date\nnextMonth (DMY d m y) = (DMY d' m' y')\n        where lastMonthYear = m == 12\n              d' = d\n              m' = if lastMonthYear then 1 else m+1\n              y' = if lastMonthYear then y+1 else y\n\ngenMonthlyDates :: Date -> [Date]\ngenMonthlyDates today = today : genMonthlyDates (nextMonth today)\n\ndatesToMonthLengths :: [Date] -> [Int]\ndatesToMonthLengths dates = map monthLengthDate dates\n\nshiftDay d l = (d+l) `mod` 7\n\ntheDates = takeWhile (\\(DMY _ _ y) -> y<=2000) $ genMonthlyDates (DMY 1 1 1901)\n\ntheLengths = datesToMonthLengths theDates\n\nstartDay = shiftDay 1 $ yearLength 1900\n\ncumulativeLengths = scanl (+) startDay theLengths\n\ndaysOfTheWeek = map ((flip mod) 7) cumulativeLengths\n\nnSundays = length $ filter (==0) daysOfTheWeek\n\n", "input": "42", "status": "success", "output": "False"}
{"code": "--  Double the value of every second digit beginning from the right. \n-- That is, the last digit is unchanged; the second-to-last digit is \n-- doubled; the third-to-last digit is unchanged; and so on. \n-- For example, [1,3,8,6] becomes [2,3,16,6].\n\ndoubleEveryOther :: [Integer] -> [Integer]\ndoubleEveryOther = zipWith (*) $ cycle [2,1] \n\n\n-- Add the digits of the doubled values and the undoubled digits\n-- from the original number. \n-- For example, [2,3,16,6] becomes 2+3+1+6+6 = 18.\n-- Calculate the remainder when the sum is divided by 10. \n-- For the above example, the remainder would be 8.\n-- If the result equals 0, then the number is valid.\n-- Example: isValidCardNumber 4012888888881881 = True \n-- Example: isValidCardNumber 4012888888881882 = False\nisValidCardNumber :: Integer -> Bool\nisValidCardNumber a =\n    let as = doubleEveryOther $ toDigits  a \n        digits = concatMap toDigits as \n        cardNumberSum =  sum  digits\n    in cardNumberSum `mod` 10 == 0\n\n-- We need to first find the digits of a number. Define the\n-- functions\n--  toDigits    :: Integer -> [Integer]\n--  toDigitsRev :: Integer -> [Integer]\n-- toDigits should convert positive Integers to a list of digits. \n-- (For 0 or negative inputs, toDigits should return the empty list.) \n-- toDigitsRev should do the same, but with the digits reversed.\n-- Example: toDigits 1234 == [1,2,3,4] \n-- Example: toDigitsRev 1234 == [4,3,2,1] \n-- Example: toDigits 0 == []\n-- Example: toDigits (-17) == []\n\ntoDigitsRev :: Integer -> [Integer]\ntoDigitsRev 0 = []\ntoDigitsRev n = if n < 0 \n    then [] \n    else n `mod` 10 : toDigitsRev (n `div` 10)\n\ntoDigits :: Integer -> [Integer]\ntoDigits = reverse . toDigitsRev\n\n\n", "input": "[42, 42]", "status": "success", "output": "[84,42]"}
{"code": "-- Solutions for the exercises of the SLIDES \"Programming In Haskell\" by Graham Hutton: CHAPTER 5 (List Comprehensions)\n\n{-- (1)\nA triple (x,y,z) of positive integers is called pythagorean if x^2 + y^2 = z^2.  Using a list comprehension, define a function\n\npyths :: Int -> [(Int,Int,Int)]\n\nthat maps an integer n to all such triples with components in [1..n].  For example:\n\n> pyths 5\n[(3,4,5),(4,3,5)]\n--}\n\npyths :: Int -> [(Int,Int,Int)]\npyths n = [ (x,y,n) | x <- [1..n], y <- [1..n], x^2 + y^2 == n^2 ]\n\nallPyths :: Int -> [(Int,Int,Int)]\nallPyths n = [ p | x <- [1..n], p <- pyths x]\n\n{-- (2)\nA positive integer is perfect if it equals the sum of all of its factors, excluding the number itself.  Using a list comprehension, define a function\n\nperfects :: Int -> [Int]\n\nthat returns the list of all perfect numbers up to a given limit.  For example:\n\n> perfects 500\n\n[6,28,496]\n--}\n\nfactors :: Int -> [Int]\nfactors n = [ x | x <- [1..n], n `mod` x == 0]\n\nperfects :: Int -> [Int]\nperfects n = [ x | x <- [1..n], sum (init (factors x)) == x] -- NOTE: using init to remove last element of factors which is the value x itself because x is always a factor of x (x*1)\n\n{-- (3)\nThe scalar product of two lists of integers xs and ys of length n is give by the sum of the products of the corresponding integers:\n\ni = 0 to n-1: (xs_i * ys_i)\n\nUsing a list comprehension, define a function that returns the scalar product of two lists.\n--}\n\nscalarProduct :: [Int] -> [Int] -> Int\nscalarProduct xs ys = sum [ x*y | (x, y) <- zip xs ys ] -- NOTE: need to zip because need to iterate over both by pairs. if first iterating over x and then over y then we would use a nested loop which is not what we wanted\n", "input": "42", "status": "success", "output": "[]"}
{"code": "{--\nReading Syntax\n1.\n\na) Yes\n\nPrelude> concat [[1,2,3], [4,5,6]]\n[1,2,3,4,5,6]\n\nb) No\n\nPrelude> ++ [1,2,3] [4,5,6]\n\n<interactive>:2:1: error: parse error on input \u2018++\u2019\nPrelude> (++) [1,2,3] [4,5,6]\n[1,2,3,4,5,6]\n\nc) Yes\n\nPrelude> (++) \"hello\" \" world\"\n\"hello world\"\n\nd) No\n\nPrelude> [\"hello\" ++ \" world]\n\n<interactive>:6:21: error:\n    lexical error in string/character literal at end of input\nPrelude> [\"hello\" ++ \" world\"]\n[\"hello world\"]\n\ne) No\n\nPrelude> 4 !! \"hello\"\n\n<interactive>:8:6: error:\n    \u2022 Couldn't match expected type \u2018Int\u2019 with actual type \u2018[Char]\u2019\n    \u2022 In the second argument of \u2018(!!)\u2019, namely \u2018\"hello\"\u2019\n      In the expression: 4 !! \"hello\"\n      In an equation for \u2018it\u2019: it = 4 !! \"hello\"\nPrelude> \"hello\" !! 4\n'o'\n\nf) Yes\n\nPrelude> (!!) \"hello\" 4\n'o'\n\ng) No\n\nPrelude> take \"4 lovely\"\n\n<interactive>:12:6: error:\n    \u2022 Couldn't match expected type \u2018Int\u2019 with actual type \u2018[Char]\u2019\n    \u2022 In the first argument of \u2018take\u2019, namely \u2018\"4 lovely\"\u2019\n      In the expression: take \"4 lovely\"\n      In an equation for \u2018it\u2019: it = take \"4 lovely\"\nPrelude> take 4 \"lovely\"\n\"love\"\n\nh) Yes\n\nPrelude> take 3 \"awesome\"\n\"awe\"\n\n2.\n\na) d\nb) c\nc) e\nd) a\ne) b\n\nBuilding Functions\n\n1.\n\na) flip (++) \"!\" \"Curry is awesome\"\n\nb) flip (:) [] $ flip (!!) 4 \"Curry is awesome!\"\n\nc) drop 9 \"Curry is awesome!\"\n\n--}\n\n-- 2.\n\na :: String -> String\na = flip (++) \"!\"\n\nb :: String -> String\nb s = flip (:) [] $ flip (!!) 4 s\n\nc :: String -> String\nc = drop 9\n\n-- 3\n\nthirdLetter :: String -> Char\nthirdLetter = flip (!!) 2 \n\n-- 4\n\nletterIndex :: Int -> Char\nletterIndex = (!!) \"Curry is awesome!\"\n\n-- 5\n\nrvrs :: String -> String\nrvrs s = (take 7 (drop 9 s)) ++ (take 4 (drop 5 s)) ++ (take 5 s)\n", "input": "\"hello\"", "status": "success", "output": "\"hello!\""}
{"code": "-- remove rename write\n\nimport qualified System.Directory as Dir\nimport System.IO\n-- for Windows use openBinaryFile (better portability)\n-- for Linux openFile and openBinaryFile perform the same action\n\nappTxt :: String -> String\nappTxt [] = \".txt\"\nappTxt x = x ++ \".txt\"\n\n\n-- currentDirectory Path\ncurDir :: String -> IO (FilePath)\ncurDir x = case x of\n\t\t\"curDir\" -> Dir.getCurrentDirectory\n\t\t_\t -> return (crtDir x)\n\n-- check for spaces in the directory path\ncrtDir :: String -> String\ncrtDir list = if (head list) == ' ' then checkLast (addSlash list) else checkLast (addSlash ('/':list))\n\t     \t where addSlash l = foldr (\\y x -> if y == ' ' then '/':x else y:x) [] l\n\t\t       checkLast l = if (last l) == '/' then take ((length l) - 1) l\n\t\t\t\t\t else l\n\nremoveFile :: FilePath -> FilePath -> IO()\nremoveFile dir file = do ndir <- curDir dir \n\t\t\t fex <- exists file\n\t\t\t case fex of\n\t\t\t\tTrue ->  Dir.removeFile (appTxt file) >> putStrLn \"File deleted!\"\n\t\t\t\tFalse -> putStrLn \"File doesn't exist, please try again!\"\n\n\nconsole :: IO ()\nconsole = do\n\t\tputStrLn \"Hello to Remove-Rename-Create!\"\n\t\tputStrLn \"Choose what you want to do!\"\n\t\tputStrLn \"1. Remove: <dir> <filename>\"\n\t\tputStrLn \"2. Rename: <dir> <oldFilename> <newFilename>\"\n\t\tputStrLn \"3. Create: <dir> <filename>\"\n\t\tputStrLn \"4. Create: <dir>\"\n\t\tputStrLn \"<dir> = home i isenko Desktop <==> /home/i/isenko/Desktop\"\n\t\tputStrLn \"<dir> = curDir <==> currentDirectory\"\n\t\tputStrLn \"<filename> = yourname <==> yourname.txt\"\n\t\tputStrLn \"Parsing input now:\"\n\n\n\nexists :: FilePath -> IO(Bool)\nexists file = Dir.getCurrentDirectory >>= \\curDir -> Dir.getDirectoryContents curDir >>= \\contents -> case (appTxt file) `elem` contents of\n\t\t\t\t\t\t\t\t\t\t\t\tTrue -> return True\n\t\t\t\t\t\t\t\t\t\t\t\tFalse -> return False\n\n", "input": "\"hello\"", "status": "success", "output": "\"hello.txt\""}
{"code": "import           Data.Char\n\n-- 2\nuppers :: String -> String\nuppers = filter isUpper\n\n-- 3\ncapitFirst :: String -> String\ncapitFirst \"\"     = \"\"\ncapitFirst (x:xs) = toUpper x : xs\n\n-- 4\ncapitAll :: String -> String\ncapitAll \"\"     = \"\"\ncapitAll (x:xs) = toUpper x : capitAll xs\n\n-- 5, 6\ncapitHead :: String -> Char\n-- capitHead s = toUpper (head s)\n-- capitHead s = toUpper . head $ s\ncapitHead = toUpper . head\n\n-- Ciphers - see ch09.12_cipher.hs\n\n-- Writing your own standard functions\n-- 1\nmyOr :: [Bool] -> Bool\nmyOr []     = False\nmyOr (x:xs) = x || myOr xs\n-- 2\nmyAny :: (a -> Bool) -> [a] -> Bool\nmyAny _ []     = False\nmyAny f (x:xs) = f x || myAny f xs\n-- 3\nmyElem :: Eq a => a -> [a] -> Bool\nmyElem _ []     = False\nmyElem e (x:xs) = (e == x) || myElem e xs\n-- 3'\nmyElem' :: Eq a => a -> [a] -> Bool\nmyElem' _ [] = False\nmyElem' e xs = any (== e) xs\n--4\nmyReverse :: [a] -> [a]\nmyReverse []     = []\nmyReverse (x:xs) = (myReverse xs) ++ [x]\n-- 5\nsquish :: [[a]] -> [a]\nsquish [x]    = x\nsquish (x:xs) = x ++ squish xs\n-- 6\nsquishMap :: (a -> [b]) -> [a] -> [b]\nsquishMap _ []     = []\nsquishMap f (x:xs) = f x ++ squishMap f xs\n-- 7\nsquishAgain :: [[a]] -> [a]\nsquishAgain xs = squishMap (\\x -> x) xs\n-- 8\nmyMaximumBy :: (a -> a -> Ordering) -> [a] -> a\nmyMaximumBy _ (x:[]) = x\nmyMaximumBy f (x:y:zs) =\n    case f x y of\n        GT        -> myMaximumBy f (x:zs)\n        otherwise -> myMaximumBy f (y:zs)\n-- 9\nmyMinimumBy :: (a -> a -> Ordering) -> [a] -> a\nmyMinimumBy _ (x:[]) = x\nmyMinimumBy f (x:y:zs) =\n    case f x y of\n        LT        -> myMinimumBy f (x:zs)\n        otherwise -> myMinimumBy f (y:zs)\n\nmyMaximum :: (Ord a) => [a] -> a\nmyMaximum = myMaximumBy compare\n\nmyMinimum :: (Ord a) => [a] -> a\nmyMinimum = myMinimumBy compare\n", "input": "\"hello\"", "status": "success", "output": "\"\""}
{"code": "import Data.List\r\n\r\nwordnames 1 = \"one\"\r\nwordnames 2 = \"two\"\r\nwordnames 3 = \"three\"\r\nwordnames 4 = \"four\"\r\nwordnames 5 = \"five\"\r\nwordnames 6 = \"six\"\r\nwordnames 7 = \"seven\"\r\nwordnames 8 = \"eight\"\r\nwordnames 9 = \"nine\"\r\n\r\nwordnames 11 = \"eleven\"\r\nwordnames 12 = \"twelve\"\r\nwordnames 13 = \"thirteen\"\r\nwordnames 14 = \"fourteen\"\r\nwordnames 15 = \"fifteen\"\r\nwordnames 16 = \"sixteen\"\r\nwordnames 17 = \"seventeen\"\r\nwordnames 18 = \"eighteen\"\r\nwordnames 19 = \"nineteen\"\r\n\r\nwordnames 10 = \"ten\"\r\nwordnames 20 = \"twenty\"\r\nwordnames 30 = \"thirty\"\r\nwordnames 40 = \"forty\"\r\nwordnames 50 = \"fifty\"\r\nwordnames 60 = \"sixty\"\r\nwordnames 70 = \"seventy\"\r\nwordnames 80 = \"eighty\"\r\nwordnames 90 = \"ninety\"\r\n\r\nwordnames 100 = \"onehundred\"\r\nwordnames 200 = \"twohundred\"\r\nwordnames 300 = \"threehundred\"\r\nwordnames 400 = \"fourhundred\"\r\nwordnames 500 = \"fivehundred\"\r\nwordnames 600 = \"sixhundred\"\r\nwordnames 700 = \"sevenhundred\"\r\nwordnames 800 = \"eighthundred\"\r\nwordnames 900 = \"ninehundred\"\r\nwordnames 1000 = \"onethousand\"\r\nwordnames n = \"\"\r\n\r\n\r\nto_tens :: Integer -> [Integer]\r\nto_tens 0 = []\r\nto_tens n = to_tens (n `div` 10) ++ [n `mod` 10] \r\n\r\ndecomp_word n = reverse $ zipWith (\\x y -> x*10^y ) (reverse $ to_tens n) [0..]\r\nfix_decomp [] = []\r\nfix_decomp (x:[]) = [x]\r\nfix_decomp (x:xs)\r\n\t\t\t| x>=10 && x<20 = [x + head xs]\r\n\t\t\t| otherwise = x : fix_decomp xs\r\n\r\ndecompose_word n = fix_decomp $ decomp_word n\r\n\r\ncustom_word_add x \"\" = x\r\ncustom_word_add \"\" y = y\r\ncustom_word_add x y = if isInfixOf \"hundred\" x then x ++ \"and\" ++ y else x ++ y\r\n\r\nwrite_word n = foldr (custom_word_add) [] (map wordnames (decompose_word n))\r\n\r\nlength_of_written n = (length $ write_word n)\r\n\r\nans = sum [length_of_written i | i <- [1..1000]]\r\n--threehundredandfourtytwo\r\n--three hundred and forty-two", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "doubleMe x = x + x\n\ndoubleUs x y = doubleMe x + doubleMe y\n\ndoubleSmallNumber x = if x > 100 then x else x * 2\n\ndoubleSmallNumber' x = (if x > 100 then x else x * 2) + 1\n\nboomBangs xs = [if x < 10 then \"BOOM!\" else \"BANG!\" | x <- xs, odd x]\n\nlength' xs = sum [1 | _ <- xs]\n\nremoveNonUppercase :: [Char] -> [Char]\nremoveNonUppercase st = [c | c <- st, c `elem` ['A'..'Z']]\n\naddThree :: Int -> Int -> Int -> Int\naddThree x y z = x + y + z\n\nfactorial :: Integer -> Integer\nfactorial n = product [1..n]\n\ncircumference :: Float -> Float\ncircumference r = 2 * pi * r\n\ncircumference' :: Double -> Double\ncircumference' r = 2 * pi * r\n\nlucky :: (Integral a) => a -> String\nlucky 7 = \"LUCKY NUMBER SEVEN!\"\nlucky x = \"Sorry, you're out of luck, pal.\"\n\nsayMe :: (Integral a) => a -> String\nsayMe 1 = \"One!\"\nsayMe 2 = \"Two!\"\nsayMe 3 = \"Three!\"\nsayMe 4 = \"Four!\"\nsayMe 5 = \"Five!\"\nsayMe x = \"Not between 1 and 5\"\n\nfactorial' :: (Integral a) => a -> a\nfactorial' 0 = 1\nfactorial' n = n * factorial' (n - 1)\n\naddVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)\naddVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)\n\nlength'' :: (Num b) => [a] -> b\nlength'' [] = 0\nlength'' (_:xs) = 1 + length'' xs\n\nsum' :: (Num a) => [a] -> a\nsum' [] = 0\nsum' (x:xs) = x + sum' xs\n\ncapital :: String -> String\ncapital \"\" = \"Empty string, whoopa!\"\ncapital all@(x:xs) = \"The first letter of \" ++ all ++ \" is \" ++ [x]\n\nbmiTell :: (RealFloat a) => a -> a -> String\nbmiTell weight height\n    | weight / height ^ 2 <= 18.5 = \"You are underweight, you emo, you!\"\n    | weight / height ^ 2 <= 25.0 = \"You are supposedly normal. Pffft, I bet you're ugly!\"\n    | weight / height ^ 2 <= 30.0 = \"You're fat! Lose some weight fatty!\"\n    | otherwise                   = \"You're a whale, congratulations!\"\n", "input": "['a', 'a']", "status": "success", "output": "\"\""}
{"code": "import qualified Data.Map as M\n\ntype TermSet = M.Map String String\n\naddTerminals :: [String] -> TermSet\naddTerminals = foldl' addTerminal M.empty\n\naddTerminal :: TermSet -> String -> TermSet\naddTerminal ts term = tryStr 1 base\n  where base = fmtLiteralName term\n\n        try :: Int -> TermSet\n        try k = tryStr k (base ++ show k)\n\n        tryStr :: Int -> String -> TermSet\n        tryStr k sym\n          | sym `M.member` ts = try (k + 1)\n          | otherwise = M.insert sym term ts\n\nfmtLiteralName :: String -> String\nfmtLiteralName = concatMap fmtLiteralChar\n\nfmtLiteralChar :: Char -> String\nfmtLiteralChar '(' = \"LPAREN\"\nfmtLiteralChar ')' = \"RPAREN\"\nfmtLiteralChar '[' = \"LBRACK\"\nfmtLiteralChar ']' = \"RBRACK\"\nfmtLiteralChar '<' = \"LANGLE\"\nfmtLiteralChar '>' = \"RANGLE\"\nfmtLiteralChar '{' = \"LCURLY\"\nfmtLiteralChar '}' = \"RCURLY\"\nfmtLiteralChar 'X' = \"XXXXXXX\"\nfmtLiteralChar '~' = \"TILDE\"\nfmtLiteralChar '`' = \"BACKTICK\"\nfmtLiteralChar '!' = \"BANG\"\nfmtLiteralChar '@' = \"AT\"\nfmtLiteralChar '#' = \"HASH\"\nfmtLiteralChar '$' = \"DOLLAR\"\nfmtLiteralChar '%' = \"PERCENT\"\nfmtLiteralChar '^' = \"CIRCUMFLEX\"\nfmtLiteralChar '&' = \"AMP\"\nfmtLiteralChar '*' = \"STAR\"\nfmtLiteralChar '-' = \"DASH\"\nfmtLiteralChar '_' = \"UNDERBAR\"\nfmtLiteralChar '+' = \"PLUS\"\nfmtLiteralChar '=' = \"EQ\"\nfmtLiteralChar '\\b' = \"BACKSPACE\"\n\nfmtLiteralChar '\\t' = \"TAB\"\nfmtLiteralChar '|' = \"PIPE\"\nfmtLiteralChar '\\\\' = \"BACKSLASH\"\nfmtLiteralChar ':' = \"COLON\"\nfmtLiteralChar ';' = \"SEMI\"\nfmtLiteralChar '\\'' = \"QUOTE\"\nfmtLiteralChar '\\\"' = \"DQUOTE\"\nfmtLiteralChar '\\n' = \"NEWLINE\"\nfmtLiteralChar '\\f' = \"FORMFEED\"\nfmtLiteralChar '\\r' = \"CR\"\n\nfmtLiteralChar ',' = \"COMMA\"\nfmtLiteralChar '.' = \"DOT\"\nfmtLiteralChar '?' = \"QUESTION\"\nfmtLiteralChar '/' = \"SLASH\"\n\nfmtLiteralChar c = [toUpper c]", "input": "[\"hello\", \"hello\"]", "status": "success", "output": "fromList [(\"HELLO\",\"hello\"),(\"HELLO2\",\"hello\")]"}
{"code": "import Data.Char\n\nfilterCaps :: String -> String\nfilterCaps [] = []\nfilterCaps (x:xs) = if isUpper x then x : filterCaps xs else filterCaps xs\n\ncapFirst :: String -> String\ncapFirst [] = []\ncapFirst (x:xs) = toUpper x : xs\n\ncapitalize :: String -> String\ncapitalize [] = []\ncapitalize (x:xs) = toUpper x : capitalize xs\n\nfirstLetter :: String -> String\nfirstLetter [] = []\nfirstLetter xs = [toUpper $ head xs]\n\nfirstLetter' :: String -> String\nfirstLetter' xs = [toUpper . head $ xs]\n\nfirstLetter'' = flip (:) [] . toUpper . head \n\nmyOr :: [Bool] -> Bool\nmyOr [] = False\nmyOr (x:xs) = if x == True then True else myOr xs\n\nmyAny :: (a -> Bool) -> [a] -> Bool\nmyAny _ [] = False\nmyAny f (x:xs) = if f x == True then True else myAny f xs\n\nmyElem :: Eq a => a -> [a] -> Bool\nmyElem _ [] = False\nmyElem e (x:xs) = if e == x then True else myElem e xs\n\nmyElem' :: Eq a => a -> [a] -> Bool\nmyElem' e xs = any (== e) xs\n\nmyReverse :: [a] -> [a]\nmyReverse [] = []\nmyReverse (x:xs) = myReverse xs ++ [x]\n\nsquish :: [[a]] -> [a]\nsquish [] = []\nsquish (x:xs) = x ++ squish xs\n\nsquishMap :: (a -> [b]) -> [a] -> [b]\nsquishMap _ [] = []\nsquishMap f (x:xs) = f x ++ squishMap f xs\n\nsquishAgain :: [[a]] -> [a]\nsquishAgain xs = squishMap id xs\n\nmyMaximumBy :: (a -> a -> Ordering) -> [a] -> a\nmyMaximumBy _ [] = error \"empty list\"\nmyMaximumBy _ [x] = x\nmyMaximumBy f (x:y:ys) = if f x y == GT then myMaximumBy f (x:ys) else myMaximumBy f (y:ys)\n\nmyMinimumBy :: (a -> a -> Ordering) -> [a] -> a\nmyMinimumBy _ [] = error \"empty list\"\nmyMinimumBy _ [x] = x\nmyMinimumBy f (x:y:ys) = if f x y == LT then myMinimumBy f (x:ys) else myMinimumBy f (y:ys)\n\nmyMaximum :: Ord a => [a] -> a\nmyMaximum xs = myMaximumBy compare xs\n\nmyMinimum :: Ord a => [a] -> a\nmyMinimum xs = myMinimumBy compare xs\n", "input": "\"hello\"", "status": "success", "output": "\"\""}
{"code": "-- Warm-up and review\n-- 1\nstops = \"pbtdkg\"\nvowels = \"aeiou\"\n-- a)\ntuples = [ (a, b, c) | a <- stops, b <- vowels, c <- stops ]\n-- b)\ntuplesP = [ (a, b, c) | a <- stops, b <- vowels, c <- stops, a == 'p' ]\n-- c)\nnouns = [\"balance\", \"farm\", \"coal\", \"fall\", \"chin\", \"fire\"]\nverbs = [\"yell\", \"pull\", \"admire\", \"learn\", \"visit\", \"plant\"]\nsentence = [ (a, b, c) | a <- nouns, b <- verbs, c <- nouns ]\n\n-- 2\n-- Calculate average word length in string\nseekritFunc :: String -> Int\nseekritFunc x =\n    div (sum (map length (words x)))\n        (length (words x))\n\nseekritFunc' :: Fractional a => String -> a\nseekritFunc' x =\n    fromIntegral (sum (map length (words x)))\n    / fromIntegral (length (words x))\n\n-- Rewriting functions using folds\n-- 1\nmyOr :: [Bool] -> Bool\nmyOr = foldr (||) False\n-- 2\nmyAny :: (a -> Bool) -> [a] -> Bool\nmyAny f = foldr (\\a b -> if f a then True else b) False\n-- 3\nmyElem :: Eq a => a -> [a] -> Bool\nmyElem x = foldr (\\a b -> if a == x then True else b) False\nmyElem' :: Eq a => a -> [a] -> Bool\nmyElem' x = any (== x)\n-- 4\nmyReverse :: [a] -> [a]\nmyReverse = foldl (flip (:)) []\n-- 5\nmyMap :: (a -> b) -> [a] -> [b]\nmyMap f = foldr (\\a b -> f a : b) []\n-- 6\nmyFilter :: (a -> Bool) -> [a] -> [a]\nmyFilter f = foldr (\\a b -> if f a then a : b else b) []\n-- 7\nsquish :: [[a]] -> [a]\nsquish = foldr (++) []\n-- 8\nsquishMap :: (a -> [b]) -> [a] -> [b]\nsquishMap f = foldr (\\a b -> f a ++ b) []\n-- 9\nsquishAgain :: [[a]] -> [a]\nsquishAgain = squishMap id\n-- 10\nmyMaximumBy :: (a -> a -> Ordering)\n            -> [a]\n            -> a\nmyMaximumBy f xs = foldr (\\a b -> if f a b == GT then a else b) (last xs) xs\n-- 11\nmyMinimumBy :: (a -> a -> Ordering)\n            -> [a]\n            -> a\nmyMinimumBy f xs = foldr (\\a b -> if f a b == LT then a else b) (last xs) xs\n", "input": "\"hello\"", "status": "success", "output": "5"}
{"code": "import Data.List\n\ntype Edge = (String, STree)\n\ndata STree = Node [Edge]\n           | Leaf\n             deriving (Show)\n\ntype EdgeFunction = [String] -> (Int, [String])\n\nconstruct :: String -> STree\nconstruct = suf . suffixes\n    where suf [[]] = Leaf\n          suf ss = Node [([a], suf n)\n                         | a <- ['\\0'..'\\255'],\n                           n@(sa:_) <- [ss `clusterBy` a]]\n          clusterBy ss a = [cs | c:cs <- ss, c == a]\n\nconstruct2 :: EdgeFunction -> [Char] -> String -> STree\nconstruct2 edge alphabet = suf . suffixes\n    where suf [[]] = Leaf\n          suf ss = Node [(take (cpl+1) (a:sa), suf ssr)\n                         | a <- alphabet,\n                           n@(sa:_) <- [ss `clusterBy` a],\n                           (cpl,ssr) <- [edge n]]\n          clusterBy ss a = [cs | c:cs <- ss, c == a]\n\nsimple :: EdgeFunction\nsimple n = (0, n)\n\ncst :: EdgeFunction\ncst [s] = (length s, [[]])\ncst awss@((a:w):ss)\n    | null [c | c:_ <- ss, a /= c] = (cpl + 1, rss)\n    | otherwise = (0, awss)\n    where (cpl, rss) = cst (w:[u | _:u <- ss])\n\n{-- snippet suffixes --}\nsuffixes :: [a] -> [[a]]\nsuffixes xs@(_:xs') = xs : suffixes xs'\nsuffixes _ = []\n{-- /snippet suffixes --}\n\n{-- snippet noAsPattern --}\nnoAsPattern :: [a] -> [[a]]\nnoAsPattern (x:xs) = (x:xs) : noAsPattern xs\nnoAsPattern _ = []                 \n{-- /snippet noAsPattern --}\n\n{-- snippet suffixes2 --}\nsuffixes2 xs = init (tails xs)\n{-- /snippet suffixes2 --}\n\n{-- snippet compose --}\ncompose :: (b -> c) -> (a -> b) -> a -> c\ncompose f g x = f (g x)\n{-- /snippet compose --}\n\n{-- snippet suffixes3 --}\nsuffixes3 xs = compose init tails xs\n{-- /snippet suffixes3 --}\n\n{-- snippet suffixes4 --}\nsuffixes4 = compose init tails\n{-- /snippet suffixes4 --}\n\n{-- snippet suffixes5 --}\nsuffixes5 = init . tails\n{-- /snippet suffixes5 --}\n", "input": "\"hello\"", "status": "success", "output": "Node [(\"e\",Node [(\"l\",Node [(\"l\",Node [(\"o\",Leaf)])])]),(\"h\",Node [(\"e\",Node [(\"l\",Node [(\"l\",Node [(\"o\",Leaf)])])])]),(\"l\",Node [(\"l\",Node [(\"o\",Leaf)]),(\"o\",Leaf)]),(\"o\",Leaf)]"}
{"code": "import Data.List\n\nrightTriangles :: Int -> [(Int, Int, Int)]\nrightTriangles longest = [(a, b, c) | c <- [1..longest], b <- [1..c], a <- [1..b], a ^ 2 + b ^ 2 == c ^ 2]\n\nfactorial :: (Integral a) => a -> a\nfactorial 0 = 0\nfactorial 1 = 1\nfactorial n = n * factorial (n - 1)\n\naddVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)\naddVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)\n\nmap' :: (a -> b) -> [a] -> [b]\nmap' f [] = []\nmap' f (x:xs) = f x : map' f xs\n\nfib :: Int -> Int\nfib 0 = 0\nfib 1 = 1\nfib n = fib (n - 2) + fib (n -1)\n\nfibSeq :: Int -> [Int]\nfibSeq count = [fib n | n <- [0..count]]\n\nsum' :: (Num a) => [a] -> a\nsum' [] = 0\nsum' (x:xs) = x + sum' xs\n\nnumTell :: (RealFloat a) => a -> String\nnumTell n\n    | n <= 3.0 = \"Smallish number...\"\n    | n <= 7.0 = \"That's the right size !\"\n    | otherwise = \"Waaay to big...\"\n                  \nquicksort :: (Ord a) => [a] -> [a]\nquicksort [] = []\nquicksort (x:xs) =\n    let smallerSorted = quicksort (filter (<= x) xs)\n        biggerSorted = quicksort (filter (> x) xs)\n    in smallerSorted ++ [x] ++ biggerSorted\n\n-- type definition could be also written as 'a -> (a -> (a -> a))'\nmultThree :: (Num a) => a -> a -> a -> a\nmultThree x y z = x * y * z\n\n-- function currying\nmultTwoWithFour :: (Num a) => a -> (a -> a)\nmultTwoWithFour = multThree 4\n\napplyTwice :: (a -> a) -> a -> a\napplyTwice f x = f (f x)\n\nzipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]\nzipWith' _ [] _ = []\nzipWith' _ _ [] = []\nzipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys\n\nflip' :: (a -> b -> c) -> b -> a -> c\nflip' f = \\ x y -> f y x\n\nlargestDivisible :: (Integral a) => a\nlargestDivisible = let p x = mod x 3829 == 0 in head (filter p [100000, 99999..])\n\nmakePower :: (Num a) => Int -> a -> a \nmakePower pow = \\ x -> foldr (*) 1 (take pow (repeat x))\n\nmakePower' :: (Num a) => Int -> a -> a\nmakePower' pow = (^ pow)\n\n\n", "input": "42", "status": "success", "output": "[(3,4,5),(6,8,10),(5,12,13),(9,12,15),(8,15,17),(12,16,20),(15,20,25),(7,24,25),(10,24,26),(20,21,29),(18,24,30),(16,30,34),(21,28,35),(12,35,37),(15,36,39),(24,32,40),(9,40,41)]"}
{"code": "-- exercise 1\n\nfun1 :: [Integer] -> Integer\nfun1 [] = 1\nfun1 (x:xs)\n  | even x = (x - 2) * fun1 xs\n  | otherwise = fun1 xs\n\nfun1' :: [Integer] -> Integer\nfun1' = product . map (subtract 2) . filter even\n\n-- exercise 2\n\ndata Tree a = Leaf\n            | Node Integer (Tree a) a (Tree a)\n            deriving (Show, Eq)\n\ntreeHeight :: Tree a -> Integer\ntreeHeight Leaf = 0\ntreeHeight (Node h _ _ _) = h\n\ninsertTree :: a -> Tree a -> Tree a\ninsertTree a Leaf = Node 0 Leaf a Leaf\ninsertTree a (Node h left c right) =\n  if hLeft < hRight\n  then (Node (hRight+1) (insertTree a left) c right)\n  else (Node (hLeft+1) left c (insertTree a right))\n  where hLeft = treeHeight left\n        hRight = treeHeight right\n\nfoldTree :: [a] -> Tree a\nfoldTree = foldr insertTree Leaf\n\n-- exercise 3\n\nxor :: [Bool] -> Bool\nxor = odd . foldr (\\x a -> if x then (a+1) else a) 0\n\nmap' :: (a -> b) -> [a] -> [b]\nmap' f = foldr (\\x a -> (f x) : a) []\n\n-- exercise 4\n-- this is buggy, see filterOut\n\ncartProd :: [a] -> [b] -> [(a, b)]\ncartProd xs ys = [(x,y) | x <- xs, y <- ys]\n\nallCarts :: [(Integer, Integer)]\nallCarts = cartProd [1,2..] [1,2..]\n\n-- for a given natural number n, give all numbers of the form\n-- i + j + 2 * i * j <= n, i > 1, i <= j\n-- this is buggy, according to https://en.wikipedia.org/wiki/Sieve_of_Sundaram\n-- it should also contain e.g. 27, but it doesn't\nfilterOut n =\n  takeWhile (<=n) .\n  map (\\(i, j) -> i + j + 2 * i * j) .\n  filter (\\(i, j) -> i <= j) $ allCarts\n\n-- for a given natural number n, is there no i and a j so that\n-- i > 1, i <= j and j + j + 2 * i * j = n?\nijNo :: Integer -> Bool\nijNo n = let r = takeWhile (==n) .\n                 dropWhile (<n) $ filterOut n\n         in null r\n\nfiltered :: Integer -> [Integer]\nfiltered n = filter ijNo [1..n]\n\nsieveSundaram :: Integer -> [Integer]\nsieveSundaram = map (\\n -> 2 * n + 1) . filtered\n", "input": "[42, 42]", "status": "success", "output": "1600"}
{"code": "import Data.List\nimport Data.Char\nimport qualified Data.Map as Map\n\nwordNums :: String -> [(String, Int)]\nwordNums = map (\\ws -> (head ws, length ws)) . group . sort . words\n\nisIn :: (Eq a) => [a] -> [a] -> Bool\nisIn needle haystack = any ( isPrefixOf needle ) $ tails haystack\n\nisIn' :: (Eq a) => [a] -> [a] -> Bool\nisIn' needle haystack = any (\\ws -> isPrefixOf needle ws) $ tails haystack\n\nisIn1 :: (Eq a) => [a] -> [a] -> Bool\nisIn1 needle = any (\\ws -> isPrefixOf needle ws) . tails\n\ncaesarEncoding :: Int -> String -> String\ncaesarEncoding offect = map (\\char -> chr $ ord char + offect)\n\ncaesarEncoding' :: Int -> String -> String\ncaesarEncoding' offect = map ( chr . (+ offect) . ord )\n\ncaesarDecoding :: Int -> String -> String\ncaesarDecoding offect = map ( \\c -> chr $ (ord c - offect) )\n\ncaesarDecoding' :: Int -> String -> String\ncaesarDecoding' offect = caesarEncoding' (negate offect)\n\ndigitSum :: Int -> Int\ndigitSum = sum . map digitToInt . show\n\nfirstTo40 :: Maybe Int\nfirstTo40 = find (\\x -> digitSum x == 40) [1..]\n\nfirstTo :: Int -> Maybe Int\nfirstTo n = find (\\x -> digitSum x == n) [1..]\n\n-- Mapping keys to values\n\n-- Find key in a maps. If there is no match anyone will cause a crash\nfindKey :: (Eq k) => k -> [(k, v)] -> v\nfindKey key xs = snd . head . filter (\\(k, v) -> k == key) $ xs\n\nfindKey' :: (Eq k) => k -> [(k, v)] -> Maybe v\nfindKey' key [] = Nothing\nfindKey' key ((k, v):xs)\n  | key == k = Just v\n  | otherwise= findKey' key xs\n\nfindKey1 :: (Eq k) => k -> [(k, v)] -> Maybe v\nfindKey1 key xs = foldr (\\(k, v) acc -> if k == key then Just v else acc) Nothing xs\n\n-- \nstring2digits :: String -> [Int]\nstring2digits = map digitToInt . filter isDigit\n\n-- phone book\nphoneBookToMap :: (Ord k) => [(k, String)] -> Map.Map k String\nphoneBookToMap xs = Map.fromListWith add xs\n  where add number1 number2 = number1 ++ \", \" ++ number2\n\n", "input": "\"hello\"", "status": "success", "output": "[(\"hello\",1)]"}
{"code": "import Data.Char\n\ndegit :: Int -> Int\ndegit = length . show\n\nsquare :: Num a => a -> a\nsquare = (^ 2)\n\nultimate ::  Int -> String\nultimate 42 = \"The Answer for all things\"\nultimate n = show n\n\nmaybeToList :: Maybe a -> [a]\nmaybeToList Nothing = []\nmaybeToList (Just a) = [a]\n\nlistToMaybe :: [a] -> Maybe a\nlistToMaybe [] = Nothing\nlistToMaybe (a:as) = Just a\n\ndeeping :: String -> String\ndeeping s@(' ':' ':_) = \"  \"++s\ndeeping s@(' ':_) = \" \"++s\ndeeping s = s\n\nbadFunc :: Int -> Int\nbadFunc 1 = 1\nbadFunc a = a\n\nfib :: Int -> Int\nfib n\n\t| n == 0 = 0\n\t| n == 1 = 1\n\t| n > 0 = fib (n-2) + fib (n-1)\n\t| n < 0 = 0\n\nfibCase :: Int -> Int\nfibCase n = case n of\n\t0 -> 0\n\t1 -> 1\n\t_ | n > 0 -> fib (n-1) + fib (n-2)\n\ntake' :: Int -> [a] -> [a]\ntake' n _ | n < 1 = []\ntake' n (x:xs) = x : (take' (n-1) xs)\n\ndrop' :: Int -> [a] -> [a]\ndrop' n l | n < 1 = l\ndrop' n (_:ls) = drop' (n-1) ls\n\nreverse' :: [a] -> [a]\nreverse' [] = []\nreverse' (x:xs) = reverse' xs ++ [x]\n\nsum' :: Num a => [a] -> a\nsum' [] = 0\nsum' (x:xs) = sum' xs + x\n\nproduct' :: Num a => [a] -> a\nproduct' [] = 1\nproduct' (x:xs) = x * product' xs\n\nfact' :: Int -> Int\nfact' 0 = 1\nfact' n = product' [1..n]\n\nrot13 :: String -> String\nrot13 str = map ( chr . (\\x -> x+13) . ord ) str\n\ninsertSort [] = []\ninsertSort (x:xs) = iSort x (insertSort xs)\n\niSort n [] = [n]\niSort n (x:xs) \n\t| n > x = x: iSort n xs\n\t| otherwise = n:x:xs\n\nqsort []     = []\nqsort (n:xs) = qsort lt ++ [n] ++ qsort gteq\n    where\n\t\tlt   = [x | x <- xs, x <  n]\n\t\tgteq = [x | x <- xs, x >= n]\n\nsankaku (x:y:z:_)\n\t| x^2 + y^2 == z^2 = [x, y, z]\n\t| otherwise = []\nsankaku (a:as) = []\nsankaku [] = []\n\n--prime :: Num n => n -> Bool\nprime n\n\t| n <= 1 = (n, False)\n\t| n <= 3 = (n, True)\n\t| otherwise = (n, all (\\x -> mod n x /= 0) [2..n-1] )\n\nttt l@(x:xs)\n\t| l == [] = []\n\t| xs == [] = []\n\t| mod x 2 == 0 = x^3:ttt xs\n\t| otherwise = x:ttt xs \n\n\n", "input": "42", "status": "success", "output": "2"}
{"code": "-- Problem 23\n--\n-- A perfect number is a number for which the sum of its proper divisors is\n-- exactly equal to the number. For example, the sum of the proper divisors\n-- of 28 would be 1 + 2 + 4 + 7 + 14 = 28, which means that 28 is a perfect\n-- number.\n--\n-- A number n is called deficient if the sum of its proper divisors is less\n-- than n and it is called abundant if this sum exceeds n.\n--\n-- As 12 is the smallest abundant number, 1 + 2 + 3 + 4 + 6 = 16, the\n-- smallest number that can be written as the sum of two abundant numbers\n-- is 24. By mathematical analysis, it can be shown that all integers\n-- greater than 28123 can be written as the sum of two abundant numbers.\n-- However, this upper limit cannot be reduced any further by analysis even\n-- though it is known that the greatest number that cannot be expressed as\n-- the sum of two abundant numbers is less than this limit.\n--\n-- Find the sum of all the positive integers which cannot be written as the\n-- sum of two abundant numbers.\n\nimport Data.List\nimport Data.Array.ST\nimport Control.Monad.ST\nimport Control.Monad\nimport Data.Array.Unboxed\n\neuler23 = sum [x | (x, True) <- (assocs . obtainNonAbundantSums) $ abundantNos maxNo]\n\nmaxNo = 28123\n\nobtainNonAbundantSums :: [Int] -> UArray Int Bool\nobtainNonAbundantSums abNos= runSTUArray $ do\n    arr <- newArray (1, maxNo) True\n    forM_ abNos $ \\m -> do\n        let xs = takeWhile (\\a -> m + a <= maxNo) $ dropWhile (< m) abNos\n        forM_ xs $ \\n -> writeArray arr (m + n) False\n    return arr\n\nabundantNos n = filter (\\n -> sumProperDivisors n > n) [1..n] \n\nsumProperDivisors n \n  | n == 1    = 0\n  | otherwise = sum factors - n\n    where factors = concatMap (\\(x,y)-> if x /= y then [x,y] else [x]) $ factorPairs n\n     \nfactorPairs :: Int -> [(Int, Int)]\nfactorPairs x = [ (y, x `div` y) | y <- [1..truncate (sqrt (fromIntegral x))], x `mod` y == 0]\n\n\n      \n", "input": "[42, 42]", "status": "success", "output": "array (1,28123) [(1,True),(2,True),(3,True),(4,True),(5,True),(6,True),(7,True),(8,True),(9,True),(10,True),(11,True),(12,True),(13,True),(14,True),(15,True),(16,True),(17,True),(18,True),(19,True),(20,True),(21,True),(22,True),(23,True),(24,True),(25,True),(26,True),(27,True),(28,True),(29,True),(30,True),(31,True),(32,True),(33,True),(34,True),(35,True),(36,True),(37,True),(38,True),(39,True),(40,True),(41,True),(42,True),(43,True),(44,True),(45,True),(46,True),(47,True),(48,True),(49,True),(50,True),(51,True),(52,True),(53,True),(54,True),(55,True),(56,True),(57,True),(58,True),(59,True),(60,True),(61,True),(62,True),(63,True),(64,True),(65,True),(66,True),(67,True),(68,True),(69,True),(70,True),(71,True),(72,True),(73,True),(74,True),(75,True),(76,True),(77,True),(78,True),(79,True),(80,True),(81,True),(82,True),(83,True),(84,False),(85,True),(86,True),(87,True),(88,True),(89,True),(90,True),(91,True),(92,True),(93,True),(94,True),(95,True),(96,True),(97,True),(98,True),(99,True),(100,True),(101,True),(102,True),(103,True),(104,True),(105,True),(106,True),(107,True),(108,True),(109,True),(110,True),(111,True),(112,True),(113,True),(114,True),(115,True),(116,True),(117,True),(118,True),(119,True),(120,True),(121,True),(122,True),(123,True),(124,True),(125,True),(126,True),(127,True),(128,True),(129,True),(130,True),(131,True),(132,True),(133,True),(134,True),(135,True),(136,True),(137,True),(138,True),(139,True),(140,True),(141,True),(142,True),(143,True),(144,True),(145,True),(146,True),(147,True),(148,True),(149,True),(150,True),(151,True),(152,True),(153,True),(154,True),(155,True),(156,True),(157,True),(158,True),(159,True),(160,True),(161,True),(162,True),(163,True),(164,True),(165,True),(166,True),(167,True),(168,True),(169,True),(170,True),(171,True),(172,True),(173,True),(174,True),(175,True),(176,True),(177,True),(178,True),(179,True),(180,True),(181,True),(182,True),(183,True),(184,True),(185,True),(186,True),(187,True),(188,True),(189,True),(190,True),(191,True),(192,True),(193,True),(194,True),(195,True),(196,True),(197,True),(198,True),(199,True),(200,True),(201,True),(202,True),(203,True),(204,True),(205,True),(206,True),(207,True),(208,True),(209,True),(210,True),(211,True),(212,True),(213,True),(214,True),(215,True),(216,True),(217,True),(218,True),(219,True),(220,True),(221,True),(222,True),(223,True),(224,True),(225,True),(226,True),(227,True),(228,True),(229,True),(230,True),(231,True),(232,True),(233,True),(234,True),(235,True),(236,True),(237,True),(238,True),(239,True),(240,True),(241,True),(242,True),(243,True),(244,True),(245,True),(246,True),(247,True),(248,True),(249,True),(250,True),(251,True),(252,True),(253,True),(254,True),(255,True),(256,True),(257,True),(258,True),(259,True),(260,True),(261,True),(262,True),(263,True),(264,True),(265,True),(266,True),(267,True),(268,True),(269,True),(270,True),(271,True),(272,True),(273,True),(274,True),(275,True),(276,True),(277,True),(278,True),(279,True),(280,True),(281,True),(282,True),(283,True),(284,True),(285,True),(286,True),(287,True),(288,True),(289,True),(290,True),(291,True),(292,True),(293,True),(294,True),(295,True),(296,True),(297,True),(298,True),(299,True),(300,True),(301,True),(302,True),(303,True),(304,True),(305,True),(306,True),(307,True),(308,True),(309,True),(310,True),(311,True),(312,True),(313,True),(314,True),(315,True),(316,True),(317,True),(318,True),(319,True),(320,True),(321,True),(322,True),(323,True),(324,True),(325,True),(326,True),(327,True),(328,True),(329,True),(330,True),(331,True),(332,True),(333,True),(334,True),(335,True),(336,True),(337,True),(338,True),(339,True),(340,True),(341,True),(342,True),(343,True),(344,True),(345,True),(346,True),(347,True),(348,True),(349,True),(350,True),(351,True),(352,True),(353,True),(354,True),(355,True),(356,True),(357,True),(358,True),(359,True),(360,True),(361,True),(362,True),(363,True),(364,True),(365,True),(366,True),(367,True),(368,True),(369,True),(370,True),(371,True),(372,True),(373,True),(374,True),(375,True),(376,True),(377,True),(378,True),(379,True),(380,True),(381,True),(382,True),(383,True),(384,True),(385,True),(386,True),(387,True),(388,True),(389,True),(390,True),(391,True),(392,True),(393,True),(394,True),(395,True),(396,True),(397,True),(398,True),(399,True),(400,True),(401,True),(402,True),(403,True),(404,True),(405,True),(406,True),(407,True),(408,True),(409,True),(410,True),(411,True),(412,True),(413,True),(414,True),(415,True),(416,True),(417,True),(418,True),(419,True),(420,True),(421,True),(422,True),(423,True),(424,True),(425,True),(426,True),(427,True),(428,True),(429,True),(430,True),(431,True),(432,True),(433,True),(434,True),(435,True),(436,True),(437,True),(438,True),(439,True),(440,True),(441,True),(442,True),(443,True),(444,True),(445,True),(446,True),(447,True),(448,True),(449,True),(450,True),(451,True),(452,True),(453,True),(454,True),(455,True),(456,True),(457,True),(458,True),(459,True),(460,True),(461,True),(462,True),(463,True),(464,True),(465,True),(466,True),(467,True),(468,True),(469,True),(470,True),(471,True),(472,True),(473,True),(474,True),(475,True),(476,True),(477,True),(478,True),(479,True),(480,True),(481,True),(482,True),(483,True),(484,True),(485,True),(486,True),(487,True),(488,True),(489,True),(490,True),(491,True),(492,True),(493,True),(494,True),(495,True),(496,True),(497,True),(498,True),(499,True),(500,True),(501,True),(502,True),(503,True),(504,True),(505,True),(506,True),(507,True),(508,True),(509,True),(510,True),(511,True),(512,True),(513,True),(514,True),(515,True),(516,True),(517,True),(518,True),(519,True),(520,True),(521,True),(522,True),(523,True),(524,True),(525,True),(526,True),(527,True),(528,True),(529,True),(530,True),(531,True),(532,True),(533,True),(534,True),(535,True),(536,True),(537,True),(538,True),(539,True),(540,True),(541,True),(542,True),(543,True),(544,True),(545,True),(546,True),(547,True),(548,True),(549,True),(550,True),(551,True),(552,True),(553,True),(554,True),(555,True),(556,True),(557,True),(558,True),(559,True),(560,True),(561,True),(562,True),(563,True),(564,True),(565,True),(566,True),(567,True),(568,True),(569,True),(570,True),(571,True),(572,True),(573,True),(574,True),(575,True),(576,True),(577,True),(578,True),(579,True),(580,True),(581,True),(582,True),(583,True),(584,True),(585,True),(586,True),(587,True),(588,True),(589,True),(590,True),(591,True),(592,True),(593,True),(594,True),(595,True),(596,True),(597,True),(598,True),(599,True),(600,True),(601,True),(602,True),(603,True),(604,True),(605,True),(606,True),(607,True),(608,True),(609,True),(610,True),(611,True),(612,True),(613,True),(614,True),(615,True),(616,True),(617,True),(618,True),(619,True),(620,True),(621,True),(622,True),(623,True),(624,True),(625,True),(626,True),(627,True),(628,True),(629,True),(630,True),(631,True),(632,True),(633,True),(634,True),(635,True),(636,True),(637,True),(638,True),(639,True),(640,True),(641,True),(642,True),(643,True),(644,True),(645,True),(646,True),(647,True),(648,True),(649,True),(650,True),(651,True),(652,True),(653,True),(654,True),(655,True),(656,True),(657,True),(658,True),(659,True),(660,True),(661,True),(662,True),(663,True),(664,True),(665,True),(666,True),(667,True),(668,True),(669,True),(670,True),(671,True),(672,True),(673,True),(674,True),(675,True),(676,True),(677,True),(678,True),(679,True),(680,True),(681,True),(682,True),(683,True),(684,True),(685,True),(686,True),(687,True),(688,True),(689,True),(690,True),(691,True),(692,True),(693,True),(694,True),(695,True),(696,True),(697,True),(698,True),(699,True),(700,True),(701,True),(702,True),(703,True),(704,True),(705,True),(706,True),(707,True),(708,True),(709,True),(710,True),(711,True),(712,True),(713,True),(714,True),(715,True),(716,True),(717,True),(718,True),(719,True),(720,True),(721,True),(722,True),(723,True),(724,True),(725,True),(726,True),(727,True),(728,True),(729,True),(730,True),(731,True),(732,True),(733,True),(734,True),(735,True),(736,True),(737,True),(738,True),(739,True),(740,True),(741,True),(742,True),(743,True),(744,True),(745,True),(746,True),(747,True),(748,True),(749,True),(750,True),(751,True),(752,True),(753,True),(754,True),(755,True),(756,True),(757,True),(758,True),(759,True),(760,True),(761,True),(762,True),(763,True),(764,True),(765,True),(766,True),(767,True),(768,True),(769,True),(770,True),(771,True),(772,True),(773,True),(774,True),(775,True),(776,True),(777,True),(778,True),(779,True),(780,True),(781,True),(782,True),(783,True),(784,True),(785,True),(786,True),(787,True),(788,True),(789,True),(790,True),(791,True),(792,True),(793,True),(794,True),(795,True),(796,True),(797,True),(798,True),(799,True),(800,True),(801,True),(802,True),(803,True),(804,True),(805,True),(806,True),(807,True),(808,True),(809,True),(810,True),(811,True),(812,True),(813,True),(814,True),(815,True),(816,True),(817,True),(818,True),(819,True),(820,True),(821,True),(822,True),(823,True),(824,True),(825,True),(826,True),(827,True),(828,True),(829,True),(830,True),(831,True),(832,True),(833,True),(834,True),(835,True),(836,True),(837,True),(838,True),(839,True),(840,True),(841,True),(842,True),(843,True),(844,True),(845,True),(846,True),(847,True),(848,True),(849,True),(850,True),(851,True),(852,True),(853,True),(854,True),(855,True),(856,True),(857,True),(858,True),(859,True),(860,True),(861,True),(862,True),(863,True),(864,True),(865,True),(866,True),(867,True),(868,True),(869,True),(870,True),(871,True),(872,True),(873,True),(874,True),(875,True),(876,True),(877,True),(878,True),(879,True),(880,True),(881,True),(882,True),(883,True),(884,True),(885,True),(886,True),(887,True),(888,True),(889,True),(890,True),(891,True),(892,True),(893,True),(894,True),(895,True),(896,True),(897,True),(898,True),(899,True),(900,True),(901,True),(902,True),(903,True),(904,True),(905,True),(906,True),(907,True),(908,True),(909,True),(910,True),(911,True),(912,True),(913,True),(914,True),(915,True),(916,True),(917,True),(918,True),(919,True),(920,True),(921,True),(922,True),(923,True),(924,True),(925,True),(926,True),(927,True),(928,True),(929,True),(930,True),(931,True),(932,True),(933,True),(934,True),(935,True),(936,True),(937,True),(938,True),(939,True),(940,True),(941,True),(942,True),(943,True),(944,True),(945,True),(946,True),(947,True),(948,True),(949,True),(950,True),(951,True),(952,True),(953,True),(954,True),(955,True),(956,True),(957,True),(958,True),(959,True),(960,True),(961,True),(962,True),(963,True),(964,True),(965,True),(966,True),(967,True),(968,True),(969,True),(970,True),(971,True),(972,True),(973,True),(974,True),(975,True),(976,True),(977,True),(978,True),(979,True),(980,True),(981,True),(982,True),(983,True),(984,True),(985,True),(986,True),(987,True),(988,True),(989,True),(990,True),(991,True),(992,True),(993,True),(994,True),(995,True),(996,True),(997,True),(998,True),(999,True),(1000,True),(1001,True),(1002,True),(1003,True),(1004,True),(1005,True),(1006,True),(1007,True),(1008,True),(1009,True),(1010,True),(1011,True),(1012,True),(1013,True),(1014,True),(1015,True),(1016,True),(1017,True),(1018,True),(1019,True),(1020,True),(1021,True),(1022,True),(1023,True),(1024,True),(1025,True),(1026,True),(1027,True),(1028,True),(1029,True),(1030,True),(1031,True),(1032,True),(1033,True),(1034,True),(1035,True),(1036,True),(1037,True),(1038,True),(1039,True),(1040,True),(1041,True),(1042,True),(1043,True),(1044,True),(1045,True),(1046,True),(1047,True),(1048,True),(1049,True),(1050,True),(1051,True),(1052,True),(1053,True),(1054,True),(1055,True),(1056,True),(1057,True),(1058,True),(1059,True),(1060,True),(1061,True),(1062,True),(1063,True),(1064,True),(1065,True),(1066,True),(1067,True),(1068,True),(1069,True),(1070,True),(1071,True),(1072,True),(1073,True),(1074,True),(1075,True),(1076,True),(1077,True),(1078,True),(1079,True),(1080,True),(1081,True),(1082,True),(1083,True),(1084,True),(1085,True),(1086,True),(1087,True),(1088,True),(1089,True),(1090,True),(1091,True),(1092,True),(1093,True),(1094,True),(1095,True),(1096,True),(1097,True),(1098,True),(1099,True),(1100,True),(1101,True),(1102,True),(1103,True),(1104,True),(1105,True),(1106,True),(1107,True),(1108,True),(1109,True),(1110,True),(1111,True),(1112,True),(1113,True),(1114,True),(1115,True),(1116,True),(1117,True),(1118,True),(1119,True),(1120,True),(1121,True),(1122,True),(1123,True),(1124,True),(1125,True),(1126,True),(1127,True),(1128,True),(1129,True),(1130,True),(1131,True),(1132,True),(1133,True),(1134,True),(1135,True),(1136,True),(1137,True),(1138,True),(1139,True),(1140,True),(1141,True),(1142,True),(1143,True),(1144,True),(1145,True),(1146,True),(1147,True),(1148,True),(1149,True),(1150,True),(1151,True),(1152,True),(1153,True),(1154,True),(1155,True),(1156,True),(1157,True),(1158,True),(1159,True),(1160,True),(1161,True),(1162,True),(1163,True),(1164,True),(1165,True),(1166,True),(1167,True),(1168,True),(1169,True),(1170,True),(1171,True),(1172,True),(1173,True),(1174,True),(1175,True),(1176,True),(1177,True),(1178,True),(1179,True),(1180,True),(1181,True),(1182,True),(1183,True),(1184,True),(1185,True),(1186,True),(1187,True),(1188,True),(1189,True),(1190,True),(1191,True),(1192,True),(1193,True),(1194,True),(1195,True),(1196,True),(1197,True),(1198,True),(1199,True),(1200,True),(1201,True),(1202,True),(1203,True),(1204,True),(1205,True),(1206,True),(1207,True),(1208,True),(1209,True),(1210,True),(1211,True),(1212,True),(1213,True),(1214,True),(1215,True),(1216,True),(1217,True),(1218,True),(1219,True),(1220,True),(1221,True),(1222,True),(1223,True),(1224,True),(1225,True),(1226,True),(1227,True),(1228,True),(1229,True),(1230,True),(1231,True),(1232,True),(1233,True),(1234,True),(1235,True),(1236,True),(1237,True),(1238,True),(1239,True),(1240,True),(1241,True),(1242,True),(1243,True),(1244,True),(1245,True),(1246,True),(1247,True),(1248,True),(1249,True),(1250,True),(1251,True),(1252,True),(1253,True),(1254,True),(1255,True),(1256,True),(1257,True),(1258,True),(1259,True),(1260,True),(1261,True),(1262,True),(1263,True),(1264,True),(1265,True),(1266,True),(1267,True),(1268,True),(1269,True),(1270,True),(1271,True),(1272,True),(1273,True),(1274,True),(1275,True),(1276,True),(1277,True),(1278,True),(1279,True),(1280,True),(1281,True),(1282,True),(1283,True),(1284,True),(1285,True),(1286,True),(1287,True),(1288,True),(1289,True),(1290,True),(1291,True),(1292,True),(1293,True),(1294,True),(1295,True),(1296,True),(1297,True),(1298,True),(1299,True),(1300,True),(1301,True),(1302,True),(1303,True),(1304,True),(1305,True),(1306,True),(1307,True),(1308,True),(1309,True),(1310,True),(1311,True),(1312,True),(1313,True),(1314,True),(1315,True),(1316,True),(1317,True),(1318,True),(1319,True),(1320,True),(1321,True),(1322,True),(1323,True),(1324,True),(1325,True),(1326,True),(1327,True),(1328,True),(1329,True),(1330,True),(1331,True),(1332,True),(1333,True),(1334,True),(1335,True),(1336,True),(1337,True),(1338,True),(1339,True),(1340,True),(1341,True),(1342,True),(1343,True),(1344,True),(1345,True),(1346,True),(1347,True),(1348,True),(1349,True),(1350,True),(1351,True),(1352,True),(1353,True),(1354,True),(1355,True),(1356,True),(1357,True),(1358,True),(1359,True),(1360,True),(1361,True),(1362,True),(1363,True),(1364,True),(1365,True),(1366,True),(1367,True),(1368,True),(1369,True),(1370,True),(1371,True),(1372,True),(1373,True),(1374,True),(1375,True),(1376,True),(1377,True),(1378,True),(1379,True),(1380,True),(1381,True),(1382,True),(1383,True),(1384,True),(1385,True),(1386,True),(1387,True),(1388,True),(1389,True),(1390,True),(1391,True),(1392,True),(1393,True),(1394,True),(1395,True),(1396,True),(1397,True),(1398,True),(1399,True),(1400,True),(1401,True),(1402,True),(1403,True),(1404,True),(1405,True),(1406,True),(1407,True),(1408,True),(1409,True),(1410,True),(1411,True),(1412,True),(1413,True),(1414,True),(1415,True),(1416,True),(1417,True),(1418,True),(1419,True),(1420,True),(1421,True),(1422,True),(1423,True),(1424,True),(1425,True),(1426,True),(1427,True),(1428,True),(1429,True),(1430,True),(1431,True),(1432,True),(1433,True),(1434,True),(1435,True),(1436,True),(1437,True),(1438,True),(1439,True),(1440,True),(1441,True),(1442,True),(1443,True),(1444,True),(1445,True),(1446,True),(1447,True),(1448,True),(1449,True),(1450,True),(1451,True),(1452,True),(1453,True),(1454,True),(1455,True),(1456,True),(1457,True),(1458,True),(1459,True),(1460,True),(1461,True),(1462,True),(1463,True),(1464,True),(1465,True),(1466,True),(1467,True),(1468,True),(1469,True),(1470,True),(1471,True),(1472,True),(1473,True),(1474,True),(1475,True),(1476,True),(1477,True),(1478,True),(1479,True),(1480,True),(1481,True),(1482,True),(1483,True),(1484,True),(1485,True),(1486,True),(1487,True),(1488,True),(1489,True),(1490,True),(1491,True),(1492,True),(1493,True),(1494,True),(1495,True),(1496,True),(1497,True),(1498,True),(1499,True),(1500,True),(1501,True),(1502,True),(1503,True),(1504,True),(1505,True),(1506,True),(1507,True),(1508,True),(1509,True),(1510,True),(1511,True),(1512,True),(1513,True),(1514,True),(1515,True),(1516,True),(1517,True),(1518,True),(1519,True),(1520,True),(1521,True),(1522,True),(1523,True),(1524,True),(1525,True),(1526,True),(1527,True),(1528,True),(1529,True),(1530,True),(1531,True),(1532,True),(1533,True),(1534,True),(1535,True),(1536,True),(1537,True),(1538,True),(1539,True),(1540,True),(1541,True),(1542,True),(1543,True),(1544,True),(1545,True),(1546,True),(1547,True),(1548,True),(1549,True),(1550,True),(1551,True),(1552,True),(1553,True),(1554,True),(1555,True),(1556,True),(1557,True),(1558,True),(1559,True),(1560,True),(1561,True),(1562,True),(1563,True),(1564,True),(1565,True),(1566,True),(1567,True),(1568,True),(1569,True),(1570,True),(1571,True),(1572,True),(1573,True),(1574,True),(1575,True),(1576,True),(1577,True),(1578,True),(1579,True),(1580,True),(1581,True),(1582,True),(1583,True),(1584,True),(1585,True),(1586,True),(1587,True),(1588,True),(1589,True),(1590,True),(1591,True),(1592,True),(1593,True),(1594,True),(1595,True),(1596,True),(1597,True),(1598,True),(1599,True),(1600,True),(1601,True),(1602,True),(1603,True),(1604,True),(1605,True),(1606,True),(1607,True),(1608,True),(1609,True),(1610,True),(1611,True),(1612,True),(1613,True),(1614,True),(1615,True),(1616,True),(1617,True),(1618,True),(1619,True),(1620,True),(1621,True),(1622,True),(1623,True),(1624,True),(1625,True),(1626,True),(1627,True),(1628,True),(1629,True),(1630,True),(1631,True),(1632,True),(1633,True),(1634,True),(1635,True),(1636,True),(1637,True),(1638,True),(1639,True),(1640,True),(1641,True),(1642,True),(1643,True),(1644,True),(1645,True),(1646,True),(1647,True),(1648,True),(1649,True),(1650,True),(1651,True),(1652,True),(1653,True),(1654,True),(1655,True),(1656,True),(1657,True),(1658,True),(1659,True),(1660,True),(1661,True),(1662,True),(1663,True),(1664,True),(1665,True),(1666,True),(1667,True),(1668,True),(1669,True),(1670,True),(1671,True),(1672,True),(1673,True),(1674,True),(1675,True),(1676,True),(1677,True),(1678,True),(1679,True),(1680,True),(1681,True),(1682,True),(1683,True),(1684,True),(1685,True),(1686,True),(1687,True),(1688,True),(1689,True),(1690,True),(1691,True),(1692,True),(1693,True),(1694,True),(1695,True),(1696,True),(1697,True),(1698,True),(1699,True),(1700,True),(1701,True),(1702,True),(1703,True),(1704,True),(1705,True),(1706,True),(1707,True),(1708,True),(1709,True),(1710,True),(1711,True),(1712,True),(1713,True),(1714,True),(1715,True),(1716,True),(1717,True),(1718,True),(1719,True),(1720,True),(1721,True),(1722,True),(1723,True),(1724,True),(1725,True),(1726,True),(1727,True),(1728,True),(1729,True),(1730,True),(1731,True),(1732,True),(1733,True),(1734,True),(1735,True),(1736,True),(1737,True),(1738,True),(1739,True),(1740,True),(1741,True),(1742,True),(1743,True),(1744,True),(1745,True),(1746,True),(1747,True),(1748,True),(1749,True),(1750,True),(1751,True),(1752,True),(1753,True),(1754,True),(1755,True),(1756,True),(1757,True),(1758,True),(1759,True),(1760,True),(1761,True),(1762,True),(1763,True),(1764,True),(1765,True),(1766,True),(1767,True),(1768,True),(1769,True),(1770,True),(1771,True),(1772,True),(1773,True),(1774,True),(1775,True),(1776,True),(1777,True),(1778,True),(1779,True),(1780,True),(1781,True),(1782,True),(1783,True),(1784,True),(1785,True),(1786,True),(1787,True),(1788,True),(1789,True),(1790,True),(1791,True),(1792,True),(1793,True),(1794,True),(1795,True),(1796,True),(1797,True),(1798,True),(1799,True),(1800,True),(1801,True),(1802,True),(1803,True),(1804,True),(1805,True),(1806,True),(1807,True),(1808,True),(1809,True),(1810,True),(1811,True),(1812,True),(1813,True),(1814,True),(1815,True),(1816,True),(1817,True),(1818,True),(1819,True),(1820,True),(1821,True),(1822,True),(1823,True),(1824,True),(1825,True),(1826,True),(1827,True),(1828,True),(1829,True),(1830,True),(1831,True),(1832,True),(1833,True),(1834,True),(1835,True),(1836,True),(1837,True),(1838,True),(1839,True),(1840,True),(1841,True),(1842,True),(1843,True),(1844,True),(1845,True),(1846,True),(1847,True),(1848,True),(1849,True),(1850,True),(1851,True),(1852,True),(1853,True),(1854,True),(1855,True),(1856,True),(1857,True),(1858,True),(1859,True),(1860,True),(1861,True),(1862,True),(1863,True),(1864,True),(1865,True),(1866,True),(1867,True),(1868,True),(1869,True),(1870,True),(1871,True),(1872,True),(1873,True),(1874,True),(1875,True),(1876,True),(1877,True),(1878,True),(1879,True),(1880,True),(1881,True),(1882,True),(1883,True),(1884,True),(1885,True),(1886,True),(1887,True),(1888,True),(1889,True),(1890,True),(1891,True),(1892,True),(1893,True),(1894,True),(1895,True),(1896,True),(1897,True),(1898,True),(1899,True),(1900,True),(1901,True),(1902,True),(1903,True),(1904,True),(1905,True),(1906,True),(1907,True),(1908,True),(1909,True),(1910,True),(1911,True),(1912,True),(1913,True),(1914,True),(1915,True),(1916,True),(1917,True),(1918,True),(1919,True),(1920,True),(1921,True),(1922,True),(1923,True),(1924,True),(1925,True),(1926,True),(1927,True),(1928,True),(1929,True),(1930,True),(1931,True),(1932,True),(1933,True),(1934,True),(1935,True),(1936,True),(1937,True),(1938,True),(1939,True),(1940,True),(1941,True),(1942,True),(1943,True),(1944,True),(1945,True),(1946,True),(1947,True),(1948,True),(1949,True),(1950,True),(1951,True),(1952,True),(1953,True),(1954,True),(1955,True),(1956,True),(1957,True),(1958,True),(1959,True),(1960,True),(1961,True),(1962,True),(1963,True),(1964,True),(1965,True),(1966,True),(1967,True),(1968,True),(1969,True),(1970,True),(1971,True),(1972,True),(1973,True),(1974,True),(1975,True),(1976,True),(1977,True),(1978,True),(1979,True),(1980,True),(1981,True),(1982,True),(1983,True),(1984,True),(1985,True),(1986,True),(1987,True),(1988,True),(1989,True),(1990,True),(1991,True),(1992,True),(1993,True),(1994,True),(1995,True),(1996,True),(1997,True),(1998,True),(1999,True),(2000,True),(2001,True),(2002,True),(2003,True),(2004,True),(2005,True),(2006,True),(2007,True),(2008,True),(2009,True),(2010,True),(2011,True),(2012,True),(2013,True),(2014,True),(2015,True),(2016,True),(2017,True),(2018,True),(2019,True),(2020,True),(2021,True),(2022,True),(2023,True),(2024,True),(2025,True),(2026,True),(2027,True),(2028,True),(2029,True),(2030,True),(2031,True),(2032,True),(2033,True),(2034,True),(2035,True),(2036,True),(2037,True),(2038,True),(2039,True),(2040,True),(2041,True),(2042,True),(2043,True),(2044,True),(2045,True),(2046,True),(2047,True),(2048,True),(2049,True),(2050,True),(2051,True),(2052,True),(2053,True),(2054,True),(2055,True),(2056,True),(2057,True),(2058,True),(2059,True),(2060,True),(2061,True),(2062,True),(2063,True),(2064,True),(2065,True),(2066,True),(2067,True),(2068,True),(2069,True),(2070,True),(2071,True),(2072,True),(2073,True),(2074,True),(2075,True),(2076,True),(2077,True),(2078,True),(2079,True),(2080,True),(2081,True),(2082,True),(2083,True),(2084,True),(2085,True),(2086,True),(2087,True),(2088,True),(2089,True),(2090,True),(2091,True),(2092,True),(2093,True),(2094,True),(2095,True),(2096,True),(2097,True),(2098,True),(2099,True),(2100,True),(2101,True),(2102,True),(2103,True),(2104,True),(2105,True),(2106,True),(2107,True),(2108,True),(2109,True),(2110,True),(2111,True),(2112,True),(2113,True),(2114,True),(2115,True),(2116,True),(2117,True),(2118,True),(2119,True),(2120,True),(2121,True),(2122,True),(2123,True),(2124,True),(2125,True),(2126,True),(2127,True),(2128,True),(2129,True),(2130,True),(2131,True),(2132,True),(2133,True),(2134,True),(2135,True),(2136,True),(2137,True),(2138,True),(2139,True),(2140,True),(2141,True),(2142,True),(2143,True),(2144,True),(2145,True),(2146,True),(2147,True),(2148,True),(2149,True),(2150,True),(2151,True),(2152,True),(2153,True),(2154,True),(2155,True),(2156,True),(2157,True),(2158,True),(2159,True),(2160,True),(2161,True),(2162,True),(2163,True),(2164,True),(2165,True),(2166,True),(2167,True),(2168,True),(2169,True),(2170,True),(2171,True),(2172,True),(2173,True),(2174,True),(2175,True),(2176,True),(2177,True),(2178,True),(2179,True),(2180,True),(2181,True),(2182,True),(2183,True),(2184,True),(2185,True),(2186,True),(2187,True),(2188,True),(2189,True),(2190,True),(2191,True),(2192,True),(2193,True),(2194,True),(2195,True),(2196,True),(2197,True),(2198,True),(2199,True),(2200,True),(2201,True),(2202,True),(2203,True),(2204,True),(2205,True),(2206,True),(2207,True),(2208,True),(2209,True),(2210,True),(2211,True),(2212,True),(2213,True),(2214,True),(2215,True),(2216,True),(2217,True),(2218,True),(2219,True),(2220,True),(2221,True),(2222,True),(2223,True),(2224,True),(2225,True),(2226,True),(2227,True),(2228,True),(2229,True),(2230,True),(2231,True),(2232,True),(2233,True),(2234,True),(2235,True),(2236,True),(2237,True),(2238,True),(2239,True),(2240,True),(2241,True),(2242,True),(2243,True),(2244,True),(2245,True),(2246,True),(2247,True),(2248,True),(2249,True),(2250,True),(2251,True),(2252,True),(2253,True),(2254,True),(2255,True),(2256,True),(2257,True),(2258,True),(2259,True),(2260,True),(2261,True),(2262,True),(2263,True),(2264,True),(2265,True),(2266,True),(2267,True),(2268,True),(2269,True),(2270,True),(2271,True),(2272,True),(2273,True),(2274,True),(2275,True),(2276,True),(2277,True),(2278,True),(2279,True),(2280,True),(2281,True),(2282,True),(2283,True),(2284,True),(2285,True),(2286,True),(2287,True),(2288,True),(2289,True),(2290,True),(2291,True),(2292,True),(2293,True),(2294,True),(2295,True),(2296,True),(2297,True),(2298,True),(2299,True),(2300,True),(2301,True),(2302,True),(2303,True),(2304,True),(2305,True),(2306,True),(2307,True),(2308,True),(2309,True),(2310,True),(2311,True),(2312,True),(2313,True),(2314,True),(2315,True),(2316,True),(2317,True),(2318,True),(2319,True),(2320,True),(2321,True),(2322,True),(2323,True),(2324,True),(2325,True),(2326,True),(2327,True),(2328,True),(2329,True),(2330,True),(2331,True),(2332,True),(2333,True),(2334,True),(2335,True),(2336,True),(2337,True),(2338,True),(2339,True),(2340,True),(2341,True),(2342,True),(2343,True),(2344,True),(2345,True),(2346,True),(2347,True),(2348,True),(2349,True),(2350,True),(2351,True),(2352,True),(2353,True),(2354,True),(2355,True),(2356,True),(2357,True),(2358,True),(2359,True),(2360,True),(2361,True),(2362,True),(2363,True),(2364,True),(2365,True),(2366,True),(2367,True),(2368,True),(2369,True),(2370,True),(2371,True),(2372,True),(2373,True),(2374,True),(2375,True),(2376,True),(2377,True),(2378,True),(2379,True),(2380,True),(2381,True),(2382,True),(2383,True),(2384,True),(2385,True),(2386,True),(2387,True),(2388,True),(2389,True),(2390,True),(2391,True),(2392,True),(2393,True),(2394,True),(2395,True),(2396,True),(2397,True),(2398,True),(2399,True),(2400,True),(2401,True),(2402,True),(2403,True),(2404,True),(2405,True),(2406,True),(2407,True),(2408,True),(2409,True),(2410,True),(2411,True),(2412,True),(2413,True),(2414,True),(2415,True),(2416,True),(2417,True),(2418,True),(2419,True),(2420,True),(2421,True),(2422,True),(2423,True),(2424,True),(2425,True),(2426,True),(2427,True),(2428,True),(2429,True),(2430,True),(2431,True),(2432,True),(2433,True),(2434,True),(2435,True),(2436,True),(2437,True),(2438,True),(2439,True),(2440,True),(2441,True),(2442,True),(2443,True),(2444,True),(2445,True),(2446,True),(2447,True),(2448,True),(2449,True),(2450,True),(2451,True),(2452,True),(2453,True),(2454,True),(2455,True),(2456,True),(2457,True),(2458,True),(2459,True),(2460,True),(2461,True),(2462,True),(2463,True),(2464,True),(2465,True),(2466,True),(2467,True),(2468,True),(2469,True),(2470,True),(2471,True),(2472,True),(2473,True),(2474,True),(2475,True),(2476,True),(2477,True),(2478,True),(2479,True),(2480,True),(2481,True),(2482,True),(2483,True),(2484,True),(2485,True),(2486,True),(2487,True),(2488,True),(2489,True),(2490,True),(2491,True),(2492,True),(2493,True),(2494,True),(2495,True),(2496,True),(2497,True),(2498,True),(2499,True),(2500,True),(2501,True),(2502,True),(2503,True),(2504,True),(2505,True),(2506,True),(2507,True),(2508,True),(2509,True),(2510,True),(2511,True),(2512,True),(2513,True),(2514,True),(2515,True),(2516,True),(2517,True),(2518,True),(2519,True),(2520,True),(2521,True),(2522,True),(2523,True),(2524,True),(2525,True),(2526,True),(2527,True),(2528,True),(2529,True),(2530,True),(2531,True),(2532,True),(2533,True),(2534,True),(2535,True),(2536,True),(2537,True),(2538,True),(2539,True),(2540,True),(2541,True),(2542,True),(2543,True),(2544,True),(2545,True),(2546,True),(2547,True),(2548,True),(2549,True),(2550,True),(2551,True),(2552,True),(2553,True),(2554,True),(2555,True),(2556,True),(2557,True),(2558,True),(2559,True),(2560,True),(2561,True),(2562,True),(2563,True),(2564,True),(2565,True),(2566,True),(2567,True),(2568,True),(2569,True),(2570,True),(2571,True),(2572,True),(2573,True),(2574,True),(2575,True),(2576,True),(2577,True),(2578,True),(2579,True),(2580,True),(2581,True),(2582,True),(2583,True),(2584,True),(2585,True),(2586,True),(2587,True),(2588,True),(2589,True),(2590,True),(2591,True),(2592,True),(2593,True),(2594,True),(2595,True),(2596,True),(2597,True),(2598,True),(2599,True),(2600,True),(2601,True),(2602,True),(2603,True),(2604,True),(2605,True),(2606,True),(2607,True),(2608,True),(2609,True),(2610,True),(2611,True),(2612,True),(2613,True),(2614,True),(2615,True),(2616,True),(2617,True),(2618,True),(2619,True),(2620,True),(2621,True),(2622,True),(2623,True),(2624,True),(2625,True),(2626,True),(2627,True),(2628,True),(2629,True),(2630,True),(2631,True),(2632,True),(2633,True),(2634,True),(2635,True),(2636,True),(2637,True),(2638,True),(2639,True),(2640,True),(2641,True),(2642,True),(2643,True),(2644,True),(2645,True),(2646,True),(2647,True),(2648,True),(2649,True),(2650,True),(2651,True),(2652,True),(2653,True),(2654,True),(2655,True),(2656,True),(2657,True),(2658,True),(2659,True),(2660,True),(2661,True),(2662,True),(2663,True),(2664,True),(2665,True),(2666,True),(2667,True),(2668,True),(2669,True),(2670,True),(2671,True),(2672,True),(2673,True),(2674,True),(2675,True),(2676,True),(2677,True),(2678,True),(2679,True),(2680,True),(2681,True),(2682,True),(2683,True),(2684,True),(2685,True),(2686,True),(2687,True),(2688,True),(2689,True),(2690,True),(2691,True),(2692,True),(2693,True),(2694,True),(2695,True),(2696,True),(2697,True),(2698,True),(2699,True),(2700,True),(2701,True),(2702,True),(2703,True),(2704,True),(2705,True),(2706,True),(2707,True),(2708,True),(2709,True),(2710,True),(2711,True),(2712,True),(2713,True),(2714,True),(2715,True),(2716,True),(2717,True),(2718,True),(2719,True),(2720,True),(2721,True),(2722,True),(2723,True),(2724,True),(2725,True),(2726,True),(2727,True),(2728,True),(2729,True),(2730,True),(2731,True),(2732,True),(2733,True),(2734,True),(2735,True),(2736,True),(2737,True),(2738,True),(2739,True),(2740,True),(2741,True),(2742,True),(2743,True),(2744,True),(2745,True),(2746,True),(2747,True),(2748,True),(2749,True),(2750,True),(2751,True),(2752,True),(2753,True),(2754,True),(2755,True),(2756,True),(2757,True),(2758,True),(2759,True),(2760,True),(2761,True),(2762,True),(2763,True),(2764,True),(2765,True),(2766,True),(2767,True),(2768,True),(2769,True),(2770,True),(2771,True),(2772,True),(2773,True),(2774,True),(2775,True),(2776,True),(2777,True),(2778,True),(2779,True),(2780,True),(2781,True),(2782,True),(2783,True),(2784,True),(2785,True),(2786,True),(2787,True),(2788,True),(2789,True),(2790,True),(2791,True),(2792,True),(2793,True),(2794,True),(2795,True),(2796,True),(2797,True),(2798,True),(2799,True),(2800,True),(2801,True),(2802,True),(2803,True),(2804,True),(2805,True),(2806,True),(2807,True),(2808,True),(2809,True),(2810,True),(2811,True),(2812,True),(2813,True),(2814,True),(2815,True),(2816,True),(2817,True),(2818,True),(2819,True),(2820,True),(2821,True),(2822,True),(2823,True),(2824,True),(2825,True),(2826,True),(2827,True),(2828,True),(2829,True),(2830,True),(2831,True),(2832,True),(2833,True),(2834,True),(2835,True),(2836,True),(2837,True),(2838,True),(2839,True),(2840,True),(2841,True),(2842,True),(2843,True),(2844,True),(2845,True),(2846,True),(2847,True),(2848,True),(2849,True),(2850,True),(2851,True),(2852,True),(2853,True),(2854,True),(2855,True),(2856,True),(2857,True),(2858,True),(2859,True),(2860,True),(2861,True),(2862,True),(2863,True),(2864,True),(2865,True),(2866,True),(2867,True),(2868,True),(2869,True),(2870,True),(2871,True),(2872,True),(2873,True),(2874,True),(2875,True),(2876,True),(2877,True),(2878,True),(2879,True),(2880,True),(2881,True),(2882,True),(2883,True),(2884,True),(2885,True),(2886,True),(2887,True),(2888,True),(2889,True),(2890,True),(2891,True),(2892,True),(2893,True),(2894,True),(2895,True),(2896,True),(2897,True),(2898,True),(2899,True),(2900,True),(2901,True),(2902,True),(2903,True),(2904,True),(2905,True),(2906,True),(2907,True),(2908,True),(2909,True),(2910,True),(2911,True),(2912,True),(2913,True),(2914,True),(2915,True),(2916,True),(2917,True),(2918,True),(2919,True),(2920,True),(2921,True),(2922,True),(2923,True),(2924,True),(2925,True),(2926,True),(2927,True),(2928,True),(2929,True),(2930,True),(2931,True),(2932,True),(2933,True),(2934,True),(2935,True),(2936,True),(2937,True),(2938,True),(2939,True),(2940,True),(2941,True),(2942,True),(2943,True),(2944,True),(2945,True),(2946,True),(2947,True),(2948,True),(2949,True),(2950,True),(2951,True),(2952,True),(2953,True),(2954,True),(2955,True),(2956,True),(2957,True),(2958,True),(2959,True),(2960,True),(2961,True),(2962,True),(2963,True),(2964,True),(2965,True),(2966,True),(2967,True),(2968,True),(2969,True),(2970,True),(2971,True),(2972,True),(2973,True),(2974,True),(2975,True),(2976,True),(2977,True),(2978,True),(2979,True),(2980,True),(2981,True),(2982,True),(2983,True),(2984,True),(2985,True),(2986,True),(2987,True),(2988,True),(2989,True),(2990,True),(2991,True),(2992,True),(2993,True),(2994,True),(2995,True),(2996,True),(2997,True),(2998,True),(2999,True),(3000,True),(3001,True),(3002,True),(3003,True),(3004,True),(3005,True),(3006,True),(3007,True),(3008,True),(3009,True),(3010,True),(3011,True),(3012,True),(3013,True),(3014,True),(3015,True),(3016,True),(3017,True),(3018,True),(3019,True),(3020,True),(3021,True),(3022,True),(3023,True),(3024,True),(3025,True),(3026,True),(3027,True),(3028,True),(3029,True),(3030,True),(3031,True),(3032,True),(3033,True),(3034,True),(3035,True),(3036,True),(3037,True),(3038,True),(3039,True),(3040,True),(3041,True),(3042,True),(3043,True),(3044,True),(3045,True),(3046,True),(3047,True),(3048,True),(3049,True),(3050,True),(3051,True),(3052,True),(3053,True),(3054,True),(3055,True),(3056,True),(3057,True),(3058,True),(3059,True),(3060,True),(3061,True),(3062,True),(3063,True),(3064,True),(3065,True),(3066,True),(3067,True),(3068,True),(3069,True),(3070,True),(3071,True),(3072,True),(3073,True),(3074,True),(3075,True),(3076,True),(3077,True),(3078,True),(3079,True),(3080,True),(3081,True),(3082,True),(3083,True),(3084,True),(3085,True),(3086,True),(3087,True),(3088,True),(3089,True),(3090,True),(3091,True),(3092,True),(3093,True),(3094,True),(3095,True),(3096,True),(3097,True),(3098,True),(3099,True),(3100,True),(3101,True),(3102,True),(3103,True),(3104,True),(3105,True),(3106,True),(3107,True),(3108,True),(3109,True),(3110,True),(3111,True),(3112,True),(3113,True),(3114,True),(3115,True),(3116,True),(3117,True),(3118,True),(3119,True),(3120,True),(3121,True),(3122,True),(3123,True),(3124,True),(3125,True),(3126,True),(3127,True),(3128,True),(3129,True),(3130,True),(3131,True),(3132,True),(3133,True),(3134,True),(3135,True),(3136,True),(3137,True),(3138,True),(3139,True),(3140,True),(3141,True),(3142,True),(3143,True),(3144,True),(3145,True),(3146,True),(3147,True),(3148,True),(3149,True),(3150,True),(3151,True),(3152,True),(3153,True),(3154,True),(3155,True),(3156,True),(3157,True),(3158,True),(3159,True),(3160,True),(3161,True),(3162,True),(3163,True),(3164,True),(3165,True),(3166,True),(3167,True),(3168,True),(3169,True),(3170,True),(3171,True),(3172,True),(3173,True),(3174,True),(3175,True),(3176,True),(3177,True),(3178,True),(3179,True),(3180,True),(3181,True),(3182,True),(3183,True),(3184,True),(3185,True),(3186,True),(3187,True),(3188,True),(3189,True),(3190,True),(3191,True),(3192,True),(3193,True),(3194,True),(3195,True),(3196,True),(3197,True),(3198,True),(3199,True),(3200,True),(3201,True),(3202,True),(3203,True),(3204,True),(3205,True),(3206,True),(3207,True),(3208,True),(3209,True),(3210,True),(3211,True),(3212,True),(3213,True),(3214,True),(3215,True),(3216,True),(3217,True),(3218,True),(3219,True),(3220,True),(3221,True),(3222,True),(3223,True),(3224,True),(3225,True),(3226,True),(3227,True),(3228,True),(3229,True),(3230,True),(3231,True),(3232,True),(3233,True),(3234,True),(3235,True),(3236,True),(3237,True),(3238,True),(3239,True),(3240,True),(3241,True),(3242,True),(3243,True),(3244,True),(3245,True),(3246,True),(3247,True),(3248,True),(3249,True),(3250,True),(3251,True),(3252,True),(3253,True),(3254,True),(3255,True),(3256,True),(3257,True),(3258,True),(3259,True),(3260,True),(3261,True),(3262,True),(3263,True),(3264,True),(3265,True),(3266,True),(3267,True),(3268,True),(3269,True),(3270,True),(3271,True),(3272,True),(3273,True),(3274,True),(3275,True),(3276,True),(3277,True),(3278,True),(3279,True),(3280,True),(3281,True),(3282,True),(3283,True),(3284,True),(3285,True),(3286,True),(3287,True),(3288,True),(3289,True),(3290,True),(3291,True),(3292,True),(3293,True),(3294,True),(3295,True),(3296,True),(3297,True),(3298,True),(3299,True),(3300,True),(3301,True),(3302,True),(3303,True),(3304,True),(3305,True),(3306,True),(3307,True),(3308,True),(3309,True),(3310,True),(3311,True),(3312,True),(3313,True),(3314,True),(3315,True),(3316,True),(3317,True),(3318,True),(3319,True),(3320,True),(3321,True),(3322,True),(3323,True),(3324,True),(3325,True),(3326,True),(3327,True),(3328,True),(3329,True),(3330,True),(3331,True),(3332,True),(3333,True),(3334,True),(3335,True),(3336,True),(3337,True),(3338,True),(3339,True),(3340,True),(3341,True),(3342,True),(3343,True),(3344,True),(3345,True),(3346,True),(3347,True),(3348,True),(3349,True),(3350,True),(3351,True),(3352,True),(3353,True),(3354,True),(3355,True),(3356,True),(3357,True),(3358,True),(3359,True),(3360,True),(3361,True),(3362,True),(3363,True),(3364,True),(3365,True),(3366,True),(3367,True),(3368,True),(3369,True),(3370,True),(3371,True),(3372,True),(3373,True),(3374,True),(3375,True),(3376,True),(3377,True),(3378,True),(3379,True),(3380,True),(3381,True),(3382,True),(3383,True),(3384,True),(3385,True),(3386,True),(3387,True),(3388,True),(3389,True),(3390,True),(3391,True),(3392,True),(3393,True),(3394,True),(3395,True),(3396,True),(3397,True),(3398,True),(3399,True),(3400,True),(3401,True),(3402,True),(3403,True),(3404,True),(3405,True),(3406,True),(3407,True),(3408,True),(3409,True),(3410,True),(3411,True),(3412,True),(3413,True),(3414,True),(3415,True),(3416,True),(3417,True),(3418,True),(3419,True),(3420,True),(3421,True),(3422,True),(3423,True),(3424,True),(3425,True),(3426,True),(3427,True),(3428,True),(3429,True),(3430,True),(3431,True),(3432,True),(3433,True),(3434,True),(3435,True),(3436,True),(3437,True),(3438,True),(3439,True),(3440,True),(3441,True),(3442,True),(3443,True),(3444,True),(3445,True),(3446,True),(3447,True),(3448,True),(3449,True),(3450,True),(3451,True),(3452,True),(3453,True),(3454,True),(3455,True),(3456,True),(3457,True),(3458,True),(3459,True),(3460,True),(3461,True),(3462,True),(3463,True),(3464,True),(3465,True),(3466,True),(3467,True),(3468,True),(3469,True),(3470,True),(3471,True),(3472,True),(3473,True),(3474,True),(3475,True),(3476,True),(3477,True),(3478,True),(3479,True),(3480,True),(3481,True),(3482,True),(3483,True),(3484,True),(3485,True),(3486,True),(3487,True),(3488,True),(3489,True),(3490,True),(3491,True),(3492,True),(3493,True),(3494,True),(3495,True),(3496,True),(3497,True),(3498,True),(3499,True),(3500,True),(3501,True),(3502,True),(3503,True),(3504,True),(3505,True),(3506,True),(3507,True),(3508,True),(3509,True),(3510,True),(3511,True),(3512,True),(3513,True),(3514,True),(3515,True),(3516,True),(3517,True),(3518,True),(3519,True),(3520,True),(3521,True),(3522,True),(3523,True),(3524,True),(3525,True),(3526,True),(3527,True),(3528,True),(3529,True),(3530,True),(3531,True),(3532,True),(3533,True),(3534,True),(3535,True),(3536,True),(3537,True),(3538,True),(3539,True),(3540,True),(3541,True),(3542,True),(3543,True),(3544,True),(3545,True),(3546,True),(3547,True),(3548,True),(3549,True),(3550,True),(3551,True),(3552,True),(3553,True),(3554,True),(3555,True),(3556,True),(3557,True),(3558,True),(3559,True),(3560,True),(3561,True),(3562,True),(3563,True),(3564,True),(3565,True),(3566,True),(3567,True),(3568,True),(3569,True),(3570,True),(3571,True),(3572,True),(3573,True),(3574,True),(3575,True),(3576,True),(3577,True),(3578,True),(3579,True),(3580,True),(3581,True),(3582,True),(3583,True),(3584,True),(3585,True),(3586,True),(3587,True),(3588,True),(3589,True),(3590,True),(3591,True),(3592,True),(3593,True),(3594,True),(3595,True),(3596,True),(3597,True),(3598,True),(3599,True),(3600,True),(3601,True),(3602,True),(3603,True),(3604,True),(3605,True),(3606,True),(3607,True),(3608,True),(3609,True),(3610,True),(3611,True),(3612,True),(3613,True),(3614,True),(3615,True),(3616,True),(3617,True),(3618,True),(3619,True),(3620,True),(3621,True),(3622,True),(3623,True),(3624,True),(3625,True),(3626,True),(3627,True),(3628,True),(3629,True),(3630,True),(3631,True),(3632,True),(3633,True),(3634,True),(3635,True),(3636,True),(3637,True),(3638,True),(3639,True),(3640,True),(3641,True),(3642,True),(3643,True),(3644,True),(3645,True),(3646,True),(3647,True),(3648,True),(3649,True),(3650,True),(3651,True),(3652,True),(3653,True),(3654,True),(3655,True),(3656,True),(3657,True),(3658,True),(3659,True),(3660,True),(3661,True),(3662,True),(3663,True),(3664,True),(3665,True),(3666,True),(3667,True),(3668,True),(3669,True),(3670,True),(3671,True),(3672,True),(3673,True),(3674,True),(3675,True),(3676,True),(3677,True),(3678,True),(3679,True),(3680,True),(3681,True),(3682,True),(3683,True),(3684,True),(3685,True),(3686,True),(3687,True),(3688,True),(3689,True),(3690,True),(3691,True),(3692,True),(3693,True),(3694,True),(3695,True),(3696,True),(3697,True),(3698,True),(3699,True),(3700,True),(3701,True),(3702,True),(3703,True),(3704,True),(3705,True),(3706,True),(3707,True),(3708,True),(3709,True),(3710,True),(3711,True),(3712,True),(3713,True),(3714,True),(3715,True),(3716,True),(3717,True),(3718,True),(3719,True),(3720,True),(3721,True),(3722,True),(3723,True),(3724,True),(3725,True),(3726,True),(3727,True),(3728,True),(3729,True),(3730,True),(3731,True),(3732,True),(3733,True),(3734,True),(3735,True),(3736,True),(3737,True),(3738,True),(3739,True),(3740,True),(3741,True),(3742,True),(3743,True),(3744,True),(3745,True),(3746,True),(3747,True),(3748,True),(3749,True),(3750,True),(3751,True),(3752,True),(3753,True),(3754,True),(3755,True),(3756,True),(3757,True),(3758,True),(3759,True),(3760,True),(3761,True),(3762,True),(3763,True),(3764,True),(3765,True),(3766,True),(3767,True),(3768,True),(3769,True),(3770,True),(3771,True),(3772,True),(3773,True),(3774,True),(3775,True),(3776,True),(3777,True),(3778,True),(3779,True),(3780,True),(3781,True),(3782,True),(3783,True),(3784,True),(3785,True),(3786,True),(3787,True),(3788,True),(3789,True),(3790,True),(3791,True),(3792,True),(3793,True),(3794,True),(3795,True),(3796,True),(3797,True),(3798,True),(3799,True),(3800,True),(3801,True),(3802,True),(3803,True),(3804,True),(3805,True),(3806,True),(3807,True),(3808,True),(3809,True),(3810,True),(3811,True),(3812,True),(3813,True),(3814,True),(3815,True),(3816,True),(3817,True),(3818,True),(3819,True),(3820,True),(3821,True),(3822,True),(3823,True),(3824,True),(3825,True),(3826,True),(3827,True),(3828,True),(3829,True),(3830,True),(3831,True),(3832,True),(3833,True),(3834,True),(3835,True),(3836,True),(3837,True),(3838,True),(3839,True),(3840,True),(3841,True),(3842,True),(3843,True),(3844,True),(3845,True),(3846,True),(3847,True),(3848,True),(3849,True),(3850,True),(3851,True),(3852,True),(3853,True),(3854,True),(3855,True),(3856,True),(3857,True),(3858,True),(3859,True),(3860,True),(3861,True),(3862,True),(3863,True),(3864,True),(3865,True),(3866,True),(3867,True),(3868,True),(3869,True),(3870,True),(3871,True),(3872,True),(3873,True),(3874,True),(3875,True),(3876,True),(3877,True),(3878,True),(3879,True),(3880,True),(3881,True),(3882,True),(3883,True),(3884,True),(3885,True),(3886,True),(3887,True),(3888,True),(3889,True),(3890,True),(3891,True),(3892,True),(3893,True),(3894,True),(3895,True),(3896,True),(3897,True),(3898,True),(3899,True),(3900,True),(3901,True),(3902,True),(3903,True),(3904,True),(3905,True),(3906,True),(3907,True),(3908,True),(3909,True),(3910,True),(3911,True),(3912,True),(3913,True),(3914,True),(3915,True),(3916,True),(3917,True),(3918,True),(3919,True),(3920,True),(3921,True),(3922,True),(3923,True),(3924,True),(3925,True),(3926,True),(3927,True),(3928,True),(3929,True),(3930,True),(3931,True),(3932,True),(3933,True),(3934,True),(3935,True),(3936,True),(3937,True),(3938,True),(3939,True),(3940,True),(3941,True),(3942,True),(3943,True),(3944,True),(3945,True),(3946,True),(3947,True),(3948,True),(3949,True),(3950,True),(3951,True),(3952,True),(3953,True),(3954,True),(3955,True),(3956,True),(3957,True),(3958,True),(3959,True),(3960,True),(3961,True),(3962,True),(3963,True),(3964,True),(3965,True),(3966,True),(3967,True),(3968,True),(3969,True),(3970,True),(3971,True),(3972,True),(3973,True),(3974,True),(3975,True),(3976,True),(3977,True),(3978,True),(3979,True),(3980,True),(3981,True),(3982,True),(3983,True),(3984,True),(3985,True),(3986,True),(3987,True),(3988,True),(3989,True),(3990,True),(3991,True),(3992,True),(3993,True),(3994,True),(3995,True),(3996,True),(3997,True),(3998,True),(3999,True),(4000,True),(4001,True),(4002,True),(4003,True),(4004,True),(4005,True),(4006,True),(4007,True),(4008,True),(4009,True),(4010,True),(4011,True),(4012,True),(4013,True),(4014,True),(4015,True),(4016,True),(4017,True),(4018,True),(4019,True),(4020,True),(4021,True),(4022,True),(4023,True),(4024,True),(4025,True),(4026,True),(4027,True),(4028,True),(4029,True),(4030,True),(4031,True),(4032,True),(4033,True),(4034,True),(4035,True),(4036,True),(4037,True),(4038,True),(4039,True),(4040,True),(4041,True),(4042,True),(4043,True),(4044,True),(4045,True),(4046,True),(4047,True),(4048,True),(4049,True),(4050,True),(4051,True),(4052,True),(4053,True),(4054,True),(4055,True),(4056,True),(4057,True),(4058,True),(4059,True),(4060,True),(4061,True),(4062,True),(4063,True),(4064,True),(4065,True),(4066,True),(4067,True),(4068,True),(4069,True),(4070,True),(4071,True),(4072,True),(4073,True),(4074,True),(4075,True),(4076,True),(4077,True),(4078,True),(4079,True),(4080,True),(4081,True),(4082,True),(4083,True),(4084,True),(4085,True),(4086,True),(4087,True),(4088,True),(4089,True),(4090,True),(4091,True),(4092,True),(4093,True),(4094,True),(4095,True),(4096,True),(4097,True),(4098,True),(4099,True),(4100,True),(4101,True),(4102,True),(4103,True),(4104,True),(4105,True),(4106,True),(4107,True),(4108,True),(4109,True),(4110,True),(4111,True),(4112,True),(4113,True),(4114,True),(4115,True),(4116,True),(4117,True),(4118,True),(4119,True),(4120,True),(4121,True),(4122,True),(4123,True),(4124,True),(4125,True),(4126,True),(4127,True),(4128,True),(4129,True),(4130,True),(4131,True),(4132,True),(4133,True),(4134,True),(4135,True),(4136,True),(4137,True),(4138,True),(4139,True),(4140,True),(4141,True),(4142,True),(4143,True),(4144,True),(4145,True),(4146,True),(4147,True),(4148,True),(4149,True),(4150,True),(4151,True),(4152,True),(4153,True),(4154,True),(4155,True),(4156,True),(4157,True),(4158,True),(4159,True),(4160,True),(4161,True),(4162,True),(4163,True),(4164,True),(4165,True),(4166,True),(4167,True),(4168,True),(4169,True),(4170,True),(4171,True),(4172,True),(4173,True),(4174,True),(4175,True),(4176,True),(4177,True),(4178,True),(4179,True),(4180,True),(4181,True),(4182,True),(4183,True),(4184,True),(4185,True),(4186,True),(4187,True),(4188,True),(4189,True),(4190,True),(4191,True),(4192,True),(4193,True),(4194,True),(4195,True),(4196,True),(4197,True),(4198,True),(4199,True),(4200,True),(4201,True),(4202,True),(4203,True),(4204,True),(4205,True),(4206,True),(4207,True),(4208,True),(4209,True),(4210,True),(4211,True),(4212,True),(4213,True),(4214,True),(4215,True),(4216,True),(4217,True),(4218,True),(4219,True),(4220,True),(4221,True),(4222,True),(4223,True),(4224,True),(4225,True),(4226,True),(4227,True),(4228,True),(4229,True),(4230,True),(4231,True),(4232,True),(4233,True),(4234,True),(4235,True),(4236,True),(4237,True),(4238,True),(4239,True),(4240,True),(4241,True),(4242,True),(4243,True),(4244,True),(4245,True),(4246,True),(4247,True),(4248,True),(4249,True),(4250,True),(4251,True),(4252,True),(4253,True),(4254,True),(4255,True),(4256,True),(4257,True),(4258,True),(4259,True),(4260,True),(4261,True),(4262,True),(4263,True),(4264,True),(4265,True),(4266,True),(4267,True),(4268,True),(4269,True),(4270,True),(4271,True),(4272,True),(4273,True),(4274,True),(4275,True),(4276,True),(4277,True),(4278,True),(4279,True),(4280,True),(4281,True),(4282,True),(4283,True),(4284,True),(4285,True),(4286,True),(4287,True),(4288,True),(4289,True),(4290,True),(4291,True),(4292,True),(4293,True),(4294,True),(4295,True),(4296,True),(4297,True),(4298,True),(4299,True),(4300,True),(4301,True),(4302,True),(4303,True),(4304,True),(4305,True),(4306,True),(4307,True),(4308,True),(4309,True),(4310,True),(4311,True),(4312,True),(4313,True),(4314,True),(4315,True),(4316,True),(4317,True),(4318,True),(4319,True),(4320,True),(4321,True),(4322,True),(4323,True),(4324,True),(4325,True),(4326,True),(4327,True),(4328,True),(4329,True),(4330,True),(4331,True),(4332,True),(4333,True),(4334,True),(4335,True),(4336,True),(4337,True),(4338,True),(4339,True),(4340,True),(4341,True),(4342,True),(4343,True),(4344,True),(4345,True),(4346,True),(4347,True),(4348,True),(4349,True),(4350,True),(4351,True),(4352,True),(4353,True),(4354,True),(4355,True),(4356,True),(4357,True),(4358,True),(4359,True),(4360,True),(4361,True),(4362,True),(4363,True),(4364,True),(4365,True),(4366,True),(4367,True),(4368,True),(4369,True),(4370,True),(4371,True),(4372,True),(4373,True),(4374,True),(4375,True),(4376,True),(4377,True),(4378,True),(4379,True),(4380,True),(4381,True),(4382,True),(4383,True),(4384,True),(4385,True),(4386,True),(4387,True),(4388,True),(4389,True),(4390,True),(4391,True),(4392,True),(4393,True),(4394,True),(4395,True),(4396,True),(4397,True),(4398,True),(4399,True),(4400,True),(4401,True),(4402,True),(4403,True),(4404,True),(4405,True),(4406,True),(4407,True),(4408,True),(4409,True),(4410,True),(4411,True),(4412,True),(4413,True),(4414,True),(4415,True),(4416,True),(4417,True),(4418,True),(4419,True),(4420,True),(4421,True),(4422,True),(4423,True),(4424,True),(4425,True),(4426,True),(4427,True),(4428,True),(4429,True),(4430,True),(4431,True),(4432,True),(4433,True),(4434,True),(4435,True),(4436,True),(4437,True),(4438,True),(4439,True),(4440,True),(4441,True),(4442,True),(4443,True),(4444,True),(4445,True),(4446,True),(4447,True),(4448,True),(4449,True),(4450,True),(4451,True),(4452,True),(4453,True),(4454,True),(4455,True),(4456,True),(4457,True),(4458,True),(4459,True),(4460,True),(4461,True),(4462,True),(4463,True),(4464,True),(4465,True),(4466,True),(4467,True),(4468,True),(4469,True),(4470,True),(4471,True),(4472,True),(4473,True),(4474,True),(4475,True),(4476,True),(4477,True),(4478,True),(4479,True),(4480,True),(4481,True),(4482,True),(4483,True),(4484,True),(4485,True),(4486,True),(4487,True),(4488,True),(4489,True),(4490,True),(4491,True),(4492,True),(4493,True),(4494,True),(4495,True),(4496,True),(4497,True),(4498,True),(4499,True),(4500,True),(4501,True),(4502,True),(4503,True),(4504,True),(4505,True),(4506,True),(4507,True),(4508,True),(4509,True),(4510,True),(4511,True),(4512,True),(4513,True),(4514,True),(4515,True),(4516,True),(4517,True),(4518,True),(4519,True),(4520,True),(4521,True),(4522,True),(4523,True),(4524,True),(4525,True),(4526,True),(4527,True),(4528,True),(4529,True),(4530,True),(4531,True),(4532,True),(4533,True),(4534,True),(4535,True),(4536,True),(4537,True),(4538,True),(4539,True),(4540,True),(4541,True),(4542,True),(4543,True),(4544,True),(4545,True),(4546,True),(4547,True),(4548,True),(4549,True),(4550,True),(4551,True),(4552,True),(4553,True),(4554,True),(4555,True),(4556,True),(4557,True),(4558,True),(4559,True),(4560,True),(4561,True),(4562,True),(4563,True),(4564,True),(4565,True),(4566,True),(4567,True),(4568,True),(4569,True),(4570,True),(4571,True),(4572,True),(4573,True),(4574,True),(4575,True),(4576,True),(4577,True),(4578,True),(4579,True),(4580,True),(4581,True),(4582,True),(4583,True),(4584,True),(4585,True),(4586,True),(4587,True),(4588,True),(4589,True),(4590,True),(4591,True),(4592,True),(4593,True),(4594,True),(4595,True),(4596,True),(4597,True),(4598,True),(4599,True),(4600,True),(4601,True),(4602,True),(4603,True),(4604,True),(4605,True),(4606,True),(4607,True),(4608,True),(4609,True),(4610,True),(4611,True),(4612,True),(4613,True),(4614,True),(4615,True),(4616,True),(4617,True),(4618,True),(4619,True),(4620,True),(4621,True),(4622,True),(4623,True),(4624,True),(4625,True),(4626,True),(4627,True),(4628,True),(4629,True),(4630,True),(4631,True),(4632,True),(4633,True),(4634,True),(4635,True),(4636,True),(4637,True),(4638,True),(4639,True),(4640,True),(4641,True),(4642,True),(4643,True),(4644,True),(4645,True),(4646,True),(4647,True),(4648,True),(4649,True),(4650,True),(4651,True),(4652,True),(4653,True),(4654,True),(4655,True),(4656,True),(4657,True),(4658,True),(4659,True),(4660,True),(4661,True),(4662,True),(4663,True),(4664,True),(4665,True),(4666,True),(4667,True),(4668,True),(4669,True),(4670,True),(4671,True),(4672,True),(4673,True),(4674,True),(4675,True),(4676,True),(4677,True),(4678,True),(4679,True),(4680,True),(4681,True),(4682,True),(4683,True),(4684,True),(4685,True),(4686,True),(4687,True),(4688,True),(4689,True),(4690,True),(4691,True),(4692,True),(4693,True),(4694,True),(4695,True),(4696,True),(4697,True),(4698,True),(4699,True),(4700,True),(4701,True),(4702,True),(4703,True),(4704,True),(4705,True),(4706,True),(4707,True),(4708,True),(4709,True),(4710,True),(4711,True),(4712,True),(4713,True),(4714,True),(4715,True),(4716,True),(4717,True),(4718,True),(4719,True),(4720,True),(4721,True),(4722,True),(4723,True),(4724,True),(4725,True),(4726,True),(4727,True),(4728,True),(4729,True),(4730,True),(4731,True),(4732,True),(4733,True),(4734,True),(4735,True),(4736,True),(4737,True),(4738,True),(4739,True),(4740,True),(4741,True),(4742,True),(4743,True),(4744,True),(4745,True),(4746,True),(4747,True),(4748,True),(4749,True),(4750,True),(4751,True),(4752,True),(4753,True),(4754,True),(4755,True),(4756,True),(4757,True),(4758,True),(4759,True),(4760,True),(4761,True),(4762,True),(4763,True),(4764,True),(4765,True),(4766,True),(4767,True),(4768,True),(4769,True),(4770,True),(4771,True),(4772,True),(4773,True),(4774,True),(4775,True),(4776,True),(4777,True),(4778,True),(4779,True),(4780,True),(4781,True),(4782,True),(4783,True),(4784,True),(4785,True),(4786,True),(4787,True),(4788,True),(4789,True),(4790,True),(4791,True),(4792,True),(4793,True),(4794,True),(4795,True),(4796,True),(4797,True),(4798,True),(4799,True),(4800,True),(4801,True),(4802,True),(4803,True),(4804,True),(4805,True),(4806,True),(4807,True),(4808,True),(4809,True),(4810,True),(4811,True),(4812,True),(4813,True),(4814,True),(4815,True),(4816,True),(4817,True),(4818,True),(4819,True),(4820,True),(4821,True),(4822,True),(4823,True),(4824,True),(4825,True),(4826,True),(4827,True),(4828,True),(4829,True),(4830,True),(4831,True),(4832,True),(4833,True),(4834,True),(4835,True),(4836,True),(4837,True),(4838,True),(4839,True),(4840,True),(4841,True),(4842,True),(4843,True),(4844,True),(4845,True),(4846,True),(4847,True),(4848,True),(4849,True),(4850,True),(4851,True),(4852,True),(4853,True),(4854,True),(4855,True),(4856,True),(4857,True),(4858,True),(4859,True),(4860,True),(4861,True),(4862,True),(4863,True),(4864,True),(4865,True),(4866,True),(4867,True),(4868,True),(4869,True),(4870,True),(4871,True),(4872,True),(4873,True),(4874,True),(4875,True),(4876,True),(4877,True),(4878,True),(4879,True),(4880,True),(4881,True),(4882,True),(4883,True),(4884,True),(4885,True),(4886,True),(4887,True),(4888,True),(4889,True),(4890,True),(4891,True),(4892,True),(4893,True),(4894,True),(4895,True),(4896,True),(4897,True),(4898,True),(4899,True),(4900,True),(4901,True),(4902,True),(4903,True),(4904,True),(4905,True),(4906,True),(4907,True),(4908,True),(4909,True),(4910,True),(4911,True),(4912,True),(4913,True),(4914,True),(4915,True),(4916,True),(4917,True),(4918,True),(4919,True),(4920,True),(4921,True),(4922,True),(4923,True),(4924,True),(4925,True),(4926,True),(4927,True),(4928,True),(4929,True),(4930,True),(4931,True),(4932,True),(4933,True),(4934,True),(4935,True),(4936,True),(4937,True),(4938,True),(4939,True),(4940,True),(4941,True),(4942,True),(4943,True),(4944,True),(4945,True),(4946,True),(4947,True),(4948,True),(4949,True),(4950,True),(4951,True),(4952,True),(4953,True),(4954,True),(4955,True),(4956,True),(4957,True),(4958,True),(4959,True),(4960,True),(4961,True),(4962,True),(4963,True),(4964,True),(4965,True),(4966,True),(4967,True),(4968,True),(4969,True),(4970,True),(4971,True),(4972,True),(4973,True),(4974,True),(4975,True),(4976,True),(4977,True),(4978,True),(4979,True),(4980,True),(4981,True),(4982,True),(4983,True),(4984,True),(4985,True),(4986,True),(4987,True),(4988,True),(4989,True),(4990,True),(4991,True),(4992,True),(4993,True),(4994,True),(4995,True),(4996,True),(4997,True),(4998,True),(4999,True),(5000,True),(5001,True),(5002,True),(5003,True),(5004,True),(5005,True),(5006,True),(5007,True),(5008,True),(5009,True),(5010,True),(5011,True),(5012,True),(5013,True),(5014,True),(5015,True),(5016,True),(5017,True),(5018,True),(5019,True),(5020,True),(5021,True),(5022,True),(5023,True),(5024,True),(5025,True),(5026,True),(5027,True),(5028,True),(5029,True),(5030,True),(5031,True),(5032,True),(5033,True),(5034,True),(5035,True),(5036,True),(5037,True),(5038,True),(5039,True),(5040,True),(5041,True),(5042,True),(5043,True),(5044,True),(5045,True),(5046,True),(5047,True),(5048,True),(5049,True),(5050,True),(5051,True),(5052,True),(5053,True),(5054,True),(5055,True),(5056,True),(5057,True),(5058,True),(5059,True),(5060,True),(5061,True),(5062,True),(5063,True),(5064,True),(5065,True),(5066,True),(5067,True),(5068,True),(5069,True),(5070,True),(5071,True),(5072,True),(5073,True),(5074,True),(5075,True),(5076,True),(5077,True),(5078,True),(5079,True),(5080,True),(5081,True),(5082,True),(5083,True),(5084,True),(5085,True),(5086,True),(5087,True),(5088,True),(5089,True),(5090,True),(5091,True),(5092,True),(5093,True),(5094,True),(5095,True),(5096,True),(5097,True),(5098,True),(5099,True),(5100,True),(5101,True),(5102,True),(5103,True),(5104,True),(5105,True),(5106,True),(5107,True),(5108,True),(5109,True),(5110,True),(5111,True),(5112,True),(5113,True),(5114,True),(5115,True),(5116,True),(5117,True),(5118,True),(5119,True),(5120,True),(5121,True),(5122,True),(5123,True),(5124,True),(5125,True),(5126,True),(5127,True),(5128,True),(5129,True),(5130,True),(5131,True),(5132,True),(5133,True),(5134,True),(5135,True),(5136,True),(5137,True),(5138,True),(5139,True),(5140,True),(5141,True),(5142,True),(5143,True),(5144,True),(5145,True),(5146,True),(5147,True),(5148,True),(5149,True),(5150,True),(5151,True),(5152,True),(5153,True),(5154,True),(5155,True),(5156,True),(5157,True),(5158,True),(5159,True),(5160,True),(5161,True),(5162,True),(5163,True),(5164,True),(5165,True),(5166,True),(5167,True),(5168,True),(5169,True),(5170,True),(5171,True),(5172,True),(5173,True),(5174,True),(5175,True),(5176,True),(5177,True),(5178,True),(5179,True),(5180,True),(5181,True),(5182,True),(5183,True),(5184,True),(5185,True),(5186,True),(5187,True),(5188,True),(5189,True),(5190,True),(5191,True),(5192,True),(5193,True),(5194,True),(5195,True),(5196,True),(5197,True),(5198,True),(5199,True),(5200,True),(5201,True),(5202,True),(5203,True),(5204,True),(5205,True),(5206,True),(5207,True),(5208,True),(5209,True),(5210,True),(5211,True),(5212,True),(5213,True),(5214,True),(5215,True),(5216,True),(5217,True),(5218,True),(5219,True),(5220,True),(5221,True),(5222,True),(5223,True),(5224,True),(5225,True),(5226,True),(5227,True),(5228,True),(5229,True),(5230,True),(5231,True),(5232,True),(5233,True),(5234,True),(5235,True),(5236,True),(5237,True),(5238,True),(5239,True),(5240,True),(5241,True),(5242,True),(5243,True),(5244,True),(5245,True),(5246,True),(5247,True),(5248,True),(5249,True),(5250,True),(5251,True),(5252,True),(5253,True),(5254,True),(5255,True),(5256,True),(5257,True),(5258,True),(5259,True),(5260,True),(5261,True),(5262,True),(5263,True),(5264,True),(5265,True),(5266,True),(5267,True),(5268,True),(5269,True),(5270,True),(5271,True),(5272,True),(5273,True),(5274,True),(5275,True),(5276,True),(5277,True),(5278,True),(5279,True),(5280,True),(5281,True),(5282,True),(5283,True),(5284,True),(5285,True),(5286,True),(5287,True),(5288,True),(5289,True),(5290,True),(5291,True),(5292,True),(5293,True),(5294,True),(5295,True),(5296,True),(5297,True),(5298,True),(5299,True),(5300,True),(5301,True),(5302,True),(5303,True),(5304,True),(5305,True),(5306,True),(5307,True),(5308,True),(5309,True),(5310,True),(5311,True),(5312,True),(5313,True),(5314,True),(5315,True),(5316,True),(5317,True),(5318,True),(5319,True),(5320,True),(5321,True),(5322,True),(5323,True),(5324,True),(5325,True),(5326,True),(5327,True),(5328,True),(5329,True),(5330,True),(5331,True),(5332,True),(5333,True),(5334,True),(5335,True),(5336,True),(5337,True),(5338,True),(5339,True),(5340,True),(5341,True),(5342,True),(5343,True),(5344,True),(5345,True),(5346,True),(5347,True),(5348,True),(5349,True),(5350,True),(5351,True),(5352,True),(5353,True),(5354,True),(5355,True),(5356,True),(5357,True),(5358,True),(5359,True),(5360,True),(5361,True),(5362,True),(5363,True),(5364,True),(5365,True),(5366,True),(5367,True),(5368,True),(5369,True),(5370,True),(5371,True),(5372,True),(5373,True),(5374,True),(5375,True),(5376,True),(5377,True),(5378,True),(5379,True),(5380,True),(5381,True),(5382,True),(5383,True),(5384,True),(5385,True),(5386,True),(5387,True),(5388,True),(5389,True),(5390,True),(5391,True),(5392,True),(5393,True),(5394,True),(5395,True),(5396,True),(5397,True),(5398,True),(5399,True),(5400,True),(5401,True),(5402,True),(5403,True),(5404,True),(5405,True),(5406,True),(5407,True),(5408,True),(5409,True),(5410,True),(5411,True),(5412,True),(5413,True),(5414,True),(5415,True),(5416,True),(5417,True),(5418,True),(5419,True),(5420,True),(5421,True),(5422,True),(5423,True),(5424,True),(5425,True),(5426,True),(5427,True),(5428,True),(5429,True),(5430,True),(5431,True),(5432,True),(5433,True),(5434,True),(5435,True),(5436,True),(5437,True),(5438,True),(5439,True),(5440,True),(5441,True),(5442,True),(5443,True),(5444,True),(5445,True),(5446,True),(5447,True),(5448,True),(5449,True),(5450,True),(5451,True),(5452,True),(5453,True),(5454,True),(5455,True),(5456,True),(5457,True),(5458,True),(5459,True),(5460,True),(5461,True),(5462,True),(5463,True),(5464,True),(5465,True),(5466,True),(5467,True),(5468,True),(5469,True),(5470,True),(5471,True),(5472,True),(5473,True),(5474,True),(5475,True),(5476,True),(5477,True),(5478,True),(5479,True),(5480,True),(5481,True),(5482,True),(5483,True),(5484,True),(5485,True),(5486,True),(5487,True),(5488,True),(5489,True),(5490,True),(5491,True),(5492,True),(5493,True),(5494,True),(5495,True),(5496,True),(5497,True),(5498,True),(5499,True),(5500,True),(5501,True),(5502,True),(5503,True),(5504,True),(5505,True),(5506,True),(5507,True),(5508,True),(5509,True),(5510,True),(5511,True),(5512,True),(5513,True),(5514,True),(5515,True),(5516,True),(5517,True),(5518,True),(5519,True),(5520,True),(5521,True),(5522,True),(5523,True),(5524,True),(5525,True),(5526,True),(5527,True),(5528,True),(5529,True),(5530,True),(5531,True),(5532,True),(5533,True),(5534,True),(5535,True),(5536,True),(5537,True),(5538,True),(5539,True),(5540,True),(5541,True),(5542,True),(5543,True),(5544,True),(5545,True),(5546,True),(5547,True),(5548,True),(5549,True),(5550,True),(5551,True),(5552,True),(5553,True),(5554,True),(5555,True),(5556,True),(5557,True),(5558,True),(5559,True),(5560,True),(5561,True),(5562,True),(5563,True),(5564,True),(5565,True),(5566,True),(5567,True),(5568,True),(5569,True),(5570,True),(5571,True),(5572,True),(5573,True),(5574,True),(5575,True),(5576,True),(5577,True),(5578,True),(5579,True),(5580,True),(5581,True),(5582,True),(5583,True),(5584,True),(5585,True),(5586,True),(5587,True),(5588,True),(5589,True),(5590,True),(5591,True),(5592,True),(5593,True),(5594,True),(5595,True),(5596,True),(5597,True),(5598,True),(5599,True),(5600,True),(5601,True),(5602,True),(5603,True),(5604,True),(5605,True),(5606,True),(5607,True),(5608,True),(5609,True),(5610,True),(5611,True),(5612,True),(5613,True),(5614,True),(5615,True),(5616,True),(5617,True),(5618,True),(5619,True),(5620,True),(5621,True),(5622,True),(5623,True),(5624,True),(5625,True),(5626,True),(5627,True),(5628,True),(5629,True),(5630,True),(5631,True),(5632,True),(5633,True),(5634,True),(5635,True),(5636,True),(5637,True),(5638,True),(5639,True),(5640,True),(5641,True),(5642,True),(5643,True),(5644,True),(5645,True),(5646,True),(5647,True),(5648,True),(5649,True),(5650,True),(5651,True),(5652,True),(5653,True),(5654,True),(5655,True),(5656,True),(5657,True),(5658,True),(5659,True),(5660,True),(5661,True),(5662,True),(5663,True),(5664,True),(5665,True),(5666,True),(5667,True),(5668,True),(5669,True),(5670,True),(5671,True),(5672,True),(5673,True),(5674,True),(5675,True),(5676,True),(5677,True),(5678,True),(5679,True),(5680,True),(5681,True),(5682,True),(5683,True),(5684,True),(5685,True),(5686,True),(5687,True),(5688,True),(5689,True),(5690,True),(5691,True),(5692,True),(5693,True),(5694,True),(5695,True),(5696,True),(5697,True),(5698,True),(5699,True),(5700,True),(5701,True),(5702,True),(5703,True),(5704,True),(5705,True),(5706,True),(5707,True),(5708,True),(5709,True),(5710,True),(5711,True),(5712,True),(5713,True),(5714,True),(5715,True),(5716,True),(5717,True),(5718,True),(5719,True),(5720,True),(5721,True),(5722,True),(5723,True),(5724,True),(5725,True),(5726,True),(5727,True),(5728,True),(5729,True),(5730,True),(5731,True),(5732,True),(5733,True),(5734,True),(5735,True),(5736,True),(5737,True),(5738,True),(5739,True),(5740,True),(5741,True),(5742,True),(5743,True),(5744,True),(5745,True),(5746,True),(5747,True),(5748,True),(5749,True),(5750,True),(5751,True),(5752,True),(5753,True),(5754,True),(5755,True),(5756,True),(5757,True),(5758,True),(5759,True),(5760,True),(5761,True),(5762,True),(5763,True),(5764,True),(5765,True),(5766,True),(5767,True),(5768,True),(5769,True),(5770,True),(5771,True),(5772,True),(5773,True),(5774,True),(5775,True),(5776,True),(5777,True),(5778,True),(5779,True),(5780,True),(5781,True),(5782,True),(5783,True),(5784,True),(5785,True),(5786,True),(5787,True),(5788,True),(5789,True),(5790,True),(5791,True),(5792,True),(5793,True),(5794,True),(5795,True),(5796,True),(5797,True),(5798,True),(5799,True),(5800,True),(5801,True),(5802,True),(5803,True),(5804,True),(5805,True),(5806,True),(5807,True),(5808,True),(5809,True),(5810,True),(5811,True),(5812,True),(5813,True),(5814,True),(5815,True),(5816,True),(5817,True),(5818,True),(5819,True),(5820,True),(5821,True),(5822,True),(5823,True),(5824,True),(5825,True),(5826,True),(5827,True),(5828,True),(5829,True),(5830,True),(5831,True),(5832,True),(5833,True),(5834,True),(5835,True),(5836,True),(5837,True),(5838,True),(5839,True),(5840,True),(5841,True),(5842,True),(5843,True),(5844,True),(5845,True),(5846,True),(5847,True),(5848,True),(5849,True),(5850,True),(5851,True),(5852,True),(5853,True),(5854,True),(5855,True),(5856,True),(5857,True),(5858,True),(5859,True),(5860,True),(5861,True),(5862,True),(5863,True),(5864,True),(5865,True),(5866,True),(5867,True),(5868,True),(5869,True),(5870,True),(5871,True),(5872,True),(5873,True),(5874,True),(5875,True),(5876,True),(5877,True),(5878,True),(5879,True),(5880,True),(5881,True),(5882,True),(5883,True),(5884,True),(5885,True),(5886,True),(5887,True),(5888,True),(5889,True),(5890,True),(5891,True),(5892,True),(5893,True),(5894,True),(5895,True),(5896,True),(5897,True),(5898,True),(5899,True),(5900,True),(5901,True),(5902,True),(5903,True),(5904,True),(5905,True),(5906,True),(5907,True),(5908,True),(5909,True),(5910,True),(5911,True),(5912,True),(5913,True),(5914,True),(5915,True),(5916,True),(5917,True),(5918,True),(5919,True),(5920,True),(5921,True),(5922,True),(5923,True),(5924,True),(5925,True),(5926,True),(5927,True),(5928,True),(5929,True),(5930,True),(5931,True),(5932,True),(5933,True),(5934,True),(5935,True),(5936,True),(5937,True),(5938,True),(5939,True),(5940,True),(5941,True),(5942,True),(5943,True),(5944,True),(5945,True),(5946,True),(5947,True),(5948,True),(5949,True),(5950,True),(5951,True),(5952,True),(5953,True),(5954,True),(5955,True),(5956,True),(5957,True),(5958,True),(5959,True),(5960,True),(5961,True),(5962,True),(5963,True),(5964,True),(5965,True),(5966,True),(5967,True),(5968,True),(5969,True),(5970,True),(5971,True),(5972,True),(5973,True),(5974,True),(5975,True),(5976,True),(5977,True),(5978,True),(5979,True),(5980,True),(5981,True),(5982,True),(5983,True),(5984,True),(5985,True),(5986,True),(5987,True),(5988,True),(5989,True),(5990,True),(5991,True),(5992,True),(5993,True),(5994,True),(5995,True),(5996,True),(5997,True),(5998,True),(5999,True),(6000,True),(6001,True),(6002,True),(6003,True),(6004,True),(6005,True),(6006,True),(6007,True),(6008,True),(6009,True),(6010,True),(6011,True),(6012,True),(6013,True),(6014,True),(6015,True),(6016,True),(6017,True),(6018,True),(6019,True),(6020,True),(6021,True),(6022,True),(6023,True),(6024,True),(6025,True),(6026,True),(6027,True),(6028,True),(6029,True),(6030,True),(6031,True),(6032,True),(6033,True),(6034,True),(6035,True),(6036,True),(6037,True),(6038,True),(6039,True),(6040,True),(6041,True),(6042,True),(6043,True),(6044,True),(6045,True),(6046,True),(6047,True),(6048,True),(6049,True),(6050,True),(6051,True),(6052,True),(6053,True),(6054,True),(6055,True),(6056,True),(6057,True),(6058,True),(6059,True),(6060,True),(6061,True),(6062,True),(6063,True),(6064,True),(6065,True),(6066,True),(6067,True),(6068,True),(6069,True),(6070,True),(6071,True),(6072,True),(6073,True),(6074,True),(6075,True),(6076,True),(6077,True),(6078,True),(6079,True),(6080,True),(6081,True),(6082,True),(6083,True),(6084,True),(6085,True),(6086,True),(6087,True),(6088,True),(6089,True),(6090,True),(6091,True),(6092,True),(6093,True),(6094,True),(6095,True),(6096,True),(6097,True),(6098,True),(6099,True),(6100,True),(6101,True),(6102,True),(6103,True),(6104,True),(6105,True),(6106,True),(6107,True),(6108,True),(6109,True),(6110,True),(6111,True),(6112,True),(6113,True),(6114,True),(6115,True),(6116,True),(6117,True),(6118,True),(6119,True),(6120,True),(6121,True),(6122,True),(6123,True),(6124,True),(6125,True),(6126,True),(6127,True),(6128,True),(6129,True),(6130,True),(6131,True),(6132,True),(6133,True),(6134,True),(6135,True),(6136,True),(6137,True),(6138,True),(6139,True),(6140,True),(6141,True),(6142,True),(6143,True),(6144,True),(6145,True),(6146,True),(6147,True),(6148,True),(6149,True),(6150,True),(6151,True),(6152,True),(6153,True),(6154,True),(6155,True),(6156,True),(6157,True),(6158,True),(6159,True),(6160,True),(6161,True),(6162,True),(6163,True),(6164,True),(6165,True),(6166,True),(6167,True),(6168,True),(6169,True),(6170,True),(6171,True),(6172,True),(6173,True),(6174,True),(6175,True),(6176,True),(6177,True),(6178,True),(6179,True),(6180,True),(6181,True),(6182,True),(6183,True),(6184,True),(6185,True),(6186,True),(6187,True),(6188,True),(6189,True),(6190,True),(6191,True),(6192,True),(6193,True),(6194,True),(6195,True),(6196,True),(6197,True),(6198,True),(6199,True),(6200,True),(6201,True),(6202,True),(6203,True),(6204,True),(6205,True),(6206,True),(6207,True),(6208,True),(6209,True),(6210,True),(6211,True),(6212,True),(6213,True),(6214,True),(6215,True),(6216,True),(6217,True),(6218,True),(6219,True),(6220,True),(6221,True),(6222,True),(6223,True),(6224,True),(6225,True),(6226,True),(6227,True),(6228,True),(6229,True),(6230,True),(6231,True),(6232,True),(6233,True),(6234,True),(6235,True),(6236,True),(6237,True),(6238,True),(6239,True),(6240,True),(6241,True),(6242,True),(6243,True),(6244,True),(6245,True),(6246,True),(6247,True),(6248,True),(6249,True),(6250,True),(6251,True),(6252,True),(6253,True),(6254,True),(6255,True),(6256,True),(6257,True),(6258,True),(6259,True),(6260,True),(6261,True),(6262,True),(6263,True),(6264,True),(6265,True),(6266,True),(6267,True),(6268,True),(6269,True),(6270,True),(6271,True),(6272,True),(6273,True),(6274,True),(6275,True),(6276,True),(6277,True),(6278,True),(6279,True),(6280,True),(6281,True),(6282,True),(6283,True),(6284,True),(6285,True),(6286,True),(6287,True),(6288,True),(6289,True),(6290,True),(6291,True),(6292,True),(6293,True),(6294,True),(6295,True),(6296,True),(6297,True),(6298,True),(6299,True),(6300,True),(6301,True),(6302,True),(6303,True),(6304,True),(6305,True),(6306,True),(6307,True),(6308,True),(6309,True),(6310,True),(6311,True),(6312,True),(6313,True),(6314,True),(6315,True),(6316,True),(6317,True),(6318,True),(6319,True),(6320,True),(6321,True),(6322,True),(6323,True),(6324,True),(6325,True),(6326,True),(6327,True),(6328,True),(6329,True),(6330,True),(6331,True),(6332,True),(6333,True),(6334,True),(6335,True),(6336,True),(6337,True),(6338,True),(6339,True),(6340,True),(6341,True),(6342,True),(6343,True),(6344,True),(6345,True),(6346,True),(6347,True),(6348,True),(6349,True),(6350,True),(6351,True),(6352,True),(6353,True),(6354,True),(6355,True),(6356,True),(6357,True),(6358,True),(6359,True),(6360,True),(6361,True),(6362,True),(6363,True),(6364,True),(6365,True),(6366,True),(6367,True),(6368,True),(6369,True),(6370,True),(6371,True),(6372,True),(6373,True),(6374,True),(6375,True),(6376,True),(6377,True),(6378,True),(6379,True),(6380,True),(6381,True),(6382,True),(6383,True),(6384,True),(6385,True),(6386,True),(6387,True),(6388,True),(6389,True),(6390,True),(6391,True),(6392,True),(6393,True),(6394,True),(6395,True),(6396,True),(6397,True),(6398,True),(6399,True),(6400,True),(6401,True),(6402,True),(6403,True),(6404,True),(6405,True),(6406,True),(6407,True),(6408,True),(6409,True),(6410,True),(6411,True),(6412,True),(6413,True),(6414,True),(6415,True),(6416,True),(6417,True),(6418,True),(6419,True),(6420,True),(6421,True),(6422,True),(6423,True),(6424,True),(6425,True),(6426,True),(6427,True),(6428,True),(6429,True),(6430,True),(6431,True),(6432,True),(6433,True),(6434,True),(6435,True),(6436,True),(6437,True),(6438,True),(6439,True),(6440,True),(6441,True),(6442,True),(6443,True),(6444,True),(6445,True),(6446,True),(6447,True),(6448,True),(6449,True),(6450,True),(6451,True),(6452,True),(6453,True),(6454,True),(6455,True),(6456,True),(6457,True),(6458,True),(6459,True),(6460,True),(6461,True),(6462,True),(6463,True),(6464,True),(6465,True),(6466,True),(6467,True),(6468,True),(6469,True),(6470,True),(6471,True),(6472,True),(6473,True),(6474,True),(6475,True),(6476,True),(6477,True),(6478,True),(6479,True),(6480,True),(6481,True),(6482,True),(6483,True),(6484,True),(6485,True),(6486,True),(6487,True),(6488,True),(6489,True),(6490,True),(6491,True),(6492,True),(6493,True),(6494,True),(6495,True),(6496,True),(6497,True),(6498,True),(6499,True),(6500,True),(6501,True),(6502,True),(6503,True),(6504,True),(6505,True),(6506,True),(6507,True),(6508,True),(6509,True),(6510,True),(6511,True),(6512,True),(6513,True),(6514,True),(6515,True),(6516,True),(6517,True),(6518,True),(6519,True),(6520,True),(6521,True),(6522,True),(6523,True),(6524,True),(6525,True),(6526,True),(6527,True),(6528,True),(6529,True),(6530,True),(6531,True),(6532,True),(6533,True),(6534,True),(6535,True),(6536,True),(6537,True),(6538,True),(6539,True),(6540,True),(6541,True),(6542,True),(6543,True),(6544,True),(6545,True),(6546,True),(6547,True),(6548,True),(6549,True),(6550,True),(6551,True),(6552,True),(6553,True),(6554,True),(6555,True),(6556,True),(6557,True),(6558,True),(6559,True),(6560,True),(6561,True),(6562,True),(6563,True),(6564,True),(6565,True),(6566,True),(6567,True),(6568,True),(6569,True),(6570,True),(6571,True),(6572,True),(6573,True),(6574,True),(6575,True),(6576,True),(6577,True),(6578,True),(6579,True),(6580,True),(6581,True),(6582,True),(6583,True),(6584,True),(6585,True),(6586,True),(6587,True),(6588,True),(6589,True),(6590,True),(6591,True),(6592,True),(6593,True),(6594,True),(6595,True),(6596,True),(6597,True),(6598,True),(6599,True),(6600,True),(6601,True),(6602,True),(6603,True),(6604,True),(6605,True),(6606,True),(6607,True),(6608,True),(6609,True),(6610,True),(6611,True),(6612,True),(6613,True),(6614,True),(6615,True),(6616,True),(6617,True),(6618,True),(6619,True),(6620,True),(6621,True),(6622,True),(6623,True),(6624,True),(6625,True),(6626,True),(6627,True),(6628,True),(6629,True),(6630,True),(6631,True),(6632,True),(6633,True),(6634,True),(6635,True),(6636,True),(6637,True),(6638,True),(6639,True),(6640,True),(6641,True),(6642,True),(6643,True),(6644,True),(6645,True),(6646,True),(6647,True),(6648,True),(6649,True),(6650,True),(6651,True),(6652,True),(6653,True),(6654,True),(6655,True),(6656,True),(6657,True),(6658,True),(6659,True),(6660,True),(6661,True),(6662,True),(6663,True),(6664,True),(6665,True),(6666,True),(6667,True),(6668,True),(6669,True),(6670,True),(6671,True),(6672,True),(6673,True),(6674,True),(6675,True),(6676,True),(6677,True),(6678,True),(6679,True),(6680,True),(6681,True),(6682,True),(6683,True),(6684,True),(6685,True),(6686,True),(6687,True),(6688,True),(6689,True),(6690,True),(6691,True),(6692,True),(6693,True),(6694,True),(6695,True),(6696,True),(6697,True),(6698,True),(6699,True),(6700,True),(6701,True),(6702,True),(6703,True),(6704,True),(6705,True),(6706,True),(6707,True),(6708,True),(6709,True),(6710,True),(6711,True),(6712,True),(6713,True),(6714,True),(6715,True),(6716,True),(6717,True),(6718,True),(6719,True),(6720,True),(6721,True),(6722,True),(6723,True),(6724,True),(6725,True),(6726,True),(6727,True),(6728,True),(6729,True),(6730,True),(6731,True),(6732,True),(6733,True),(6734,True),(6735,True),(6736,True),(6737,True),(6738,True),(6739,True),(6740,True),(6741,True),(6742,True),(6743,True),(6744,True),(6745,True),(6746,True),(6747,True),(6748,True),(6749,True),(6750,True),(6751,True),(6752,True),(6753,True),(6754,True),(6755,True),(6756,True),(6757,True),(6758,True),(6759,True),(6760,True),(6761,True),(6762,True),(6763,True),(6764,True),(6765,True),(6766,True),(6767,True),(6768,True),(6769,True),(6770,True),(6771,True),(6772,True),(6773,True),(6774,True),(6775,True),(6776,True),(6777,True),(6778,True),(6779,True),(6780,True),(6781,True),(6782,True),(6783,True),(6784,True),(6785,True),(6786,True),(6787,True),(6788,True),(6789,True),(6790,True),(6791,True),(6792,True),(6793,True),(6794,True),(6795,True),(6796,True),(6797,True),(6798,True),(6799,True),(6800,True),(6801,True),(6802,True),(6803,True),(6804,True),(6805,True),(6806,True),(6807,True),(6808,True),(6809,True),(6810,True),(6811,True),(6812,True),(6813,True),(6814,True),(6815,True),(6816,True),(6817,True),(6818,True),(6819,True),(6820,True),(6821,True),(6822,True),(6823,True),(6824,True),(6825,True),(6826,True),(6827,True),(6828,True),(6829,True),(6830,True),(6831,True),(6832,True),(6833,True),(6834,True),(6835,True),(6836,True),(6837,True),(6838,True),(6839,True),(6840,True),(6841,True),(6842,True),(6843,True),(6844,True),(6845,True),(6846,True),(6847,True),(6848,True),(6849,True),(6850,True),(6851,True),(6852,True),(6853,True),(6854,True),(6855,True),(6856,True),(6857,True),(6858,True),(6859,True),(6860,True),(6861,True),(6862,True),(6863,True),(6864,True),(6865,True),(6866,True),(6867,True),(6868,True),(6869,True),(6870,True),(6871,True),(6872,True),(6873,True),(6874,True),(6875,True),(6876,True),(6877,True),(6878,True),(6879,True),(6880,True),(6881,True),(6882,True),(6883,True),(6884,True),(6885,True),(6886,True),(6887,True),(6888,True),(6889,True),(6890,True),(6891,True),(6892,True),(6893,True),(6894,True),(6895,True),(6896,True),(6897,True),(6898,True),(6899,True),(6900,True),(6901,True),(6902,True),(6903,True),(6904,True),(6905,True),(6906,True),(6907,True),(6908,True),(6909,True),(6910,True),(6911,True),(6912,True),(6913,True),(6914,True),(6915,True),(6916,True),(6917,True),(6918,True),(6919,True),(6920,True),(6921,True),(6922,True),(6923,True),(6924,True),(6925,True),(6926,True),(6927,True),(6928,True),(6929,True),(6930,True),(6931,True),(6932,True),(6933,True),(6934,True),(6935,True),(6936,True),(6937,True),(6938,True),(6939,True),(6940,True),(6941,True),(6942,True),(6943,True),(6944,True),(6945,True),(6946,True),(6947,True),(6948,True),(6949,True),(6950,True),(6951,True),(6952,True),(6953,True),(6954,True),(6955,True),(6956,True),(6957,True),(6958,True),(6959,True),(6960,True),(6961,True),(6962,True),(6963,True),(6964,True),(6965,True),(6966,True),(6967,True),(6968,True),(6969,True),(6970,True),(6971,True),(6972,True),(6973,True),(6974,True),(6975,True),(6976,True),(6977,True),(6978,True),(6979,True),(6980,True),(6981,True),(6982,True),(6983,True),(6984,True),(6985,True),(6986,True),(6987,True),(6988,True),(6989,True),(6990,True),(6991,True),(6992,True),(6993,True),(6994,True),(6995,True),(6996,True),(6997,True),(6998,True),(6999,True),(7000,True),(7001,True),(7002,True),(7003,True),(7004,True),(7005,True),(7006,True),(7007,True),(7008,True),(7009,True),(7010,True),(7011,True),(7012,True),(7013,True),(7014,True),(7015,True),(7016,True),(7017,True),(7018,True),(7019,True),(7020,True),(7021,True),(7022,True),(7023,True),(7024,True),(7025,True),(7026,True),(7027,True),(7028,True),(7029,True),(7030,True),(7031,True),(7032,True),(7033,True),(7034,True),(7035,True),(7036,True),(7037,True),(7038,True),(7039,True),(7040,True),(7041,True),(7042,True),(7043,True),(7044,True),(7045,True),(7046,True),(7047,True),(7048,True),(7049,True),(7050,True),(7051,True),(7052,True),(7053,True),(7054,True),(7055,True),(7056,True),(7057,True),(7058,True),(7059,True),(7060,True),(7061,True),(7062,True),(7063,True),(7064,True),(7065,True),(7066,True),(7067,True),(7068,True),(7069,True),(7070,True),(7071,True),(7072,True),(7073,True),(7074,True),(7075,True),(7076,True),(7077,True),(7078,True),(7079,True),(7080,True),(7081,True),(7082,True),(7083,True),(7084,True),(7085,True),(7086,True),(7087,True),(7088,True),(7089,True),(7090,True),(7091,True),(7092,True),(7093,True),(7094,True),(7095,True),(7096,True),(7097,True),(7098,True),(7099,True),(7100,True),(7101,True),(7102,True),(7103,True),(7104,True),(7105,True),(7106,True),(7107,True),(7108,True),(7109,True),(7110,True),(7111,True),(7112,True),(7113,True),(7114,True),(7115,True),(7116,True),(7117,True),(7118,True),(7119,True),(7120,True),(7121,True),(7122,True),(7123,True),(7124,True),(7125,True),(7126,True),(7127,True),(7128,True),(7129,True),(7130,True),(7131,True),(7132,True),(7133,True),(7134,True),(7135,True),(7136,True),(7137,True),(7138,True),(7139,True),(7140,True),(7141,True),(7142,True),(7143,True),(7144,True),(7145,True),(7146,True),(7147,True),(7148,True),(7149,True),(7150,True),(7151,True),(7152,True),(7153,True),(7154,True),(7155,True),(7156,True),(7157,True),(7158,True),(7159,True),(7160,True),(7161,True),(7162,True),(7163,True),(7164,True),(7165,True),(7166,True),(7167,True),(7168,True),(7169,True),(7170,True),(7171,True),(7172,True),(7173,True),(7174,True),(7175,True),(7176,True),(7177,True),(7178,True),(7179,True),(7180,True),(7181,True),(7182,True),(7183,True),(7184,True),(7185,True),(7186,True),(7187,True),(7188,True),(7189,True),(7190,True),(7191,True),(7192,True),(7193,True),(7194,True),(7195,True),(7196,True),(7197,True),(7198,True),(7199,True),(7200,True),(7201,True),(7202,True),(7203,True),(7204,True),(7205,True),(7206,True),(7207,True),(7208,True),(7209,True),(7210,True),(7211,True),(7212,True),(7213,True),(7214,True),(7215,True),(7216,True),(7217,True),(7218,True),(7219,True),(7220,True),(7221,True),(7222,True),(7223,True),(7224,True),(7225,True),(7226,True),(7227,True),(7228,True),(7229,True),(7230,True),(7231,True),(7232,True),(7233,True),(7234,True),(7235,True),(7236,True),(7237,True),(7238,True),(7239,True),(7240,True),(7241,True),(7242,True),(7243,True),(7244,True),(7245,True),(7246,True),(7247,True),(7248,True),(7249,True),(7250,True),(7251,True),(7252,True),(7253,True),(7254,True),(7255,True),(7256,True),(7257,True),(7258,True),(7259,True),(7260,True),(7261,True),(7262,True),(7263,True),(7264,True),(7265,True),(7266,True),(7267,True),(7268,True),(7269,True),(7270,True),(7271,True),(7272,True),(7273,True),(7274,True),(7275,True),(7276,True),(7277,True),(7278,True),(7279,True),(7280,True),(7281,True),(7282,True),(7283,True),(7284,True),(7285,True),(7286,True),(7287,True),(7288,True),(7289,True),(7290,True),(7291,True),(7292,True),(7293,True),(7294,True),(7295,True),(7296,True),(7297,True),(7298,True),(7299,True),(7300,True),(7301,True),(7302,True),(7303,True),(7304,True),(7305,True),(7306,True),(7307,True),(7308,True),(7309,True),(7310,True),(7311,True),(7312,True),(7313,True),(7314,True),(7315,True),(7316,True),(7317,True),(7318,True),(7319,True),(7320,True),(7321,True),(7322,True),(7323,True),(7324,True),(7325,True),(7326,True),(7327,True),(7328,True),(7329,True),(7330,True),(7331,True),(7332,True),(7333,True),(7334,True),(7335,True),(7336,True),(7337,True),(7338,True),(7339,True),(7340,True),(7341,True),(7342,True),(7343,True),(7344,True),(7345,True),(7346,True),(7347,True),(7348,True),(7349,True),(7350,True),(7351,True),(7352,True),(7353,True),(7354,True),(7355,True),(7356,True),(7357,True),(7358,True),(7359,True),(7360,True),(7361,True),(7362,True),(7363,True),(7364,True),(7365,True),(7366,True),(7367,True),(7368,True),(7369,True),(7370,True),(7371,True),(7372,True),(7373,True),(7374,True),(7375,True),(7376,True),(7377,True),(7378,True),(7379,True),(7380,True),(7381,True),(7382,True),(7383,True),(7384,True),(7385,True),(7386,True),(7387,True),(7388,True),(7389,True),(7390,True),(7391,True),(7392,True),(7393,True),(7394,True),(7395,True),(7396,True),(7397,True),(7398,True),(7399,True),(7400,True),(7401,True),(7402,True),(7403,True),(7404,True),(7405,True),(7406,True),(7407,True),(7408,True),(7409,True),(7410,True),(7411,True),(7412,True),(7413,True),(7414,True),(7415,True),(7416,True),(7417,True),(7418,True),(7419,True),(7420,True),(7421,True),(7422,True),(7423,True),(7424,True),(7425,True),(7426,True),(7427,True),(7428,True),(7429,True),(7430,True),(7431,True),(7432,True),(7433,True),(7434,True),(7435,True),(7436,True),(7437,True),(7438,True),(7439,True),(7440,True),(7441,True),(7442,True),(7443,True),(7444,True),(7445,True),(7446,True),(7447,True),(7448,True),(7449,True),(7450,True),(7451,True),(7452,True),(7453,True),(7454,True),(7455,True),(7456,True),(7457,True),(7458,True),(7459,True),(7460,True),(7461,True),(7462,True),(7463,True),(7464,True),(7465,True),(7466,True),(7467,True),(7468,True),(7469,True),(7470,True),(7471,True),(7472,True),(7473,True),(7474,True),(7475,True),(7476,True),(7477,True),(7478,True),(7479,True),(7480,True),(7481,True),(7482,True),(7483,True),(7484,True),(7485,True),(7486,True),(7487,True),(7488,True),(7489,True),(7490,True),(7491,True),(7492,True),(7493,True),(7494,True),(7495,True),(7496,True),(7497,True),(7498,True),(7499,True),(7500,True),(7501,True),(7502,True),(7503,True),(7504,True),(7505,True),(7506,True),(7507,True),(7508,True),(7509,True),(7510,True),(7511,True),(7512,True),(7513,True),(7514,True),(7515,True),(7516,True),(7517,True),(7518,True),(7519,True),(7520,True),(7521,True),(7522,True),(7523,True),(7524,True),(7525,True),(7526,True),(7527,True),(7528,True),(7529,True),(7530,True),(7531,True),(7532,True),(7533,True),(7534,True),(7535,True),(7536,True),(7537,True),(7538,True),(7539,True),(7540,True),(7541,True),(7542,True),(7543,True),(7544,True),(7545,True),(7546,True),(7547,True),(7548,True),(7549,True),(7550,True),(7551,True),(7552,True),(7553,True),(7554,True),(7555,True),(7556,True),(7557,True),(7558,True),(7559,True),(7560,True),(7561,True),(7562,True),(7563,True),(7564,True),(7565,True),(7566,True),(7567,True),(7568,True),(7569,True),(7570,True),(7571,True),(7572,True),(7573,True),(7574,True),(7575,True),(7576,True),(7577,True),(7578,True),(7579,True),(7580,True),(7581,True),(7582,True),(7583,True),(7584,True),(7585,True),(7586,True),(7587,True),(7588,True),(7589,True),(7590,True),(7591,True),(7592,True),(7593,True),(7594,True),(7595,True),(7596,True),(7597,True),(7598,True),(7599,True),(7600,True),(7601,True),(7602,True),(7603,True),(7604,True),(7605,True),(7606,True),(7607,True),(7608,True),(7609,True),(7610,True),(7611,True),(7612,True),(7613,True),(7614,True),(7615,True),(7616,True),(7617,True),(7618,True),(7619,True),(7620,True),(7621,True),(7622,True),(7623,True),(7624,True),(7625,True),(7626,True),(7627,True),(7628,True),(7629,True),(7630,True),(7631,True),(7632,True),(7633,True),(7634,True),(7635,True),(7636,True),(7637,True),(7638,True),(7639,True),(7640,True),(7641,True),(7642,True),(7643,True),(7644,True),(7645,True),(7646,True),(7647,True),(7648,True),(7649,True),(7650,True),(7651,True),(7652,True),(7653,True),(7654,True),(7655,True),(7656,True),(7657,True),(7658,True),(7659,True),(7660,True),(7661,True),(7662,True),(7663,True),(7664,True),(7665,True),(7666,True),(7667,True),(7668,True),(7669,True),(7670,True),(7671,True),(7672,True),(7673,True),(7674,True),(7675,True),(7676,True),(7677,True),(7678,True),(7679,True),(7680,True),(7681,True),(7682,True),(7683,True),(7684,True),(7685,True),(7686,True),(7687,True),(7688,True),(7689,True),(7690,True),(7691,True),(7692,True),(7693,True),(7694,True),(7695,True),(7696,True),(7697,True),(7698,True),(7699,True),(7700,True),(7701,True),(7702,True),(7703,True),(7704,True),(7705,True),(7706,True),(7707,True),(7708,True),(7709,True),(7710,True),(7711,True),(7712,True),(7713,True),(7714,True),(7715,True),(7716,True),(7717,True),(7718,True),(7719,True),(7720,True),(7721,True),(7722,True),(7723,True),(7724,True),(7725,True),(7726,True),(7727,True),(7728,True),(7729,True),(7730,True),(7731,True),(7732,True),(7733,True),(7734,True),(7735,True),(7736,True),(7737,True),(7738,True),(7739,True),(7740,True),(7741,True),(7742,True),(7743,True),(7744,True),(7745,True),(7746,True),(7747,True),(7748,True),(7749,True),(7750,True),(7751,True),(7752,True),(7753,True),(7754,True),(7755,True),(7756,True),(7757,True),(7758,True),(7759,True),(7760,True),(7761,True),(7762,True),(7763,True),(7764,True),(7765,True),(7766,True),(7767,True),(7768,True),(7769,True),(7770,True),(7771,True),(7772,True),(7773,True),(7774,True),(7775,True),(7776,True),(7777,True),(7778,True),(7779,True),(7780,True),(7781,True),(7782,True),(7783,True),(7784,True),(7785,True),(7786,True),(7787,True),(7788,True),(7789,True),(7790,True),(7791,True),(7792,True),(7793,True),(7794,True),(7795,True),(7796,True),(7797,True),(7798,True),(7799,True),(7800,True),(7801,True),(7802,True),(7803,True),(7804,True),(7805,True),(7806,True),(7807,True),(7808,True),(7809,True),(7810,True),(7811,True),(7812,True),(7813,True),(7814,True),(7815,True),(7816,True),(7817,True),(7818,True),(7819,True),(7820,True),(7821,True),(7822,True),(7823,True),(7824,True),(7825,True),(7826,True),(7827,True),(7828,True),(7829,True),(7830,True),(7831,True),(7832,True),(7833,True),(7834,True),(7835,True),(7836,True),(7837,True),(7838,True),(7839,True),(7840,True),(7841,True),(7842,True),(7843,True),(7844,True),(7845,True),(7846,True),(7847,True),(7848,True),(7849,True),(7850,True),(7851,True),(7852,True),(7853,True),(7854,True),(7855,True),(7856,True),(7857,True),(7858,True),(7859,True),(7860,True),(7861,True),(7862,True),(7863,True),(7864,True),(7865,True),(7866,True),(7867,True),(7868,True),(7869,True),(7870,True),(7871,True),(7872,True),(7873,True),(7874,True),(7875,True),(7876,True),(7877,True),(7878,True),(7879,True),(7880,True),(7881,True),(7882,True),(7883,True),(7884,True),(7885,True),(7886,True),(7887,True),(7888,True),(7889,True),(7890,True),(7891,True),(7892,True),(7893,True),(7894,True),(7895,True),(7896,True),(7897,True),(7898,True),(7899,True),(7900,True),(7901,True),(7902,True),(7903,True),(7904,True),(7905,True),(7906,True),(7907,True),(7908,True),(7909,True),(7910,True),(7911,True),(7912,True),(7913,True),(7914,True),(7915,True),(7916,True),(7917,True),(7918,True),(7919,True),(7920,True),(7921,True),(7922,True),(7923,True),(7924,True),(7925,True),(7926,True),(7927,True),(7928,True),(7929,True),(7930,True),(7931,True),(7932,True),(7933,True),(7934,True),(7935,True),(7936,True),(7937,True),(7938,True),(7939,True),(7940,True),(7941,True),(7942,True),(7943,True),(7944,True),(7945,True),(7946,True),(7947,True),(7948,True),(7949,True),(7950,True),(7951,True),(7952,True),(7953,True),(7954,True),(7955,True),(7956,True),(7957,True),(7958,True),(7959,True),(7960,True),(7961,True),(7962,True),(7963,True),(7964,True),(7965,True),(7966,True),(7967,True),(7968,True),(7969,True),(7970,True),(7971,True),(7972,True),(7973,True),(7974,True),(7975,True),(7976,True),(7977,True),(7978,True),(7979,True),(7980,True),(7981,True),(7982,True),(7983,True),(7984,True),(7985,True),(7986,True),(7987,True),(7988,True),(7989,True),(7990,True),(7991,True),(7992,True),(7993,True),(7994,True),(7995,True),(7996,True),(7997,True),(7998,True),(7999,True),(8000,True),(8001,True),(8002,True),(8003,True),(8004,True),(8005,True),(8006,True),(8007,True),(8008,True),(8009,True),(8010,True),(8011,True),(8012,True),(8013,True),(8014,True),(8015,True),(8016,True),(8017,True),(8018,True),(8019,True),(8020,True),(8021,True),(8022,True),(8023,True),(8024,True),(8025,True),(8026,True),(8027,True),(8028,True),(8029,True),(8030,True),(8031,True),(8032,True),(8033,True),(8034,True),(8035,True),(8036,True),(8037,True),(8038,True),(8039,True),(8040,True),(8041,True),(8042,True),(8043,True),(8044,True),(8045,True),(8046,True),(8047,True),(8048,True),(8049,True),(8050,True),(8051,True),(8052,True),(8053,True),(8054,True),(8055,True),(8056,True),(8057,True),(8058,True),(8059,True),(8060,True),(8061,True),(8062,True),(8063,True),(8064,True),(8065,True),(8066,True),(8067,True),(8068,True),(8069,True),(8070,True),(8071,True),(8072,True),(8073,True),(8074,True),(8075,True),(8076,True),(8077,True),(8078,True),(8079,True),(8080,True),(8081,True),(8082,True),(8083,True),(8084,True),(8085,True),(8086,True),(8087,True),(8088,True),(8089,True),(8090,True),(8091,True),(8092,True),(8093,True),(8094,True),(8095,True),(8096,True),(8097,True),(8098,True),(8099,True),(8100,True),(8101,True),(8102,True),(8103,True),(8104,True),(8105,True),(8106,True),(8107,True),(8108,True),(8109,True),(8110,True),(8111,True),(8112,True),(8113,True),(8114,True),(8115,True),(8116,True),(8117,True),(8118,True),(8119,True),(8120,True),(8121,True),(8122,True),(8123,True),(8124,True),(8125,True),(8126,True),(8127,True),(8128,True),(8129,True),(8130,True),(8131,True),(8132,True),(8133,True),(8134,True),(8135,True),(8136,True),(8137,True),(8138,True),(8139,True),(8140,True),(8141,True),(8142,True),(8143,True),(8144,True),(8145,True),(8146,True),(8147,True),(8148,True),(8149,True),(8150,True),(8151,True),(8152,True),(8153,True),(8154,True),(8155,True),(8156,True),(8157,True),(8158,True),(8159,True),(8160,True),(8161,True),(8162,True),(8163,True),(8164,True),(8165,True),(8166,True),(8167,True),(8168,True),(8169,True),(8170,True),(8171,True),(8172,True),(8173,True),(8174,True),(8175,True),(8176,True),(8177,True),(8178,True),(8179,True),(8180,True),(8181,True),(8182,True),(8183,True),(8184,True),(8185,True),(8186,True),(8187,True),(8188,True),(8189,True),(8190,True),(8191,True),(8192,True),(8193,True),(8194,True),(8195,True),(8196,True),(8197,True),(8198,True),(8199,True),(8200,True),(8201,True),(8202,True),(8203,True),(8204,True),(8205,True),(8206,True),(8207,True),(8208,True),(8209,True),(8210,True),(8211,True),(8212,True),(8213,True),(8214,True),(8215,True),(8216,True),(8217,True),(8218,True),(8219,True),(8220,True),(8221,True),(8222,True),(8223,True),(8224,True),(8225,True),(8226,True),(8227,True),(8228,True),(8229,True),(8230,True),(8231,True),(8232,True),(8233,True),(8234,True),(8235,True),(8236,True),(8237,True),(8238,True),(8239,True),(8240,True),(8241,True),(8242,True),(8243,True),(8244,True),(8245,True),(8246,True),(8247,True),(8248,True),(8249,True),(8250,True),(8251,True),(8252,True),(8253,True),(8254,True),(8255,True),(8256,True),(8257,True),(8258,True),(8259,True),(8260,True),(8261,True),(8262,True),(8263,True),(8264,True),(8265,True),(8266,True),(8267,True),(8268,True),(8269,True),(8270,True),(8271,True),(8272,True),(8273,True),(8274,True),(8275,True),(8276,True),(8277,True),(8278,True),(8279,True),(8280,True),(8281,True),(8282,True),(8283,True),(8284,True),(8285,True),(8286,True),(8287,True),(8288,True),(8289,True),(8290,True),(8291,True),(8292,True),(8293,True),(8294,True),(8295,True),(8296,True),(8297,True),(8298,True),(8299,True),(8300,True),(8301,True),(8302,True),(8303,True),(8304,True),(8305,True),(8306,True),(8307,True),(8308,True),(8309,True),(8310,True),(8311,True),(8312,True),(8313,True),(8314,True),(8315,True),(8316,True),(8317,True),(8318,True),(8319,True),(8320,True),(8321,True),(8322,True),(8323,True),(8324,True),(8325,True),(8326,True),(8327,True),(8328,True),(8329,True),(8330,True),(8331,True),(8332,True),(8333,True),(8334,True),(8335,True),(8336,True),(8337,True),(8338,True),(8339,True),(8340,True),(8341,True),(8342,True),(8343,True),(8344,True),(8345,True),(8346,True),(8347,True),(8348,True),(8349,True),(8350,True),(8351,True),(8352,True),(8353,True),(8354,True),(8355,True),(8356,True),(8357,True),(8358,True),(8359,True),(8360,True),(8361,True),(8362,True),(8363,True),(8364,True),(8365,True),(8366,True),(8367,True),(8368,True),(8369,True),(8370,True),(8371,True),(8372,True),(8373,True),(8374,True),(8375,True),(8376,True),(8377,True),(8378,True),(8379,True),(8380,True),(8381,True),(8382,True),(8383,True),(8384,True),(8385,True),(8386,True),(8387,True),(8388,True),(8389,True),(8390,True),(8391,True),(8392,True),(8393,True),(8394,True),(8395,True),(8396,True),(8397,True),(8398,True),(8399,True),(8400,True),(8401,True),(8402,True),(8403,True),(8404,True),(8405,True),(8406,True),(8407,True),(8408,True),(8409,True),(8410,True),(8411,True),(8412,True),(8413,True),(8414,True),(8415,True),(8416,True),(8417,True),(8418,True),(8419,True),(8420,True),(8421,True),(8422,True),(8423,True),(8424,True),(8425,True),(8426,True),(8427,True),(8428,True),(8429,True),(8430,True),(8431,True),(8432,True),(8433,True),(8434,True),(8435,True),(8436,True),(8437,True),(8438,True),(8439,True),(8440,True),(8441,True),(8442,True),(8443,True),(8444,True),(8445,True),(8446,True),(8447,True),(8448,True),(8449,True),(8450,True),(8451,True),(8452,True),(8453,True),(8454,True),(8455,True),(8456,True),(8457,True),(8458,True),(8459,True),(8460,True),(8461,True),(8462,True),(8463,True),(8464,True),(8465,True),(8466,True),(8467,True),(8468,True),(8469,True),(8470,True),(8471,True),(8472,True),(8473,True),(8474,True),(8475,True),(8476,True),(8477,True),(8478,True),(8479,True),(8480,True),(8481,True),(8482,True),(8483,True),(8484,True),(8485,True),(8486,True),(8487,True),(8488,True),(8489,True),(8490,True),(8491,True),(8492,True),(8493,True),(8494,True),(8495,True),(8496,True),(8497,True),(8498,True),(8499,True),(8500,True),(8501,True),(8502,True),(8503,True),(8504,True),(8505,True),(8506,True),(8507,True),(8508,True),(8509,True),(8510,True),(8511,True),(8512,True),(8513,True),(8514,True),(8515,True),(8516,True),(8517,True),(8518,True),(8519,True),(8520,True),(8521,True),(8522,True),(8523,True),(8524,True),(8525,True),(8526,True),(8527,True),(8528,True),(8529,True),(8530,True),(8531,True),(8532,True),(8533,True),(8534,True),(8535,True),(8536,True),(8537,True),(8538,True),(8539,True),(8540,True),(8541,True),(8542,True),(8543,True),(8544,True),(8545,True),(8546,True),(8547,True),(8548,True),(8549,True),(8550,True),(8551,True),(8552,True),(8553,True),(8554,True),(8555,True),(8556,True),(8557,True),(8558,True),(8559,True),(8560,True),(8561,True),(8562,True),(8563,True),(8564,True),(8565,True),(8566,True),(8567,True),(8568,True),(8569,True),(8570,True),(8571,True),(8572,True),(8573,True),(8574,True),(8575,True),(8576,True),(8577,True),(8578,True),(8579,True),(8580,True),(8581,True),(8582,True),(8583,True),(8584,True),(8585,True),(8586,True),(8587,True),(8588,True),(8589,True),(8590,True),(8591,True),(8592,True),(8593,True),(8594,True),(8595,True),(8596,True),(8597,True),(8598,True),(8599,True),(8600,True),(8601,True),(8602,True),(8603,True),(8604,True),(8605,True),(8606,True),(8607,True),(8608,True),(8609,True),(8610,True),(8611,True),(8612,True),(8613,True),(8614,True),(8615,True),(8616,True),(8617,True),(8618,True),(8619,True),(8620,True),(8621,True),(8622,True),(8623,True),(8624,True),(8625,True),(8626,True),(8627,True),(8628,True),(8629,True),(8630,True),(8631,True),(8632,True),(8633,True),(8634,True),(8635,True),(8636,True),(8637,True),(8638,True),(8639,True),(8640,True),(8641,True),(8642,True),(8643,True),(8644,True),(8645,True),(8646,True),(8647,True),(8648,True),(8649,True),(8650,True),(8651,True),(8652,True),(8653,True),(8654,True),(8655,True),(8656,True),(8657,True),(8658,True),(8659,True),(8660,True),(8661,True),(8662,True),(8663,True),(8664,True),(8665,True),(8666,True),(8667,True),(8668,True),(8669,True),(8670,True),(8671,True),(8672,True),(8673,True),(8674,True),(8675,True),(8676,True),(8677,True),(8678,True),(8679,True),(8680,True),(8681,True),(8682,True),(8683,True),(8684,True),(8685,True),(8686,True),(8687,True),(8688,True),(8689,True),(8690,True),(8691,True),(8692,True),(8693,True),(8694,True),(8695,True),(8696,True),(8697,True),(8698,True),(8699,True),(8700,True),(8701,True),(8702,True),(8703,True),(8704,True),(8705,True),(8706,True),(8707,True),(8708,True),(8709,True),(8710,True),(8711,True),(8712,True),(8713,True),(8714,True),(8715,True),(8716,True),(8717,True),(8718,True),(8719,True),(8720,True),(8721,True),(8722,True),(8723,True),(8724,True),(8725,True),(8726,True),(8727,True),(8728,True),(8729,True),(8730,True),(8731,True),(8732,True),(8733,True),(8734,True),(8735,True),(8736,True),(8737,True),(8738,True),(8739,True),(8740,True),(8741,True),(8742,True),(8743,True),(8744,True),(8745,True),(8746,True),(8747,True),(8748,True),(8749,True),(8750,True),(8751,True),(8752,True),(8753,True),(8754,True),(8755,True),(8756,True),(8757,True),(8758,True),(8759,True),(8760,True),(8761,True),(8762,True),(8763,True),(8764,True),(8765,True),(8766,True),(8767,True),(8768,True),(8769,True),(8770,True),(8771,True),(8772,True),(8773,True),(8774,True),(8775,True),(8776,True),(8777,True),(8778,True),(8779,True),(8780,True),(8781,True),(8782,True),(8783,True),(8784,True),(8785,True),(8786,True),(8787,True),(8788,True),(8789,True),(8790,True),(8791,True),(8792,True),(8793,True),(8794,True),(8795,True),(8796,True),(8797,True),(8798,True),(8799,True),(8800,True),(8801,True),(8802,True),(8803,True),(8804,True),(8805,True),(8806,True),(8807,True),(8808,True),(8809,True),(8810,True),(8811,True),(8812,True),(8813,True),(8814,True),(8815,True),(8816,True),(8817,True),(8818,True),(8819,True),(8820,True),(8821,True),(8822,True),(8823,True),(8824,True),(8825,True),(8826,True),(8827,True),(8828,True),(8829,True),(8830,True),(8831,True),(8832,True),(8833,True),(8834,True),(8835,True),(8836,True),(8837,True),(8838,True),(8839,True),(8840,True),(8841,True),(8842,True),(8843,True),(8844,True),(8845,True),(8846,True),(8847,True),(8848,True),(8849,True),(8850,True),(8851,True),(8852,True),(8853,True),(8854,True),(8855,True),(8856,True),(8857,True),(8858,True),(8859,True),(8860,True),(8861,True),(8862,True),(8863,True),(8864,True),(8865,True),(8866,True),(8867,True),(8868,True),(8869,True),(8870,True),(8871,True),(8872,True),(8873,True),(8874,True),(8875,True),(8876,True),(8877,True),(8878,True),(8879,True),(8880,True),(8881,True),(8882,True),(8883,True),(8884,True),(8885,True),(8886,True),(8887,True),(8888,True),(8889,True),(8890,True),(8891,True),(8892,True),(8893,True),(8894,True),(8895,True),(8896,True),(8897,True),(8898,True),(8899,True),(8900,True),(8901,True),(8902,True),(8903,True),(8904,True),(8905,True),(8906,True),(8907,True),(8908,True),(8909,True),(8910,True),(8911,True),(8912,True),(8913,True),(8914,True),(8915,True),(8916,True),(8917,True),(8918,True),(8919,True),(8920,True),(8921,True),(8922,True),(8923,True),(8924,True),(8925,True),(8926,True),(8927,True),(8928,True),(8929,True),(8930,True),(8931,True),(8932,True),(8933,True),(8934,True),(8935,True),(8936,True),(8937,True),(8938,True),(8939,True),(8940,True),(8941,True),(8942,True),(8943,True),(8944,True),(8945,True),(8946,True),(8947,True),(8948,True),(8949,True),(8950,True),(8951,True),(8952,True),(8953,True),(8954,True),(8955,True),(8956,True),(8957,True),(8958,True),(8959,True),(8960,True),(8961,True),(8962,True),(8963,True),(8964,True),(8965,True),(8966,True),(8967,True),(8968,True),(8969,True),(8970,True),(8971,True),(8972,True),(8973,True),(8974,True),(8975,True),(8976,True),(8977,True),(8978,True),(8979,True),(8980,True),(8981,True),(8982,True),(8983,True),(8984,True),(8985,True),(8986,True),(8987,True),(8988,True),(8989,True),(8990,True),(8991,True),(8992,True),(8993,True),(8994,True),(8995,True),(8996,True),(8997,True),(8998,True),(8999,True),(9000,True),(9001,True),(9002,True),(9003,True),(9004,True),(9005,True),(9006,True),(9007,True),(9008,True),(9009,True),(9010,True),(9011,True),(9012,True),(9013,True),(9014,True),(9015,True),(9016,True),(9017,True),(9018,True),(9019,True),(9020,True),(9021,True),(9022,True),(9023,True),(9024,True),(9025,True),(9026,True),(9027,True),(9028,True),(9029,True),(9030,True),(9031,True),(9032,True),(9033,True),(9034,True),(9035,True),(9036,True),(9037,True),(9038,True),(9039,True),(9040,True),(9041,True),(9042,True),(9043,True),(9044,True),(9045,True),(9046,True),(9047,True),(9048,True),(9049,True),(9050,True),(9051,True),(9052,True),(9053,True),(9054,True),(9055,True),(9056,True),(9057,True),(9058,True),(9059,True),(9060,True),(9061,True),(9062,True),(9063,True),(9064,True),(9065,True),(9066,True),(9067,True),(9068,True),(9069,True),(9070,True),(9071,True),(9072,True),(9073,True),(9074,True),(9075,True),(9076,True),(9077,True),(9078,True),(9079,True),(9080,True),(9081,True),(9082,True),(9083,True),(9084,True),(9085,True),(9086,True),(9087,True),(9088,True),(9089,True),(9090,True),(9091,True),(9092,True),(9093,True),(9094,True),(9095,True),(9096,True),(9097,True),(9098,True),(9099,True),(9100,True),(9101,True),(9102,True),(9103,True),(9104,True),(9105,True),(9106,True),(9107,True),(9108,True),(9109,True),(9110,True),(9111,True),(9112,True),(9113,True),(9114,True),(9115,True),(9116,True),(9117,True),(9118,True),(9119,True),(9120,True),(9121,True),(9122,True),(9123,True),(9124,True),(9125,True),(9126,True),(9127,True),(9128,True),(9129,True),(9130,True),(9131,True),(9132,True),(9133,True),(9134,True),(9135,True),(9136,True),(9137,True),(9138,True),(9139,True),(9140,True),(9141,True),(9142,True),(9143,True),(9144,True),(9145,True),(9146,True),(9147,True),(9148,True),(9149,True),(9150,True),(9151,True),(9152,True),(9153,True),(9154,True),(9155,True),(9156,True),(9157,True),(9158,True),(9159,True),(9160,True),(9161,True),(9162,True),(9163,True),(9164,True),(9165,True),(9166,True),(9167,True),(9168,True),(9169,True),(9170,True),(9171,True),(9172,True),(9173,True),(9174,True),(9175,True),(9176,True),(9177,True),(9178,True),(9179,True),(9180,True),(9181,True),(9182,True),(9183,True),(9184,True),(9185,True),(9186,True),(9187,True),(9188,True),(9189,True),(9190,True),(9191,True),(9192,True),(9193,True),(9194,True),(9195,True),(9196,True),(9197,True),(9198,True),(9199,True),(9200,True),(9201,True),(9202,True),(9203,True),(9204,True),(9205,True),(9206,True),(9207,True),(9208,True),(9209,True),(9210,True),(9211,True),(9212,True),(9213,True),(9214,True),(9215,True),(9216,True),(9217,True),(9218,True),(9219,True),(9220,True),(9221,True),(9222,True),(9223,True),(9224,True),(9225,True),(9226,True),(9227,True),(9228,True),(9229,True),(9230,True),(9231,True),(9232,True),(9233,True),(9234,True),(9235,True),(9236,True),(9237,True),(9238,True),(9239,True),(9240,True),(9241,True),(9242,True),(9243,True),(9244,True),(9245,True),(9246,True),(9247,True),(9248,True),(9249,True),(9250,True),(9251,True),(9252,True),(9253,True),(9254,True),(9255,True),(9256,True),(9257,True),(9258,True),(9259,True),(9260,True),(9261,True),(9262,True),(9263,True),(9264,True),(9265,True),(9266,True),(9267,True),(9268,True),(9269,True),(9270,True),(9271,True),(9272,True),(9273,True),(9274,True),(9275,True),(9276,True),(9277,True),(9278,True),(9279,True),(9280,True),(9281,True),(9282,True),(9283,True),(9284,True),(9285,True),(9286,True),(9287,True),(9288,True),(9289,True),(9290,True),(9291,True),(9292,True),(9293,True),(9294,True),(9295,True),(9296,True),(9297,True),(9298,True),(9299,True),(9300,True),(9301,True),(9302,True),(9303,True),(9304,True),(9305,True),(9306,True),(9307,True),(9308,True),(9309,True),(9310,True),(9311,True),(9312,True),(9313,True),(9314,True),(9315,True),(9316,True),(9317,True),(9318,True),(9319,True),(9320,True),(9321,True),(9322,True),(9323,True),(9324,True),(9325,True),(9326,True),(9327,True),(9328,True),(9329,True),(9330,True),(9331,True),(9332,True),(9333,True),(9334,True),(9335,True),(9336,True),(9337,True),(9338,True),(9339,True),(9340,True),(9341,True),(9342,True),(9343,True),(9344,True),(9345,True),(9346,True),(9347,True),(9348,True),(9349,True),(9350,True),(9351,True),(9352,True),(9353,True),(9354,True),(9355,True),(9356,True),(9357,True),(9358,True),(9359,True),(9360,True),(9361,True),(9362,True),(9363,True),(9364,True),(9365,True),(9366,True),(9367,True),(9368,True),(9369,True),(9370,True),(9371,True),(9372,True),(9373,True),(9374,True),(9375,True),(9376,True),(9377,True),(9378,True),(9379,True),(9380,True),(9381,True),(9382,True),(9383,True),(9384,True),(9385,True),(9386,True),(9387,True),(9388,True),(9389,True),(9390,True),(9391,True),(9392,True),(9393,True),(9394,True),(9395,True),(9396,True),(9397,True),(9398,True),(9399,True),(9400,True),(9401,True),(9402,True),(9403,True),(9404,True),(9405,True),(9406,True),(9407,True),(9408,True),(9409,True),(9410,True),(9411,True),(9412,True),(9413,True),(9414,True),(9415,True),(9416,True),(9417,True),(9418,True),(9419,True),(9420,True),(9421,True),(9422,True),(9423,True),(9424,True),(9425,True),(9426,True),(9427,True),(9428,True),(9429,True),(9430,True),(9431,True),(9432,True),(9433,True),(9434,True),(9435,True),(9436,True),(9437,True),(9438,True),(9439,True),(9440,True),(9441,True),(9442,True),(9443,True),(9444,True),(9445,True),(9446,True),(9447,True),(9448,True),(9449,True),(9450,True),(9451,True),(9452,True),(9453,True),(9454,True),(9455,True),(9456,True),(9457,True),(9458,True),(9459,True),(9460,True),(9461,True),(9462,True),(9463,True),(9464,True),(9465,True),(9466,True),(9467,True),(9468,True),(9469,True),(9470,True),(9471,True),(9472,True),(9473,True),(9474,True),(9475,True),(9476,True),(9477,True),(9478,True),(9479,True),(9480,True),(9481,True),(9482,True),(9483,True),(9484,True),(9485,True),(9486,True),(9487,True),(9488,True),(9489,True),(9490,True),(9491,True),(9492,True),(9493,True),(9494,True),(9495,True),(9496,True),(9497,True),(9498,True),(9499,True),(9500,True),(9501,True),(9502,True),(9503,True),(9504,True),(9505,True),(9506,True),(9507,True),(9508,True),(9509,True),(9510,True),(9511,True),(9512,True),(9513,True),(9514,True),(9515,True),(9516,True),(9517,True),(9518,True),(9519,True),(9520,True),(9521,True),(9522,True),(9523,True),(9524,True),(9525,True),(9526,True),(9527,True),(9528,True),(9529,True),(9530,True),(9531,True),(9532,True),(9533,True),(9534,True),(9535,True),(9536,True),(9537,True),(9538,True),(9539,True),(9540,True),(9541,True),(9542,True),(9543,True),(9544,True),(9545,True),(9546,True),(9547,True),(9548,True),(9549,True),(9550,True),(9551,True),(9552,True),(9553,True),(9554,True),(9555,True),(9556,True),(9557,True),(9558,True),(9559,True),(9560,True),(9561,True),(9562,True),(9563,True),(9564,True),(9565,True),(9566,True),(9567,True),(9568,True),(9569,True),(9570,True),(9571,True),(9572,True),(9573,True),(9574,True),(9575,True),(9576,True),(9577,True),(9578,True),(9579,True),(9580,True),(9581,True),(9582,True),(9583,True),(9584,True),(9585,True),(9586,True),(9587,True),(9588,True),(9589,True),(9590,True),(9591,True),(9592,True),(9593,True),(9594,True),(9595,True),(9596,True),(9597,True),(9598,True),(9599,True),(9600,True),(9601,True),(9602,True),(9603,True),(9604,True),(9605,True),(9606,True),(9607,True),(9608,True),(9609,True),(9610,True),(9611,True),(9612,True),(9613,True),(9614,True),(9615,True),(9616,True),(9617,True),(9618,True),(9619,True),(9620,True),(9621,True),(9622,True),(9623,True),(9624,True),(9625,True),(9626,True),(9627,True),(9628,True),(9629,True),(9630,True),(9631,True),(9632,True),(9633,True),(9634,True),(9635,True),(9636,True),(9637,True),(9638,True),(9639,True),(9640,True),(9641,True),(9642,True),(9643,True),(9644,True),(9645,True),(9646,True),(9647,True),(9648,True),(9649,True),(9650,True),(9651,True),(9652,True),(9653,True),(9654,True),(9655,True),(9656,True),(9657,True),(9658,True),(9659,True),(9660,True),(9661,True),(9662,True),(9663,True),(9664,True),(9665,True),(9666,True),(9667,True),(9668,True),(9669,True),(9670,True),(9671,True),(9672,True),(9673,True),(9674,True),(9675,True),(9676,True),(9677,True),(9678,True),(9679,True),(9680,True),(9681,True),(9682,True),(9683,True),(9684,True),(9685,True),(9686,True),(9687,True),(9688,True),(9689,True),(9690,True),(9691,True),(9692,True),(9693,True),(9694,True),(9695,True),(9696,True),(9697,True),(9698,True),(9699,True),(9700,True),(9701,True),(9702,True),(9703,True),(9704,True),(9705,True),(9706,True),(9707,True),(9708,True),(9709,True),(9710,True),(9711,True),(9712,True),(9713,True),(9714,True),(9715,True),(9716,True),(9717,True),(9718,True),(9719,True),(9720,True),(9721,True),(9722,True),(9723,True),(9724,True),(9725,True),(9726,True),(9727,True),(9728,True),(9729,True),(9730,True),(9731,True),(9732,True),(9733,True),(9734,True),(9735,True),(9736,True),(9737,True),(9738,True),(9739,True),(9740,True),(9741,True),(9742,True),(9743,True),(9744,True),(9745,True),(9746,True),(9747,True),(9748,True),(9749,True),(9750,True),(9751,True),(9752,True),(9753,True),(9754,True),(9755,True),(9756,True),(9757,True),(9758,True),(9759,True),(9760,True),(9761,True),(9762,True),(9763,True),(9764,True),(9765,True),(9766,True),(9767,True),(9768,True),(9769,True),(9770,True),(9771,True),(9772,True),(9773,True),(9774,True),(9775,True),(9776,True),(9777,True),(9778,True),(9779,True),(9780,True),(9781,True),(9782,True),(9783,True),(9784,True),(9785,True),(9786,True),(9787,True),(9788,True),(9789,True),(9790,True),(9791,True),(9792,True),(9793,True),(9794,True),(9795,True),(9796,True),(9797,True),(9798,True),(9799,True),(9800,True),(9801,True),(9802,True),(9803,True),(9804,True),(9805,True),(9806,True),(9807,True),(9808,True),(9809,True),(9810,True),(9811,True),(9812,True),(9813,True),(9814,True),(9815,True),(9816,True),(9817,True),(9818,True),(9819,True),(9820,True),(9821,True),(9822,True),(9823,True),(9824,True),(9825,True),(9826,True),(9827,True),(9828,True),(9829,True),(9830,True),(9831,True),(9832,True),(9833,True),(9834,True),(9835,True),(9836,True),(9837,True),(9838,True),(9839,True),(9840,True),(9841,True),(9842,True),(9843,True),(9844,True),(9845,True),(9846,True),(9847,True),(9848,True),(9849,True),(9850,True),(9851,True),(9852,True),(9853,True),(9854,True),(9855,True),(9856,True),(9857,True),(9858,True),(9859,True),(9860,True),(9861,True),(9862,True),(9863,True),(9864,True),(9865,True),(9866,True),(9867,True),(9868,True),(9869,True),(9870,True),(9871,True),(9872,True),(9873,True),(9874,True),(9875,True),(9876,True),(9877,True),(9878,True),(9879,True),(9880,True),(9881,True),(9882,True),(9883,True),(9884,True),(9885,True),(9886,True),(9887,True),(9888,True),(9889,True),(9890,True),(9891,True),(9892,True),(9893,True),(9894,True),(9895,True),(9896,True),(9897,True),(9898,True),(9899,True),(9900,True),(9901,True),(9902,True),(9903,True),(9904,True),(9905,True),(9906,True),(9907,True),(9908,True),(9909,True),(9910,True),(9911,True),(9912,True),(9913,True),(9914,True),(9915,True),(9916,True),(9917,True),(9918,True),(9919,True),(9920,True),(9921,True),(9922,True),(9923,True),(9924,True),(9925,True),(9926,True),(9927,True),(9928,True),(9929,True),(9930,True),(9931,True),(9932,True),(9933,True),(9934,True),(9935,True),(9936,True),(9937,True),(9938,True),(9939,True),(9940,True),(9941,True),(9942,True),(9943,True),(9944,True),(9945,True),(9946,True),(9947,True),(9948,True),(9949,True),(9950,True),(9951,True),(9952,True),(9953,True),(9954,True),(9955,True),(9956,True),(9957,True),(9958,True),(9959,True),(9960,True),(9961,True),(9962,True),(9963,True),(9964,True),(9965,True),(9966,True),(9967,True),(9968,True),(9969,True),(9970,True),(9971,True),(9972,True),(9973,True),(9974,True),(9975,True),(9976,True),(9977,True),(9978,True),(9979,True),(9980,True),(9981,True),(9982,True),(9983,True),(9984,True),(9985,True),(9986,True),(9987,True),(9988,True),(9989,True),(9990,True),(9991,True),(9992,True),(9993,True),(9994,True),(9995,True),(9996,True),(9997,True),(9998,True),(9999,True),(10000,True),(10001,True),(10002,True),(10003,True),(10004,True),(10005,True),(10006,True),(10007,True),(10008,True),(10009,True),(10010,True),(10011,True),(10012,True),(10013,True),(10014,True),(10015,True),(10016,True),(10017,True),(10018,True),(10019,True),(10020,True),(10021,True),(10022,True),(10023,True),(10024,True),(10025,True),(10026,True),(10027,True),(10028,True),(10029,True),(10030,True),(10031,True),(10032,True),(10033,True),(10034,True),(10035,True),(10036,True),(10037,True),(10038,True),(10039,True),(10040,True),(10041,True),(10042,True),(10043,True),(10044,True),(10045,True),(10046,True),(10047,True),(10048,True),(10049,True),(10050,True),(10051,True),(10052,True),(10053,True),(10054,True),(10055,True),(10056,True),(10057,True),(10058,True),(10059,True),(10060,True),(10061,True),(10062,True),(10063,True),(10064,True),(10065,True),(10066,True),(10067,True),(10068,True),(10069,True),(10070,True),(10071,True),(10072,True),(10073,True),(10074,True),(10075,True),(10076,True),(10077,True),(10078,True),(10079,True),(10080,True),(10081,True),(10082,True),(10083,True),(10084,True),(10085,True),(10086,True),(10087,True),(10088,True),(10089,True),(10090,True),(10091,True),(10092,True),(10093,True),(10094,True),(10095,True),(10096,True),(10097,True),(10098,True),(10099,True),(10100,True),(10101,True),(10102,True),(10103,True),(10104,True),(10105,True),(10106,True),(10107,True),(10108,True),(10109,True),(10110,True),(10111,True),(10112,True),(10113,True),(10114,True),(10115,True),(10116,True),(10117,True),(10118,True),(10119,True),(10120,True),(10121,True),(10122,True),(10123,True),(10124,True),(10125,True),(10126,True),(10127,True),(10128,True),(10129,True),(10130,True),(10131,True),(10132,True),(10133,True),(10134,True),(10135,True),(10136,True),(10137,True),(10138,True),(10139,True),(10140,True),(10141,True),(10142,True),(10143,True),(10144,True),(10145,True),(10146,True),(10147,True),(10148,True),(10149,True),(10150,True),(10151,True),(10152,True),(10153,True),(10154,True),(10155,True),(10156,True),(10157,True),(10158,True),(10159,True),(10160,True),(10161,True),(10162,True),(10163,True),(10164,True),(10165,True),(10166,True),(10167,True),(10168,True),(10169,True),(10170,True),(10171,True),(10172,True),(10173,True),(10174,True),(10175,True),(10176,True),(10177,True),(10178,True),(10179,True),(10180,True),(10181,True),(10182,True),(10183,True),(10184,True),(10185,True),(10186,True),(10187,True),(10188,True),(10189,True),(10190,True),(10191,True),(10192,True),(10193,True),(10194,True),(10195,True),(10196,True),(10197,True),(10198,True),(10199,True),(10200,True),(10201,True),(10202,True),(10203,True),(10204,True),(10205,True),(10206,True),(10207,True),(10208,True),(10209,True),(10210,True),(10211,True),(10212,True),(10213,True),(10214,True),(10215,True),(10216,True),(10217,True),(10218,True),(10219,True),(10220,True),(10221,True),(10222,True),(10223,True),(10224,True),(10225,True),(10226,True),(10227,True),(10228,True),(10229,True),(10230,True),(10231,True),(10232,True),(10233,True),(10234,True),(10235,True),(10236,True),(10237,True),(10238,True),(10239,True),(10240,True),(10241,True),(10242,True),(10243,True),(10244,True),(10245,True),(10246,True),(10247,True),(10248,True),(10249,True),(10250,True),(10251,True),(10252,True),(10253,True),(10254,True),(10255,True),(10256,True),(10257,True),(10258,True),(10259,True),(10260,True),(10261,True),(10262,True),(10263,True),(10264,True),(10265,True),(10266,True),(10267,True),(10268,True),(10269,True),(10270,True),(10271,True),(10272,True),(10273,True),(10274,True),(10275,True),(10276,True),(10277,True),(10278,True),(10279,True),(10280,True),(10281,True),(10282,True),(10283,True),(10284,True),(10285,True),(10286,True),(10287,True),(10288,True),(10289,True),(10290,True),(10291,True),(10292,True),(10293,True),(10294,True),(10295,True),(10296,True),(10297,True),(10298,True),(10299,True),(10300,True),(10301,True),(10302,True),(10303,True),(10304,True),(10305,True),(10306,True),(10307,True),(10308,True),(10309,True),(10310,True),(10311,True),(10312,True),(10313,True),(10314,True),(10315,True),(10316,True),(10317,True),(10318,True),(10319,True),(10320,True),(10321,True),(10322,True),(10323,True),(10324,True),(10325,True),(10326,True),(10327,True),(10328,True),(10329,True),(10330,True),(10331,True),(10332,True),(10333,True),(10334,True),(10335,True),(10336,True),(10337,True),(10338,True),(10339,True),(10340,True),(10341,True),(10342,True),(10343,True),(10344,True),(10345,True),(10346,True),(10347,True),(10348,True),(10349,True),(10350,True),(10351,True),(10352,True),(10353,True),(10354,True),(10355,True),(10356,True),(10357,True),(10358,True),(10359,True),(10360,True),(10361,True),(10362,True),(10363,True),(10364,True),(10365,True),(10366,True),(10367,True),(10368,True),(10369,True),(10370,True),(10371,True),(10372,True),(10373,True),(10374,True),(10375,True),(10376,True),(10377,True),(10378,True),(10379,True),(10380,True),(10381,True),(10382,True),(10383,True),(10384,True),(10385,True),(10386,True),(10387,True),(10388,True),(10389,True),(10390,True),(10391,True),(10392,True),(10393,True),(10394,True),(10395,True),(10396,True),(10397,True),(10398,True),(10399,True),(10400,True),(10401,True),(10402,True),(10403,True),(10404,True),(10405,True),(10406,True),(10407,True),(10408,True),(10409,True),(10410,True),(10411,True),(10412,True),(10413,True),(10414,True),(10415,True),(10416,True),(10417,True),(10418,True),(10419,True),(10420,True),(10421,True),(10422,True),(10423,True),(10424,True),(10425,True),(10426,True),(10427,True),(10428,True),(10429,True),(10430,True),(10431,True),(10432,True),(10433,True),(10434,True),(10435,True),(10436,True),(10437,True),(10438,True),(10439,True),(10440,True),(10441,True),(10442,True),(10443,True),(10444,True),(10445,True),(10446,True),(10447,True),(10448,True),(10449,True),(10450,True),(10451,True),(10452,True),(10453,True),(10454,True),(10455,True),(10456,True),(10457,True),(10458,True),(10459,True),(10460,True),(10461,True),(10462,True),(10463,True),(10464,True),(10465,True),(10466,True),(10467,True),(10468,True),(10469,True),(10470,True),(10471,True),(10472,True),(10473,True),(10474,True),(10475,True),(10476,True),(10477,True),(10478,True),(10479,True),(10480,True),(10481,True),(10482,True),(10483,True),(10484,True),(10485,True),(10486,True),(10487,True),(10488,True),(10489,True),(10490,True),(10491,True),(10492,True),(10493,True),(10494,True),(10495,True),(10496,True),(10497,True),(10498,True),(10499,True),(10500,True),(10501,True),(10502,True),(10503,True),(10504,True),(10505,True),(10506,True),(10507,True),(10508,True),(10509,True),(10510,True),(10511,True),(10512,True),(10513,True),(10514,True),(10515,True),(10516,True),(10517,True),(10518,True),(10519,True),(10520,True),(10521,True),(10522,True),(10523,True),(10524,True),(10525,True),(10526,True),(10527,True),(10528,True),(10529,True),(10530,True),(10531,True),(10532,True),(10533,True),(10534,True),(10535,True),(10536,True),(10537,True),(10538,True),(10539,True),(10540,True),(10541,True),(10542,True),(10543,True),(10544,True),(10545,True),(10546,True),(10547,True),(10548,True),(10549,True),(10550,True),(10551,True),(10552,True),(10553,True),(10554,True),(10555,True),(10556,True),(10557,True),(10558,True),(10559,True),(10560,True),(10561,True),(10562,True),(10563,True),(10564,True),(10565,True),(10566,True),(10567,True),(10568,True),(10569,True),(10570,True),(10571,True),(10572,True),(10573,True),(10574,True),(10575,True),(10576,True),(10577,True),(10578,True),(10579,True),(10580,True),(10581,True),(10582,True),(10583,True),(10584,True),(10585,True),(10586,True),(10587,True),(10588,True),(10589,True),(10590,True),(10591,True),(10592,True),(10593,True),(10594,True),(10595,True),(10596,True),(10597,True),(10598,True),(10599,True),(10600,True),(10601,True),(10602,True),(10603,True),(10604,True),(10605,True),(10606,True),(10607,True),(10608,True),(10609,True),(10610,True),(10611,True),(10612,True),(10613,True),(10614,True),(10615,True),(10616,True),(10617,True),(10618,True),(10619,True),(10620,True),(10621,True),(10622,True),(10623,True),(10624,True),(10625,True),(10626,True),(10627,True),(10628,True),(10629,True),(10630,True),(10631,True),(10632,True),(10633,True),(10634,True),(10635,True),(10636,True),(10637,True),(10638,True),(10639,True),(10640,True),(10641,True),(10642,True),(10643,True),(10644,True),(10645,True),(10646,True),(10647,True),(10648,True),(10649,True),(10650,True),(10651,True),(10652,True),(10653,True),(10654,True),(10655,True),(10656,True),(10657,True),(10658,True),(10659,True),(10660,True),(10661,True),(10662,True),(10663,True),(10664,True),(10665,True),(10666,True),(10667,True),(10668,True),(10669,True),(10670,True),(10671,True),(10672,True),(10673,True),(10674,True),(10675,True),(10676,True),(10677,True),(10678,True),(10679,True),(10680,True),(10681,True),(10682,True),(10683,True),(10684,True),(10685,True),(10686,True),(10687,True),(10688,True),(10689,True),(10690,True),(10691,True),(10692,True),(10693,True),(10694,True),(10695,True),(10696,True),(10697,True),(10698,True),(10699,True),(10700,True),(10701,True),(10702,True),(10703,True),(10704,True),(10705,True),(10706,True),(10707,True),(10708,True),(10709,True),(10710,True),(10711,True),(10712,True),(10713,True),(10714,True),(10715,True),(10716,True),(10717,True),(10718,True),(10719,True),(10720,True),(10721,True),(10722,True),(10723,True),(10724,True),(10725,True),(10726,True),(10727,True),(10728,True),(10729,True),(10730,True),(10731,True),(10732,True),(10733,True),(10734,True),(10735,True),(10736,True),(10737,True),(10738,True),(10739,True),(10740,True),(10741,True),(10742,True),(10743,True),(10744,True),(10745,True),(10746,True),(10747,True),(10748,True),(10749,True),(10750,True),(10751,True),(10752,True),(10753,True),(10754,True),(10755,True),(10756,True),(10757,True),(10758,True),(10759,True),(10760,True),(10761,True),(10762,True),(10763,True),(10764,True),(10765,True),(10766,True),(10767,True),(10768,True),(10769,True),(10770,True),(10771,True),(10772,True),(10773,True),(10774,True),(10775,True),(10776,True),(10777,True),(10778,True),(10779,True),(10780,True),(10781,True),(10782,True),(10783,True),(10784,True),(10785,True),(10786,True),(10787,True),(10788,True),(10789,True),(10790,True),(10791,True),(10792,True),(10793,True),(10794,True),(10795,True),(10796,True),(10797,True),(10798,True),(10799,True),(10800,True),(10801,True),(10802,True),(10803,True),(10804,True),(10805,True),(10806,True),(10807,True),(10808,True),(10809,True),(10810,True),(10811,True),(10812,True),(10813,True),(10814,True),(10815,True),(10816,True),(10817,True),(10818,True),(10819,True),(10820,True),(10821,True),(10822,True),(10823,True),(10824,True),(10825,True),(10826,True),(10827,True),(10828,True),(10829,True),(10830,True),(10831,True),(10832,True),(10833,True),(10834,True),(10835,True),(10836,True),(10837,True),(10838,True),(10839,True),(10840,True),(10841,True),(10842,True),(10843,True),(10844,True),(10845,True),(10846,True),(10847,True),(10848,True),(10849,True),(10850,True),(10851,True),(10852,True),(10853,True),(10854,True),(10855,True),(10856,True),(10857,True),(10858,True),(10859,True),(10860,True),(10861,True),(10862,True),(10863,True),(10864,True),(10865,True),(10866,True),(10867,True),(10868,True),(10869,True),(10870,True),(10871,True),(10872,True),(10873,True),(10874,True),(10875,True),(10876,True),(10877,True),(10878,True),(10879,True),(10880,True),(10881,True),(10882,True),(10883,True),(10884,True),(10885,True),(10886,True),(10887,True),(10888,True),(10889,True),(10890,True),(10891,True),(10892,True),(10893,True),(10894,True),(10895,True),(10896,True),(10897,True),(10898,True),(10899,True),(10900,True),(10901,True),(10902,True),(10903,True),(10904,True),(10905,True),(10906,True),(10907,True),(10908,True),(10909,True),(10910,True),(10911,True),(10912,True),(10913,True),(10914,True),(10915,True),(10916,True),(10917,True),(10918,True),(10919,True),(10920,True),(10921,True),(10922,True),(10923,True),(10924,True),(10925,True),(10926,True),(10927,True),(10928,True),(10929,True),(10930,True),(10931,True),(10932,True),(10933,True),(10934,True),(10935,True),(10936,True),(10937,True),(10938,True),(10939,True),(10940,True),(10941,True),(10942,True),(10943,True),(10944,True),(10945,True),(10946,True),(10947,True),(10948,True),(10949,True),(10950,True),(10951,True),(10952,True),(10953,True),(10954,True),(10955,True),(10956,True),(10957,True),(10958,True),(10959,True),(10960,True),(10961,True),(10962,True),(10963,True),(10964,True),(10965,True),(10966,True),(10967,True),(10968,True),(10969,True),(10970,True),(10971,True),(10972,True),(10973,True),(10974,True),(10975,True),(10976,True),(10977,True),(10978,True),(10979,True),(10980,True),(10981,True),(10982,True),(10983,True),(10984,True),(10985,True),(10986,True),(10987,True),(10988,True),(10989,True),(10990,True),(10991,True),(10992,True),(10993,True),(10994,True),(10995,True),(10996,True),(10997,True),(10998,True),(10999,True),(11000,True),(11001,True),(11002,True),(11003,True),(11004,True),(11005,True),(11006,True),(11007,True),(11008,True),(11009,True),(11010,True),(11011,True),(11012,True),(11013,True),(11014,True),(11015,True),(11016,True),(11017,True),(11018,True),(11019,True),(11020,True),(11021,True),(11022,True),(11023,True),(11024,True),(11025,True),(11026,True),(11027,True),(11028,True),(11029,True),(11030,True),(11031,True),(11032,True),(11033,True),(11034,True),(11035,True),(11036,True),(11037,True),(11038,True),(11039,True),(11040,True),(11041,True),(11042,True),(11043,True),(11044,True),(11045,True),(11046,True),(11047,True),(11048,True),(11049,True),(11050,True),(11051,True),(11052,True),(11053,True),(11054,True),(11055,True),(11056,True),(11057,True),(11058,True),(11059,True),(11060,True),(11061,True),(11062,True),(11063,True),(11064,True),(11065,True),(11066,True),(11067,True),(11068,True),(11069,True),(11070,True),(11071,True),(11072,True),(11073,True),(11074,True),(11075,True),(11076,True),(11077,True),(11078,True),(11079,True),(11080,True),(11081,True),(11082,True),(11083,True),(11084,True),(11085,True),(11086,True),(11087,True),(11088,True),(11089,True),(11090,True),(11091,True),(11092,True),(11093,True),(11094,True),(11095,True),(11096,True),(11097,True),(11098,True),(11099,True),(11100,True),(11101,True),(11102,True),(11103,True),(11104,True),(11105,True),(11106,True),(11107,True),(11108,True),(11109,True),(11110,True),(11111,True),(11112,True),(11113,True),(11114,True),(11115,True),(11116,True),(11117,True),(11118,True),(11119,True),(11120,True),(11121,True),(11122,True),(11123,True),(11124,True),(11125,True),(11126,True),(11127,True),(11128,True),(11129,True),(11130,True),(11131,True),(11132,True),(11133,True),(11134,True),(11135,True),(11136,True),(11137,True),(11138,True),(11139,True),(11140,True),(11141,True),(11142,True),(11143,True),(11144,True),(11145,True),(11146,True),(11147,True),(11148,True),(11149,True),(11150,True),(11151,True),(11152,True),(11153,True),(11154,True),(11155,True),(11156,True),(11157,True),(11158,True),(11159,True),(11160,True),(11161,True),(11162,True),(11163,True),(11164,True),(11165,True),(11166,True),(11167,True),(11168,True),(11169,True),(11170,True),(11171,True),(11172,True),(11173,True),(11174,True),(11175,True),(11176,True),(11177,True),(11178,True),(11179,True),(11180,True),(11181,True),(11182,True),(11183,True),(11184,True),(11185,True),(11186,True),(11187,True),(11188,True),(11189,True),(11190,True),(11191,True),(11192,True),(11193,True),(11194,True),(11195,True),(11196,True),(11197,True),(11198,True),(11199,True),(11200,True),(11201,True),(11202,True),(11203,True),(11204,True),(11205,True),(11206,True),(11207,True),(11208,True),(11209,True),(11210,True),(11211,True),(11212,True),(11213,True),(11214,True),(11215,True),(11216,True),(11217,True),(11218,True),(11219,True),(11220,True),(11221,True),(11222,True),(11223,True),(11224,True),(11225,True),(11226,True),(11227,True),(11228,True),(11229,True),(11230,True),(11231,True),(11232,True),(11233,True),(11234,True),(11235,True),(11236,True),(11237,True),(11238,True),(11239,True),(11240,True),(11241,True),(11242,True),(11243,True),(11244,True),(11245,True),(11246,True),(11247,True),(11248,True),(11249,True),(11250,True),(11251,True),(11252,True),(11253,True),(11254,True),(11255,True),(11256,True),(11257,True),(11258,True),(11259,True),(11260,True),(11261,True),(11262,True),(11263,True),(11264,True),(11265,True),(11266,True),(11267,True),(11268,True),(11269,True),(11270,True),(11271,True),(11272,True),(11273,True),(11274,True),(11275,True),(11276,True),(11277,True),(11278,True),(11279,True),(11280,True),(11281,True),(11282,True),(11283,True),(11284,True),(11285,True),(11286,True),(11287,True),(11288,True),(11289,True),(11290,True),(11291,True),(11292,True),(11293,True),(11294,True),(11295,True),(11296,True),(11297,True),(11298,True),(11299,True),(11300,True),(11301,True),(11302,True),(11303,True),(11304,True),(11305,True),(11306,True),(11307,True),(11308,True),(11309,True),(11310,True),(11311,True),(11312,True),(11313,True),(11314,True),(11315,True),(11316,True),(11317,True),(11318,True),(11319,True),(11320,True),(11321,True),(11322,True),(11323,True),(11324,True),(11325,True),(11326,True),(11327,True),(11328,True),(11329,True),(11330,True),(11331,True),(11332,True),(11333,True),(11334,True),(11335,True),(11336,True),(11337,True),(11338,True),(11339,True),(11340,True),(11341,True),(11342,True),(11343,True),(11344,True),(11345,True),(11346,True),(11347,True),(11348,True),(11349,True),(11350,True),(11351,True),(11352,True),(11353,True),(11354,True),(11355,True),(11356,True),(11357,True),(11358,True),(11359,True),(11360,True),(11361,True),(11362,True),(11363,True),(11364,True),(11365,True),(11366,True),(11367,True),(11368,True),(11369,True),(11370,True),(11371,True),(11372,True),(11373,True),(11374,True),(11375,True),(11376,True),(11377,True),(11378,True),(11379,True),(11380,True),(11381,True),(11382,True),(11383,True),(11384,True),(11385,True),(11386,True),(11387,True),(11388,True),(11389,True),(11390,True),(11391,True),(11392,True),(11393,True),(11394,True),(11395,True),(11396,True),(11397,True),(11398,True),(11399,True),(11400,True),(11401,True),(11402,True),(11403,True),(11404,True),(11405,True),(11406,True),(11407,True),(11408,True),(11409,True),(11410,True),(11411,True),(11412,True),(11413,True),(11414,True),(11415,True),(11416,True),(11417,True),(11418,True),(11419,True),(11420,True),(11421,True),(11422,True),(11423,True),(11424,True),(11425,True),(11426,True),(11427,True),(11428,True),(11429,True),(11430,True),(11431,True),(11432,True),(11433,True),(11434,True),(11435,True),(11436,True),(11437,True),(11438,True),(11439,True),(11440,True),(11441,True),(11442,True),(11443,True),(11444,True),(11445,True),(11446,True),(11447,True),(11448,True),(11449,True),(11450,True),(11451,True),(11452,True),(11453,True),(11454,True),(11455,True),(11456,True),(11457,True),(11458,True),(11459,True),(11460,True),(11461,True),(11462,True),(11463,True),(11464,True),(11465,True),(11466,True),(11467,True),(11468,True),(11469,True),(11470,True),(11471,True),(11472,True),(11473,True),(11474,True),(11475,True),(11476,True),(11477,True),(11478,True),(11479,True),(11480,True),(11481,True),(11482,True),(11483,True),(11484,True),(11485,True),(11486,True),(11487,True),(11488,True),(11489,True),(11490,True),(11491,True),(11492,True),(11493,True),(11494,True),(11495,True),(11496,True),(11497,True),(11498,True),(11499,True),(11500,True),(11501,True),(11502,True),(11503,True),(11504,True),(11505,True),(11506,True),(11507,True),(11508,True),(11509,True),(11510,True),(11511,True),(11512,True),(11513,True),(11514,True),(11515,True),(11516,True),(11517,True),(11518,True),(11519,True),(11520,True),(11521,True),(11522,True),(11523,True),(11524,True),(11525,True),(11526,True),(11527,True),(11528,True),(11529,True),(11530,True),(11531,True),(11532,True),(11533,True),(11534,True),(11535,True),(11536,True),(11537,True),(11538,True),(11539,True),(11540,True),(11541,True),(11542,True),(11543,True),(11544,True),(11545,True),(11546,True),(11547,True),(11548,True),(11549,True),(11550,True),(11551,True),(11552,True),(11553,True),(11554,True),(11555,True),(11556,True),(11557,True),(11558,True),(11559,True),(11560,True),(11561,True),(11562,True),(11563,True),(11564,True),(11565,True),(11566,True),(11567,True),(11568,True),(11569,True),(11570,True),(11571,True),(11572,True),(11573,True),(11574,True),(11575,True),(11576,True),(11577,True),(11578,True),(11579,True),(11580,True),(11581,True),(11582,True),(11583,True),(11584,True),(11585,True),(11586,True),(11587,True),(11588,True),(11589,True),(11590,True),(11591,True),(11592,True),(11593,True),(11594,True),(11595,True),(11596,True),(11597,True),(11598,True),(11599,True),(11600,True),(11601,True),(11602,True),(11603,True),(11604,True),(11605,True),(11606,True),(11607,True),(11608,True),(11609,True),(11610,True),(11611,True),(11612,True),(11613,True),(11614,True),(11615,True),(11616,True),(11617,True),(11618,True),(11619,True),(11620,True),(11621,True),(11622,True),(11623,True),(11624,True),(11625,True),(11626,True),(11627,True),(11628,True),(11629,True),(11630,True),(11631,True),(11632,True),(11633,True),(11634,True),(11635,True),(11636,True),(11637,True),(11638,True),(11639,True),(11640,True),(11641,True),(11642,True),(11643,True),(11644,True),(11645,True),(11646,True),(11647,True),(11648,True),(11649,True),(11650,True),(11651,True),(11652,True),(11653,True),(11654,True),(11655,True),(11656,True),(11657,True),(11658,True),(11659,True),(11660,True),(11661,True),(11662,True),(11663,True),(11664,True),(11665,True),(11666,True),(11667,True),(11668,True),(11669,True),(11670,True),(11671,True),(11672,True),(11673,True),(11674,True),(11675,True),(11676,True),(11677,True),(11678,True),(11679,True),(11680,True),(11681,True),(11682,True),(11683,True),(11684,True),(11685,True),(11686,True),(11687,True),(11688,True),(11689,True),(11690,True),(11691,True),(11692,True),(11693,True),(11694,True),(11695,True),(11696,True),(11697,True),(11698,True),(11699,True),(11700,True),(11701,True),(11702,True),(11703,True),(11704,True),(11705,True),(11706,True),(11707,True),(11708,True),(11709,True),(11710,True),(11711,True),(11712,True),(11713,True),(11714,True),(11715,True),(11716,True),(11717,True),(11718,True),(11719,True),(11720,True),(11721,True),(11722,True),(11723,True),(11724,True),(11725,True),(11726,True),(11727,True),(11728,True),(11729,True),(11730,True),(11731,True),(11732,True),(11733,True),(11734,True),(11735,True),(11736,True),(11737,True),(11738,True),(11739,True),(11740,True),(11741,True),(11742,True),(11743,True),(11744,True),(11745,True),(11746,True),(11747,True),(11748,True),(11749,True),(11750,True),(11751,True),(11752,True),(11753,True),(11754,True),(11755,True),(11756,True),(11757,True),(11758,True),(11759,True),(11760,True),(11761,True),(11762,True),(11763,True),(11764,True),(11765,True),(11766,True),(11767,True),(11768,True),(11769,True),(11770,True),(11771,True),(11772,True),(11773,True),(11774,True),(11775,True),(11776,True),(11777,True),(11778,True),(11779,True),(11780,True),(11781,True),(11782,True),(11783,True),(11784,True),(11785,True),(11786,True),(11787,True),(11788,True),(11789,True),(11790,True),(11791,True),(11792,True),(11793,True),(11794,True),(11795,True),(11796,True),(11797,True),(11798,True),(11799,True),(11800,True),(11801,True),(11802,True),(11803,True),(11804,True),(11805,True),(11806,True),(11807,True),(11808,True),(11809,True),(11810,True),(11811,True),(11812,True),(11813,True),(11814,True),(11815,True),(11816,True),(11817,True),(11818,True),(11819,True),(11820,True),(11821,True),(11822,True),(11823,True),(11824,True),(11825,True),(11826,True),(11827,True),(11828,True),(11829,True),(11830,True),(11831,True),(11832,True),(11833,True),(11834,True),(11835,True),(11836,True),(11837,True),(11838,True),(11839,True),(11840,True),(11841,True),(11842,True),(11843,True),(11844,True),(11845,True),(11846,True),(11847,True),(11848,True),(11849,True),(11850,True),(11851,True),(11852,True),(11853,True),(11854,True),(11855,True),(11856,True),(11857,True),(11858,True),(11859,True),(11860,True),(11861,True),(11862,True),(11863,True),(11864,True),(11865,True),(11866,True),(11867,True),(11868,True),(11869,True),(11870,True),(11871,True),(11872,True),(11873,True),(11874,True),(11875,True),(11876,True),(11877,True),(11878,True),(11879,True),(11880,True),(11881,True),(11882,True),(11883,True),(11884,True),(11885,True),(11886,True),(11887,True),(11888,True),(11889,True),(11890,True),(11891,True),(11892,True),(11893,True),(11894,True),(11895,True),(11896,True),(11897,True),(11898,True),(11899,True),(11900,True),(11901,True),(11902,True),(11903,True),(11904,True),(11905,True),(11906,True),(11907,True),(11908,True),(11909,True),(11910,True),(11911,True),(11912,True),(11913,True),(11914,True),(11915,True),(11916,True),(11917,True),(11918,True),(11919,True),(11920,True),(11921,True),(11922,True),(11923,True),(11924,True),(11925,True),(11926,True),(11927,True),(11928,True),(11929,True),(11930,True),(11931,True),(11932,True),(11933,True),(11934,True),(11935,True),(11936,True),(11937,True),(11938,True),(11939,True),(11940,True),(11941,True),(11942,True),(11943,True),(11944,True),(11945,True),(11946,True),(11947,True),(11948,True),(11949,True),(11950,True),(11951,True),(11952,True),(11953,True),(11954,True),(11955,True),(11956,True),(11957,True),(11958,True),(11959,True),(11960,True),(11961,True),(11962,True),(11963,True),(11964,True),(11965,True),(11966,True),(11967,True),(11968,True),(11969,True),(11970,True),(11971,True),(11972,True),(11973,True),(11974,True),(11975,True),(11976,True),(11977,True),(11978,True),(11979,True),(11980,True),(11981,True),(11982,True),(11983,True),(11984,True),(11985,True),(11986,True),(11987,True),(11988,True),(11989,True),(11990,True),(11991,True),(11992,True),(11993,True),(11994,True),(11995,True),(11996,True),(11997,True),(11998,True),(11999,True),(12000,True),(12001,True),(12002,True),(12003,True),(12004,True),(12005,True),(12006,True),(12007,True),(12008,True),(12009,True),(12010,True),(12011,True),(12012,True),(12013,True),(12014,True),(12015,True),(12016,True),(12017,True),(12018,True),(12019,True),(12020,True),(12021,True),(12022,True),(12023,True),(12024,True),(12025,True),(12026,True),(12027,True),(12028,True),(12029,True),(12030,True),(12031,True),(12032,True),(12033,True),(12034,True),(12035,True),(12036,True),(12037,True),(12038,True),(12039,True),(12040,True),(12041,True),(12042,True),(12043,True),(12044,True),(12045,True),(12046,True),(12047,True),(12048,True),(12049,True),(12050,True),(12051,True),(12052,True),(12053,True),(12054,True),(12055,True),(12056,True),(12057,True),(12058,True),(12059,True),(12060,True),(12061,True),(12062,True),(12063,True),(12064,True),(12065,True),(12066,True),(12067,True),(12068,True),(12069,True),(12070,True),(12071,True),(12072,True),(12073,True),(12074,True),(12075,True),(12076,True),(12077,True),(12078,True),(12079,True),(12080,True),(12081,True),(12082,True),(12083,True),(12084,True),(12085,True),(12086,True),(12087,True),(12088,True),(12089,True),(12090,True),(12091,True),(12092,True),(12093,True),(12094,True),(12095,True),(12096,True),(12097,True),(12098,True),(12099,True),(12100,True),(12101,True),(12102,True),(12103,True),(12104,True),(12105,True),(12106,True),(12107,True),(12108,True),(12109,True),(12110,True),(12111,True),(12112,True),(12113,True),(12114,True),(12115,True),(12116,True),(12117,True),(12118,True),(12119,True),(12120,True),(12121,True),(12122,True),(12123,True),(12124,True),(12125,True),(12126,True),(12127,True),(12128,True),(12129,True),(12130,True),(12131,True),(12132,True),(12133,True),(12134,True),(12135,True),(12136,True),(12137,True),(12138,True),(12139,True),(12140,True),(12141,True),(12142,True),(12143,True),(12144,True),(12145,True),(12146,True),(12147,True),(12148,True),(12149,True),(12150,True),(12151,True),(12152,True),(12153,True),(12154,True),(12155,True),(12156,True),(12157,True),(12158,True),(12159,True),(12160,True),(12161,True),(12162,True),(12163,True),(12164,True),(12165,True),(12166,True),(12167,True),(12168,True),(12169,True),(12170,True),(12171,True),(12172,True),(12173,True),(12174,True),(12175,True),(12176,True),(12177,True),(12178,True),(12179,True),(12180,True),(12181,True),(12182,True),(12183,True),(12184,True),(12185,True),(12186,True),(12187,True),(12188,True),(12189,True),(12190,True),(12191,True),(12192,True),(12193,True),(12194,True),(12195,True),(12196,True),(12197,True),(12198,True),(12199,True),(12200,True),(12201,True),(12202,True),(12203,True),(12204,True),(12205,True),(12206,True),(12207,True),(12208,True),(12209,True),(12210,True),(12211,True),(12212,True),(12213,True),(12214,True),(12215,True),(12216,True),(12217,True),(12218,True),(12219,True),(12220,True),(12221,True),(12222,True),(12223,True),(12224,True),(12225,True),(12226,True),(12227,True),(12228,True),(12229,True),(12230,True),(12231,True),(12232,True),(12233,True),(12234,True),(12235,True),(12236,True),(12237,True),(12238,True),(12239,True),(12240,True),(12241,True),(12242,True),(12243,True),(12244,True),(12245,True),(12246,True),(12247,True),(12248,True),(12249,True),(12250,True),(12251,True),(12252,True),(12253,True),(12254,True),(12255,True),(12256,True),(12257,True),(12258,True),(12259,True),(12260,True),(12261,True),(12262,True),(12263,True),(12264,True),(12265,True),(12266,True),(12267,True),(12268,True),(12269,True),(12270,True),(12271,True),(12272,True),(12273,True),(12274,True),(12275,True),(12276,True),(12277,True),(12278,True),(12279,True),(12280,True),(12281,True),(12282,True),(12283,True),(12284,True),(12285,True),(12286,True),(12287,True),(12288,True),(12289,True),(12290,True),(12291,True),(12292,True),(12293,True),(12294,True),(12295,True),(12296,True),(12297,True),(12298,True),(12299,True),(12300,True),(12301,True),(12302,True),(12303,True),(12304,True),(12305,True),(12306,True),(12307,True),(12308,True),(12309,True),(12310,True),(12311,True),(12312,True),(12313,True),(12314,True),(12315,True),(12316,True),(12317,True),(12318,True),(12319,True),(12320,True),(12321,True),(12322,True),(12323,True),(12324,True),(12325,True),(12326,True),(12327,True),(12328,True),(12329,True),(12330,True),(12331,True),(12332,True),(12333,True),(12334,True),(12335,True),(12336,True),(12337,True),(12338,True),(12339,True),(12340,True),(12341,True),(12342,True),(12343,True),(12344,True),(12345,True),(12346,True),(12347,True),(12348,True),(12349,True),(12350,True),(12351,True),(12352,True),(12353,True),(12354,True),(12355,True),(12356,True),(12357,True),(12358,True),(12359,True),(12360,True),(12361,True),(12362,True),(12363,True),(12364,True),(12365,True),(12366,True),(12367,True),(12368,True),(12369,True),(12370,True),(12371,True),(12372,True),(12373,True),(12374,True),(12375,True),(12376,True),(12377,True),(12378,True),(12379,True),(12380,True),(12381,True),(12382,True),(12383,True),(12384,True),(12385,True),(12386,True),(12387,True),(12388,True),(12389,True),(12390,True),(12391,True),(12392,True),(12393,True),(12394,True),(12395,True),(12396,True),(12397,True),(12398,True),(12399,True),(12400,True),(12401,True),(12402,True),(12403,True),(12404,True),(12405,True),(12406,True),(12407,True),(12408,True),(12409,True),(12410,True),(12411,True),(12412,True),(12413,True),(12414,True),(12415,True),(12416,True),(12417,True),(12418,True),(12419,True),(12420,True),(12421,True),(12422,True),(12423,True),(12424,True),(12425,True),(12426,True),(12427,True),(12428,True),(12429,True),(12430,True),(12431,True),(12432,True),(12433,True),(12434,True),(12435,True),(12436,True),(12437,True),(12438,True),(12439,True),(12440,True),(12441,True),(12442,True),(12443,True),(12444,True),(12445,True),(12446,True),(12447,True),(12448,True),(12449,True),(12450,True),(12451,True),(12452,True),(12453,True),(12454,True),(12455,True),(12456,True),(12457,True),(12458,True),(12459,True),(12460,True),(12461,True),(12462,True),(12463,True),(12464,True),(12465,True),(12466,True),(12467,True),(12468,True),(12469,True),(12470,True),(12471,True),(12472,True),(12473,True),(12474,True),(12475,True),(12476,True),(12477,True),(12478,True),(12479,True),(12480,True),(12481,True),(12482,True),(12483,True),(12484,True),(12485,True),(12486,True),(12487,True),(12488,True),(12489,True),(12490,True),(12491,True),(12492,True),(12493,True),(12494,True),(12495,True),(12496,True),(12497,True),(12498,True),(12499,True),(12500,True),(12501,True),(12502,True),(12503,True),(12504,True),(12505,True),(12506,True),(12507,True),(12508,True),(12509,True),(12510,True),(12511,True),(12512,True),(12513,True),(12514,True),(12515,True),(12516,True),(12517,True),(12518,True),(12519,True),(12520,True),(12521,True),(12522,True),(12523,True),(12524,True),(12525,True),(12526,True),(12527,True),(12528,True),(12529,True),(12530,True),(12531,True),(12532,True),(12533,True),(12534,True),(12535,True),(12536,True),(12537,True),(12538,True),(12539,True),(12540,True),(12541,True),(12542,True),(12543,True),(12544,True),(12545,True),(12546,True),(12547,True),(12548,True),(12549,True),(12550,True),(12551,True),(12552,True),(12553,True),(12554,True),(12555,True),(12556,True),(12557,True),(12558,True),(12559,True),(12560,True),(12561,True),(12562,True),(12563,True),(12564,True),(12565,True),(12566,True),(12567,True),(12568,True),(12569,True),(12570,True),(12571,True),(12572,True),(12573,True),(12574,True),(12575,True),(12576,True),(12577,True),(12578,True),(12579,True),(12580,True),(12581,True),(12582,True),(12583,True),(12584,True),(12585,True),(12586,True),(12587,True),(12588,True),(12589,True),(12590,True),(12591,True),(12592,True),(12593,True),(12594,True),(12595,True),(12596,True),(12597,True),(12598,True),(12599,True),(12600,True),(12601,True),(12602,True),(12603,True),(12604,True),(12605,True),(12606,True),(12607,True),(12608,True),(12609,True),(12610,True),(12611,True),(12612,True),(12613,True),(12614,True),(12615,True),(12616,True),(12617,True),(12618,True),(12619,True),(12620,True),(12621,True),(12622,True),(12623,True),(12624,True),(12625,True),(12626,True),(12627,True),(12628,True),(12629,True),(12630,True),(12631,True),(12632,True),(12633,True),(12634,True),(12635,True),(12636,True),(12637,True),(12638,True),(12639,True),(12640,True),(12641,True),(12642,True),(12643,True),(12644,True),(12645,True),(12646,True),(12647,True),(12648,True),(12649,True),(12650,True),(12651,True),(12652,True),(12653,True),(12654,True),(12655,True),(12656,True),(12657,True),(12658,True),(12659,True),(12660,True),(12661,True),(12662,True),(12663,True),(12664,True),(12665,True),(12666,True),(12667,True),(12668,True),(12669,True),(12670,True),(12671,True),(12672,True),(12673,True),(12674,True),(12675,True),(12676,True),(12677,True),(12678,True),(12679,True),(12680,True),(12681,True),(12682,True),(12683,True),(12684,True),(12685,True),(12686,True),(12687,True),(12688,True),(12689,True),(12690,True),(12691,True),(12692,True),(12693,True),(12694,True),(12695,True),(12696,True),(12697,True),(12698,True),(12699,True),(12700,True),(12701,True),(12702,True),(12703,True),(12704,True),(12705,True),(12706,True),(12707,True),(12708,True),(12709,True),(12710,True),(12711,True),(12712,True),(12713,True),(12714,True),(12715,True),(12716,True),(12717,True),(12718,True),(12719,True),(12720,True),(12721,True),(12722,True),(12723,True),(12724,True),(12725,True),(12726,True),(12727,True),(12728,True),(12729,True),(12730,True),(12731,True),(12732,True),(12733,True),(12734,True),(12735,True),(12736,True),(12737,True),(12738,True),(12739,True),(12740,True),(12741,True),(12742,True),(12743,True),(12744,True),(12745,True),(12746,True),(12747,True),(12748,True),(12749,True),(12750,True),(12751,True),(12752,True),(12753,True),(12754,True),(12755,True),(12756,True),(12757,True),(12758,True),(12759,True),(12760,True),(12761,True),(12762,True),(12763,True),(12764,True),(12765,True),(12766,True),(12767,True),(12768,True),(12769,True),(12770,True),(12771,True),(12772,True),(12773,True),(12774,True),(12775,True),(12776,True),(12777,True),(12778,True),(12779,True),(12780,True),(12781,True),(12782,True),(12783,True),(12784,True),(12785,True),(12786,True),(12787,True),(12788,True),(12789,True),(12790,True),(12791,True),(12792,True),(12793,True),(12794,True),(12795,True),(12796,True),(12797,True),(12798,True),(12799,True),(12800,True),(12801,True),(12802,True),(12803,True),(12804,True),(12805,True),(12806,True),(12807,True),(12808,True),(12809,True),(12810,True),(12811,True),(12812,True),(12813,True),(12814,True),(12815,True),(12816,True),(12817,True),(12818,True),(12819,True),(12820,True),(12821,True),(12822,True),(12823,True),(12824,True),(12825,True),(12826,True),(12827,True),(12828,True),(12829,True),(12830,True),(12831,True),(12832,True),(12833,True),(12834,True),(12835,True),(12836,True),(12837,True),(12838,True),(12839,True),(12840,True),(12841,True),(12842,True),(12843,True),(12844,True),(12845,True),(12846,True),(12847,True),(12848,True),(12849,True),(12850,True),(12851,True),(12852,True),(12853,True),(12854,True),(12855,True),(12856,True),(12857,True),(12858,True),(12859,True),(12860,True),(12861,True),(12862,True),(12863,True),(12864,True),(12865,True),(12866,True),(12867,True),(12868,True),(12869,True),(12870,True),(12871,True),(12872,True),(12873,True),(12874,True),(12875,True),(12876,True),(12877,True),(12878,True),(12879,True),(12880,True),(12881,True),(12882,True),(12883,True),(12884,True),(12885,True),(12886,True),(12887,True),(12888,True),(12889,True),(12890,True),(12891,True),(12892,True),(12893,True),(12894,True),(12895,True),(12896,True),(12897,True),(12898,True),(12899,True),(12900,True),(12901,True),(12902,True),(12903,True),(12904,True),(12905,True),(12906,True),(12907,True),(12908,True),(12909,True),(12910,True),(12911,True),(12912,True),(12913,True),(12914,True),(12915,True),(12916,True),(12917,True),(12918,True),(12919,True),(12920,True),(12921,True),(12922,True),(12923,True),(12924,True),(12925,True),(12926,True),(12927,True),(12928,True),(12929,True),(12930,True),(12931,True),(12932,True),(12933,True),(12934,True),(12935,True),(12936,True),(12937,True),(12938,True),(12939,True),(12940,True),(12941,True),(12942,True),(12943,True),(12944,True),(12945,True),(12946,True),(12947,True),(12948,True),(12949,True),(12950,True),(12951,True),(12952,True),(12953,True),(12954,True),(12955,True),(12956,True),(12957,True),(12958,True),(12959,True),(12960,True),(12961,True),(12962,True),(12963,True),(12964,True),(12965,True),(12966,True),(12967,True),(12968,True),(12969,True),(12970,True),(12971,True),(12972,True),(12973,True),(12974,True),(12975,True),(12976,True),(12977,True),(12978,True),(12979,True),(12980,True),(12981,True),(12982,True),(12983,True),(12984,True),(12985,True),(12986,True),(12987,True),(12988,True),(12989,True),(12990,True),(12991,True),(12992,True),(12993,True),(12994,True),(12995,True),(12996,True),(12997,True),(12998,True),(12999,True),(13000,True),(13001,True),(13002,True),(13003,True),(13004,True),(13005,True),(13006,True),(13007,True),(13008,True),(13009,True),(13010,True),(13011,True),(13012,True),(13013,True),(13014,True),(13015,True),(13016,True),(13017,True),(13018,True),(13019,True),(13020,True),(13021,True),(13022,True),(13023,True),(13024,True),(13025,True),(13026,True),(13027,True),(13028,True),(13029,True),(13030,True),(13031,True),(13032,True),(13033,True),(13034,True),(13035,True),(13036,True),(13037,True),(13038,True),(13039,True),(13040,True),(13041,True),(13042,True),(13043,True),(13044,True),(13045,True),(13046,True),(13047,True),(13048,True),(13049,True),(13050,True),(13051,True),(13052,True),(13053,True),(13054,True),(13055,True),(13056,True),(13057,True),(13058,True),(13059,True),(13060,True),(13061,True),(13062,True),(13063,True),(13064,True),(13065,True),(13066,True),(13067,True),(13068,True),(13069,True),(13070,True),(13071,True),(13072,True),(13073,True),(13074,True),(13075,True),(13076,True),(13077,True),(13078,True),(13079,True),(13080,True),(13081,True),(13082,True),(13083,True),(13084,True),(13085,True),(13086,True),(13087,True),(13088,True),(13089,True),(13090,True),(13091,True),(13092,True),(13093,True),(13094,True),(13095,True),(13096,True),(13097,True),(13098,True),(13099,True),(13100,True),(13101,True),(13102,True),(13103,True),(13104,True),(13105,True),(13106,True),(13107,True),(13108,True),(13109,True),(13110,True),(13111,True),(13112,True),(13113,True),(13114,True),(13115,True),(13116,True),(13117,True),(13118,True),(13119,True),(13120,True),(13121,True),(13122,True),(13123,True),(13124,True),(13125,True),(13126,True),(13127,True),(13128,True),(13129,True),(13130,True),(13131,True),(13132,True),(13133,True),(13134,True),(13135,True),(13136,True),(13137,True),(13138,True),(13139,True),(13140,True),(13141,True),(13142,True),(13143,True),(13144,True),(13145,True),(13146,True),(13147,True),(13148,True),(13149,True),(13150,True),(13151,True),(13152,True),(13153,True),(13154,True),(13155,True),(13156,True),(13157,True),(13158,True),(13159,True),(13160,True),(13161,True),(13162,True),(13163,True),(13164,True),(13165,True),(13166,True),(13167,True),(13168,True),(13169,True),(13170,True),(13171,True),(13172,True),(13173,True),(13174,True),(13175,True),(13176,True),(13177,True),(13178,True),(13179,True),(13180,True),(13181,True),(13182,True),(13183,True),(13184,True),(13185,True),(13186,True),(13187,True),(13188,True),(13189,True),(13190,True),(13191,True),(13192,True),(13193,True),(13194,True),(13195,True),(13196,True),(13197,True),(13198,True),(13199,True),(13200,True),(13201,True),(13202,True),(13203,True),(13204,True),(13205,True),(13206,True),(13207,True),(13208,True),(13209,True),(13210,True),(13211,True),(13212,True),(13213,True),(13214,True),(13215,True),(13216,True),(13217,True),(13218,True),(13219,True),(13220,True),(13221,True),(13222,True),(13223,True),(13224,True),(13225,True),(13226,True),(13227,True),(13228,True),(13229,True),(13230,True),(13231,True),(13232,True),(13233,True),(13234,True),(13235,True),(13236,True),(13237,True),(13238,True),(13239,True),(13240,True),(13241,True),(13242,True),(13243,True),(13244,True),(13245,True),(13246,True),(13247,True),(13248,True),(13249,True),(13250,True),(13251,True),(13252,True),(13253,True),(13254,True),(13255,True),(13256,True),(13257,True),(13258,True),(13259,True),(13260,True),(13261,True),(13262,True),(13263,True),(13264,True),(13265,True),(13266,True),(13267,True),(13268,True),(13269,True),(13270,True),(13271,True),(13272,True),(13273,True),(13274,True),(13275,True),(13276,True),(13277,True),(13278,True),(13279,True),(13280,True),(13281,True),(13282,True),(13283,True),(13284,True),(13285,True),(13286,True),(13287,True),(13288,True),(13289,True),(13290,True),(13291,True),(13292,True),(13293,True),(13294,True),(13295,True),(13296,True),(13297,True),(13298,True),(13299,True),(13300,True),(13301,True),(13302,True),(13303,True),(13304,True),(13305,True),(13306,True),(13307,True),(13308,True),(13309,True),(13310,True),(13311,True),(13312,True),(13313,True),(13314,True),(13315,True),(13316,True),(13317,True),(13318,True),(13319,True),(13320,True),(13321,True),(13322,True),(13323,True),(13324,True),(13325,True),(13326,True),(13327,True),(13328,True),(13329,True),(13330,True),(13331,True),(13332,True),(13333,True),(13334,True),(13335,True),(13336,True),(13337,True),(13338,True),(13339,True),(13340,True),(13341,True),(13342,True),(13343,True),(13344,True),(13345,True),(13346,True),(13347,True),(13348,True),(13349,True),(13350,True),(13351,True),(13352,True),(13353,True),(13354,True),(13355,True),(13356,True),(13357,True),(13358,True),(13359,True),(13360,True),(13361,True),(13362,True),(13363,True),(13364,True),(13365,True),(13366,True),(13367,True),(13368,True),(13369,True),(13370,True),(13371,True),(13372,True),(13373,True),(13374,True),(13375,True),(13376,True),(13377,True),(13378,True),(13379,True),(13380,True),(13381,True),(13382,True),(13383,True),(13384,True),(13385,True),(13386,True),(13387,True),(13388,True),(13389,True),(13390,True),(13391,True),(13392,True),(13393,True),(13394,True),(13395,True),(13396,True),(13397,True),(13398,True),(13399,True),(13400,True),(13401,True),(13402,True),(13403,True),(13404,True),(13405,True),(13406,True),(13407,True),(13408,True),(13409,True),(13410,True),(13411,True),(13412,True),(13413,True),(13414,True),(13415,True),(13416,True),(13417,True),(13418,True),(13419,True),(13420,True),(13421,True),(13422,True),(13423,True),(13424,True),(13425,True),(13426,True),(13427,True),(13428,True),(13429,True),(13430,True),(13431,True),(13432,True),(13433,True),(13434,True),(13435,True),(13436,True),(13437,True),(13438,True),(13439,True),(13440,True),(13441,True),(13442,True),(13443,True),(13444,True),(13445,True),(13446,True),(13447,True),(13448,True),(13449,True),(13450,True),(13451,True),(13452,True),(13453,True),(13454,True),(13455,True),(13456,True),(13457,True),(13458,True),(13459,True),(13460,True),(13461,True),(13462,True),(13463,True),(13464,True),(13465,True),(13466,True),(13467,True),(13468,True),(13469,True),(13470,True),(13471,True),(13472,True),(13473,True),(13474,True),(13475,True),(13476,True),(13477,True),(13478,True),(13479,True),(13480,True),(13481,True),(13482,True),(13483,True),(13484,True),(13485,True),(13486,True),(13487,True),(13488,True),(13489,True),(13490,True),(13491,True),(13492,True),(13493,True),(13494,True),(13495,True),(13496,True),(13497,True),(13498,True),(13499,True),(13500,True),(13501,True),(13502,True),(13503,True),(13504,True),(13505,True),(13506,True),(13507,True),(13508,True),(13509,True),(13510,True),(13511,True),(13512,True),(13513,True),(13514,True),(13515,True),(13516,True),(13517,True),(13518,True),(13519,True),(13520,True),(13521,True),(13522,True),(13523,True),(13524,True),(13525,True),(13526,True),(13527,True),(13528,True),(13529,True),(13530,True),(13531,True),(13532,True),(13533,True),(13534,True),(13535,True),(13536,True),(13537,True),(13538,True),(13539,True),(13540,True),(13541,True),(13542,True),(13543,True),(13544,True),(13545,True),(13546,True),(13547,True),(13548,True),(13549,True),(13550,True),(13551,True),(13552,True),(13553,True),(13554,True),(13555,True),(13556,True),(13557,True),(13558,True),(13559,True),(13560,True),(13561,True),(13562,True),(13563,True),(13564,True),(13565,True),(13566,True),(13567,True),(13568,True),(13569,True),(13570,True),(13571,True),(13572,True),(13573,True),(13574,True),(13575,True),(13576,True),(13577,True),(13578,True),(13579,True),(13580,True),(13581,True),(13582,True),(13583,True),(13584,True),(13585,True),(13586,True),(13587,True),(13588,True),(13589,True),(13590,True),(13591,True),(13592,True),(13593,True),(13594,True),(13595,True),(13596,True),(13597,True),(13598,True),(13599,True),(13600,True),(13601,True),(13602,True),(13603,True),(13604,True),(13605,True),(13606,True),(13607,True),(13608,True),(13609,True),(13610,True),(13611,True),(13612,True),(13613,True),(13614,True),(13615,True),(13616,True),(13617,True),(13618,True),(13619,True),(13620,True),(13621,True),(13622,True),(13623,True),(13624,True),(13625,True),(13626,True),(13627,True),(13628,True),(13629,True),(13630,True),(13631,True),(13632,True),(13633,True),(13634,True),(13635,True),(13636,True),(13637,True),(13638,True),(13639,True),(13640,True),(13641,True),(13642,True),(13643,True),(13644,True),(13645,True),(13646,True),(13647,True),(13648,True),(13649,True),(13650,True),(13651,True),(13652,True),(13653,True),(13654,True),(13655,True),(13656,True),(13657,True),(13658,True),(13659,True),(13660,True),(13661,True),(13662,True),(13663,True),(13664,True),(13665,True),(13666,True),(13667,True),(13668,True),(13669,True),(13670,True),(13671,True),(13672,True),(13673,True),(13674,True),(13675,True),(13676,True),(13677,True),(13678,True),(13679,True),(13680,True),(13681,True),(13682,True),(13683,True),(13684,True),(13685,True),(13686,True),(13687,True),(13688,True),(13689,True),(13690,True),(13691,True),(13692,True),(13693,True),(13694,True),(13695,True),(13696,True),(13697,True),(13698,True),(13699,True),(13700,True),(13701,True),(13702,True),(13703,True),(13704,True),(13705,True),(13706,True),(13707,True),(13708,True),(13709,True),(13710,True),(13711,True),(13712,True),(13713,True),(13714,True),(13715,True),(13716,True),(13717,True),(13718,True),(13719,True),(13720,True),(13721,True),(13722,True),(13723,True),(13724,True),(13725,True),(13726,True),(13727,True),(13728,True),(13729,True),(13730,True),(13731,True),(13732,True),(13733,True),(13734,True),(13735,True),(13736,True),(13737,True),(13738,True),(13739,True),(13740,True),(13741,True),(13742,True),(13743,True),(13744,True),(13745,True),(13746,True),(13747,True),(13748,True),(13749,True),(13750,True),(13751,True),(13752,True),(13753,True),(13754,True),(13755,True),(13756,True),(13757,True),(13758,True),(13759,True),(13760,True),(13761,True),(13762,True),(13763,True),(13764,True),(13765,True),(13766,True),(13767,True),(13768,True),(13769,True),(13770,True),(13771,True),(13772,True),(13773,True),(13774,True),(13775,True),(13776,True),(13777,True),(13778,True),(13779,True),(13780,True),(13781,True),(13782,True),(13783,True),(13784,True),(13785,True),(13786,True),(13787,True),(13788,True),(13789,True),(13790,True),(13791,True),(13792,True),(13793,True),(13794,True),(13795,True),(13796,True),(13797,True),(13798,True),(13799,True),(13800,True),(13801,True),(13802,True),(13803,True),(13804,True),(13805,True),(13806,True),(13807,True),(13808,True),(13809,True),(13810,True),(13811,True),(13812,True),(13813,True),(13814,True),(13815,True),(13816,True),(13817,True),(13818,True),(13819,True),(13820,True),(13821,True),(13822,True),(13823,True),(13824,True),(13825,True),(13826,True),(13827,True),(13828,True),(13829,True),(13830,True),(13831,True),(13832,True),(13833,True),(13834,True),(13835,True),(13836,True),(13837,True),(13838,True),(13839,True),(13840,True),(13841,True),(13842,True),(13843,True),(13844,True),(13845,True),(13846,True),(13847,True),(13848,True),(13849,True),(13850,True),(13851,True),(13852,True),(13853,True),(13854,True),(13855,True),(13856,True),(13857,True),(13858,True),(13859,True),(13860,True),(13861,True),(13862,True),(13863,True),(13864,True),(13865,True),(13866,True),(13867,True),(13868,True),(13869,True),(13870,True),(13871,True),(13872,True),(13873,True),(13874,True),(13875,True),(13876,True),(13877,True),(13878,True),(13879,True),(13880,True),(13881,True),(13882,True),(13883,True),(13884,True),(13885,True),(13886,True),(13887,True),(13888,True),(13889,True),(13890,True),(13891,True),(13892,True),(13893,True),(13894,True),(13895,True),(13896,True),(13897,True),(13898,True),(13899,True),(13900,True),(13901,True),(13902,True),(13903,True),(13904,True),(13905,True),(13906,True),(13907,True),(13908,True),(13909,True),(13910,True),(13911,True),(13912,True),(13913,True),(13914,True),(13915,True),(13916,True),(13917,True),(13918,True),(13919,True),(13920,True),(13921,True),(13922,True),(13923,True),(13924,True),(13925,True),(13926,True),(13927,True),(13928,True),(13929,True),(13930,True),(13931,True),(13932,True),(13933,True),(13934,True),(13935,True),(13936,True),(13937,True),(13938,True),(13939,True),(13940,True),(13941,True),(13942,True),(13943,True),(13944,True),(13945,True),(13946,True),(13947,True),(13948,True),(13949,True),(13950,True),(13951,True),(13952,True),(13953,True),(13954,True),(13955,True),(13956,True),(13957,True),(13958,True),(13959,True),(13960,True),(13961,True),(13962,True),(13963,True),(13964,True),(13965,True),(13966,True),(13967,True),(13968,True),(13969,True),(13970,True),(13971,True),(13972,True),(13973,True),(13974,True),(13975,True),(13976,True),(13977,True),(13978,True),(13979,True),(13980,True),(13981,True),(13982,True),(13983,True),(13984,True),(13985,True),(13986,True),(13987,True),(13988,True),(13989,True),(13990,True),(13991,True),(13992,True),(13993,True),(13994,True),(13995,True),(13996,True),(13997,True),(13998,True),(13999,True),(14000,True),(14001,True),(14002,True),(14003,True),(14004,True),(14005,True),(14006,True),(14007,True),(14008,True),(14009,True),(14010,True),(14011,True),(14012,True),(14013,True),(14014,True),(14015,True),(14016,True),(14017,True),(14018,True),(14019,True),(14020,True),(14021,True),(14022,True),(14023,True),(14024,True),(14025,True),(14026,True),(14027,True),(14028,True),(14029,True),(14030,True),(14031,True),(14032,True),(14033,True),(14034,True),(14035,True),(14036,True),(14037,True),(14038,True),(14039,True),(14040,True),(14041,True),(14042,True),(14043,True),(14044,True),(14045,True),(14046,True),(14047,True),(14048,True),(14049,True),(14050,True),(14051,True),(14052,True),(14053,True),(14054,True),(14055,True),(14056,True),(14057,True),(14058,True),(14059,True),(14060,True),(14061,True),(14062,True),(14063,True),(14064,True),(14065,True),(14066,True),(14067,True),(14068,True),(14069,True),(14070,True),(14071,True),(14072,True),(14073,True),(14074,True),(14075,True),(14076,True),(14077,True),(14078,True),(14079,True),(14080,True),(14081,True),(14082,True),(14083,True),(14084,True),(14085,True),(14086,True),(14087,True),(14088,True),(14089,True),(14090,True),(14091,True),(14092,True),(14093,True),(14094,True),(14095,True),(14096,True),(14097,True),(14098,True),(14099,True),(14100,True),(14101,True),(14102,True),(14103,True),(14104,True),(14105,True),(14106,True),(14107,True),(14108,True),(14109,True),(14110,True),(14111,True),(14112,True),(14113,True),(14114,True),(14115,True),(14116,True),(14117,True),(14118,True),(14119,True),(14120,True),(14121,True),(14122,True),(14123,True),(14124,True),(14125,True),(14126,True),(14127,True),(14128,True),(14129,True),(14130,True),(14131,True),(14132,True),(14133,True),(14134,True),(14135,True),(14136,True),(14137,True),(14138,True),(14139,True),(14140,True),(14141,True),(14142,True),(14143,True),(14144,True),(14145,True),(14146,True),(14147,True),(14148,True),(14149,True),(14150,True),(14151,True),(14152,True),(14153,True),(14154,True),(14155,True),(14156,True),(14157,True),(14158,True),(14159,True),(14160,True),(14161,True),(14162,True),(14163,True),(14164,True),(14165,True),(14166,True),(14167,True),(14168,True),(14169,True),(14170,True),(14171,True),(14172,True),(14173,True),(14174,True),(14175,True),(14176,True),(14177,True),(14178,True),(14179,True),(14180,True),(14181,True),(14182,True),(14183,True),(14184,True),(14185,True),(14186,True),(14187,True),(14188,True),(14189,True),(14190,True),(14191,True),(14192,True),(14193,True),(14194,True),(14195,True),(14196,True),(14197,True),(14198,True),(14199,True),(14200,True),(14201,True),(14202,True),(14203,True),(14204,True),(14205,True),(14206,True),(14207,True),(14208,True),(14209,True),(14210,True),(14211,True),(14212,True),(14213,True),(14214,True),(14215,True),(14216,True),(14217,True),(14218,True),(14219,True),(14220,True),(14221,True),(14222,True),(14223,True),(14224,True),(14225,True),(14226,True),(14227,True),(14228,True),(14229,True),(14230,True),(14231,True),(14232,True),(14233,True),(14234,True),(14235,True),(14236,True),(14237,True),(14238,True),(14239,True),(14240,True),(14241,True),(14242,True),(14243,True),(14244,True),(14245,True),(14246,True),(14247,True),(14248,True),(14249,True),(14250,True),(14251,True),(14252,True),(14253,True),(14254,True),(14255,True),(14256,True),(14257,True),(14258,True),(14259,True),(14260,True),(14261,True),(14262,True),(14263,True),(14264,True),(14265,True),(14266,True),(14267,True),(14268,True),(14269,True),(14270,True),(14271,True),(14272,True),(14273,True),(14274,True),(14275,True),(14276,True),(14277,True),(14278,True),(14279,True),(14280,True),(14281,True),(14282,True),(14283,True),(14284,True),(14285,True),(14286,True),(14287,True),(14288,True),(14289,True),(14290,True),(14291,True),(14292,True),(14293,True),(14294,True),(14295,True),(14296,True),(14297,True),(14298,True),(14299,True),(14300,True),(14301,True),(14302,True),(14303,True),(14304,True),(14305,True),(14306,True),(14307,True),(14308,True),(14309,True),(14310,True),(14311,True),(14312,True),(14313,True),(14314,True),(14315,True),(14316,True),(14317,True),(14318,True),(14319,True),(14320,True),(14321,True),(14322,True),(14323,True),(14324,True),(14325,True),(14326,True),(14327,True),(14328,True),(14329,True),(14330,True),(14331,True),(14332,True),(14333,True),(14334,True),(14335,True),(14336,True),(14337,True),(14338,True),(14339,True),(14340,True),(14341,True),(14342,True),(14343,True),(14344,True),(14345,True),(14346,True),(14347,True),(14348,True),(14349,True),(14350,True),(14351,True),(14352,True),(14353,True),(14354,True),(14355,True),(14356,True),(14357,True),(14358,True),(14359,True),(14360,True),(14361,True),(14362,True),(14363,True),(14364,True),(14365,True),(14366,True),(14367,True),(14368,True),(14369,True),(14370,True),(14371,True),(14372,True),(14373,True),(14374,True),(14375,True),(14376,True),(14377,True),(14378,True),(14379,True),(14380,True),(14381,True),(14382,True),(14383,True),(14384,True),(14385,True),(14386,True),(14387,True),(14388,True),(14389,True),(14390,True),(14391,True),(14392,True),(14393,True),(14394,True),(14395,True),(14396,True),(14397,True),(14398,True),(14399,True),(14400,True),(14401,True),(14402,True),(14403,True),(14404,True),(14405,True),(14406,True),(14407,True),(14408,True),(14409,True),(14410,True),(14411,True),(14412,True),(14413,True),(14414,True),(14415,True),(14416,True),(14417,True),(14418,True),(14419,True),(14420,True),(14421,True),(14422,True),(14423,True),(14424,True),(14425,True),(14426,True),(14427,True),(14428,True),(14429,True),(14430,True),(14431,True),(14432,True),(14433,True),(14434,True),(14435,True),(14436,True),(14437,True),(14438,True),(14439,True),(14440,True),(14441,True),(14442,True),(14443,True),(14444,True),(14445,True),(14446,True),(14447,True),(14448,True),(14449,True),(14450,True),(14451,True),(14452,True),(14453,True),(14454,True),(14455,True),(14456,True),(14457,True),(14458,True),(14459,True),(14460,True),(14461,True),(14462,True),(14463,True),(14464,True),(14465,True),(14466,True),(14467,True),(14468,True),(14469,True),(14470,True),(14471,True),(14472,True),(14473,True),(14474,True),(14475,True),(14476,True),(14477,True),(14478,True),(14479,True),(14480,True),(14481,True),(14482,True),(14483,True),(14484,True),(14485,True),(14486,True),(14487,True),(14488,True),(14489,True),(14490,True),(14491,True),(14492,True),(14493,True),(14494,True),(14495,True),(14496,True),(14497,True),(14498,True),(14499,True),(14500,True),(14501,True),(14502,True),(14503,True),(14504,True),(14505,True),(14506,True),(14507,True),(14508,True),(14509,True),(14510,True),(14511,True),(14512,True),(14513,True),(14514,True),(14515,True),(14516,True),(14517,True),(14518,True),(14519,True),(14520,True),(14521,True),(14522,True),(14523,True),(14524,True),(14525,True),(14526,True),(14527,True),(14528,True),(14529,True),(14530,True),(14531,True),(14532,True),(14533,True),(14534,True),(14535,True),(14536,True),(14537,True),(14538,True),(14539,True),(14540,True),(14541,True),(14542,True),(14543,True),(14544,True),(14545,True),(14546,True),(14547,True),(14548,True),(14549,True),(14550,True),(14551,True),(14552,True),(14553,True),(14554,True),(14555,True),(14556,True),(14557,True),(14558,True),(14559,True),(14560,True),(14561,True),(14562,True),(14563,True),(14564,True),(14565,True),(14566,True),(14567,True),(14568,True),(14569,True),(14570,True),(14571,True),(14572,True),(14573,True),(14574,True),(14575,True),(14576,True),(14577,True),(14578,True),(14579,True),(14580,True),(14581,True),(14582,True),(14583,True),(14584,True),(14585,True),(14586,True),(14587,True),(14588,True),(14589,True),(14590,True),(14591,True),(14592,True),(14593,True),(14594,True),(14595,True),(14596,True),(14597,True),(14598,True),(14599,True),(14600,True),(14601,True),(14602,True),(14603,True),(14604,True),(14605,True),(14606,True),(14607,True),(14608,True),(14609,True),(14610,True),(14611,True),(14612,True),(14613,True),(14614,True),(14615,True),(14616,True),(14617,True),(14618,True),(14619,True),(14620,True),(14621,True),(14622,True),(14623,True),(14624,True),(14625,True),(14626,True),(14627,True),(14628,True),(14629,True),(14630,True),(14631,True),(14632,True),(14633,True),(14634,True),(14635,True),(14636,True),(14637,True),(14638,True),(14639,True),(14640,True),(14641,True),(14642,True),(14643,True),(14644,True),(14645,True),(14646,True),(14647,True),(14648,True),(14649,True),(14650,True),(14651,True),(14652,True),(14653,True),(14654,True),(14655,True),(14656,True),(14657,True),(14658,True),(14659,True),(14660,True),(14661,True),(14662,True),(14663,True),(14664,True),(14665,True),(14666,True),(14667,True),(14668,True),(14669,True),(14670,True),(14671,True),(14672,True),(14673,True),(14674,True),(14675,True),(14676,True),(14677,True),(14678,True),(14679,True),(14680,True),(14681,True),(14682,True),(14683,True),(14684,True),(14685,True),(14686,True),(14687,True),(14688,True),(14689,True),(14690,True),(14691,True),(14692,True),(14693,True),(14694,True),(14695,True),(14696,True),(14697,True),(14698,True),(14699,True),(14700,True),(14701,True),(14702,True),(14703,True),(14704,True),(14705,True),(14706,True),(14707,True),(14708,True),(14709,True),(14710,True),(14711,True),(14712,True),(14713,True),(14714,True),(14715,True),(14716,True),(14717,True),(14718,True),(14719,True),(14720,True),(14721,True),(14722,True),(14723,True),(14724,True),(14725,True),(14726,True),(14727,True),(14728,True),(14729,True),(14730,True),(14731,True),(14732,True),(14733,True),(14734,True),(14735,True),(14736,True),(14737,True),(14738,True),(14739,True),(14740,True),(14741,True),(14742,True),(14743,True),(14744,True),(14745,True),(14746,True),(14747,True),(14748,True),(14749,True),(14750,True),(14751,True),(14752,True),(14753,True),(14754,True),(14755,True),(14756,True),(14757,True),(14758,True),(14759,True),(14760,True),(14761,True),(14762,True),(14763,True),(14764,True),(14765,True),(14766,True),(14767,True),(14768,True),(14769,True),(14770,True),(14771,True),(14772,True),(14773,True),(14774,True),(14775,True),(14776,True),(14777,True),(14778,True),(14779,True),(14780,True),(14781,True),(14782,True),(14783,True),(14784,True),(14785,True),(14786,True),(14787,True),(14788,True),(14789,True),(14790,True),(14791,True),(14792,True),(14793,True),(14794,True),(14795,True),(14796,True),(14797,True),(14798,True),(14799,True),(14800,True),(14801,True),(14802,True),(14803,True),(14804,True),(14805,True),(14806,True),(14807,True),(14808,True),(14809,True),(14810,True),(14811,True),(14812,True),(14813,True),(14814,True),(14815,True),(14816,True),(14817,True),(14818,True),(14819,True),(14820,True),(14821,True),(14822,True),(14823,True),(14824,True),(14825,True),(14826,True),(14827,True),(14828,True),(14829,True),(14830,True),(14831,True),(14832,True),(14833,True),(14834,True),(14835,True),(14836,True),(14837,True),(14838,True),(14839,True),(14840,True),(14841,True),(14842,True),(14843,True),(14844,True),(14845,True),(14846,True),(14847,True),(14848,True),(14849,True),(14850,True),(14851,True),(14852,True),(14853,True),(14854,True),(14855,True),(14856,True),(14857,True),(14858,True),(14859,True),(14860,True),(14861,True),(14862,True),(14863,True),(14864,True),(14865,True),(14866,True),(14867,True),(14868,True),(14869,True),(14870,True),(14871,True),(14872,True),(14873,True),(14874,True),(14875,True),(14876,True),(14877,True),(14878,True),(14879,True),(14880,True),(14881,True),(14882,True),(14883,True),(14884,True),(14885,True),(14886,True),(14887,True),(14888,True),(14889,True),(14890,True),(14891,True),(14892,True),(14893,True),(14894,True),(14895,True),(14896,True),(14897,True),(14898,True),(14899,True),(14900,True),(14901,True),(14902,True),(14903,True),(14904,True),(14905,True),(14906,True),(14907,True),(14908,True),(14909,True),(14910,True),(14911,True),(14912,True),(14913,True),(14914,True),(14915,True),(14916,True),(14917,True),(14918,True),(14919,True),(14920,True),(14921,True),(14922,True),(14923,True),(14924,True),(14925,True),(14926,True),(14927,True),(14928,True),(14929,True),(14930,True),(14931,True),(14932,True),(14933,True),(14934,True),(14935,True),(14936,True),(14937,True),(14938,True),(14939,True),(14940,True),(14941,True),(14942,True),(14943,True),(14944,True),(14945,True),(14946,True),(14947,True),(14948,True),(14949,True),(14950,True),(14951,True),(14952,True),(14953,True),(14954,True),(14955,True),(14956,True),(14957,True),(14958,True),(14959,True),(14960,True),(14961,True),(14962,True),(14963,True),(14964,True),(14965,True),(14966,True),(14967,True),(14968,True),(14969,True),(14970,True),(14971,True),(14972,True),(14973,True),(14974,True),(14975,True),(14976,True),(14977,True),(14978,True),(14979,True),(14980,True),(14981,True),(14982,True),(14983,True),(14984,True),(14985,True),(14986,True),(14987,True),(14988,True),(14989,True),(14990,True),(14991,True),(14992,True),(14993,True),(14994,True),(14995,True),(14996,True),(14997,True),(14998,True),(14999,True),(15000,True),(15001,True),(15002,True),(15003,True),(15004,True),(15005,True),(15006,True),(15007,True),(15008,True),(15009,True),(15010,True),(15011,True),(15012,True),(15013,True),(15014,True),(15015,True),(15016,True),(15017,True),(15018,True),(15019,True),(15020,True),(15021,True),(15022,True),(15023,True),(15024,True),(15025,True),(15026,True),(15027,True),(15028,True),(15029,True),(15030,True),(15031,True),(15032,True),(15033,True),(15034,True),(15035,True),(15036,True),(15037,True),(15038,True),(15039,True),(15040,True),(15041,True),(15042,True),(15043,True),(15044,True),(15045,True),(15046,True),(15047,True),(15048,True),(15049,True),(15050,True),(15051,True),(15052,True),(15053,True),(15054,True),(15055,True),(15056,True),(15057,True),(15058,True),(15059,True),(15060,True),(15061,True),(15062,True),(15063,True),(15064,True),(15065,True),(15066,True),(15067,True),(15068,True),(15069,True),(15070,True),(15071,True),(15072,True),(15073,True),(15074,True),(15075,True),(15076,True),(15077,True),(15078,True),(15079,True),(15080,True),(15081,True),(15082,True),(15083,True),(15084,True),(15085,True),(15086,True),(15087,True),(15088,True),(15089,True),(15090,True),(15091,True),(15092,True),(15093,True),(15094,True),(15095,True),(15096,True),(15097,True),(15098,True),(15099,True),(15100,True),(15101,True),(15102,True),(15103,True),(15104,True),(15105,True),(15106,True),(15107,True),(15108,True),(15109,True),(15110,True),(15111,True),(15112,True),(15113,True),(15114,True),(15115,True),(15116,True),(15117,True),(15118,True),(15119,True),(15120,True),(15121,True),(15122,True),(15123,True),(15124,True),(15125,True),(15126,True),(15127,True),(15128,True),(15129,True),(15130,True),(15131,True),(15132,True),(15133,True),(15134,True),(15135,True),(15136,True),(15137,True),(15138,True),(15139,True),(15140,True),(15141,True),(15142,True),(15143,True),(15144,True),(15145,True),(15146,True),(15147,True),(15148,True),(15149,True),(15150,True),(15151,True),(15152,True),(15153,True),(15154,True),(15155,True),(15156,True),(15157,True),(15158,True),(15159,True),(15160,True),(15161,True),(15162,True),(15163,True),(15164,True),(15165,True),(15166,True),(15167,True),(15168,True),(15169,True),(15170,True),(15171,True),(15172,True),(15173,True),(15174,True),(15175,True),(15176,True),(15177,True),(15178,True),(15179,True),(15180,True),(15181,True),(15182,True),(15183,True),(15184,True),(15185,True),(15186,True),(15187,True),(15188,True),(15189,True),(15190,True),(15191,True),(15192,True),(15193,True),(15194,True),(15195,True),(15196,True),(15197,True),(15198,True),(15199,True),(15200,True),(15201,True),(15202,True),(15203,True),(15204,True),(15205,True),(15206,True),(15207,True),(15208,True),(15209,True),(15210,True),(15211,True),(15212,True),(15213,True),(15214,True),(15215,True),(15216,True),(15217,True),(15218,True),(15219,True),(15220,True),(15221,True),(15222,True),(15223,True),(15224,True),(15225,True),(15226,True),(15227,True),(15228,True),(15229,True),(15230,True),(15231,True),(15232,True),(15233,True),(15234,True),(15235,True),(15236,True),(15237,True),(15238,True),(15239,True),(15240,True),(15241,True),(15242,True),(15243,True),(15244,True),(15245,True),(15246,True),(15247,True),(15248,True),(15249,True),(15250,True),(15251,True),(15252,True),(15253,True),(15254,True),(15255,True),(15256,True),(15257,True),(15258,True),(15259,True),(15260,True),(15261,True),(15262,True),(15263,True),(15264,True),(15265,True),(15266,True),(15267,True),(15268,True),(15269,True),(15270,True),(15271,True),(15272,True),(15273,True),(15274,True),(15275,True),(15276,True),(15277,True),(15278,True),(15279,True),(15280,True),(15281,True),(15282,True),(15283,True),(15284,True),(15285,True),(15286,True),(15287,True),(15288,True),(15289,True),(15290,True),(15291,True),(15292,True),(15293,True),(15294,True),(15295,True),(15296,True),(15297,True),(15298,True),(15299,True),(15300,True),(15301,True),(15302,True),(15303,True),(15304,True),(15305,True),(15306,True),(15307,True),(15308,True),(15309,True),(15310,True),(15311,True),(15312,True),(15313,True),(15314,True),(15315,True),(15316,True),(15317,True),(15318,True),(15319,True),(15320,True),(15321,True),(15322,True),(15323,True),(15324,True),(15325,True),(15326,True),(15327,True),(15328,True),(15329,True),(15330,True),(15331,True),(15332,True),(15333,True),(15334,True),(15335,True),(15336,True),(15337,True),(15338,True),(15339,True),(15340,True),(15341,True),(15342,True),(15343,True),(15344,True),(15345,True),(15346,True),(15347,True),(15348,True),(15349,True),(15350,True),(15351,True),(15352,True),(15353,True),(15354,True),(15355,True),(15356,True),(15357,True),(15358,True),(15359,True),(15360,True),(15361,True),(15362,True),(15363,True),(15364,True),(15365,True),(15366,True),(15367,True),(15368,True),(15369,True),(15370,True),(15371,True),(15372,True),(15373,True),(15374,True),(15375,True),(15376,True),(15377,True),(15378,True),(15379,True),(15380,True),(15381,True),(15382,True),(15383,True),(15384,True),(15385,True),(15386,True),(15387,True),(15388,True),(15389,True),(15390,True),(15391,True),(15392,True),(15393,True),(15394,True),(15395,True),(15396,True),(15397,True),(15398,True),(15399,True),(15400,True),(15401,True),(15402,True),(15403,True),(15404,True),(15405,True),(15406,True),(15407,True),(15408,True),(15409,True),(15410,True),(15411,True),(15412,True),(15413,True),(15414,True),(15415,True),(15416,True),(15417,True),(15418,True),(15419,True),(15420,True),(15421,True),(15422,True),(15423,True),(15424,True),(15425,True),(15426,True),(15427,True),(15428,True),(15429,True),(15430,True),(15431,True),(15432,True),(15433,True),(15434,True),(15435,True),(15436,True),(15437,True),(15438,True),(15439,True),(15440,True),(15441,True),(15442,True),(15443,True),(15444,True),(15445,True),(15446,True),(15447,True),(15448,True),(15449,True),(15450,True),(15451,True),(15452,True),(15453,True),(15454,True),(15455,True),(15456,True),(15457,True),(15458,True),(15459,True),(15460,True),(15461,True),(15462,True),(15463,True),(15464,True),(15465,True),(15466,True),(15467,True),(15468,True),(15469,True),(15470,True),(15471,True),(15472,True),(15473,True),(15474,True),(15475,True),(15476,True),(15477,True),(15478,True),(15479,True),(15480,True),(15481,True),(15482,True),(15483,True),(15484,True),(15485,True),(15486,True),(15487,True),(15488,True),(15489,True),(15490,True),(15491,True),(15492,True),(15493,True),(15494,True),(15495,True),(15496,True),(15497,True),(15498,True),(15499,True),(15500,True),(15501,True),(15502,True),(15503,True),(15504,True),(15505,True),(15506,True),(15507,True),(15508,True),(15509,True),(15510,True),(15511,True),(15512,True),(15513,True),(15514,True),(15515,True),(15516,True),(15517,True),(15518,True),(15519,True),(15520,True),(15521,True),(15522,True),(15523,True),(15524,True),(15525,True),(15526,True),(15527,True),(15528,True),(15529,True),(15530,True),(15531,True),(15532,True),(15533,True),(15534,True),(15535,True),(15536,True),(15537,True),(15538,True),(15539,True),(15540,True),(15541,True),(15542,True),(15543,True),(15544,True),(15545,True),(15546,True),(15547,True),(15548,True),(15549,True),(15550,True),(15551,True),(15552,True),(15553,True),(15554,True),(15555,True),(15556,True),(15557,True),(15558,True),(15559,True),(15560,True),(15561,True),(15562,True),(15563,True),(15564,True),(15565,True),(15566,True),(15567,True),(15568,True),(15569,True),(15570,True),(15571,True),(15572,True),(15573,True),(15574,True),(15575,True),(15576,True),(15577,True),(15578,True),(15579,True),(15580,True),(15581,True),(15582,True),(15583,True),(15584,True),(15585,True),(15586,True),(15587,True),(15588,True),(15589,True),(15590,True),(15591,True),(15592,True),(15593,True),(15594,True),(15595,True),(15596,True),(15597,True),(15598,True),(15599,True),(15600,True),(15601,True),(15602,True),(15603,True),(15604,True),(15605,True),(15606,True),(15607,True),(15608,True),(15609,True),(15610,True),(15611,True),(15612,True),(15613,True),(15614,True),(15615,True),(15616,True),(15617,True),(15618,True),(15619,True),(15620,True),(15621,True),(15622,True),(15623,True),(15624,True),(15625,True),(15626,True),(15627,True),(15628,True),(15629,True),(15630,True),(15631,True),(15632,True),(15633,True),(15634,True),(15635,True),(15636,True),(15637,True),(15638,True),(15639,True),(15640,True),(15641,True),(15642,True),(15643,True),(15644,True),(15645,True),(15646,True),(15647,True),(15648,True),(15649,True),(15650,True),(15651,True),(15652,True),(15653,True),(15654,True),(15655,True),(15656,True),(15657,True),(15658,True),(15659,True),(15660,True),(15661,True),(15662,True),(15663,True),(15664,True),(15665,True),(15666,True),(15667,True),(15668,True),(15669,True),(15670,True),(15671,True),(15672,True),(15673,True),(15674,True),(15675,True),(15676,True),(15677,True),(15678,True),(15679,True),(15680,True),(15681,True),(15682,True),(15683,True),(15684,True),(15685,True),(15686,True),(15687,True),(15688,True),(15689,True),(15690,True),(15691,True),(15692,True),(15693,True),(15694,True),(15695,True),(15696,True),(15697,True),(15698,True),(15699,True),(15700,True),(15701,True),(15702,True),(15703,True),(15704,True),(15705,True),(15706,True),(15707,True),(15708,True),(15709,True),(15710,True),(15711,True),(15712,True),(15713,True),(15714,True),(15715,True),(15716,True),(15717,True),(15718,True),(15719,True),(15720,True),(15721,True),(15722,True),(15723,True),(15724,True),(15725,True),(15726,True),(15727,True),(15728,True),(15729,True),(15730,True),(15731,True),(15732,True),(15733,True),(15734,True),(15735,True),(15736,True),(15737,True),(15738,True),(15739,True),(15740,True),(15741,True),(15742,True),(15743,True),(15744,True),(15745,True),(15746,True),(15747,True),(15748,True),(15749,True),(15750,True),(15751,True),(15752,True),(15753,True),(15754,True),(15755,True),(15756,True),(15757,True),(15758,True),(15759,True),(15760,True),(15761,True),(15762,True),(15763,True),(15764,True),(15765,True),(15766,True),(15767,True),(15768,True),(15769,True),(15770,True),(15771,True),(15772,True),(15773,True),(15774,True),(15775,True),(15776,True),(15777,True),(15778,True),(15779,True),(15780,True),(15781,True),(15782,True),(15783,True),(15784,True),(15785,True),(15786,True),(15787,True),(15788,True),(15789,True),(15790,True),(15791,True),(15792,True),(15793,True),(15794,True),(15795,True),(15796,True),(15797,True),(15798,True),(15799,True),(15800,True),(15801,True),(15802,True),(15803,True),(15804,True),(15805,True),(15806,True),(15807,True),(15808,True),(15809,True),(15810,True),(15811,True),(15812,True),(15813,True),(15814,True),(15815,True),(15816,True),(15817,True),(15818,True),(15819,True),(15820,True),(15821,True),(15822,True),(15823,True),(15824,True),(15825,True),(15826,True),(15827,True),(15828,True),(15829,True),(15830,True),(15831,True),(15832,True),(15833,True),(15834,True),(15835,True),(15836,True),(15837,True),(15838,True),(15839,True),(15840,True),(15841,True),(15842,True),(15843,True),(15844,True),(15845,True),(15846,True),(15847,True),(15848,True),(15849,True),(15850,True),(15851,True),(15852,True),(15853,True),(15854,True),(15855,True),(15856,True),(15857,True),(15858,True),(15859,True),(15860,True),(15861,True),(15862,True),(15863,True),(15864,True),(15865,True),(15866,True),(15867,True),(15868,True),(15869,True),(15870,True),(15871,True),(15872,True),(15873,True),(15874,True),(15875,True),(15876,True),(15877,True),(15878,True),(15879,True),(15880,True),(15881,True),(15882,True),(15883,True),(15884,True),(15885,True),(15886,True),(15887,True),(15888,True),(15889,True),(15890,True),(15891,True),(15892,True),(15893,True),(15894,True),(15895,True),(15896,True),(15897,True),(15898,True),(15899,True),(15900,True),(15901,True),(15902,True),(15903,True),(15904,True),(15905,True),(15906,True),(15907,True),(15908,True),(15909,True),(15910,True),(15911,True),(15912,True),(15913,True),(15914,True),(15915,True),(15916,True),(15917,True),(15918,True),(15919,True),(15920,True),(15921,True),(15922,True),(15923,True),(15924,True),(15925,True),(15926,True),(15927,True),(15928,True),(15929,True),(15930,True),(15931,True),(15932,True),(15933,True),(15934,True),(15935,True),(15936,True),(15937,True),(15938,True),(15939,True),(15940,True),(15941,True),(15942,True),(15943,True),(15944,True),(15945,True),(15946,True),(15947,True),(15948,True),(15949,True),(15950,True),(15951,True),(15952,True),(15953,True),(15954,True),(15955,True),(15956,True),(15957,True),(15958,True),(15959,True),(15960,True),(15961,True),(15962,True),(15963,True),(15964,True),(15965,True),(15966,True),(15967,True),(15968,True),(15969,True),(15970,True),(15971,True),(15972,True),(15973,True),(15974,True),(15975,True),(15976,True),(15977,True),(15978,True),(15979,True),(15980,True),(15981,True),(15982,True),(15983,True),(15984,True),(15985,True),(15986,True),(15987,True),(15988,True),(15989,True),(15990,True),(15991,True),(15992,True),(15993,True),(15994,True),(15995,True),(15996,True),(15997,True),(15998,True),(15999,True),(16000,True),(16001,True),(16002,True),(16003,True),(16004,True),(16005,True),(16006,True),(16007,True),(16008,True),(16009,True),(16010,True),(16011,True),(16012,True),(16013,True),(16014,True),(16015,True),(16016,True),(16017,True),(16018,True),(16019,True),(16020,True),(16021,True),(16022,True),(16023,True),(16024,True),(16025,True),(16026,True),(16027,True),(16028,True),(16029,True),(16030,True),(16031,True),(16032,True),(16033,True),(16034,True),(16035,True),(16036,True),(16037,True),(16038,True),(16039,True),(16040,True),(16041,True),(16042,True),(16043,True),(16044,True),(16045,True),(16046,True),(16047,True),(16048,True),(16049,True),(16050,True),(16051,True),(16052,True),(16053,True),(16054,True),(16055,True),(16056,True),(16057,True),(16058,True),(16059,True),(16060,True),(16061,True),(16062,True),(16063,True),(16064,True),(16065,True),(16066,True),(16067,True),(16068,True),(16069,True),(16070,True),(16071,True),(16072,True),(16073,True),(16074,True),(16075,True),(16076,True),(16077,True),(16078,True),(16079,True),(16080,True),(16081,True),(16082,True),(16083,True),(16084,True),(16085,True),(16086,True),(16087,True),(16088,True),(16089,True),(16090,True),(16091,True),(16092,True),(16093,True),(16094,True),(16095,True),(16096,True),(16097,True),(16098,True),(16099,True),(16100,True),(16101,True),(16102,True),(16103,True),(16104,True),(16105,True),(16106,True),(16107,True),(16108,True),(16109,True),(16110,True),(16111,True),(16112,True),(16113,True),(16114,True),(16115,True),(16116,True),(16117,True),(16118,True),(16119,True),(16120,True),(16121,True),(16122,True),(16123,True),(16124,True),(16125,True),(16126,True),(16127,True),(16128,True),(16129,True),(16130,True),(16131,True),(16132,True),(16133,True),(16134,True),(16135,True),(16136,True),(16137,True),(16138,True),(16139,True),(16140,True),(16141,True),(16142,True),(16143,True),(16144,True),(16145,True),(16146,True),(16147,True),(16148,True),(16149,True),(16150,True),(16151,True),(16152,True),(16153,True),(16154,True),(16155,True),(16156,True),(16157,True),(16158,True),(16159,True),(16160,True),(16161,True),(16162,True),(16163,True),(16164,True),(16165,True),(16166,True),(16167,True),(16168,True),(16169,True),(16170,True),(16171,True),(16172,True),(16173,True),(16174,True),(16175,True),(16176,True),(16177,True),(16178,True),(16179,True),(16180,True),(16181,True),(16182,True),(16183,True),(16184,True),(16185,True),(16186,True),(16187,True),(16188,True),(16189,True),(16190,True),(16191,True),(16192,True),(16193,True),(16194,True),(16195,True),(16196,True),(16197,True),(16198,True),(16199,True),(16200,True),(16201,True),(16202,True),(16203,True),(16204,True),(16205,True),(16206,True),(16207,True),(16208,True),(16209,True),(16210,True),(16211,True),(16212,True),(16213,True),(16214,True),(16215,True),(16216,True),(16217,True),(16218,True),(16219,True),(16220,True),(16221,True),(16222,True),(16223,True),(16224,True),(16225,True),(16226,True),(16227,True),(16228,True),(16229,True),(16230,True),(16231,True),(16232,True),(16233,True),(16234,True),(16235,True),(16236,True),(16237,True),(16238,True),(16239,True),(16240,True),(16241,True),(16242,True),(16243,True),(16244,True),(16245,True),(16246,True),(16247,True),(16248,True),(16249,True),(16250,True),(16251,True),(16252,True),(16253,True),(16254,True),(16255,True),(16256,True),(16257,True),(16258,True),(16259,True),(16260,True),(16261,True),(16262,True),(16263,True),(16264,True),(16265,True),(16266,True),(16267,True),(16268,True),(16269,True),(16270,True),(16271,True),(16272,True),(16273,True),(16274,True),(16275,True),(16276,True),(16277,True),(16278,True),(16279,True),(16280,True),(16281,True),(16282,True),(16283,True),(16284,True),(16285,True),(16286,True),(16287,True),(16288,True),(16289,True),(16290,True),(16291,True),(16292,True),(16293,True),(16294,True),(16295,True),(16296,True),(16297,True),(16298,True),(16299,True),(16300,True),(16301,True),(16302,True),(16303,True),(16304,True),(16305,True),(16306,True),(16307,True),(16308,True),(16309,True),(16310,True),(16311,True),(16312,True),(16313,True),(16314,True),(16315,True),(16316,True),(16317,True),(16318,True),(16319,True),(16320,True),(16321,True),(16322,True),(16323,True),(16324,True),(16325,True),(16326,True),(16327,True),(16328,True),(16329,True),(16330,True),(16331,True),(16332,True),(16333,True),(16334,True),(16335,True),(16336,True),(16337,True),(16338,True),(16339,True),(16340,True),(16341,True),(16342,True),(16343,True),(16344,True),(16345,True),(16346,True),(16347,True),(16348,True),(16349,True),(16350,True),(16351,True),(16352,True),(16353,True),(16354,True),(16355,True),(16356,True),(16357,True),(16358,True),(16359,True),(16360,True),(16361,True),(16362,True),(16363,True),(16364,True),(16365,True),(16366,True),(16367,True),(16368,True),(16369,True),(16370,True),(16371,True),(16372,True),(16373,True),(16374,True),(16375,True),(16376,True),(16377,True),(16378,True),(16379,True),(16380,True),(16381,True),(16382,True),(16383,True),(16384,True),(16385,True),(16386,True),(16387,True),(16388,True),(16389,True),(16390,True),(16391,True),(16392,True),(16393,True),(16394,True),(16395,True),(16396,True),(16397,True),(16398,True),(16399,True),(16400,True),(16401,True),(16402,True),(16403,True),(16404,True),(16405,True),(16406,True),(16407,True),(16408,True),(16409,True),(16410,True),(16411,True),(16412,True),(16413,True),(16414,True),(16415,True),(16416,True),(16417,True),(16418,True),(16419,True),(16420,True),(16421,True),(16422,True),(16423,True),(16424,True),(16425,True),(16426,True),(16427,True),(16428,True),(16429,True),(16430,True),(16431,True),(16432,True),(16433,True),(16434,True),(16435,True),(16436,True),(16437,True),(16438,True),(16439,True),(16440,True),(16441,True),(16442,True),(16443,True),(16444,True),(16445,True),(16446,True),(16447,True),(16448,True),(16449,True),(16450,True),(16451,True),(16452,True),(16453,True),(16454,True),(16455,True),(16456,True),(16457,True),(16458,True),(16459,True),(16460,True),(16461,True),(16462,True),(16463,True),(16464,True),(16465,True),(16466,True),(16467,True),(16468,True),(16469,True),(16470,True),(16471,True),(16472,True),(16473,True),(16474,True),(16475,True),(16476,True),(16477,True),(16478,True),(16479,True),(16480,True),(16481,True),(16482,True),(16483,True),(16484,True),(16485,True),(16486,True),(16487,True),(16488,True),(16489,True),(16490,True),(16491,True),(16492,True),(16493,True),(16494,True),(16495,True),(16496,True),(16497,True),(16498,True),(16499,True),(16500,True),(16501,True),(16502,True),(16503,True),(16504,True),(16505,True),(16506,True),(16507,True),(16508,True),(16509,True),(16510,True),(16511,True),(16512,True),(16513,True),(16514,True),(16515,True),(16516,True),(16517,True),(16518,True),(16519,True),(16520,True),(16521,True),(16522,True),(16523,True),(16524,True),(16525,True),(16526,True),(16527,True),(16528,True),(16529,True),(16530,True),(16531,True),(16532,True),(16533,True),(16534,True),(16535,True),(16536,True),(16537,True),(16538,True),(16539,True),(16540,True),(16541,True),(16542,True),(16543,True),(16544,True),(16545,True),(16546,True),(16547,True),(16548,True),(16549,True),(16550,True),(16551,True),(16552,True),(16553,True),(16554,True),(16555,True),(16556,True),(16557,True),(16558,True),(16559,True),(16560,True),(16561,True),(16562,True),(16563,True),(16564,True),(16565,True),(16566,True),(16567,True),(16568,True),(16569,True),(16570,True),(16571,True),(16572,True),(16573,True),(16574,True),(16575,True),(16576,True),(16577,True),(16578,True),(16579,True),(16580,True),(16581,True),(16582,True),(16583,True),(16584,True),(16585,True),(16586,True),(16587,True),(16588,True),(16589,True),(16590,True),(16591,True),(16592,True),(16593,True),(16594,True),(16595,True),(16596,True),(16597,True),(16598,True),(16599,True),(16600,True),(16601,True),(16602,True),(16603,True),(16604,True),(16605,True),(16606,True),(16607,True),(16608,True),(16609,True),(16610,True),(16611,True),(16612,True),(16613,True),(16614,True),(16615,True),(16616,True),(16617,True),(16618,True),(16619,True),(16620,True),(16621,True),(16622,True),(16623,True),(16624,True),(16625,True),(16626,True),(16627,True),(16628,True),(16629,True),(16630,True),(16631,True),(16632,True),(16633,True),(16634,True),(16635,True),(16636,True),(16637,True),(16638,True),(16639,True),(16640,True),(16641,True),(16642,True),(16643,True),(16644,True),(16645,True),(16646,True),(16647,True),(16648,True),(16649,True),(16650,True),(16651,True),(16652,True),(16653,True),(16654,True),(16655,True),(16656,True),(16657,True),(16658,True),(16659,True),(16660,True),(16661,True),(16662,True),(16663,True),(16664,True),(16665,True),(16666,True),(16667,True),(16668,True),(16669,True),(16670,True),(16671,True),(16672,True),(16673,True),(16674,True),(16675,True),(16676,True),(16677,True),(16678,True),(16679,True),(16680,True),(16681,True),(16682,True),(16683,True),(16684,True),(16685,True),(16686,True),(16687,True),(16688,True),(16689,True),(16690,True),(16691,True),(16692,True),(16693,True),(16694,True),(16695,True),(16696,True),(16697,True),(16698,True),(16699,True),(16700,True),(16701,True),(16702,True),(16703,True),(16704,True),(16705,True),(16706,True),(16707,True),(16708,True),(16709,True),(16710,True),(16711,True),(16712,True),(16713,True),(16714,True),(16715,True),(16716,True),(16717,True),(16718,True),(16719,True),(16720,True),(16721,True),(16722,True),(16723,True),(16724,True),(16725,True),(16726,True),(16727,True),(16728,True),(16729,True),(16730,True),(16731,True),(16732,True),(16733,True),(16734,True),(16735,True),(16736,True),(16737,True),(16738,True),(16739,True),(16740,True),(16741,True),(16742,True),(16743,True),(16744,True),(16745,True),(16746,True),(16747,True),(16748,True),(16749,True),(16750,True),(16751,True),(16752,True),(16753,True),(16754,True),(16755,True),(16756,True),(16757,True),(16758,True),(16759,True),(16760,True),(16761,True),(16762,True),(16763,True),(16764,True),(16765,True),(16766,True),(16767,True),(16768,True),(16769,True),(16770,True),(16771,True),(16772,True),(16773,True),(16774,True),(16775,True),(16776,True),(16777,True),(16778,True),(16779,True),(16780,True),(16781,True),(16782,True),(16783,True),(16784,True),(16785,True),(16786,True),(16787,True),(16788,True),(16789,True),(16790,True),(16791,True),(16792,True),(16793,True),(16794,True),(16795,True),(16796,True),(16797,True),(16798,True),(16799,True),(16800,True),(16801,True),(16802,True),(16803,True),(16804,True),(16805,True),(16806,True),(16807,True),(16808,True),(16809,True),(16810,True),(16811,True),(16812,True),(16813,True),(16814,True),(16815,True),(16816,True),(16817,True),(16818,True),(16819,True),(16820,True),(16821,True),(16822,True),(16823,True),(16824,True),(16825,True),(16826,True),(16827,True),(16828,True),(16829,True),(16830,True),(16831,True),(16832,True),(16833,True),(16834,True),(16835,True),(16836,True),(16837,True),(16838,True),(16839,True),(16840,True),(16841,True),(16842,True),(16843,True),(16844,True),(16845,True),(16846,True),(16847,True),(16848,True),(16849,True),(16850,True),(16851,True),(16852,True),(16853,True),(16854,True),(16855,True),(16856,True),(16857,True),(16858,True),(16859,True),(16860,True),(16861,True),(16862,True),(16863,True),(16864,True),(16865,True),(16866,True),(16867,True),(16868,True),(16869,True),(16870,True),(16871,True),(16872,True),(16873,True),(16874,True),(16875,True),(16876,True),(16877,True),(16878,True),(16879,True),(16880,True),(16881,True),(16882,True),(16883,True),(16884,True),(16885,True),(16886,True),(16887,True),(16888,True),(16889,True),(16890,True),(16891,True),(16892,True),(16893,True),(16894,True),(16895,True),(16896,True),(16897,True),(16898,True),(16899,True),(16900,True),(16901,True),(16902,True),(16903,True),(16904,True),(16905,True),(16906,True),(16907,True),(16908,True),(16909,True),(16910,True),(16911,True),(16912,True),(16913,True),(16914,True),(16915,True),(16916,True),(16917,True),(16918,True),(16919,True),(16920,True),(16921,True),(16922,True),(16923,True),(16924,True),(16925,True),(16926,True),(16927,True),(16928,True),(16929,True),(16930,True),(16931,True),(16932,True),(16933,True),(16934,True),(16935,True),(16936,True),(16937,True),(16938,True),(16939,True),(16940,True),(16941,True),(16942,True),(16943,True),(16944,True),(16945,True),(16946,True),(16947,True),(16948,True),(16949,True),(16950,True),(16951,True),(16952,True),(16953,True),(16954,True),(16955,True),(16956,True),(16957,True),(16958,True),(16959,True),(16960,True),(16961,True),(16962,True),(16963,True),(16964,True),(16965,True),(16966,True),(16967,True),(16968,True),(16969,True),(16970,True),(16971,True),(16972,True),(16973,True),(16974,True),(16975,True),(16976,True),(16977,True),(16978,True),(16979,True),(16980,True),(16981,True),(16982,True),(16983,True),(16984,True),(16985,True),(16986,True),(16987,True),(16988,True),(16989,True),(16990,True),(16991,True),(16992,True),(16993,True),(16994,True),(16995,True),(16996,True),(16997,True),(16998,True),(16999,True),(17000,True),(17001,True),(17002,True),(17003,True),(17004,True),(17005,True),(17006,True),(17007,True),(17008,True),(17009,True),(17010,True),(17011,True),(17012,True),(17013,True),(17014,True),(17015,True),(17016,True),(17017,True),(17018,True),(17019,True),(17020,True),(17021,True),(17022,True),(17023,True),(17024,True),(17025,True),(17026,True),(17027,True),(17028,True),(17029,True),(17030,True),(17031,True),(17032,True),(17033,True),(17034,True),(17035,True),(17036,True),(17037,True),(17038,True),(17039,True),(17040,True),(17041,True),(17042,True),(17043,True),(17044,True),(17045,True),(17046,True),(17047,True),(17048,True),(17049,True),(17050,True),(17051,True),(17052,True),(17053,True),(17054,True),(17055,True),(17056,True),(17057,True),(17058,True),(17059,True),(17060,True),(17061,True),(17062,True),(17063,True),(17064,True),(17065,True),(17066,True),(17067,True),(17068,True),(17069,True),(17070,True),(17071,True),(17072,True),(17073,True),(17074,True),(17075,True),(17076,True),(17077,True),(17078,True),(17079,True),(17080,True),(17081,True),(17082,True),(17083,True),(17084,True),(17085,True),(17086,True),(17087,True),(17088,True),(17089,True),(17090,True),(17091,True),(17092,True),(17093,True),(17094,True),(17095,True),(17096,True),(17097,True),(17098,True),(17099,True),(17100,True),(17101,True),(17102,True),(17103,True),(17104,True),(17105,True),(17106,True),(17107,True),(17108,True),(17109,True),(17110,True),(17111,True),(17112,True),(17113,True),(17114,True),(17115,True),(17116,True),(17117,True),(17118,True),(17119,True),(17120,True),(17121,True),(17122,True),(17123,True),(17124,True),(17125,True),(17126,True),(17127,True),(17128,True),(17129,True),(17130,True),(17131,True),(17132,True),(17133,True),(17134,True),(17135,True),(17136,True),(17137,True),(17138,True),(17139,True),(17140,True),(17141,True),(17142,True),(17143,True),(17144,True),(17145,True),(17146,True),(17147,True),(17148,True),(17149,True),(17150,True),(17151,True),(17152,True),(17153,True),(17154,True),(17155,True),(17156,True),(17157,True),(17158,True),(17159,True),(17160,True),(17161,True),(17162,True),(17163,True),(17164,True),(17165,True),(17166,True),(17167,True),(17168,True),(17169,True),(17170,True),(17171,True),(17172,True),(17173,True),(17174,True),(17175,True),(17176,True),(17177,True),(17178,True),(17179,True),(17180,True),(17181,True),(17182,True),(17183,True),(17184,True),(17185,True),(17186,True),(17187,True),(17188,True),(17189,True),(17190,True),(17191,True),(17192,True),(17193,True),(17194,True),(17195,True),(17196,True),(17197,True),(17198,True),(17199,True),(17200,True),(17201,True),(17202,True),(17203,True),(17204,True),(17205,True),(17206,True),(17207,True),(17208,True),(17209,True),(17210,True),(17211,True),(17212,True),(17213,True),(17214,True),(17215,True),(17216,True),(17217,True),(17218,True),(17219,True),(17220,True),(17221,True),(17222,True),(17223,True),(17224,True),(17225,True),(17226,True),(17227,True),(17228,True),(17229,True),(17230,True),(17231,True),(17232,True),(17233,True),(17234,True),(17235,True),(17236,True),(17237,True),(17238,True),(17239,True),(17240,True),(17241,True),(17242,True),(17243,True),(17244,True),(17245,True),(17246,True),(17247,True),(17248,True),(17249,True),(17250,True),(17251,True),(17252,True),(17253,True),(17254,True),(17255,True),(17256,True),(17257,True),(17258,True),(17259,True),(17260,True),(17261,True),(17262,True),(17263,True),(17264,True),(17265,True),(17266,True),(17267,True),(17268,True),(17269,True),(17270,True),(17271,True),(17272,True),(17273,True),(17274,True),(17275,True),(17276,True),(17277,True),(17278,True),(17279,True),(17280,True),(17281,True),(17282,True),(17283,True),(17284,True),(17285,True),(17286,True),(17287,True),(17288,True),(17289,True),(17290,True),(17291,True),(17292,True),(17293,True),(17294,True),(17295,True),(17296,True),(17297,True),(17298,True),(17299,True),(17300,True),(17301,True),(17302,True),(17303,True),(17304,True),(17305,True),(17306,True),(17307,True),(17308,True),(17309,True),(17310,True),(17311,True),(17312,True),(17313,True),(17314,True),(17315,True),(17316,True),(17317,True),(17318,True),(17319,True),(17320,True),(17321,True),(17322,True),(17323,True),(17324,True),(17325,True),(17326,True),(17327,True),(17328,True),(17329,True),(17330,True),(17331,True),(17332,True),(17333,True),(17334,True),(17335,True),(17336,True),(17337,True),(17338,True),(17339,True),(17340,True),(17341,True),(17342,True),(17343,True),(17344,True),(17345,True),(17346,True),(17347,True),(17348,True),(17349,True),(17350,True),(17351,True),(17352,True),(17353,True),(17354,True),(17355,True),(17356,True),(17357,True),(17358,True),(17359,True),(17360,True),(17361,True),(17362,True),(17363,True),(17364,True),(17365,True),(17366,True),(17367,True),(17368,True),(17369,True),(17370,True),(17371,True),(17372,True),(17373,True),(17374,True),(17375,True),(17376,True),(17377,True),(17378,True),(17379,True),(17380,True),(17381,True),(17382,True),(17383,True),(17384,True),(17385,True),(17386,True),(17387,True),(17388,True),(17389,True),(17390,True),(17391,True),(17392,True),(17393,True),(17394,True),(17395,True),(17396,True),(17397,True),(17398,True),(17399,True),(17400,True),(17401,True),(17402,True),(17403,True),(17404,True),(17405,True),(17406,True),(17407,True),(17408,True),(17409,True),(17410,True),(17411,True),(17412,True),(17413,True),(17414,True),(17415,True),(17416,True),(17417,True),(17418,True),(17419,True),(17420,True),(17421,True),(17422,True),(17423,True),(17424,True),(17425,True),(17426,True),(17427,True),(17428,True),(17429,True),(17430,True),(17431,True),(17432,True),(17433,True),(17434,True),(17435,True),(17436,True),(17437,True),(17438,True),(17439,True),(17440,True),(17441,True),(17442,True),(17443,True),(17444,True),(17445,True),(17446,True),(17447,True),(17448,True),(17449,True),(17450,True),(17451,True),(17452,True),(17453,True),(17454,True),(17455,True),(17456,True),(17457,True),(17458,True),(17459,True),(17460,True),(17461,True),(17462,True),(17463,True),(17464,True),(17465,True),(17466,True),(17467,True),(17468,True),(17469,True),(17470,True),(17471,True),(17472,True),(17473,True),(17474,True),(17475,True),(17476,True),(17477,True),(17478,True),(17479,True),(17480,True),(17481,True),(17482,True),(17483,True),(17484,True),(17485,True),(17486,True),(17487,True),(17488,True),(17489,True),(17490,True),(17491,True),(17492,True),(17493,True),(17494,True),(17495,True),(17496,True),(17497,True),(17498,True),(17499,True),(17500,True),(17501,True),(17502,True),(17503,True),(17504,True),(17505,True),(17506,True),(17507,True),(17508,True),(17509,True),(17510,True),(17511,True),(17512,True),(17513,True),(17514,True),(17515,True),(17516,True),(17517,True),(17518,True),(17519,True),(17520,True),(17521,True),(17522,True),(17523,True),(17524,True),(17525,True),(17526,True),(17527,True),(17528,True),(17529,True),(17530,True),(17531,True),(17532,True),(17533,True),(17534,True),(17535,True),(17536,True),(17537,True),(17538,True),(17539,True),(17540,True),(17541,True),(17542,True),(17543,True),(17544,True),(17545,True),(17546,True),(17547,True),(17548,True),(17549,True),(17550,True),(17551,True),(17552,True),(17553,True),(17554,True),(17555,True),(17556,True),(17557,True),(17558,True),(17559,True),(17560,True),(17561,True),(17562,True),(17563,True),(17564,True),(17565,True),(17566,True),(17567,True),(17568,True),(17569,True),(17570,True),(17571,True),(17572,True),(17573,True),(17574,True),(17575,True),(17576,True),(17577,True),(17578,True),(17579,True),(17580,True),(17581,True),(17582,True),(17583,True),(17584,True),(17585,True),(17586,True),(17587,True),(17588,True),(17589,True),(17590,True),(17591,True),(17592,True),(17593,True),(17594,True),(17595,True),(17596,True),(17597,True),(17598,True),(17599,True),(17600,True),(17601,True),(17602,True),(17603,True),(17604,True),(17605,True),(17606,True),(17607,True),(17608,True),(17609,True),(17610,True),(17611,True),(17612,True),(17613,True),(17614,True),(17615,True),(17616,True),(17617,True),(17618,True),(17619,True),(17620,True),(17621,True),(17622,True),(17623,True),(17624,True),(17625,True),(17626,True),(17627,True),(17628,True),(17629,True),(17630,True),(17631,True),(17632,True),(17633,True),(17634,True),(17635,True),(17636,True),(17637,True),(17638,True),(17639,True),(17640,True),(17641,True),(17642,True),(17643,True),(17644,True),(17645,True),(17646,True),(17647,True),(17648,True),(17649,True),(17650,True),(17651,True),(17652,True),(17653,True),(17654,True),(17655,True),(17656,True),(17657,True),(17658,True),(17659,True),(17660,True),(17661,True),(17662,True),(17663,True),(17664,True),(17665,True),(17666,True),(17667,True),(17668,True),(17669,True),(17670,True),(17671,True),(17672,True),(17673,True),(17674,True),(17675,True),(17676,True),(17677,True),(17678,True),(17679,True),(17680,True),(17681,True),(17682,True),(17683,True),(17684,True),(17685,True),(17686,True),(17687,True),(17688,True),(17689,True),(17690,True),(17691,True),(17692,True),(17693,True),(17694,True),(17695,True),(17696,True),(17697,True),(17698,True),(17699,True),(17700,True),(17701,True),(17702,True),(17703,True),(17704,True),(17705,True),(17706,True),(17707,True),(17708,True),(17709,True),(17710,True),(17711,True),(17712,True),(17713,True),(17714,True),(17715,True),(17716,True),(17717,True),(17718,True),(17719,True),(17720,True),(17721,True),(17722,True),(17723,True),(17724,True),(17725,True),(17726,True),(17727,True),(17728,True),(17729,True),(17730,True),(17731,True),(17732,True),(17733,True),(17734,True),(17735,True),(17736,True),(17737,True),(17738,True),(17739,True),(17740,True),(17741,True),(17742,True),(17743,True),(17744,True),(17745,True),(17746,True),(17747,True),(17748,True),(17749,True),(17750,True),(17751,True),(17752,True),(17753,True),(17754,True),(17755,True),(17756,True),(17757,True),(17758,True),(17759,True),(17760,True),(17761,True),(17762,True),(17763,True),(17764,True),(17765,True),(17766,True),(17767,True),(17768,True),(17769,True),(17770,True),(17771,True),(17772,True),(17773,True),(17774,True),(17775,True),(17776,True),(17777,True),(17778,True),(17779,True),(17780,True),(17781,True),(17782,True),(17783,True),(17784,True),(17785,True),(17786,True),(17787,True),(17788,True),(17789,True),(17790,True),(17791,True),(17792,True),(17793,True),(17794,True),(17795,True),(17796,True),(17797,True),(17798,True),(17799,True),(17800,True),(17801,True),(17802,True),(17803,True),(17804,True),(17805,True),(17806,True),(17807,True),(17808,True),(17809,True),(17810,True),(17811,True),(17812,True),(17813,True),(17814,True),(17815,True),(17816,True),(17817,True),(17818,True),(17819,True),(17820,True),(17821,True),(17822,True),(17823,True),(17824,True),(17825,True),(17826,True),(17827,True),(17828,True),(17829,True),(17830,True),(17831,True),(17832,True),(17833,True),(17834,True),(17835,True),(17836,True),(17837,True),(17838,True),(17839,True),(17840,True),(17841,True),(17842,True),(17843,True),(17844,True),(17845,True),(17846,True),(17847,True),(17848,True),(17849,True),(17850,True),(17851,True),(17852,True),(17853,True),(17854,True),(17855,True),(17856,True),(17857,True),(17858,True),(17859,True),(17860,True),(17861,True),(17862,True),(17863,True),(17864,True),(17865,True),(17866,True),(17867,True),(17868,True),(17869,True),(17870,True),(17871,True),(17872,True),(17873,True),(17874,True),(17875,True),(17876,True),(17877,True),(17878,True),(17879,True),(17880,True),(17881,True),(17882,True),(17883,True),(17884,True),(17885,True),(17886,True),(17887,True),(17888,True),(17889,True),(17890,True),(17891,True),(17892,True),(17893,True),(17894,True),(17895,True),(17896,True),(17897,True),(17898,True),(17899,True),(17900,True),(17901,True),(17902,True),(17903,True),(17904,True),(17905,True),(17906,True),(17907,True),(17908,True),(17909,True),(17910,True),(17911,True),(17912,True),(17913,True),(17914,True),(17915,True),(17916,True),(17917,True),(17918,True),(17919,True),(17920,True),(17921,True),(17922,True),(17923,True),(17924,True),(17925,True),(17926,True),(17927,True),(17928,True),(17929,True),(17930,True),(17931,True),(17932,True),(17933,True),(17934,True),(17935,True),(17936,True),(17937,True),(17938,True),(17939,True),(17940,True),(17941,True),(17942,True),(17943,True),(17944,True),(17945,True),(17946,True),(17947,True),(17948,True),(17949,True),(17950,True),(17951,True),(17952,True),(17953,True),(17954,True),(17955,True),(17956,True),(17957,True),(17958,True),(17959,True),(17960,True),(17961,True),(17962,True),(17963,True),(17964,True),(17965,True),(17966,True),(17967,True),(17968,True),(17969,True),(17970,True),(17971,True),(17972,True),(17973,True),(17974,True),(17975,True),(17976,True),(17977,True),(17978,True),(17979,True),(17980,True),(17981,True),(17982,True),(17983,True),(17984,True),(17985,True),(17986,True),(17987,True),(17988,True),(17989,True),(17990,True),(17991,True),(17992,True),(17993,True),(17994,True),(17995,True),(17996,True),(17997,True),(17998,True),(17999,True),(18000,True),(18001,True),(18002,True),(18003,True),(18004,True),(18005,True),(18006,True),(18007,True),(18008,True),(18009,True),(18010,True),(18011,True),(18012,True),(18013,True),(18014,True),(18015,True),(18016,True),(18017,True),(18018,True),(18019,True),(18020,True),(18021,True),(18022,True),(18023,True),(18024,True),(18025,True),(18026,True),(18027,True),(18028,True),(18029,True),(18030,True),(18031,True),(18032,True),(18033,True),(18034,True),(18035,True),(18036,True),(18037,True),(18038,True),(18039,True),(18040,True),(18041,True),(18042,True),(18043,True),(18044,True),(18045,True),(18046,True),(18047,True),(18048,True),(18049,True),(18050,True),(18051,True),(18052,True),(18053,True),(18054,True),(18055,True),(18056,True),(18057,True),(18058,True),(18059,True),(18060,True),(18061,True),(18062,True),(18063,True),(18064,True),(18065,True),(18066,True),(18067,True),(18068,True),(18069,True),(18070,True),(18071,True),(18072,True),(18073,True),(18074,True),(18075,True),(18076,True),(18077,True),(18078,True),(18079,True),(18080,True),(18081,True),(18082,True),(18083,True),(18084,True),(18085,True),(18086,True),(18087,True),(18088,True),(18089,True),(18090,True),(18091,True),(18092,True),(18093,True),(18094,True),(18095,True),(18096,True),(18097,True),(18098,True),(18099,True),(18100,True),(18101,True),(18102,True),(18103,True),(18104,True),(18105,True),(18106,True),(18107,True),(18108,True),(18109,True),(18110,True),(18111,True),(18112,True),(18113,True),(18114,True),(18115,True),(18116,True),(18117,True),(18118,True),(18119,True),(18120,True),(18121,True),(18122,True),(18123,True),(18124,True),(18125,True),(18126,True),(18127,True),(18128,True),(18129,True),(18130,True),(18131,True),(18132,True),(18133,True),(18134,True),(18135,True),(18136,True),(18137,True),(18138,True),(18139,True),(18140,True),(18141,True),(18142,True),(18143,True),(18144,True),(18145,True),(18146,True),(18147,True),(18148,True),(18149,True),(18150,True),(18151,True),(18152,True),(18153,True),(18154,True),(18155,True),(18156,True),(18157,True),(18158,True),(18159,True),(18160,True),(18161,True),(18162,True),(18163,True),(18164,True),(18165,True),(18166,True),(18167,True),(18168,True),(18169,True),(18170,True),(18171,True),(18172,True),(18173,True),(18174,True),(18175,True),(18176,True),(18177,True),(18178,True),(18179,True),(18180,True),(18181,True),(18182,True),(18183,True),(18184,True),(18185,True),(18186,True),(18187,True),(18188,True),(18189,True),(18190,True),(18191,True),(18192,True),(18193,True),(18194,True),(18195,True),(18196,True),(18197,True),(18198,True),(18199,True),(18200,True),(18201,True),(18202,True),(18203,True),(18204,True),(18205,True),(18206,True),(18207,True),(18208,True),(18209,True),(18210,True),(18211,True),(18212,True),(18213,True),(18214,True),(18215,True),(18216,True),(18217,True),(18218,True),(18219,True),(18220,True),(18221,True),(18222,True),(18223,True),(18224,True),(18225,True),(18226,True),(18227,True),(18228,True),(18229,True),(18230,True),(18231,True),(18232,True),(18233,True),(18234,True),(18235,True),(18236,True),(18237,True),(18238,True),(18239,True),(18240,True),(18241,True),(18242,True),(18243,True),(18244,True),(18245,True),(18246,True),(18247,True),(18248,True),(18249,True),(18250,True),(18251,True),(18252,True),(18253,True),(18254,True),(18255,True),(18256,True),(18257,True),(18258,True),(18259,True),(18260,True),(18261,True),(18262,True),(18263,True),(18264,True),(18265,True),(18266,True),(18267,True),(18268,True),(18269,True),(18270,True),(18271,True),(18272,True),(18273,True),(18274,True),(18275,True),(18276,True),(18277,True),(18278,True),(18279,True),(18280,True),(18281,True),(18282,True),(18283,True),(18284,True),(18285,True),(18286,True),(18287,True),(18288,True),(18289,True),(18290,True),(18291,True),(18292,True),(18293,True),(18294,True),(18295,True),(18296,True),(18297,True),(18298,True),(18299,True),(18300,True),(18301,True),(18302,True),(18303,True),(18304,True),(18305,True),(18306,True),(18307,True),(18308,True),(18309,True),(18310,True),(18311,True),(18312,True),(18313,True),(18314,True),(18315,True),(18316,True),(18317,True),(18318,True),(18319,True),(18320,True),(18321,True),(18322,True),(18323,True),(18324,True),(18325,True),(18326,True),(18327,True),(18328,True),(18329,True),(18330,True),(18331,True),(18332,True),(18333,True),(18334,True),(18335,True),(18336,True),(18337,True),(18338,True),(18339,True),(18340,True),(18341,True),(18342,True),(18343,True),(18344,True),(18345,True),(18346,True),(18347,True),(18348,True),(18349,True),(18350,True),(18351,True),(18352,True),(18353,True),(18354,True),(18355,True),(18356,True),(18357,True),(18358,True),(18359,True),(18360,True),(18361,True),(18362,True),(18363,True),(18364,True),(18365,True),(18366,True),(18367,True),(18368,True),(18369,True),(18370,True),(18371,True),(18372,True),(18373,True),(18374,True),(18375,True),(18376,True),(18377,True),(18378,True),(18379,True),(18380,True),(18381,True),(18382,True),(18383,True),(18384,True),(18385,True),(18386,True),(18387,True),(18388,True),(18389,True),(18390,True),(18391,True),(18392,True),(18393,True),(18394,True),(18395,True),(18396,True),(18397,True),(18398,True),(18399,True),(18400,True),(18401,True),(18402,True),(18403,True),(18404,True),(18405,True),(18406,True),(18407,True),(18408,True),(18409,True),(18410,True),(18411,True),(18412,True),(18413,True),(18414,True),(18415,True),(18416,True),(18417,True),(18418,True),(18419,True),(18420,True),(18421,True),(18422,True),(18423,True),(18424,True),(18425,True),(18426,True),(18427,True),(18428,True),(18429,True),(18430,True),(18431,True),(18432,True),(18433,True),(18434,True),(18435,True),(18436,True),(18437,True),(18438,True),(18439,True),(18440,True),(18441,True),(18442,True),(18443,True),(18444,True),(18445,True),(18446,True),(18447,True),(18448,True),(18449,True),(18450,True),(18451,True),(18452,True),(18453,True),(18454,True),(18455,True),(18456,True),(18457,True),(18458,True),(18459,True),(18460,True),(18461,True),(18462,True),(18463,True),(18464,True),(18465,True),(18466,True),(18467,True),(18468,True),(18469,True),(18470,True),(18471,True),(18472,True),(18473,True),(18474,True),(18475,True),(18476,True),(18477,True),(18478,True),(18479,True),(18480,True),(18481,True),(18482,True),(18483,True),(18484,True),(18485,True),(18486,True),(18487,True),(18488,True),(18489,True),(18490,True),(18491,True),(18492,True),(18493,True),(18494,True),(18495,True),(18496,True),(18497,True),(18498,True),(18499,True),(18500,True),(18501,True),(18502,True),(18503,True),(18504,True),(18505,True),(18506,True),(18507,True),(18508,True),(18509,True),(18510,True),(18511,True),(18512,True),(18513,True),(18514,True),(18515,True),(18516,True),(18517,True),(18518,True),(18519,True),(18520,True),(18521,True),(18522,True),(18523,True),(18524,True),(18525,True),(18526,True),(18527,True),(18528,True),(18529,True),(18530,True),(18531,True),(18532,True),(18533,True),(18534,True),(18535,True),(18536,True),(18537,True),(18538,True),(18539,True),(18540,True),(18541,True),(18542,True),(18543,True),(18544,True),(18545,True),(18546,True),(18547,True),(18548,True),(18549,True),(18550,True),(18551,True),(18552,True),(18553,True),(18554,True),(18555,True),(18556,True),(18557,True),(18558,True),(18559,True),(18560,True),(18561,True),(18562,True),(18563,True),(18564,True),(18565,True),(18566,True),(18567,True),(18568,True),(18569,True),(18570,True),(18571,True),(18572,True),(18573,True),(18574,True),(18575,True),(18576,True),(18577,True),(18578,True),(18579,True),(18580,True),(18581,True),(18582,True),(18583,True),(18584,True),(18585,True),(18586,True),(18587,True),(18588,True),(18589,True),(18590,True),(18591,True),(18592,True),(18593,True),(18594,True),(18595,True),(18596,True),(18597,True),(18598,True),(18599,True),(18600,True),(18601,True),(18602,True),(18603,True),(18604,True),(18605,True),(18606,True),(18607,True),(18608,True),(18609,True),(18610,True),(18611,True),(18612,True),(18613,True),(18614,True),(18615,True),(18616,True),(18617,True),(18618,True),(18619,True),(18620,True),(18621,True),(18622,True),(18623,True),(18624,True),(18625,True),(18626,True),(18627,True),(18628,True),(18629,True),(18630,True),(18631,True),(18632,True),(18633,True),(18634,True),(18635,True),(18636,True),(18637,True),(18638,True),(18639,True),(18640,True),(18641,True),(18642,True),(18643,True),(18644,True),(18645,True),(18646,True),(18647,True),(18648,True),(18649,True),(18650,True),(18651,True),(18652,True),(18653,True),(18654,True),(18655,True),(18656,True),(18657,True),(18658,True),(18659,True),(18660,True),(18661,True),(18662,True),(18663,True),(18664,True),(18665,True),(18666,True),(18667,True),(18668,True),(18669,True),(18670,True),(18671,True),(18672,True),(18673,True),(18674,True),(18675,True),(18676,True),(18677,True),(18678,True),(18679,True),(18680,True),(18681,True),(18682,True),(18683,True),(18684,True),(18685,True),(18686,True),(18687,True),(18688,True),(18689,True),(18690,True),(18691,True),(18692,True),(18693,True),(18694,True),(18695,True),(18696,True),(18697,True),(18698,True),(18699,True),(18700,True),(18701,True),(18702,True),(18703,True),(18704,True),(18705,True),(18706,True),(18707,True),(18708,True),(18709,True),(18710,True),(18711,True),(18712,True),(18713,True),(18714,True),(18715,True),(18716,True),(18717,True),(18718,True),(18719,True),(18720,True),(18721,True),(18722,True),(18723,True),(18724,True),(18725,True),(18726,True),(18727,True),(18728,True),(18729,True),(18730,True),(18731,True),(18732,True),(18733,True),(18734,True),(18735,True),(18736,True),(18737,True),(18738,True),(18739,True),(18740,True),(18741,True),(18742,True),(18743,True),(18744,True),(18745,True),(18746,True),(18747,True),(18748,True),(18749,True),(18750,True),(18751,True),(18752,True),(18753,True),(18754,True),(18755,True),(18756,True),(18757,True),(18758,True),(18759,True),(18760,True),(18761,True),(18762,True),(18763,True),(18764,True),(18765,True),(18766,True),(18767,True),(18768,True),(18769,True),(18770,True),(18771,True),(18772,True),(18773,True),(18774,True),(18775,True),(18776,True),(18777,True),(18778,True),(18779,True),(18780,True),(18781,True),(18782,True),(18783,True),(18784,True),(18785,True),(18786,True),(18787,True),(18788,True),(18789,True),(18790,True),(18791,True),(18792,True),(18793,True),(18794,True),(18795,True),(18796,True),(18797,True),(18798,True),(18799,True),(18800,True),(18801,True),(18802,True),(18803,True),(18804,True),(18805,True),(18806,True),(18807,True),(18808,True),(18809,True),(18810,True),(18811,True),(18812,True),(18813,True),(18814,True),(18815,True),(18816,True),(18817,True),(18818,True),(18819,True),(18820,True),(18821,True),(18822,True),(18823,True),(18824,True),(18825,True),(18826,True),(18827,True),(18828,True),(18829,True),(18830,True),(18831,True),(18832,True),(18833,True),(18834,True),(18835,True),(18836,True),(18837,True),(18838,True),(18839,True),(18840,True),(18841,True),(18842,True),(18843,True),(18844,True),(18845,True),(18846,True),(18847,True),(18848,True),(18849,True),(18850,True),(18851,True),(18852,True),(18853,True),(18854,True),(18855,True),(18856,True),(18857,True),(18858,True),(18859,True),(18860,True),(18861,True),(18862,True),(18863,True),(18864,True),(18865,True),(18866,True),(18867,True),(18868,True),(18869,True),(18870,True),(18871,True),(18872,True),(18873,True),(18874,True),(18875,True),(18876,True),(18877,True),(18878,True),(18879,True),(18880,True),(18881,True),(18882,True),(18883,True),(18884,True),(18885,True),(18886,True),(18887,True),(18888,True),(18889,True),(18890,True),(18891,True),(18892,True),(18893,True),(18894,True),(18895,True),(18896,True),(18897,True),(18898,True),(18899,True),(18900,True),(18901,True),(18902,True),(18903,True),(18904,True),(18905,True),(18906,True),(18907,True),(18908,True),(18909,True),(18910,True),(18911,True),(18912,True),(18913,True),(18914,True),(18915,True),(18916,True),(18917,True),(18918,True),(18919,True),(18920,True),(18921,True),(18922,True),(18923,True),(18924,True),(18925,True),(18926,True),(18927,True),(18928,True),(18929,True),(18930,True),(18931,True),(18932,True),(18933,True),(18934,True),(18935,True),(18936,True),(18937,True),(18938,True),(18939,True),(18940,True),(18941,True),(18942,True),(18943,True),(18944,True),(18945,True),(18946,True),(18947,True),(18948,True),(18949,True),(18950,True),(18951,True),(18952,True),(18953,True),(18954,True),(18955,True),(18956,True),(18957,True),(18958,True),(18959,True),(18960,True),(18961,True),(18962,True),(18963,True),(18964,True),(18965,True),(18966,True),(18967,True),(18968,True),(18969,True),(18970,True),(18971,True),(18972,True),(18973,True),(18974,True),(18975,True),(18976,True),(18977,True),(18978,True),(18979,True),(18980,True),(18981,True),(18982,True),(18983,True),(18984,True),(18985,True),(18986,True),(18987,True),(18988,True),(18989,True),(18990,True),(18991,True),(18992,True),(18993,True),(18994,True),(18995,True),(18996,True),(18997,True),(18998,True),(18999,True),(19000,True),(19001,True),(19002,True),(19003,True),(19004,True),(19005,True),(19006,True),(19007,True),(19008,True),(19009,True),(19010,True),(19011,True),(19012,True),(19013,True),(19014,True),(19015,True),(19016,True),(19017,True),(19018,True),(19019,True),(19020,True),(19021,True),(19022,True),(19023,True),(19024,True),(19025,True),(19026,True),(19027,True),(19028,True),(19029,True),(19030,True),(19031,True),(19032,True),(19033,True),(19034,True),(19035,True),(19036,True),(19037,True),(19038,True),(19039,True),(19040,True),(19041,True),(19042,True),(19043,True),(19044,True),(19045,True),(19046,True),(19047,True),(19048,True),(19049,True),(19050,True),(19051,True),(19052,True),(19053,True),(19054,True),(19055,True),(19056,True),(19057,True),(19058,True),(19059,True),(19060,True),(19061,True),(19062,True),(19063,True),(19064,True),(19065,True),(19066,True),(19067,True),(19068,True),(19069,True),(19070,True),(19071,True),(19072,True),(19073,True),(19074,True),(19075,True),(19076,True),(19077,True),(19078,True),(19079,True),(19080,True),(19081,True),(19082,True),(19083,True),(19084,True),(19085,True),(19086,True),(19087,True),(19088,True),(19089,True),(19090,True),(19091,True),(19092,True),(19093,True),(19094,True),(19095,True),(19096,True),(19097,True),(19098,True),(19099,True),(19100,True),(19101,True),(19102,True),(19103,True),(19104,True),(19105,True),(19106,True),(19107,True),(19108,True),(19109,True),(19110,True),(19111,True),(19112,True),(19113,True),(19114,True),(19115,True),(19116,True),(19117,True),(19118,True),(19119,True),(19120,True),(19121,True),(19122,True),(19123,True),(19124,True),(19125,True),(19126,True),(19127,True),(19128,True),(19129,True),(19130,True),(19131,True),(19132,True),(19133,True),(19134,True),(19135,True),(19136,True),(19137,True),(19138,True),(19139,True),(19140,True),(19141,True),(19142,True),(19143,True),(19144,True),(19145,True),(19146,True),(19147,True),(19148,True),(19149,True),(19150,True),(19151,True),(19152,True),(19153,True),(19154,True),(19155,True),(19156,True),(19157,True),(19158,True),(19159,True),(19160,True),(19161,True),(19162,True),(19163,True),(19164,True),(19165,True),(19166,True),(19167,True),(19168,True),(19169,True),(19170,True),(19171,True),(19172,True),(19173,True),(19174,True),(19175,True),(19176,True),(19177,True),(19178,True),(19179,True),(19180,True),(19181,True),(19182,True),(19183,True),(19184,True),(19185,True),(19186,True),(19187,True),(19188,True),(19189,True),(19190,True),(19191,True),(19192,True),(19193,True),(19194,True),(19195,True),(19196,True),(19197,True),(19198,True),(19199,True),(19200,True),(19201,True),(19202,True),(19203,True),(19204,True),(19205,True),(19206,True),(19207,True),(19208,True),(19209,True),(19210,True),(19211,True),(19212,True),(19213,True),(19214,True),(19215,True),(19216,True),(19217,True),(19218,True),(19219,True),(19220,True),(19221,True),(19222,True),(19223,True),(19224,True),(19225,True),(19226,True),(19227,True),(19228,True),(19229,True),(19230,True),(19231,True),(19232,True),(19233,True),(19234,True),(19235,True),(19236,True),(19237,True),(19238,True),(19239,True),(19240,True),(19241,True),(19242,True),(19243,True),(19244,True),(19245,True),(19246,True),(19247,True),(19248,True),(19249,True),(19250,True),(19251,True),(19252,True),(19253,True),(19254,True),(19255,True),(19256,True),(19257,True),(19258,True),(19259,True),(19260,True),(19261,True),(19262,True),(19263,True),(19264,True),(19265,True),(19266,True),(19267,True),(19268,True),(19269,True),(19270,True),(19271,True),(19272,True),(19273,True),(19274,True),(19275,True),(19276,True),(19277,True),(19278,True),(19279,True),(19280,True),(19281,True),(19282,True),(19283,True),(19284,True),(19285,True),(19286,True),(19287,True),(19288,True),(19289,True),(19290,True),(19291,True),(19292,True),(19293,True),(19294,True),(19295,True),(19296,True),(19297,True),(19298,True),(19299,True),(19300,True),(19301,True),(19302,True),(19303,True),(19304,True),(19305,True),(19306,True),(19307,True),(19308,True),(19309,True),(19310,True),(19311,True),(19312,True),(19313,True),(19314,True),(19315,True),(19316,True),(19317,True),(19318,True),(19319,True),(19320,True),(19321,True),(19322,True),(19323,True),(19324,True),(19325,True),(19326,True),(19327,True),(19328,True),(19329,True),(19330,True),(19331,True),(19332,True),(19333,True),(19334,True),(19335,True),(19336,True),(19337,True),(19338,True),(19339,True),(19340,True),(19341,True),(19342,True),(19343,True),(19344,True),(19345,True),(19346,True),(19347,True),(19348,True),(19349,True),(19350,True),(19351,True),(19352,True),(19353,True),(19354,True),(19355,True),(19356,True),(19357,True),(19358,True),(19359,True),(19360,True),(19361,True),(19362,True),(19363,True),(19364,True),(19365,True),(19366,True),(19367,True),(19368,True),(19369,True),(19370,True),(19371,True),(19372,True),(19373,True),(19374,True),(19375,True),(19376,True),(19377,True),(19378,True),(19379,True),(19380,True),(19381,True),(19382,True),(19383,True),(19384,True),(19385,True),(19386,True),(19387,True),(19388,True),(19389,True),(19390,True),(19391,True),(19392,True),(19393,True),(19394,True),(19395,True),(19396,True),(19397,True),(19398,True),(19399,True),(19400,True),(19401,True),(19402,True),(19403,True),(19404,True),(19405,True),(19406,True),(19407,True),(19408,True),(19409,True),(19410,True),(19411,True),(19412,True),(19413,True),(19414,True),(19415,True),(19416,True),(19417,True),(19418,True),(19419,True),(19420,True),(19421,True),(19422,True),(19423,True),(19424,True),(19425,True),(19426,True),(19427,True),(19428,True),(19429,True),(19430,True),(19431,True),(19432,True),(19433,True),(19434,True),(19435,True),(19436,True),(19437,True),(19438,True),(19439,True),(19440,True),(19441,True),(19442,True),(19443,True),(19444,True),(19445,True),(19446,True),(19447,True),(19448,True),(19449,True),(19450,True),(19451,True),(19452,True),(19453,True),(19454,True),(19455,True),(19456,True),(19457,True),(19458,True),(19459,True),(19460,True),(19461,True),(19462,True),(19463,True),(19464,True),(19465,True),(19466,True),(19467,True),(19468,True),(19469,True),(19470,True),(19471,True),(19472,True),(19473,True),(19474,True),(19475,True),(19476,True),(19477,True),(19478,True),(19479,True),(19480,True),(19481,True),(19482,True),(19483,True),(19484,True),(19485,True),(19486,True),(19487,True),(19488,True),(19489,True),(19490,True),(19491,True),(19492,True),(19493,True),(19494,True),(19495,True),(19496,True),(19497,True),(19498,True),(19499,True),(19500,True),(19501,True),(19502,True),(19503,True),(19504,True),(19505,True),(19506,True),(19507,True),(19508,True),(19509,True),(19510,True),(19511,True),(19512,True),(19513,True),(19514,True),(19515,True),(19516,True),(19517,True),(19518,True),(19519,True),(19520,True),(19521,True),(19522,True),(19523,True),(19524,True),(19525,True),(19526,True),(19527,True),(19528,True),(19529,True),(19530,True),(19531,True),(19532,True),(19533,True),(19534,True),(19535,True),(19536,True),(19537,True),(19538,True),(19539,True),(19540,True),(19541,True),(19542,True),(19543,True),(19544,True),(19545,True),(19546,True),(19547,True),(19548,True),(19549,True),(19550,True),(19551,True),(19552,True),(19553,True),(19554,True),(19555,True),(19556,True),(19557,True),(19558,True),(19559,True),(19560,True),(19561,True),(19562,True),(19563,True),(19564,True),(19565,True),(19566,True),(19567,True),(19568,True),(19569,True),(19570,True),(19571,True),(19572,True),(19573,True),(19574,True),(19575,True),(19576,True),(19577,True),(19578,True),(19579,True),(19580,True),(19581,True),(19582,True),(19583,True),(19584,True),(19585,True),(19586,True),(19587,True),(19588,True),(19589,True),(19590,True),(19591,True),(19592,True),(19593,True),(19594,True),(19595,True),(19596,True),(19597,True),(19598,True),(19599,True),(19600,True),(19601,True),(19602,True),(19603,True),(19604,True),(19605,True),(19606,True),(19607,True),(19608,True),(19609,True),(19610,True),(19611,True),(19612,True),(19613,True),(19614,True),(19615,True),(19616,True),(19617,True),(19618,True),(19619,True),(19620,True),(19621,True),(19622,True),(19623,True),(19624,True),(19625,True),(19626,True),(19627,True),(19628,True),(19629,True),(19630,True),(19631,True),(19632,True),(19633,True),(19634,True),(19635,True),(19636,True),(19637,True),(19638,True),(19639,True),(19640,True),(19641,True),(19642,True),(19643,True),(19644,True),(19645,True),(19646,True),(19647,True),(19648,True),(19649,True),(19650,True),(19651,True),(19652,True),(19653,True),(19654,True),(19655,True),(19656,True),(19657,True),(19658,True),(19659,True),(19660,True),(19661,True),(19662,True),(19663,True),(19664,True),(19665,True),(19666,True),(19667,True),(19668,True),(19669,True),(19670,True),(19671,True),(19672,True),(19673,True),(19674,True),(19675,True),(19676,True),(19677,True),(19678,True),(19679,True),(19680,True),(19681,True),(19682,True),(19683,True),(19684,True),(19685,True),(19686,True),(19687,True),(19688,True),(19689,True),(19690,True),(19691,True),(19692,True),(19693,True),(19694,True),(19695,True),(19696,True),(19697,True),(19698,True),(19699,True),(19700,True),(19701,True),(19702,True),(19703,True),(19704,True),(19705,True),(19706,True),(19707,True),(19708,True),(19709,True),(19710,True),(19711,True),(19712,True),(19713,True),(19714,True),(19715,True),(19716,True),(19717,True),(19718,True),(19719,True),(19720,True),(19721,True),(19722,True),(19723,True),(19724,True),(19725,True),(19726,True),(19727,True),(19728,True),(19729,True),(19730,True),(19731,True),(19732,True),(19733,True),(19734,True),(19735,True),(19736,True),(19737,True),(19738,True),(19739,True),(19740,True),(19741,True),(19742,True),(19743,True),(19744,True),(19745,True),(19746,True),(19747,True),(19748,True),(19749,True),(19750,True),(19751,True),(19752,True),(19753,True),(19754,True),(19755,True),(19756,True),(19757,True),(19758,True),(19759,True),(19760,True),(19761,True),(19762,True),(19763,True),(19764,True),(19765,True),(19766,True),(19767,True),(19768,True),(19769,True),(19770,True),(19771,True),(19772,True),(19773,True),(19774,True),(19775,True),(19776,True),(19777,True),(19778,True),(19779,True),(19780,True),(19781,True),(19782,True),(19783,True),(19784,True),(19785,True),(19786,True),(19787,True),(19788,True),(19789,True),(19790,True),(19791,True),(19792,True),(19793,True),(19794,True),(19795,True),(19796,True),(19797,True),(19798,True),(19799,True),(19800,True),(19801,True),(19802,True),(19803,True),(19804,True),(19805,True),(19806,True),(19807,True),(19808,True),(19809,True),(19810,True),(19811,True),(19812,True),(19813,True),(19814,True),(19815,True),(19816,True),(19817,True),(19818,True),(19819,True),(19820,True),(19821,True),(19822,True),(19823,True),(19824,True),(19825,True),(19826,True),(19827,True),(19828,True),(19829,True),(19830,True),(19831,True),(19832,True),(19833,True),(19834,True),(19835,True),(19836,True),(19837,True),(19838,True),(19839,True),(19840,True),(19841,True),(19842,True),(19843,True),(19844,True),(19845,True),(19846,True),(19847,True),(19848,True),(19849,True),(19850,True),(19851,True),(19852,True),(19853,True),(19854,True),(19855,True),(19856,True),(19857,True),(19858,True),(19859,True),(19860,True),(19861,True),(19862,True),(19863,True),(19864,True),(19865,True),(19866,True),(19867,True),(19868,True),(19869,True),(19870,True),(19871,True),(19872,True),(19873,True),(19874,True),(19875,True),(19876,True),(19877,True),(19878,True),(19879,True),(19880,True),(19881,True),(19882,True),(19883,True),(19884,True),(19885,True),(19886,True),(19887,True),(19888,True),(19889,True),(19890,True),(19891,True),(19892,True),(19893,True),(19894,True),(19895,True),(19896,True),(19897,True),(19898,True),(19899,True),(19900,True),(19901,True),(19902,True),(19903,True),(19904,True),(19905,True),(19906,True),(19907,True),(19908,True),(19909,True),(19910,True),(19911,True),(19912,True),(19913,True),(19914,True),(19915,True),(19916,True),(19917,True),(19918,True),(19919,True),(19920,True),(19921,True),(19922,True),(19923,True),(19924,True),(19925,True),(19926,True),(19927,True),(19928,True),(19929,True),(19930,True),(19931,True),(19932,True),(19933,True),(19934,True),(19935,True),(19936,True),(19937,True),(19938,True),(19939,True),(19940,True),(19941,True),(19942,True),(19943,True),(19944,True),(19945,True),(19946,True),(19947,True),(19948,True),(19949,True),(19950,True),(19951,True),(19952,True),(19953,True),(19954,True),(19955,True),(19956,True),(19957,True),(19958,True),(19959,True),(19960,True),(19961,True),(19962,True),(19963,True),(19964,True),(19965,True),(19966,True),(19967,True),(19968,True),(19969,True),(19970,True),(19971,True),(19972,True),(19973,True),(19974,True),(19975,True),(19976,True),(19977,True),(19978,True),(19979,True),(19980,True),(19981,True),(19982,True),(19983,True),(19984,True),(19985,True),(19986,True),(19987,True),(19988,True),(19989,True),(19990,True),(19991,True),(19992,True),(19993,True),(19994,True),(19995,True),(19996,True),(19997,True),(19998,True),(19999,True),(20000,True),(20001,True),(20002,True),(20003,True),(20004,True),(20005,True),(20006,True),(20007,True),(20008,True),(20009,True),(20010,True),(20011,True),(20012,True),(20013,True),(20014,True),(20015,True),(20016,True),(20017,True),(20018,True),(20019,True),(20020,True),(20021,True),(20022,True),(20023,True),(20024,True),(20025,True),(20026,True),(20027,True),(20028,True),(20029,True),(20030,True),(20031,True),(20032,True),(20033,True),(20034,True),(20035,True),(20036,True),(20037,True),(20038,True),(20039,True),(20040,True),(20041,True),(20042,True),(20043,True),(20044,True),(20045,True),(20046,True),(20047,True),(20048,True),(20049,True),(20050,True),(20051,True),(20052,True),(20053,True),(20054,True),(20055,True),(20056,True),(20057,True),(20058,True),(20059,True),(20060,True),(20061,True),(20062,True),(20063,True),(20064,True),(20065,True),(20066,True),(20067,True),(20068,True),(20069,True),(20070,True),(20071,True),(20072,True),(20073,True),(20074,True),(20075,True),(20076,True),(20077,True),(20078,True),(20079,True),(20080,True),(20081,True),(20082,True),(20083,True),(20084,True),(20085,True),(20086,True),(20087,True),(20088,True),(20089,True),(20090,True),(20091,True),(20092,True),(20093,True),(20094,True),(20095,True),(20096,True),(20097,True),(20098,True),(20099,True),(20100,True),(20101,True),(20102,True),(20103,True),(20104,True),(20105,True),(20106,True),(20107,True),(20108,True),(20109,True),(20110,True),(20111,True),(20112,True),(20113,True),(20114,True),(20115,True),(20116,True),(20117,True),(20118,True),(20119,True),(20120,True),(20121,True),(20122,True),(20123,True),(20124,True),(20125,True),(20126,True),(20127,True),(20128,True),(20129,True),(20130,True),(20131,True),(20132,True),(20133,True),(20134,True),(20135,True),(20136,True),(20137,True),(20138,True),(20139,True),(20140,True),(20141,True),(20142,True),(20143,True),(20144,True),(20145,True),(20146,True),(20147,True),(20148,True),(20149,True),(20150,True),(20151,True),(20152,True),(20153,True),(20154,True),(20155,True),(20156,True),(20157,True),(20158,True),(20159,True),(20160,True),(20161,True),(20162,True),(20163,True),(20164,True),(20165,True),(20166,True),(20167,True),(20168,True),(20169,True),(20170,True),(20171,True),(20172,True),(20173,True),(20174,True),(20175,True),(20176,True),(20177,True),(20178,True),(20179,True),(20180,True),(20181,True),(20182,True),(20183,True),(20184,True),(20185,True),(20186,True),(20187,True),(20188,True),(20189,True),(20190,True),(20191,True),(20192,True),(20193,True),(20194,True),(20195,True),(20196,True),(20197,True),(20198,True),(20199,True),(20200,True),(20201,True),(20202,True),(20203,True),(20204,True),(20205,True),(20206,True),(20207,True),(20208,True),(20209,True),(20210,True),(20211,True),(20212,True),(20213,True),(20214,True),(20215,True),(20216,True),(20217,True),(20218,True),(20219,True),(20220,True),(20221,True),(20222,True),(20223,True),(20224,True),(20225,True),(20226,True),(20227,True),(20228,True),(20229,True),(20230,True),(20231,True),(20232,True),(20233,True),(20234,True),(20235,True),(20236,True),(20237,True),(20238,True),(20239,True),(20240,True),(20241,True),(20242,True),(20243,True),(20244,True),(20245,True),(20246,True),(20247,True),(20248,True),(20249,True),(20250,True),(20251,True),(20252,True),(20253,True),(20254,True),(20255,True),(20256,True),(20257,True),(20258,True),(20259,True),(20260,True),(20261,True),(20262,True),(20263,True),(20264,True),(20265,True),(20266,True),(20267,True),(20268,True),(20269,True),(20270,True),(20271,True),(20272,True),(20273,True),(20274,True),(20275,True),(20276,True),(20277,True),(20278,True),(20279,True),(20280,True),(20281,True),(20282,True),(20283,True),(20284,True),(20285,True),(20286,True),(20287,True),(20288,True),(20289,True),(20290,True),(20291,True),(20292,True),(20293,True),(20294,True),(20295,True),(20296,True),(20297,True),(20298,True),(20299,True),(20300,True),(20301,True),(20302,True),(20303,True),(20304,True),(20305,True),(20306,True),(20307,True),(20308,True),(20309,True),(20310,True),(20311,True),(20312,True),(20313,True),(20314,True),(20315,True),(20316,True),(20317,True),(20318,True),(20319,True),(20320,True),(20321,True),(20322,True),(20323,True),(20324,True),(20325,True),(20326,True),(20327,True),(20328,True),(20329,True),(20330,True),(20331,True),(20332,True),(20333,True),(20334,True),(20335,True),(20336,True),(20337,True),(20338,True),(20339,True),(20340,True),(20341,True),(20342,True),(20343,True),(20344,True),(20345,True),(20346,True),(20347,True),(20348,True),(20349,True),(20350,True),(20351,True),(20352,True),(20353,True),(20354,True),(20355,True),(20356,True),(20357,True),(20358,True),(20359,True),(20360,True),(20361,True),(20362,True),(20363,True),(20364,True),(20365,True),(20366,True),(20367,True),(20368,True),(20369,True),(20370,True),(20371,True),(20372,True),(20373,True),(20374,True),(20375,True),(20376,True),(20377,True),(20378,True),(20379,True),(20380,True),(20381,True),(20382,True),(20383,True),(20384,True),(20385,True),(20386,True),(20387,True),(20388,True),(20389,True),(20390,True),(20391,True),(20392,True),(20393,True),(20394,True),(20395,True),(20396,True),(20397,True),(20398,True),(20399,True),(20400,True),(20401,True),(20402,True),(20403,True),(20404,True),(20405,True),(20406,True),(20407,True),(20408,True),(20409,True),(20410,True),(20411,True),(20412,True),(20413,True),(20414,True),(20415,True),(20416,True),(20417,True),(20418,True),(20419,True),(20420,True),(20421,True),(20422,True),(20423,True),(20424,True),(20425,True),(20426,True),(20427,True),(20428,True),(20429,True),(20430,True),(20431,True),(20432,True),(20433,True),(20434,True),(20435,True),(20436,True),(20437,True),(20438,True),(20439,True),(20440,True),(20441,True),(20442,True),(20443,True),(20444,True),(20445,True),(20446,True),(20447,True),(20448,True),(20449,True),(20450,True),(20451,True),(20452,True),(20453,True),(20454,True),(20455,True),(20456,True),(20457,True),(20458,True),(20459,True),(20460,True),(20461,True),(20462,True),(20463,True),(20464,True),(20465,True),(20466,True),(20467,True),(20468,True),(20469,True),(20470,True),(20471,True),(20472,True),(20473,True),(20474,True),(20475,True),(20476,True),(20477,True),(20478,True),(20479,True),(20480,True),(20481,True),(20482,True),(20483,True),(20484,True),(20485,True),(20486,True),(20487,True),(20488,True),(20489,True),(20490,True),(20491,True),(20492,True),(20493,True),(20494,True),(20495,True),(20496,True),(20497,True),(20498,True),(20499,True),(20500,True),(20501,True),(20502,True),(20503,True),(20504,True),(20505,True),(20506,True),(20507,True),(20508,True),(20509,True),(20510,True),(20511,True),(20512,True),(20513,True),(20514,True),(20515,True),(20516,True),(20517,True),(20518,True),(20519,True),(20520,True),(20521,True),(20522,True),(20523,True),(20524,True),(20525,True),(20526,True),(20527,True),(20528,True),(20529,True),(20530,True),(20531,True),(20532,True),(20533,True),(20534,True),(20535,True),(20536,True),(20537,True),(20538,True),(20539,True),(20540,True),(20541,True),(20542,True),(20543,True),(20544,True),(20545,True),(20546,True),(20547,True),(20548,True),(20549,True),(20550,True),(20551,True),(20552,True),(20553,True),(20554,True),(20555,True),(20556,True),(20557,True),(20558,True),(20559,True),(20560,True),(20561,True),(20562,True),(20563,True),(20564,True),(20565,True),(20566,True),(20567,True),(20568,True),(20569,True),(20570,True),(20571,True),(20572,True),(20573,True),(20574,True),(20575,True),(20576,True),(20577,True),(20578,True),(20579,True),(20580,True),(20581,True),(20582,True),(20583,True),(20584,True),(20585,True),(20586,True),(20587,True),(20588,True),(20589,True),(20590,True),(20591,True),(20592,True),(20593,True),(20594,True),(20595,True),(20596,True),(20597,True),(20598,True),(20599,True),(20600,True),(20601,True),(20602,True),(20603,True),(20604,True),(20605,True),(20606,True),(20607,True),(20608,True),(20609,True),(20610,True),(20611,True),(20612,True),(20613,True),(20614,True),(20615,True),(20616,True),(20617,True),(20618,True),(20619,True),(20620,True),(20621,True),(20622,True),(20623,True),(20624,True),(20625,True),(20626,True),(20627,True),(20628,True),(20629,True),(20630,True),(20631,True),(20632,True),(20633,True),(20634,True),(20635,True),(20636,True),(20637,True),(20638,True),(20639,True),(20640,True),(20641,True),(20642,True),(20643,True),(20644,True),(20645,True),(20646,True),(20647,True),(20648,True),(20649,True),(20650,True),(20651,True),(20652,True),(20653,True),(20654,True),(20655,True),(20656,True),(20657,True),(20658,True),(20659,True),(20660,True),(20661,True),(20662,True),(20663,True),(20664,True),(20665,True),(20666,True),(20667,True),(20668,True),(20669,True),(20670,True),(20671,True),(20672,True),(20673,True),(20674,True),(20675,True),(20676,True),(20677,True),(20678,True),(20679,True),(20680,True),(20681,True),(20682,True),(20683,True),(20684,True),(20685,True),(20686,True),(20687,True),(20688,True),(20689,True),(20690,True),(20691,True),(20692,True),(20693,True),(20694,True),(20695,True),(20696,True),(20697,True),(20698,True),(20699,True),(20700,True),(20701,True),(20702,True),(20703,True),(20704,True),(20705,True),(20706,True),(20707,True),(20708,True),(20709,True),(20710,True),(20711,True),(20712,True),(20713,True),(20714,True),(20715,True),(20716,True),(20717,True),(20718,True),(20719,True),(20720,True),(20721,True),(20722,True),(20723,True),(20724,True),(20725,True),(20726,True),(20727,True),(20728,True),(20729,True),(20730,True),(20731,True),(20732,True),(20733,True),(20734,True),(20735,True),(20736,True),(20737,True),(20738,True),(20739,True),(20740,True),(20741,True),(20742,True),(20743,True),(20744,True),(20745,True),(20746,True),(20747,True),(20748,True),(20749,True),(20750,True),(20751,True),(20752,True),(20753,True),(20754,True),(20755,True),(20756,True),(20757,True),(20758,True),(20759,True),(20760,True),(20761,True),(20762,True),(20763,True),(20764,True),(20765,True),(20766,True),(20767,True),(20768,True),(20769,True),(20770,True),(20771,True),(20772,True),(20773,True),(20774,True),(20775,True),(20776,True),(20777,True),(20778,True),(20779,True),(20780,True),(20781,True),(20782,True),(20783,True),(20784,True),(20785,True),(20786,True),(20787,True),(20788,True),(20789,True),(20790,True),(20791,True),(20792,True),(20793,True),(20794,True),(20795,True),(20796,True),(20797,True),(20798,True),(20799,True),(20800,True),(20801,True),(20802,True),(20803,True),(20804,True),(20805,True),(20806,True),(20807,True),(20808,True),(20809,True),(20810,True),(20811,True),(20812,True),(20813,True),(20814,True),(20815,True),(20816,True),(20817,True),(20818,True),(20819,True),(20820,True),(20821,True),(20822,True),(20823,True),(20824,True),(20825,True),(20826,True),(20827,True),(20828,True),(20829,True),(20830,True),(20831,True),(20832,True),(20833,True),(20834,True),(20835,True),(20836,True),(20837,True),(20838,True),(20839,True),(20840,True),(20841,True),(20842,True),(20843,True),(20844,True),(20845,True),(20846,True),(20847,True),(20848,True),(20849,True),(20850,True),(20851,True),(20852,True),(20853,True),(20854,True),(20855,True),(20856,True),(20857,True),(20858,True),(20859,True),(20860,True),(20861,True),(20862,True),(20863,True),(20864,True),(20865,True),(20866,True),(20867,True),(20868,True),(20869,True),(20870,True),(20871,True),(20872,True),(20873,True),(20874,True),(20875,True),(20876,True),(20877,True),(20878,True),(20879,True),(20880,True),(20881,True),(20882,True),(20883,True),(20884,True),(20885,True),(20886,True),(20887,True),(20888,True),(20889,True),(20890,True),(20891,True),(20892,True),(20893,True),(20894,True),(20895,True),(20896,True),(20897,True),(20898,True),(20899,True),(20900,True),(20901,True),(20902,True),(20903,True),(20904,True),(20905,True),(20906,True),(20907,True),(20908,True),(20909,True),(20910,True),(20911,True),(20912,True),(20913,True),(20914,True),(20915,True),(20916,True),(20917,True),(20918,True),(20919,True),(20920,True),(20921,True),(20922,True),(20923,True),(20924,True),(20925,True),(20926,True),(20927,True),(20928,True),(20929,True),(20930,True),(20931,True),(20932,True),(20933,True),(20934,True),(20935,True),(20936,True),(20937,True),(20938,True),(20939,True),(20940,True),(20941,True),(20942,True),(20943,True),(20944,True),(20945,True),(20946,True),(20947,True),(20948,True),(20949,True),(20950,True),(20951,True),(20952,True),(20953,True),(20954,True),(20955,True),(20956,True),(20957,True),(20958,True),(20959,True),(20960,True),(20961,True),(20962,True),(20963,True),(20964,True),(20965,True),(20966,True),(20967,True),(20968,True),(20969,True),(20970,True),(20971,True),(20972,True),(20973,True),(20974,True),(20975,True),(20976,True),(20977,True),(20978,True),(20979,True),(20980,True),(20981,True),(20982,True),(20983,True),(20984,True),(20985,True),(20986,True),(20987,True),(20988,True),(20989,True),(20990,True),(20991,True),(20992,True),(20993,True),(20994,True),(20995,True),(20996,True),(20997,True),(20998,True),(20999,True),(21000,True),(21001,True),(21002,True),(21003,True),(21004,True),(21005,True),(21006,True),(21007,True),(21008,True),(21009,True),(21010,True),(21011,True),(21012,True),(21013,True),(21014,True),(21015,True),(21016,True),(21017,True),(21018,True),(21019,True),(21020,True),(21021,True),(21022,True),(21023,True),(21024,True),(21025,True),(21026,True),(21027,True),(21028,True),(21029,True),(21030,True),(21031,True),(21032,True),(21033,True),(21034,True),(21035,True),(21036,True),(21037,True),(21038,True),(21039,True),(21040,True),(21041,True),(21042,True),(21043,True),(21044,True),(21045,True),(21046,True),(21047,True),(21048,True),(21049,True),(21050,True),(21051,True),(21052,True),(21053,True),(21054,True),(21055,True),(21056,True),(21057,True),(21058,True),(21059,True),(21060,True),(21061,True),(21062,True),(21063,True),(21064,True),(21065,True),(21066,True),(21067,True),(21068,True),(21069,True),(21070,True),(21071,True),(21072,True),(21073,True),(21074,True),(21075,True),(21076,True),(21077,True),(21078,True),(21079,True),(21080,True),(21081,True),(21082,True),(21083,True),(21084,True),(21085,True),(21086,True),(21087,True),(21088,True),(21089,True),(21090,True),(21091,True),(21092,True),(21093,True),(21094,True),(21095,True),(21096,True),(21097,True),(21098,True),(21099,True),(21100,True),(21101,True),(21102,True),(21103,True),(21104,True),(21105,True),(21106,True),(21107,True),(21108,True),(21109,True),(21110,True),(21111,True),(21112,True),(21113,True),(21114,True),(21115,True),(21116,True),(21117,True),(21118,True),(21119,True),(21120,True),(21121,True),(21122,True),(21123,True),(21124,True),(21125,True),(21126,True),(21127,True),(21128,True),(21129,True),(21130,True),(21131,True),(21132,True),(21133,True),(21134,True),(21135,True),(21136,True),(21137,True),(21138,True),(21139,True),(21140,True),(21141,True),(21142,True),(21143,True),(21144,True),(21145,True),(21146,True),(21147,True),(21148,True),(21149,True),(21150,True),(21151,True),(21152,True),(21153,True),(21154,True),(21155,True),(21156,True),(21157,True),(21158,True),(21159,True),(21160,True),(21161,True),(21162,True),(21163,True),(21164,True),(21165,True),(21166,True),(21167,True),(21168,True),(21169,True),(21170,True),(21171,True),(21172,True),(21173,True),(21174,True),(21175,True),(21176,True),(21177,True),(21178,True),(21179,True),(21180,True),(21181,True),(21182,True),(21183,True),(21184,True),(21185,True),(21186,True),(21187,True),(21188,True),(21189,True),(21190,True),(21191,True),(21192,True),(21193,True),(21194,True),(21195,True),(21196,True),(21197,True),(21198,True),(21199,True),(21200,True),(21201,True),(21202,True),(21203,True),(21204,True),(21205,True),(21206,True),(21207,True),(21208,True),(21209,True),(21210,True),(21211,True),(21212,True),(21213,True),(21214,True),(21215,True),(21216,True),(21217,True),(21218,True),(21219,True),(21220,True),(21221,True),(21222,True),(21223,True),(21224,True),(21225,True),(21226,True),(21227,True),(21228,True),(21229,True),(21230,True),(21231,True),(21232,True),(21233,True),(21234,True),(21235,True),(21236,True),(21237,True),(21238,True),(21239,True),(21240,True),(21241,True),(21242,True),(21243,True),(21244,True),(21245,True),(21246,True),(21247,True),(21248,True),(21249,True),(21250,True),(21251,True),(21252,True),(21253,True),(21254,True),(21255,True),(21256,True),(21257,True),(21258,True),(21259,True),(21260,True),(21261,True),(21262,True),(21263,True),(21264,True),(21265,True),(21266,True),(21267,True),(21268,True),(21269,True),(21270,True),(21271,True),(21272,True),(21273,True),(21274,True),(21275,True),(21276,True),(21277,True),(21278,True),(21279,True),(21280,True),(21281,True),(21282,True),(21283,True),(21284,True),(21285,True),(21286,True),(21287,True),(21288,True),(21289,True),(21290,True),(21291,True),(21292,True),(21293,True),(21294,True),(21295,True),(21296,True),(21297,True),(21298,True),(21299,True),(21300,True),(21301,True),(21302,True),(21303,True),(21304,True),(21305,True),(21306,True),(21307,True),(21308,True),(21309,True),(21310,True),(21311,True),(21312,True),(21313,True),(21314,True),(21315,True),(21316,True),(21317,True),(21318,True),(21319,True),(21320,True),(21321,True),(21322,True),(21323,True),(21324,True),(21325,True),(21326,True),(21327,True),(21328,True),(21329,True),(21330,True),(21331,True),(21332,True),(21333,True),(21334,True),(21335,True),(21336,True),(21337,True),(21338,True),(21339,True),(21340,True),(21341,True),(21342,True),(21343,True),(21344,True),(21345,True),(21346,True),(21347,True),(21348,True),(21349,True),(21350,True),(21351,True),(21352,True),(21353,True),(21354,True),(21355,True),(21356,True),(21357,True),(21358,True),(21359,True),(21360,True),(21361,True),(21362,True),(21363,True),(21364,True),(21365,True),(21366,True),(21367,True),(21368,True),(21369,True),(21370,True),(21371,True),(21372,True),(21373,True),(21374,True),(21375,True),(21376,True),(21377,True),(21378,True),(21379,True),(21380,True),(21381,True),(21382,True),(21383,True),(21384,True),(21385,True),(21386,True),(21387,True),(21388,True),(21389,True),(21390,True),(21391,True),(21392,True),(21393,True),(21394,True),(21395,True),(21396,True),(21397,True),(21398,True),(21399,True),(21400,True),(21401,True),(21402,True),(21403,True),(21404,True),(21405,True),(21406,True),(21407,True),(21408,True),(21409,True),(21410,True),(21411,True),(21412,True),(21413,True),(21414,True),(21415,True),(21416,True),(21417,True),(21418,True),(21419,True),(21420,True),(21421,True),(21422,True),(21423,True),(21424,True),(21425,True),(21426,True),(21427,True),(21428,True),(21429,True),(21430,True),(21431,True),(21432,True),(21433,True),(21434,True),(21435,True),(21436,True),(21437,True),(21438,True),(21439,True),(21440,True),(21441,True),(21442,True),(21443,True),(21444,True),(21445,True),(21446,True),(21447,True),(21448,True),(21449,True),(21450,True),(21451,True),(21452,True),(21453,True),(21454,True),(21455,True),(21456,True),(21457,True),(21458,True),(21459,True),(21460,True),(21461,True),(21462,True),(21463,True),(21464,True),(21465,True),(21466,True),(21467,True),(21468,True),(21469,True),(21470,True),(21471,True),(21472,True),(21473,True),(21474,True),(21475,True),(21476,True),(21477,True),(21478,True),(21479,True),(21480,True),(21481,True),(21482,True),(21483,True),(21484,True),(21485,True),(21486,True),(21487,True),(21488,True),(21489,True),(21490,True),(21491,True),(21492,True),(21493,True),(21494,True),(21495,True),(21496,True),(21497,True),(21498,True),(21499,True),(21500,True),(21501,True),(21502,True),(21503,True),(21504,True),(21505,True),(21506,True),(21507,True),(21508,True),(21509,True),(21510,True),(21511,True),(21512,True),(21513,True),(21514,True),(21515,True),(21516,True),(21517,True),(21518,True),(21519,True),(21520,True),(21521,True),(21522,True),(21523,True),(21524,True),(21525,True),(21526,True),(21527,True),(21528,True),(21529,True),(21530,True),(21531,True),(21532,True),(21533,True),(21534,True),(21535,True),(21536,True),(21537,True),(21538,True),(21539,True),(21540,True),(21541,True),(21542,True),(21543,True),(21544,True),(21545,True),(21546,True),(21547,True),(21548,True),(21549,True),(21550,True),(21551,True),(21552,True),(21553,True),(21554,True),(21555,True),(21556,True),(21557,True),(21558,True),(21559,True),(21560,True),(21561,True),(21562,True),(21563,True),(21564,True),(21565,True),(21566,True),(21567,True),(21568,True),(21569,True),(21570,True),(21571,True),(21572,True),(21573,True),(21574,True),(21575,True),(21576,True),(21577,True),(21578,True),(21579,True),(21580,True),(21581,True),(21582,True),(21583,True),(21584,True),(21585,True),(21586,True),(21587,True),(21588,True),(21589,True),(21590,True),(21591,True),(21592,True),(21593,True),(21594,True),(21595,True),(21596,True),(21597,True),(21598,True),(21599,True),(21600,True),(21601,True),(21602,True),(21603,True),(21604,True),(21605,True),(21606,True),(21607,True),(21608,True),(21609,True),(21610,True),(21611,True),(21612,True),(21613,True),(21614,True),(21615,True),(21616,True),(21617,True),(21618,True),(21619,True),(21620,True),(21621,True),(21622,True),(21623,True),(21624,True),(21625,True),(21626,True),(21627,True),(21628,True),(21629,True),(21630,True),(21631,True),(21632,True),(21633,True),(21634,True),(21635,True),(21636,True),(21637,True),(21638,True),(21639,True),(21640,True),(21641,True),(21642,True),(21643,True),(21644,True),(21645,True),(21646,True),(21647,True),(21648,True),(21649,True),(21650,True),(21651,True),(21652,True),(21653,True),(21654,True),(21655,True),(21656,True),(21657,True),(21658,True),(21659,True),(21660,True),(21661,True),(21662,True),(21663,True),(21664,True),(21665,True),(21666,True),(21667,True),(21668,True),(21669,True),(21670,True),(21671,True),(21672,True),(21673,True),(21674,True),(21675,True),(21676,True),(21677,True),(21678,True),(21679,True),(21680,True),(21681,True),(21682,True),(21683,True),(21684,True),(21685,True),(21686,True),(21687,True),(21688,True),(21689,True),(21690,True),(21691,True),(21692,True),(21693,True),(21694,True),(21695,True),(21696,True),(21697,True),(21698,True),(21699,True),(21700,True),(21701,True),(21702,True),(21703,True),(21704,True),(21705,True),(21706,True),(21707,True),(21708,True),(21709,True),(21710,True),(21711,True),(21712,True),(21713,True),(21714,True),(21715,True),(21716,True),(21717,True),(21718,True),(21719,True),(21720,True),(21721,True),(21722,True),(21723,True),(21724,True),(21725,True),(21726,True),(21727,True),(21728,True),(21729,True),(21730,True),(21731,True),(21732,True),(21733,True),(21734,True),(21735,True),(21736,True),(21737,True),(21738,True),(21739,True),(21740,True),(21741,True),(21742,True),(21743,True),(21744,True),(21745,True),(21746,True),(21747,True),(21748,True),(21749,True),(21750,True),(21751,True),(21752,True),(21753,True),(21754,True),(21755,True),(21756,True),(21757,True),(21758,True),(21759,True),(21760,True),(21761,True),(21762,True),(21763,True),(21764,True),(21765,True),(21766,True),(21767,True),(21768,True),(21769,True),(21770,True),(21771,True),(21772,True),(21773,True),(21774,True),(21775,True),(21776,True),(21777,True),(21778,True),(21779,True),(21780,True),(21781,True),(21782,True),(21783,True),(21784,True),(21785,True),(21786,True),(21787,True),(21788,True),(21789,True),(21790,True),(21791,True),(21792,True),(21793,True),(21794,True),(21795,True),(21796,True),(21797,True),(21798,True),(21799,True),(21800,True),(21801,True),(21802,True),(21803,True),(21804,True),(21805,True),(21806,True),(21807,True),(21808,True),(21809,True),(21810,True),(21811,True),(21812,True),(21813,True),(21814,True),(21815,True),(21816,True),(21817,True),(21818,True),(21819,True),(21820,True),(21821,True),(21822,True),(21823,True),(21824,True),(21825,True),(21826,True),(21827,True),(21828,True),(21829,True),(21830,True),(21831,True),(21832,True),(21833,True),(21834,True),(21835,True),(21836,True),(21837,True),(21838,True),(21839,True),(21840,True),(21841,True),(21842,True),(21843,True),(21844,True),(21845,True),(21846,True),(21847,True),(21848,True),(21849,True),(21850,True),(21851,True),(21852,True),(21853,True),(21854,True),(21855,True),(21856,True),(21857,True),(21858,True),(21859,True),(21860,True),(21861,True),(21862,True),(21863,True),(21864,True),(21865,True),(21866,True),(21867,True),(21868,True),(21869,True),(21870,True),(21871,True),(21872,True),(21873,True),(21874,True),(21875,True),(21876,True),(21877,True),(21878,True),(21879,True),(21880,True),(21881,True),(21882,True),(21883,True),(21884,True),(21885,True),(21886,True),(21887,True),(21888,True),(21889,True),(21890,True),(21891,True),(21892,True),(21893,True),(21894,True),(21895,True),(21896,True),(21897,True),(21898,True),(21899,True),(21900,True),(21901,True),(21902,True),(21903,True),(21904,True),(21905,True),(21906,True),(21907,True),(21908,True),(21909,True),(21910,True),(21911,True),(21912,True),(21913,True),(21914,True),(21915,True),(21916,True),(21917,True),(21918,True),(21919,True),(21920,True),(21921,True),(21922,True),(21923,True),(21924,True),(21925,True),(21926,True),(21927,True),(21928,True),(21929,True),(21930,True),(21931,True),(21932,True),(21933,True),(21934,True),(21935,True),(21936,True),(21937,True),(21938,True),(21939,True),(21940,True),(21941,True),(21942,True),(21943,True),(21944,True),(21945,True),(21946,True),(21947,True),(21948,True),(21949,True),(21950,True),(21951,True),(21952,True),(21953,True),(21954,True),(21955,True),(21956,True),(21957,True),(21958,True),(21959,True),(21960,True),(21961,True),(21962,True),(21963,True),(21964,True),(21965,True),(21966,True),(21967,True),(21968,True),(21969,True),(21970,True),(21971,True),(21972,True),(21973,True),(21974,True),(21975,True),(21976,True),(21977,True),(21978,True),(21979,True),(21980,True),(21981,True),(21982,True),(21983,True),(21984,True),(21985,True),(21986,True),(21987,True),(21988,True),(21989,True),(21990,True),(21991,True),(21992,True),(21993,True),(21994,True),(21995,True),(21996,True),(21997,True),(21998,True),(21999,True),(22000,True),(22001,True),(22002,True),(22003,True),(22004,True),(22005,True),(22006,True),(22007,True),(22008,True),(22009,True),(22010,True),(22011,True),(22012,True),(22013,True),(22014,True),(22015,True),(22016,True),(22017,True),(22018,True),(22019,True),(22020,True),(22021,True),(22022,True),(22023,True),(22024,True),(22025,True),(22026,True),(22027,True),(22028,True),(22029,True),(22030,True),(22031,True),(22032,True),(22033,True),(22034,True),(22035,True),(22036,True),(22037,True),(22038,True),(22039,True),(22040,True),(22041,True),(22042,True),(22043,True),(22044,True),(22045,True),(22046,True),(22047,True),(22048,True),(22049,True),(22050,True),(22051,True),(22052,True),(22053,True),(22054,True),(22055,True),(22056,True),(22057,True),(22058,True),(22059,True),(22060,True),(22061,True),(22062,True),(22063,True),(22064,True),(22065,True),(22066,True),(22067,True),(22068,True),(22069,True),(22070,True),(22071,True),(22072,True),(22073,True),(22074,True),(22075,True),(22076,True),(22077,True),(22078,True),(22079,True),(22080,True),(22081,True),(22082,True),(22083,True),(22084,True),(22085,True),(22086,True),(22087,True),(22088,True),(22089,True),(22090,True),(22091,True),(22092,True),(22093,True),(22094,True),(22095,True),(22096,True),(22097,True),(22098,True),(22099,True),(22100,True),(22101,True),(22102,True),(22103,True),(22104,True),(22105,True),(22106,True),(22107,True),(22108,True),(22109,True),(22110,True),(22111,True),(22112,True),(22113,True),(22114,True),(22115,True),(22116,True),(22117,True),(22118,True),(22119,True),(22120,True),(22121,True),(22122,True),(22123,True),(22124,True),(22125,True),(22126,True),(22127,True),(22128,True),(22129,True),(22130,True),(22131,True),(22132,True),(22133,True),(22134,True),(22135,True),(22136,True),(22137,True),(22138,True),(22139,True),(22140,True),(22141,True),(22142,True),(22143,True),(22144,True),(22145,True),(22146,True),(22147,True),(22148,True),(22149,True),(22150,True),(22151,True),(22152,True),(22153,True),(22154,True),(22155,True),(22156,True),(22157,True),(22158,True),(22159,True),(22160,True),(22161,True),(22162,True),(22163,True),(22164,True),(22165,True),(22166,True),(22167,True),(22168,True),(22169,True),(22170,True),(22171,True),(22172,True),(22173,True),(22174,True),(22175,True),(22176,True),(22177,True),(22178,True),(22179,True),(22180,True),(22181,True),(22182,True),(22183,True),(22184,True),(22185,True),(22186,True),(22187,True),(22188,True),(22189,True),(22190,True),(22191,True),(22192,True),(22193,True),(22194,True),(22195,True),(22196,True),(22197,True),(22198,True),(22199,True),(22200,True),(22201,True),(22202,True),(22203,True),(22204,True),(22205,True),(22206,True),(22207,True),(22208,True),(22209,True),(22210,True),(22211,True),(22212,True),(22213,True),(22214,True),(22215,True),(22216,True),(22217,True),(22218,True),(22219,True),(22220,True),(22221,True),(22222,True),(22223,True),(22224,True),(22225,True),(22226,True),(22227,True),(22228,True),(22229,True),(22230,True),(22231,True),(22232,True),(22233,True),(22234,True),(22235,True),(22236,True),(22237,True),(22238,True),(22239,True),(22240,True),(22241,True),(22242,True),(22243,True),(22244,True),(22245,True),(22246,True),(22247,True),(22248,True),(22249,True),(22250,True),(22251,True),(22252,True),(22253,True),(22254,True),(22255,True),(22256,True),(22257,True),(22258,True),(22259,True),(22260,True),(22261,True),(22262,True),(22263,True),(22264,True),(22265,True),(22266,True),(22267,True),(22268,True),(22269,True),(22270,True),(22271,True),(22272,True),(22273,True),(22274,True),(22275,True),(22276,True),(22277,True),(22278,True),(22279,True),(22280,True),(22281,True),(22282,True),(22283,True),(22284,True),(22285,True),(22286,True),(22287,True),(22288,True),(22289,True),(22290,True),(22291,True),(22292,True),(22293,True),(22294,True),(22295,True),(22296,True),(22297,True),(22298,True),(22299,True),(22300,True),(22301,True),(22302,True),(22303,True),(22304,True),(22305,True),(22306,True),(22307,True),(22308,True),(22309,True),(22310,True),(22311,True),(22312,True),(22313,True),(22314,True),(22315,True),(22316,True),(22317,True),(22318,True),(22319,True),(22320,True),(22321,True),(22322,True),(22323,True),(22324,True),(22325,True),(22326,True),(22327,True),(22328,True),(22329,True),(22330,True),(22331,True),(22332,True),(22333,True),(22334,True),(22335,True),(22336,True),(22337,True),(22338,True),(22339,True),(22340,True),(22341,True),(22342,True),(22343,True),(22344,True),(22345,True),(22346,True),(22347,True),(22348,True),(22349,True),(22350,True),(22351,True),(22352,True),(22353,True),(22354,True),(22355,True),(22356,True),(22357,True),(22358,True),(22359,True),(22360,True),(22361,True),(22362,True),(22363,True),(22364,True),(22365,True),(22366,True),(22367,True),(22368,True),(22369,True),(22370,True),(22371,True),(22372,True),(22373,True),(22374,True),(22375,True),(22376,True),(22377,True),(22378,True),(22379,True),(22380,True),(22381,True),(22382,True),(22383,True),(22384,True),(22385,True),(22386,True),(22387,True),(22388,True),(22389,True),(22390,True),(22391,True),(22392,True),(22393,True),(22394,True),(22395,True),(22396,True),(22397,True),(22398,True),(22399,True),(22400,True),(22401,True),(22402,True),(22403,True),(22404,True),(22405,True),(22406,True),(22407,True),(22408,True),(22409,True),(22410,True),(22411,True),(22412,True),(22413,True),(22414,True),(22415,True),(22416,True),(22417,True),(22418,True),(22419,True),(22420,True),(22421,True),(22422,True),(22423,True),(22424,True),(22425,True),(22426,True),(22427,True),(22428,True),(22429,True),(22430,True),(22431,True),(22432,True),(22433,True),(22434,True),(22435,True),(22436,True),(22437,True),(22438,True),(22439,True),(22440,True),(22441,True),(22442,True),(22443,True),(22444,True),(22445,True),(22446,True),(22447,True),(22448,True),(22449,True),(22450,True),(22451,True),(22452,True),(22453,True),(22454,True),(22455,True),(22456,True),(22457,True),(22458,True),(22459,True),(22460,True),(22461,True),(22462,True),(22463,True),(22464,True),(22465,True),(22466,True),(22467,True),(22468,True),(22469,True),(22470,True),(22471,True),(22472,True),(22473,True),(22474,True),(22475,True),(22476,True),(22477,True),(22478,True),(22479,True),(22480,True),(22481,True),(22482,True),(22483,True),(22484,True),(22485,True),(22486,True),(22487,True),(22488,True),(22489,True),(22490,True),(22491,True),(22492,True),(22493,True),(22494,True),(22495,True),(22496,True),(22497,True),(22498,True),(22499,True),(22500,True),(22501,True),(22502,True),(22503,True),(22504,True),(22505,True),(22506,True),(22507,True),(22508,True),(22509,True),(22510,True),(22511,True),(22512,True),(22513,True),(22514,True),(22515,True),(22516,True),(22517,True),(22518,True),(22519,True),(22520,True),(22521,True),(22522,True),(22523,True),(22524,True),(22525,True),(22526,True),(22527,True),(22528,True),(22529,True),(22530,True),(22531,True),(22532,True),(22533,True),(22534,True),(22535,True),(22536,True),(22537,True),(22538,True),(22539,True),(22540,True),(22541,True),(22542,True),(22543,True),(22544,True),(22545,True),(22546,True),(22547,True),(22548,True),(22549,True),(22550,True),(22551,True),(22552,True),(22553,True),(22554,True),(22555,True),(22556,True),(22557,True),(22558,True),(22559,True),(22560,True),(22561,True),(22562,True),(22563,True),(22564,True),(22565,True),(22566,True),(22567,True),(22568,True),(22569,True),(22570,True),(22571,True),(22572,True),(22573,True),(22574,True),(22575,True),(22576,True),(22577,True),(22578,True),(22579,True),(22580,True),(22581,True),(22582,True),(22583,True),(22584,True),(22585,True),(22586,True),(22587,True),(22588,True),(22589,True),(22590,True),(22591,True),(22592,True),(22593,True),(22594,True),(22595,True),(22596,True),(22597,True),(22598,True),(22599,True),(22600,True),(22601,True),(22602,True),(22603,True),(22604,True),(22605,True),(22606,True),(22607,True),(22608,True),(22609,True),(22610,True),(22611,True),(22612,True),(22613,True),(22614,True),(22615,True),(22616,True),(22617,True),(22618,True),(22619,True),(22620,True),(22621,True),(22622,True),(22623,True),(22624,True),(22625,True),(22626,True),(22627,True),(22628,True),(22629,True),(22630,True),(22631,True),(22632,True),(22633,True),(22634,True),(22635,True),(22636,True),(22637,True),(22638,True),(22639,True),(22640,True),(22641,True),(22642,True),(22643,True),(22644,True),(22645,True),(22646,True),(22647,True),(22648,True),(22649,True),(22650,True),(22651,True),(22652,True),(22653,True),(22654,True),(22655,True),(22656,True),(22657,True),(22658,True),(22659,True),(22660,True),(22661,True),(22662,True),(22663,True),(22664,True),(22665,True),(22666,True),(22667,True),(22668,True),(22669,True),(22670,True),(22671,True),(22672,True),(22673,True),(22674,True),(22675,True),(22676,True),(22677,True),(22678,True),(22679,True),(22680,True),(22681,True),(22682,True),(22683,True),(22684,True),(22685,True),(22686,True),(22687,True),(22688,True),(22689,True),(22690,True),(22691,True),(22692,True),(22693,True),(22694,True),(22695,True),(22696,True),(22697,True),(22698,True),(22699,True),(22700,True),(22701,True),(22702,True),(22703,True),(22704,True),(22705,True),(22706,True),(22707,True),(22708,True),(22709,True),(22710,True),(22711,True),(22712,True),(22713,True),(22714,True),(22715,True),(22716,True),(22717,True),(22718,True),(22719,True),(22720,True),(22721,True),(22722,True),(22723,True),(22724,True),(22725,True),(22726,True),(22727,True),(22728,True),(22729,True),(22730,True),(22731,True),(22732,True),(22733,True),(22734,True),(22735,True),(22736,True),(22737,True),(22738,True),(22739,True),(22740,True),(22741,True),(22742,True),(22743,True),(22744,True),(22745,True),(22746,True),(22747,True),(22748,True),(22749,True),(22750,True),(22751,True),(22752,True),(22753,True),(22754,True),(22755,True),(22756,True),(22757,True),(22758,True),(22759,True),(22760,True),(22761,True),(22762,True),(22763,True),(22764,True),(22765,True),(22766,True),(22767,True),(22768,True),(22769,True),(22770,True),(22771,True),(22772,True),(22773,True),(22774,True),(22775,True),(22776,True),(22777,True),(22778,True),(22779,True),(22780,True),(22781,True),(22782,True),(22783,True),(22784,True),(22785,True),(22786,True),(22787,True),(22788,True),(22789,True),(22790,True),(22791,True),(22792,True),(22793,True),(22794,True),(22795,True),(22796,True),(22797,True),(22798,True),(22799,True),(22800,True),(22801,True),(22802,True),(22803,True),(22804,True),(22805,True),(22806,True),(22807,True),(22808,True),(22809,True),(22810,True),(22811,True),(22812,True),(22813,True),(22814,True),(22815,True),(22816,True),(22817,True),(22818,True),(22819,True),(22820,True),(22821,True),(22822,True),(22823,True),(22824,True),(22825,True),(22826,True),(22827,True),(22828,True),(22829,True),(22830,True),(22831,True),(22832,True),(22833,True),(22834,True),(22835,True),(22836,True),(22837,True),(22838,True),(22839,True),(22840,True),(22841,True),(22842,True),(22843,True),(22844,True),(22845,True),(22846,True),(22847,True),(22848,True),(22849,True),(22850,True),(22851,True),(22852,True),(22853,True),(22854,True),(22855,True),(22856,True),(22857,True),(22858,True),(22859,True),(22860,True),(22861,True),(22862,True),(22863,True),(22864,True),(22865,True),(22866,True),(22867,True),(22868,True),(22869,True),(22870,True),(22871,True),(22872,True),(22873,True),(22874,True),(22875,True),(22876,True),(22877,True),(22878,True),(22879,True),(22880,True),(22881,True),(22882,True),(22883,True),(22884,True),(22885,True),(22886,True),(22887,True),(22888,True),(22889,True),(22890,True),(22891,True),(22892,True),(22893,True),(22894,True),(22895,True),(22896,True),(22897,True),(22898,True),(22899,True),(22900,True),(22901,True),(22902,True),(22903,True),(22904,True),(22905,True),(22906,True),(22907,True),(22908,True),(22909,True),(22910,True),(22911,True),(22912,True),(22913,True),(22914,True),(22915,True),(22916,True),(22917,True),(22918,True),(22919,True),(22920,True),(22921,True),(22922,True),(22923,True),(22924,True),(22925,True),(22926,True),(22927,True),(22928,True),(22929,True),(22930,True),(22931,True),(22932,True),(22933,True),(22934,True),(22935,True),(22936,True),(22937,True),(22938,True),(22939,True),(22940,True),(22941,True),(22942,True),(22943,True),(22944,True),(22945,True),(22946,True),(22947,True),(22948,True),(22949,True),(22950,True),(22951,True),(22952,True),(22953,True),(22954,True),(22955,True),(22956,True),(22957,True),(22958,True),(22959,True),(22960,True),(22961,True),(22962,True),(22963,True),(22964,True),(22965,True),(22966,True),(22967,True),(22968,True),(22969,True),(22970,True),(22971,True),(22972,True),(22973,True),(22974,True),(22975,True),(22976,True),(22977,True),(22978,True),(22979,True),(22980,True),(22981,True),(22982,True),(22983,True),(22984,True),(22985,True),(22986,True),(22987,True),(22988,True),(22989,True),(22990,True),(22991,True),(22992,True),(22993,True),(22994,True),(22995,True),(22996,True),(22997,True),(22998,True),(22999,True),(23000,True),(23001,True),(23002,True),(23003,True),(23004,True),(23005,True),(23006,True),(23007,True),(23008,True),(23009,True),(23010,True),(23011,True),(23012,True),(23013,True),(23014,True),(23015,True),(23016,True),(23017,True),(23018,True),(23019,True),(23020,True),(23021,True),(23022,True),(23023,True),(23024,True),(23025,True),(23026,True),(23027,True),(23028,True),(23029,True),(23030,True),(23031,True),(23032,True),(23033,True),(23034,True),(23035,True),(23036,True),(23037,True),(23038,True),(23039,True),(23040,True),(23041,True),(23042,True),(23043,True),(23044,True),(23045,True),(23046,True),(23047,True),(23048,True),(23049,True),(23050,True),(23051,True),(23052,True),(23053,True),(23054,True),(23055,True),(23056,True),(23057,True),(23058,True),(23059,True),(23060,True),(23061,True),(23062,True),(23063,True),(23064,True),(23065,True),(23066,True),(23067,True),(23068,True),(23069,True),(23070,True),(23071,True),(23072,True),(23073,True),(23074,True),(23075,True),(23076,True),(23077,True),(23078,True),(23079,True),(23080,True),(23081,True),(23082,True),(23083,True),(23084,True),(23085,True),(23086,True),(23087,True),(23088,True),(23089,True),(23090,True),(23091,True),(23092,True),(23093,True),(23094,True),(23095,True),(23096,True),(23097,True),(23098,True),(23099,True),(23100,True),(23101,True),(23102,True),(23103,True),(23104,True),(23105,True),(23106,True),(23107,True),(23108,True),(23109,True),(23110,True),(23111,True),(23112,True),(23113,True),(23114,True),(23115,True),(23116,True),(23117,True),(23118,True),(23119,True),(23120,True),(23121,True),(23122,True),(23123,True),(23124,True),(23125,True),(23126,True),(23127,True),(23128,True),(23129,True),(23130,True),(23131,True),(23132,True),(23133,True),(23134,True),(23135,True),(23136,True),(23137,True),(23138,True),(23139,True),(23140,True),(23141,True),(23142,True),(23143,True),(23144,True),(23145,True),(23146,True),(23147,True),(23148,True),(23149,True),(23150,True),(23151,True),(23152,True),(23153,True),(23154,True),(23155,True),(23156,True),(23157,True),(23158,True),(23159,True),(23160,True),(23161,True),(23162,True),(23163,True),(23164,True),(23165,True),(23166,True),(23167,True),(23168,True),(23169,True),(23170,True),(23171,True),(23172,True),(23173,True),(23174,True),(23175,True),(23176,True),(23177,True),(23178,True),(23179,True),(23180,True),(23181,True),(23182,True),(23183,True),(23184,True),(23185,True),(23186,True),(23187,True),(23188,True),(23189,True),(23190,True),(23191,True),(23192,True),(23193,True),(23194,True),(23195,True),(23196,True),(23197,True),(23198,True),(23199,True),(23200,True),(23201,True),(23202,True),(23203,True),(23204,True),(23205,True),(23206,True),(23207,True),(23208,True),(23209,True),(23210,True),(23211,True),(23212,True),(23213,True),(23214,True),(23215,True),(23216,True),(23217,True),(23218,True),(23219,True),(23220,True),(23221,True),(23222,True),(23223,True),(23224,True),(23225,True),(23226,True),(23227,True),(23228,True),(23229,True),(23230,True),(23231,True),(23232,True),(23233,True),(23234,True),(23235,True),(23236,True),(23237,True),(23238,True),(23239,True),(23240,True),(23241,True),(23242,True),(23243,True),(23244,True),(23245,True),(23246,True),(23247,True),(23248,True),(23249,True),(23250,True),(23251,True),(23252,True),(23253,True),(23254,True),(23255,True),(23256,True),(23257,True),(23258,True),(23259,True),(23260,True),(23261,True),(23262,True),(23263,True),(23264,True),(23265,True),(23266,True),(23267,True),(23268,True),(23269,True),(23270,True),(23271,True),(23272,True),(23273,True),(23274,True),(23275,True),(23276,True),(23277,True),(23278,True),(23279,True),(23280,True),(23281,True),(23282,True),(23283,True),(23284,True),(23285,True),(23286,True),(23287,True),(23288,True),(23289,True),(23290,True),(23291,True),(23292,True),(23293,True),(23294,True),(23295,True),(23296,True),(23297,True),(23298,True),(23299,True),(23300,True),(23301,True),(23302,True),(23303,True),(23304,True),(23305,True),(23306,True),(23307,True),(23308,True),(23309,True),(23310,True),(23311,True),(23312,True),(23313,True),(23314,True),(23315,True),(23316,True),(23317,True),(23318,True),(23319,True),(23320,True),(23321,True),(23322,True),(23323,True),(23324,True),(23325,True),(23326,True),(23327,True),(23328,True),(23329,True),(23330,True),(23331,True),(23332,True),(23333,True),(23334,True),(23335,True),(23336,True),(23337,True),(23338,True),(23339,True),(23340,True),(23341,True),(23342,True),(23343,True),(23344,True),(23345,True),(23346,True),(23347,True),(23348,True),(23349,True),(23350,True),(23351,True),(23352,True),(23353,True),(23354,True),(23355,True),(23356,True),(23357,True),(23358,True),(23359,True),(23360,True),(23361,True),(23362,True),(23363,True),(23364,True),(23365,True),(23366,True),(23367,True),(23368,True),(23369,True),(23370,True),(23371,True),(23372,True),(23373,True),(23374,True),(23375,True),(23376,True),(23377,True),(23378,True),(23379,True),(23380,True),(23381,True),(23382,True),(23383,True),(23384,True),(23385,True),(23386,True),(23387,True),(23388,True),(23389,True),(23390,True),(23391,True),(23392,True),(23393,True),(23394,True),(23395,True),(23396,True),(23397,True),(23398,True),(23399,True),(23400,True),(23401,True),(23402,True),(23403,True),(23404,True),(23405,True),(23406,True),(23407,True),(23408,True),(23409,True),(23410,True),(23411,True),(23412,True),(23413,True),(23414,True),(23415,True),(23416,True),(23417,True),(23418,True),(23419,True),(23420,True),(23421,True),(23422,True),(23423,True),(23424,True),(23425,True),(23426,True),(23427,True),(23428,True),(23429,True),(23430,True),(23431,True),(23432,True),(23433,True),(23434,True),(23435,True),(23436,True),(23437,True),(23438,True),(23439,True),(23440,True),(23441,True),(23442,True),(23443,True),(23444,True),(23445,True),(23446,True),(23447,True),(23448,True),(23449,True),(23450,True),(23451,True),(23452,True),(23453,True),(23454,True),(23455,True),(23456,True),(23457,True),(23458,True),(23459,True),(23460,True),(23461,True),(23462,True),(23463,True),(23464,True),(23465,True),(23466,True),(23467,True),(23468,True),(23469,True),(23470,True),(23471,True),(23472,True),(23473,True),(23474,True),(23475,True),(23476,True),(23477,True),(23478,True),(23479,True),(23480,True),(23481,True),(23482,True),(23483,True),(23484,True),(23485,True),(23486,True),(23487,True),(23488,True),(23489,True),(23490,True),(23491,True),(23492,True),(23493,True),(23494,True),(23495,True),(23496,True),(23497,True),(23498,True),(23499,True),(23500,True),(23501,True),(23502,True),(23503,True),(23504,True),(23505,True),(23506,True),(23507,True),(23508,True),(23509,True),(23510,True),(23511,True),(23512,True),(23513,True),(23514,True),(23515,True),(23516,True),(23517,True),(23518,True),(23519,True),(23520,True),(23521,True),(23522,True),(23523,True),(23524,True),(23525,True),(23526,True),(23527,True),(23528,True),(23529,True),(23530,True),(23531,True),(23532,True),(23533,True),(23534,True),(23535,True),(23536,True),(23537,True),(23538,True),(23539,True),(23540,True),(23541,True),(23542,True),(23543,True),(23544,True),(23545,True),(23546,True),(23547,True),(23548,True),(23549,True),(23550,True),(23551,True),(23552,True),(23553,True),(23554,True),(23555,True),(23556,True),(23557,True),(23558,True),(23559,True),(23560,True),(23561,True),(23562,True),(23563,True),(23564,True),(23565,True),(23566,True),(23567,True),(23568,True),(23569,True),(23570,True),(23571,True),(23572,True),(23573,True),(23574,True),(23575,True),(23576,True),(23577,True),(23578,True),(23579,True),(23580,True),(23581,True),(23582,True),(23583,True),(23584,True),(23585,True),(23586,True),(23587,True),(23588,True),(23589,True),(23590,True),(23591,True),(23592,True),(23593,True),(23594,True),(23595,True),(23596,True),(23597,True),(23598,True),(23599,True),(23600,True),(23601,True),(23602,True),(23603,True),(23604,True),(23605,True),(23606,True),(23607,True),(23608,True),(23609,True),(23610,True),(23611,True),(23612,True),(23613,True),(23614,True),(23615,True),(23616,True),(23617,True),(23618,True),(23619,True),(23620,True),(23621,True),(23622,True),(23623,True),(23624,True),(23625,True),(23626,True),(23627,True),(23628,True),(23629,True),(23630,True),(23631,True),(23632,True),(23633,True),(23634,True),(23635,True),(23636,True),(23637,True),(23638,True),(23639,True),(23640,True),(23641,True),(23642,True),(23643,True),(23644,True),(23645,True),(23646,True),(23647,True),(23648,True),(23649,True),(23650,True),(23651,True),(23652,True),(23653,True),(23654,True),(23655,True),(23656,True),(23657,True),(23658,True),(23659,True),(23660,True),(23661,True),(23662,True),(23663,True),(23664,True),(23665,True),(23666,True),(23667,True),(23668,True),(23669,True),(23670,True),(23671,True),(23672,True),(23673,True),(23674,True),(23675,True),(23676,True),(23677,True),(23678,True),(23679,True),(23680,True),(23681,True),(23682,True),(23683,True),(23684,True),(23685,True),(23686,True),(23687,True),(23688,True),(23689,True),(23690,True),(23691,True),(23692,True),(23693,True),(23694,True),(23695,True),(23696,True),(23697,True),(23698,True),(23699,True),(23700,True),(23701,True),(23702,True),(23703,True),(23704,True),(23705,True),(23706,True),(23707,True),(23708,True),(23709,True),(23710,True),(23711,True),(23712,True),(23713,True),(23714,True),(23715,True),(23716,True),(23717,True),(23718,True),(23719,True),(23720,True),(23721,True),(23722,True),(23723,True),(23724,True),(23725,True),(23726,True),(23727,True),(23728,True),(23729,True),(23730,True),(23731,True),(23732,True),(23733,True),(23734,True),(23735,True),(23736,True),(23737,True),(23738,True),(23739,True),(23740,True),(23741,True),(23742,True),(23743,True),(23744,True),(23745,True),(23746,True),(23747,True),(23748,True),(23749,True),(23750,True),(23751,True),(23752,True),(23753,True),(23754,True),(23755,True),(23756,True),(23757,True),(23758,True),(23759,True),(23760,True),(23761,True),(23762,True),(23763,True),(23764,True),(23765,True),(23766,True),(23767,True),(23768,True),(23769,True),(23770,True),(23771,True),(23772,True),(23773,True),(23774,True),(23775,True),(23776,True),(23777,True),(23778,True),(23779,True),(23780,True),(23781,True),(23782,True),(23783,True),(23784,True),(23785,True),(23786,True),(23787,True),(23788,True),(23789,True),(23790,True),(23791,True),(23792,True),(23793,True),(23794,True),(23795,True),(23796,True),(23797,True),(23798,True),(23799,True),(23800,True),(23801,True),(23802,True),(23803,True),(23804,True),(23805,True),(23806,True),(23807,True),(23808,True),(23809,True),(23810,True),(23811,True),(23812,True),(23813,True),(23814,True),(23815,True),(23816,True),(23817,True),(23818,True),(23819,True),(23820,True),(23821,True),(23822,True),(23823,True),(23824,True),(23825,True),(23826,True),(23827,True),(23828,True),(23829,True),(23830,True),(23831,True),(23832,True),(23833,True),(23834,True),(23835,True),(23836,True),(23837,True),(23838,True),(23839,True),(23840,True),(23841,True),(23842,True),(23843,True),(23844,True),(23845,True),(23846,True),(23847,True),(23848,True),(23849,True),(23850,True),(23851,True),(23852,True),(23853,True),(23854,True),(23855,True),(23856,True),(23857,True),(23858,True),(23859,True),(23860,True),(23861,True),(23862,True),(23863,True),(23864,True),(23865,True),(23866,True),(23867,True),(23868,True),(23869,True),(23870,True),(23871,True),(23872,True),(23873,True),(23874,True),(23875,True),(23876,True),(23877,True),(23878,True),(23879,True),(23880,True),(23881,True),(23882,True),(23883,True),(23884,True),(23885,True),(23886,True),(23887,True),(23888,True),(23889,True),(23890,True),(23891,True),(23892,True),(23893,True),(23894,True),(23895,True),(23896,True),(23897,True),(23898,True),(23899,True),(23900,True),(23901,True),(23902,True),(23903,True),(23904,True),(23905,True),(23906,True),(23907,True),(23908,True),(23909,True),(23910,True),(23911,True),(23912,True),(23913,True),(23914,True),(23915,True),(23916,True),(23917,True),(23918,True),(23919,True),(23920,True),(23921,True),(23922,True),(23923,True),(23924,True),(23925,True),(23926,True),(23927,True),(23928,True),(23929,True),(23930,True),(23931,True),(23932,True),(23933,True),(23934,True),(23935,True),(23936,True),(23937,True),(23938,True),(23939,True),(23940,True),(23941,True),(23942,True),(23943,True),(23944,True),(23945,True),(23946,True),(23947,True),(23948,True),(23949,True),(23950,True),(23951,True),(23952,True),(23953,True),(23954,True),(23955,True),(23956,True),(23957,True),(23958,True),(23959,True),(23960,True),(23961,True),(23962,True),(23963,True),(23964,True),(23965,True),(23966,True),(23967,True),(23968,True),(23969,True),(23970,True),(23971,True),(23972,True),(23973,True),(23974,True),(23975,True),(23976,True),(23977,True),(23978,True),(23979,True),(23980,True),(23981,True),(23982,True),(23983,True),(23984,True),(23985,True),(23986,True),(23987,True),(23988,True),(23989,True),(23990,True),(23991,True),(23992,True),(23993,True),(23994,True),(23995,True),(23996,True),(23997,True),(23998,True),(23999,True),(24000,True),(24001,True),(24002,True),(24003,True),(24004,True),(24005,True),(24006,True),(24007,True),(24008,True),(24009,True),(24010,True),(24011,True),(24012,True),(24013,True),(24014,True),(24015,True),(24016,True),(24017,True),(24018,True),(24019,True),(24020,True),(24021,True),(24022,True),(24023,True),(24024,True),(24025,True),(24026,True),(24027,True),(24028,True),(24029,True),(24030,True),(24031,True),(24032,True),(24033,True),(24034,True),(24035,True),(24036,True),(24037,True),(24038,True),(24039,True),(24040,True),(24041,True),(24042,True),(24043,True),(24044,True),(24045,True),(24046,True),(24047,True),(24048,True),(24049,True),(24050,True),(24051,True),(24052,True),(24053,True),(24054,True),(24055,True),(24056,True),(24057,True),(24058,True),(24059,True),(24060,True),(24061,True),(24062,True),(24063,True),(24064,True),(24065,True),(24066,True),(24067,True),(24068,True),(24069,True),(24070,True),(24071,True),(24072,True),(24073,True),(24074,True),(24075,True),(24076,True),(24077,True),(24078,True),(24079,True),(24080,True),(24081,True),(24082,True),(24083,True),(24084,True),(24085,True),(24086,True),(24087,True),(24088,True),(24089,True),(24090,True),(24091,True),(24092,True),(24093,True),(24094,True),(24095,True),(24096,True),(24097,True),(24098,True),(24099,True),(24100,True),(24101,True),(24102,True),(24103,True),(24104,True),(24105,True),(24106,True),(24107,True),(24108,True),(24109,True),(24110,True),(24111,True),(24112,True),(24113,True),(24114,True),(24115,True),(24116,True),(24117,True),(24118,True),(24119,True),(24120,True),(24121,True),(24122,True),(24123,True),(24124,True),(24125,True),(24126,True),(24127,True),(24128,True),(24129,True),(24130,True),(24131,True),(24132,True),(24133,True),(24134,True),(24135,True),(24136,True),(24137,True),(24138,True),(24139,True),(24140,True),(24141,True),(24142,True),(24143,True),(24144,True),(24145,True),(24146,True),(24147,True),(24148,True),(24149,True),(24150,True),(24151,True),(24152,True),(24153,True),(24154,True),(24155,True),(24156,True),(24157,True),(24158,True),(24159,True),(24160,True),(24161,True),(24162,True),(24163,True),(24164,True),(24165,True),(24166,True),(24167,True),(24168,True),(24169,True),(24170,True),(24171,True),(24172,True),(24173,True),(24174,True),(24175,True),(24176,True),(24177,True),(24178,True),(24179,True),(24180,True),(24181,True),(24182,True),(24183,True),(24184,True),(24185,True),(24186,True),(24187,True),(24188,True),(24189,True),(24190,True),(24191,True),(24192,True),(24193,True),(24194,True),(24195,True),(24196,True),(24197,True),(24198,True),(24199,True),(24200,True),(24201,True),(24202,True),(24203,True),(24204,True),(24205,True),(24206,True),(24207,True),(24208,True),(24209,True),(24210,True),(24211,True),(24212,True),(24213,True),(24214,True),(24215,True),(24216,True),(24217,True),(24218,True),(24219,True),(24220,True),(24221,True),(24222,True),(24223,True),(24224,True),(24225,True),(24226,True),(24227,True),(24228,True),(24229,True),(24230,True),(24231,True),(24232,True),(24233,True),(24234,True),(24235,True),(24236,True),(24237,True),(24238,True),(24239,True),(24240,True),(24241,True),(24242,True),(24243,True),(24244,True),(24245,True),(24246,True),(24247,True),(24248,True),(24249,True),(24250,True),(24251,True),(24252,True),(24253,True),(24254,True),(24255,True),(24256,True),(24257,True),(24258,True),(24259,True),(24260,True),(24261,True),(24262,True),(24263,True),(24264,True),(24265,True),(24266,True),(24267,True),(24268,True),(24269,True),(24270,True),(24271,True),(24272,True),(24273,True),(24274,True),(24275,True),(24276,True),(24277,True),(24278,True),(24279,True),(24280,True),(24281,True),(24282,True),(24283,True),(24284,True),(24285,True),(24286,True),(24287,True),(24288,True),(24289,True),(24290,True),(24291,True),(24292,True),(24293,True),(24294,True),(24295,True),(24296,True),(24297,True),(24298,True),(24299,True),(24300,True),(24301,True),(24302,True),(24303,True),(24304,True),(24305,True),(24306,True),(24307,True),(24308,True),(24309,True),(24310,True),(24311,True),(24312,True),(24313,True),(24314,True),(24315,True),(24316,True),(24317,True),(24318,True),(24319,True),(24320,True),(24321,True),(24322,True),(24323,True),(24324,True),(24325,True),(24326,True),(24327,True),(24328,True),(24329,True),(24330,True),(24331,True),(24332,True),(24333,True),(24334,True),(24335,True),(24336,True),(24337,True),(24338,True),(24339,True),(24340,True),(24341,True),(24342,True),(24343,True),(24344,True),(24345,True),(24346,True),(24347,True),(24348,True),(24349,True),(24350,True),(24351,True),(24352,True),(24353,True),(24354,True),(24355,True),(24356,True),(24357,True),(24358,True),(24359,True),(24360,True),(24361,True),(24362,True),(24363,True),(24364,True),(24365,True),(24366,True),(24367,True),(24368,True),(24369,True),(24370,True),(24371,True),(24372,True),(24373,True),(24374,True),(24375,True),(24376,True),(24377,True),(24378,True),(24379,True),(24380,True),(24381,True),(24382,True),(24383,True),(24384,True),(24385,True),(24386,True),(24387,True),(24388,True),(24389,True),(24390,True),(24391,True),(24392,True),(24393,True),(24394,True),(24395,True),(24396,True),(24397,True),(24398,True),(24399,True),(24400,True),(24401,True),(24402,True),(24403,True),(24404,True),(24405,True),(24406,True),(24407,True),(24408,True),(24409,True),(24410,True),(24411,True),(24412,True),(24413,True),(24414,True),(24415,True),(24416,True),(24417,True),(24418,True),(24419,True),(24420,True),(24421,True),(24422,True),(24423,True),(24424,True),(24425,True),(24426,True),(24427,True),(24428,True),(24429,True),(24430,True),(24431,True),(24432,True),(24433,True),(24434,True),(24435,True),(24436,True),(24437,True),(24438,True),(24439,True),(24440,True),(24441,True),(24442,True),(24443,True),(24444,True),(24445,True),(24446,True),(24447,True),(24448,True),(24449,True),(24450,True),(24451,True),(24452,True),(24453,True),(24454,True),(24455,True),(24456,True),(24457,True),(24458,True),(24459,True),(24460,True),(24461,True),(24462,True),(24463,True),(24464,True),(24465,True),(24466,True),(24467,True),(24468,True),(24469,True),(24470,True),(24471,True),(24472,True),(24473,True),(24474,True),(24475,True),(24476,True),(24477,True),(24478,True),(24479,True),(24480,True),(24481,True),(24482,True),(24483,True),(24484,True),(24485,True),(24486,True),(24487,True),(24488,True),(24489,True),(24490,True),(24491,True),(24492,True),(24493,True),(24494,True),(24495,True),(24496,True),(24497,True),(24498,True),(24499,True),(24500,True),(24501,True),(24502,True),(24503,True),(24504,True),(24505,True),(24506,True),(24507,True),(24508,True),(24509,True),(24510,True),(24511,True),(24512,True),(24513,True),(24514,True),(24515,True),(24516,True),(24517,True),(24518,True),(24519,True),(24520,True),(24521,True),(24522,True),(24523,True),(24524,True),(24525,True),(24526,True),(24527,True),(24528,True),(24529,True),(24530,True),(24531,True),(24532,True),(24533,True),(24534,True),(24535,True),(24536,True),(24537,True),(24538,True),(24539,True),(24540,True),(24541,True),(24542,True),(24543,True),(24544,True),(24545,True),(24546,True),(24547,True),(24548,True),(24549,True),(24550,True),(24551,True),(24552,True),(24553,True),(24554,True),(24555,True),(24556,True),(24557,True),(24558,True),(24559,True),(24560,True),(24561,True),(24562,True),(24563,True),(24564,True),(24565,True),(24566,True),(24567,True),(24568,True),(24569,True),(24570,True),(24571,True),(24572,True),(24573,True),(24574,True),(24575,True),(24576,True),(24577,True),(24578,True),(24579,True),(24580,True),(24581,True),(24582,True),(24583,True),(24584,True),(24585,True),(24586,True),(24587,True),(24588,True),(24589,True),(24590,True),(24591,True),(24592,True),(24593,True),(24594,True),(24595,True),(24596,True),(24597,True),(24598,True),(24599,True),(24600,True),(24601,True),(24602,True),(24603,True),(24604,True),(24605,True),(24606,True),(24607,True),(24608,True),(24609,True),(24610,True),(24611,True),(24612,True),(24613,True),(24614,True),(24615,True),(24616,True),(24617,True),(24618,True),(24619,True),(24620,True),(24621,True),(24622,True),(24623,True),(24624,True),(24625,True),(24626,True),(24627,True),(24628,True),(24629,True),(24630,True),(24631,True),(24632,True),(24633,True),(24634,True),(24635,True),(24636,True),(24637,True),(24638,True),(24639,True),(24640,True),(24641,True),(24642,True),(24643,True),(24644,True),(24645,True),(24646,True),(24647,True),(24648,True),(24649,True),(24650,True),(24651,True),(24652,True),(24653,True),(24654,True),(24655,True),(24656,True),(24657,True),(24658,True),(24659,True),(24660,True),(24661,True),(24662,True),(24663,True),(24664,True),(24665,True),(24666,True),(24667,True),(24668,True),(24669,True),(24670,True),(24671,True),(24672,True),(24673,True),(24674,True),(24675,True),(24676,True),(24677,True),(24678,True),(24679,True),(24680,True),(24681,True),(24682,True),(24683,True),(24684,True),(24685,True),(24686,True),(24687,True),(24688,True),(24689,True),(24690,True),(24691,True),(24692,True),(24693,True),(24694,True),(24695,True),(24696,True),(24697,True),(24698,True),(24699,True),(24700,True),(24701,True),(24702,True),(24703,True),(24704,True),(24705,True),(24706,True),(24707,True),(24708,True),(24709,True),(24710,True),(24711,True),(24712,True),(24713,True),(24714,True),(24715,True),(24716,True),(24717,True),(24718,True),(24719,True),(24720,True),(24721,True),(24722,True),(24723,True),(24724,True),(24725,True),(24726,True),(24727,True),(24728,True),(24729,True),(24730,True),(24731,True),(24732,True),(24733,True),(24734,True),(24735,True),(24736,True),(24737,True),(24738,True),(24739,True),(24740,True),(24741,True),(24742,True),(24743,True),(24744,True),(24745,True),(24746,True),(24747,True),(24748,True),(24749,True),(24750,True),(24751,True),(24752,True),(24753,True),(24754,True),(24755,True),(24756,True),(24757,True),(24758,True),(24759,True),(24760,True),(24761,True),(24762,True),(24763,True),(24764,True),(24765,True),(24766,True),(24767,True),(24768,True),(24769,True),(24770,True),(24771,True),(24772,True),(24773,True),(24774,True),(24775,True),(24776,True),(24777,True),(24778,True),(24779,True),(24780,True),(24781,True),(24782,True),(24783,True),(24784,True),(24785,True),(24786,True),(24787,True),(24788,True),(24789,True),(24790,True),(24791,True),(24792,True),(24793,True),(24794,True),(24795,True),(24796,True),(24797,True),(24798,True),(24799,True),(24800,True),(24801,True),(24802,True),(24803,True),(24804,True),(24805,True),(24806,True),(24807,True),(24808,True),(24809,True),(24810,True),(24811,True),(24812,True),(24813,True),(24814,True),(24815,True),(24816,True),(24817,True),(24818,True),(24819,True),(24820,True),(24821,True),(24822,True),(24823,True),(24824,True),(24825,True),(24826,True),(24827,True),(24828,True),(24829,True),(24830,True),(24831,True),(24832,True),(24833,True),(24834,True),(24835,True),(24836,True),(24837,True),(24838,True),(24839,True),(24840,True),(24841,True),(24842,True),(24843,True),(24844,True),(24845,True),(24846,True),(24847,True),(24848,True),(24849,True),(24850,True),(24851,True),(24852,True),(24853,True),(24854,True),(24855,True),(24856,True),(24857,True),(24858,True),(24859,True),(24860,True),(24861,True),(24862,True),(24863,True),(24864,True),(24865,True),(24866,True),(24867,True),(24868,True),(24869,True),(24870,True),(24871,True),(24872,True),(24873,True),(24874,True),(24875,True),(24876,True),(24877,True),(24878,True),(24879,True),(24880,True),(24881,True),(24882,True),(24883,True),(24884,True),(24885,True),(24886,True),(24887,True),(24888,True),(24889,True),(24890,True),(24891,True),(24892,True),(24893,True),(24894,True),(24895,True),(24896,True),(24897,True),(24898,True),(24899,True),(24900,True),(24901,True),(24902,True),(24903,True),(24904,True),(24905,True),(24906,True),(24907,True),(24908,True),(24909,True),(24910,True),(24911,True),(24912,True),(24913,True),(24914,True),(24915,True),(24916,True),(24917,True),(24918,True),(24919,True),(24920,True),(24921,True),(24922,True),(24923,True),(24924,True),(24925,True),(24926,True),(24927,True),(24928,True),(24929,True),(24930,True),(24931,True),(24932,True),(24933,True),(24934,True),(24935,True),(24936,True),(24937,True),(24938,True),(24939,True),(24940,True),(24941,True),(24942,True),(24943,True),(24944,True),(24945,True),(24946,True),(24947,True),(24948,True),(24949,True),(24950,True),(24951,True),(24952,True),(24953,True),(24954,True),(24955,True),(24956,True),(24957,True),(24958,True),(24959,True),(24960,True),(24961,True),(24962,True),(24963,True),(24964,True),(24965,True),(24966,True),(24967,True),(24968,True),(24969,True),(24970,True),(24971,True),(24972,True),(24973,True),(24974,True),(24975,True),(24976,True),(24977,True),(24978,True),(24979,True),(24980,True),(24981,True),(24982,True),(24983,True),(24984,True),(24985,True),(24986,True),(24987,True),(24988,True),(24989,True),(24990,True),(24991,True),(24992,True),(24993,True),(24994,True),(24995,True),(24996,True),(24997,True),(24998,True),(24999,True),(25000,True),(25001,True),(25002,True),(25003,True),(25004,True),(25005,True),(25006,True),(25007,True),(25008,True),(25009,True),(25010,True),(25011,True),(25012,True),(25013,True),(25014,True),(25015,True),(25016,True),(25017,True),(25018,True),(25019,True),(25020,True),(25021,True),(25022,True),(25023,True),(25024,True),(25025,True),(25026,True),(25027,True),(25028,True),(25029,True),(25030,True),(25031,True),(25032,True),(25033,True),(25034,True),(25035,True),(25036,True),(25037,True),(25038,True),(25039,True),(25040,True),(25041,True),(25042,True),(25043,True),(25044,True),(25045,True),(25046,True),(25047,True),(25048,True),(25049,True),(25050,True),(25051,True),(25052,True),(25053,True),(25054,True),(25055,True),(25056,True),(25057,True),(25058,True),(25059,True),(25060,True),(25061,True),(25062,True),(25063,True),(25064,True),(25065,True),(25066,True),(25067,True),(25068,True),(25069,True),(25070,True),(25071,True),(25072,True),(25073,True),(25074,True),(25075,True),(25076,True),(25077,True),(25078,True),(25079,True),(25080,True),(25081,True),(25082,True),(25083,True),(25084,True),(25085,True),(25086,True),(25087,True),(25088,True),(25089,True),(25090,True),(25091,True),(25092,True),(25093,True),(25094,True),(25095,True),(25096,True),(25097,True),(25098,True),(25099,True),(25100,True),(25101,True),(25102,True),(25103,True),(25104,True),(25105,True),(25106,True),(25107,True),(25108,True),(25109,True),(25110,True),(25111,True),(25112,True),(25113,True),(25114,True),(25115,True),(25116,True),(25117,True),(25118,True),(25119,True),(25120,True),(25121,True),(25122,True),(25123,True),(25124,True),(25125,True),(25126,True),(25127,True),(25128,True),(25129,True),(25130,True),(25131,True),(25132,True),(25133,True),(25134,True),(25135,True),(25136,True),(25137,True),(25138,True),(25139,True),(25140,True),(25141,True),(25142,True),(25143,True),(25144,True),(25145,True),(25146,True),(25147,True),(25148,True),(25149,True),(25150,True),(25151,True),(25152,True),(25153,True),(25154,True),(25155,True),(25156,True),(25157,True),(25158,True),(25159,True),(25160,True),(25161,True),(25162,True),(25163,True),(25164,True),(25165,True),(25166,True),(25167,True),(25168,True),(25169,True),(25170,True),(25171,True),(25172,True),(25173,True),(25174,True),(25175,True),(25176,True),(25177,True),(25178,True),(25179,True),(25180,True),(25181,True),(25182,True),(25183,True),(25184,True),(25185,True),(25186,True),(25187,True),(25188,True),(25189,True),(25190,True),(25191,True),(25192,True),(25193,True),(25194,True),(25195,True),(25196,True),(25197,True),(25198,True),(25199,True),(25200,True),(25201,True),(25202,True),(25203,True),(25204,True),(25205,True),(25206,True),(25207,True),(25208,True),(25209,True),(25210,True),(25211,True),(25212,True),(25213,True),(25214,True),(25215,True),(25216,True),(25217,True),(25218,True),(25219,True),(25220,True),(25221,True),(25222,True),(25223,True),(25224,True),(25225,True),(25226,True),(25227,True),(25228,True),(25229,True),(25230,True),(25231,True),(25232,True),(25233,True),(25234,True),(25235,True),(25236,True),(25237,True),(25238,True),(25239,True),(25240,True),(25241,True),(25242,True),(25243,True),(25244,True),(25245,True),(25246,True),(25247,True),(25248,True),(25249,True),(25250,True),(25251,True),(25252,True),(25253,True),(25254,True),(25255,True),(25256,True),(25257,True),(25258,True),(25259,True),(25260,True),(25261,True),(25262,True),(25263,True),(25264,True),(25265,True),(25266,True),(25267,True),(25268,True),(25269,True),(25270,True),(25271,True),(25272,True),(25273,True),(25274,True),(25275,True),(25276,True),(25277,True),(25278,True),(25279,True),(25280,True),(25281,True),(25282,True),(25283,True),(25284,True),(25285,True),(25286,True),(25287,True),(25288,True),(25289,True),(25290,True),(25291,True),(25292,True),(25293,True),(25294,True),(25295,True),(25296,True),(25297,True),(25298,True),(25299,True),(25300,True),(25301,True),(25302,True),(25303,True),(25304,True),(25305,True),(25306,True),(25307,True),(25308,True),(25309,True),(25310,True),(25311,True),(25312,True),(25313,True),(25314,True),(25315,True),(25316,True),(25317,True),(25318,True),(25319,True),(25320,True),(25321,True),(25322,True),(25323,True),(25324,True),(25325,True),(25326,True),(25327,True),(25328,True),(25329,True),(25330,True),(25331,True),(25332,True),(25333,True),(25334,True),(25335,True),(25336,True),(25337,True),(25338,True),(25339,True),(25340,True),(25341,True),(25342,True),(25343,True),(25344,True),(25345,True),(25346,True),(25347,True),(25348,True),(25349,True),(25350,True),(25351,True),(25352,True),(25353,True),(25354,True),(25355,True),(25356,True),(25357,True),(25358,True),(25359,True),(25360,True),(25361,True),(25362,True),(25363,True),(25364,True),(25365,True),(25366,True),(25367,True),(25368,True),(25369,True),(25370,True),(25371,True),(25372,True),(25373,True),(25374,True),(25375,True),(25376,True),(25377,True),(25378,True),(25379,True),(25380,True),(25381,True),(25382,True),(25383,True),(25384,True),(25385,True),(25386,True),(25387,True),(25388,True),(25389,True),(25390,True),(25391,True),(25392,True),(25393,True),(25394,True),(25395,True),(25396,True),(25397,True),(25398,True),(25399,True),(25400,True),(25401,True),(25402,True),(25403,True),(25404,True),(25405,True),(25406,True),(25407,True),(25408,True),(25409,True),(25410,True),(25411,True),(25412,True),(25413,True),(25414,True),(25415,True),(25416,True),(25417,True),(25418,True),(25419,True),(25420,True),(25421,True),(25422,True),(25423,True),(25424,True),(25425,True),(25426,True),(25427,True),(25428,True),(25429,True),(25430,True),(25431,True),(25432,True),(25433,True),(25434,True),(25435,True),(25436,True),(25437,True),(25438,True),(25439,True),(25440,True),(25441,True),(25442,True),(25443,True),(25444,True),(25445,True),(25446,True),(25447,True),(25448,True),(25449,True),(25450,True),(25451,True),(25452,True),(25453,True),(25454,True),(25455,True),(25456,True),(25457,True),(25458,True),(25459,True),(25460,True),(25461,True),(25462,True),(25463,True),(25464,True),(25465,True),(25466,True),(25467,True),(25468,True),(25469,True),(25470,True),(25471,True),(25472,True),(25473,True),(25474,True),(25475,True),(25476,True),(25477,True),(25478,True),(25479,True),(25480,True),(25481,True),(25482,True),(25483,True),(25484,True),(25485,True),(25486,True),(25487,True),(25488,True),(25489,True),(25490,True),(25491,True),(25492,True),(25493,True),(25494,True),(25495,True),(25496,True),(25497,True),(25498,True),(25499,True),(25500,True),(25501,True),(25502,True),(25503,True),(25504,True),(25505,True),(25506,True),(25507,True),(25508,True),(25509,True),(25510,True),(25511,True),(25512,True),(25513,True),(25514,True),(25515,True),(25516,True),(25517,True),(25518,True),(25519,True),(25520,True),(25521,True),(25522,True),(25523,True),(25524,True),(25525,True),(25526,True),(25527,True),(25528,True),(25529,True),(25530,True),(25531,True),(25532,True),(25533,True),(25534,True),(25535,True),(25536,True),(25537,True),(25538,True),(25539,True),(25540,True),(25541,True),(25542,True),(25543,True),(25544,True),(25545,True),(25546,True),(25547,True),(25548,True),(25549,True),(25550,True),(25551,True),(25552,True),(25553,True),(25554,True),(25555,True),(25556,True),(25557,True),(25558,True),(25559,True),(25560,True),(25561,True),(25562,True),(25563,True),(25564,True),(25565,True),(25566,True),(25567,True),(25568,True),(25569,True),(25570,True),(25571,True),(25572,True),(25573,True),(25574,True),(25575,True),(25576,True),(25577,True),(25578,True),(25579,True),(25580,True),(25581,True),(25582,True),(25583,True),(25584,True),(25585,True),(25586,True),(25587,True),(25588,True),(25589,True),(25590,True),(25591,True),(25592,True),(25593,True),(25594,True),(25595,True),(25596,True),(25597,True),(25598,True),(25599,True),(25600,True),(25601,True),(25602,True),(25603,True),(25604,True),(25605,True),(25606,True),(25607,True),(25608,True),(25609,True),(25610,True),(25611,True),(25612,True),(25613,True),(25614,True),(25615,True),(25616,True),(25617,True),(25618,True),(25619,True),(25620,True),(25621,True),(25622,True),(25623,True),(25624,True),(25625,True),(25626,True),(25627,True),(25628,True),(25629,True),(25630,True),(25631,True),(25632,True),(25633,True),(25634,True),(25635,True),(25636,True),(25637,True),(25638,True),(25639,True),(25640,True),(25641,True),(25642,True),(25643,True),(25644,True),(25645,True),(25646,True),(25647,True),(25648,True),(25649,True),(25650,True),(25651,True),(25652,True),(25653,True),(25654,True),(25655,True),(25656,True),(25657,True),(25658,True),(25659,True),(25660,True),(25661,True),(25662,True),(25663,True),(25664,True),(25665,True),(25666,True),(25667,True),(25668,True),(25669,True),(25670,True),(25671,True),(25672,True),(25673,True),(25674,True),(25675,True),(25676,True),(25677,True),(25678,True),(25679,True),(25680,True),(25681,True),(25682,True),(25683,True),(25684,True),(25685,True),(25686,True),(25687,True),(25688,True),(25689,True),(25690,True),(25691,True),(25692,True),(25693,True),(25694,True),(25695,True),(25696,True),(25697,True),(25698,True),(25699,True),(25700,True),(25701,True),(25702,True),(25703,True),(25704,True),(25705,True),(25706,True),(25707,True),(25708,True),(25709,True),(25710,True),(25711,True),(25712,True),(25713,True),(25714,True),(25715,True),(25716,True),(25717,True),(25718,True),(25719,True),(25720,True),(25721,True),(25722,True),(25723,True),(25724,True),(25725,True),(25726,True),(25727,True),(25728,True),(25729,True),(25730,True),(25731,True),(25732,True),(25733,True),(25734,True),(25735,True),(25736,True),(25737,True),(25738,True),(25739,True),(25740,True),(25741,True),(25742,True),(25743,True),(25744,True),(25745,True),(25746,True),(25747,True),(25748,True),(25749,True),(25750,True),(25751,True),(25752,True),(25753,True),(25754,True),(25755,True),(25756,True),(25757,True),(25758,True),(25759,True),(25760,True),(25761,True),(25762,True),(25763,True),(25764,True),(25765,True),(25766,True),(25767,True),(25768,True),(25769,True),(25770,True),(25771,True),(25772,True),(25773,True),(25774,True),(25775,True),(25776,True),(25777,True),(25778,True),(25779,True),(25780,True),(25781,True),(25782,True),(25783,True),(25784,True),(25785,True),(25786,True),(25787,True),(25788,True),(25789,True),(25790,True),(25791,True),(25792,True),(25793,True),(25794,True),(25795,True),(25796,True),(25797,True),(25798,True),(25799,True),(25800,True),(25801,True),(25802,True),(25803,True),(25804,True),(25805,True),(25806,True),(25807,True),(25808,True),(25809,True),(25810,True),(25811,True),(25812,True),(25813,True),(25814,True),(25815,True),(25816,True),(25817,True),(25818,True),(25819,True),(25820,True),(25821,True),(25822,True),(25823,True),(25824,True),(25825,True),(25826,True),(25827,True),(25828,True),(25829,True),(25830,True),(25831,True),(25832,True),(25833,True),(25834,True),(25835,True),(25836,True),(25837,True),(25838,True),(25839,True),(25840,True),(25841,True),(25842,True),(25843,True),(25844,True),(25845,True),(25846,True),(25847,True),(25848,True),(25849,True),(25850,True),(25851,True),(25852,True),(25853,True),(25854,True),(25855,True),(25856,True),(25857,True),(25858,True),(25859,True),(25860,True),(25861,True),(25862,True),(25863,True),(25864,True),(25865,True),(25866,True),(25867,True),(25868,True),(25869,True),(25870,True),(25871,True),(25872,True),(25873,True),(25874,True),(25875,True),(25876,True),(25877,True),(25878,True),(25879,True),(25880,True),(25881,True),(25882,True),(25883,True),(25884,True),(25885,True),(25886,True),(25887,True),(25888,True),(25889,True),(25890,True),(25891,True),(25892,True),(25893,True),(25894,True),(25895,True),(25896,True),(25897,True),(25898,True),(25899,True),(25900,True),(25901,True),(25902,True),(25903,True),(25904,True),(25905,True),(25906,True),(25907,True),(25908,True),(25909,True),(25910,True),(25911,True),(25912,True),(25913,True),(25914,True),(25915,True),(25916,True),(25917,True),(25918,True),(25919,True),(25920,True),(25921,True),(25922,True),(25923,True),(25924,True),(25925,True),(25926,True),(25927,True),(25928,True),(25929,True),(25930,True),(25931,True),(25932,True),(25933,True),(25934,True),(25935,True),(25936,True),(25937,True),(25938,True),(25939,True),(25940,True),(25941,True),(25942,True),(25943,True),(25944,True),(25945,True),(25946,True),(25947,True),(25948,True),(25949,True),(25950,True),(25951,True),(25952,True),(25953,True),(25954,True),(25955,True),(25956,True),(25957,True),(25958,True),(25959,True),(25960,True),(25961,True),(25962,True),(25963,True),(25964,True),(25965,True),(25966,True),(25967,True),(25968,True),(25969,True),(25970,True),(25971,True),(25972,True),(25973,True),(25974,True),(25975,True),(25976,True),(25977,True),(25978,True),(25979,True),(25980,True),(25981,True),(25982,True),(25983,True),(25984,True),(25985,True),(25986,True),(25987,True),(25988,True),(25989,True),(25990,True),(25991,True),(25992,True),(25993,True),(25994,True),(25995,True),(25996,True),(25997,True),(25998,True),(25999,True),(26000,True),(26001,True),(26002,True),(26003,True),(26004,True),(26005,True),(26006,True),(26007,True),(26008,True),(26009,True),(26010,True),(26011,True),(26012,True),(26013,True),(26014,True),(26015,True),(26016,True),(26017,True),(26018,True),(26019,True),(26020,True),(26021,True),(26022,True),(26023,True),(26024,True),(26025,True),(26026,True),(26027,True),(26028,True),(26029,True),(26030,True),(26031,True),(26032,True),(26033,True),(26034,True),(26035,True),(26036,True),(26037,True),(26038,True),(26039,True),(26040,True),(26041,True),(26042,True),(26043,True),(26044,True),(26045,True),(26046,True),(26047,True),(26048,True),(26049,True),(26050,True),(26051,True),(26052,True),(26053,True),(26054,True),(26055,True),(26056,True),(26057,True),(26058,True),(26059,True),(26060,True),(26061,True),(26062,True),(26063,True),(26064,True),(26065,True),(26066,True),(26067,True),(26068,True),(26069,True),(26070,True),(26071,True),(26072,True),(26073,True),(26074,True),(26075,True),(26076,True),(26077,True),(26078,True),(26079,True),(26080,True),(26081,True),(26082,True),(26083,True),(26084,True),(26085,True),(26086,True),(26087,True),(26088,True),(26089,True),(26090,True),(26091,True),(26092,True),(26093,True),(26094,True),(26095,True),(26096,True),(26097,True),(26098,True),(26099,True),(26100,True),(26101,True),(26102,True),(26103,True),(26104,True),(26105,True),(26106,True),(26107,True),(26108,True),(26109,True),(26110,True),(26111,True),(26112,True),(26113,True),(26114,True),(26115,True),(26116,True),(26117,True),(26118,True),(26119,True),(26120,True),(26121,True),(26122,True),(26123,True),(26124,True),(26125,True),(26126,True),(26127,True),(26128,True),(26129,True),(26130,True),(26131,True),(26132,True),(26133,True),(26134,True),(26135,True),(26136,True),(26137,True),(26138,True),(26139,True),(26140,True),(26141,True),(26142,True),(26143,True),(26144,True),(26145,True),(26146,True),(26147,True),(26148,True),(26149,True),(26150,True),(26151,True),(26152,True),(26153,True),(26154,True),(26155,True),(26156,True),(26157,True),(26158,True),(26159,True),(26160,True),(26161,True),(26162,True),(26163,True),(26164,True),(26165,True),(26166,True),(26167,True),(26168,True),(26169,True),(26170,True),(26171,True),(26172,True),(26173,True),(26174,True),(26175,True),(26176,True),(26177,True),(26178,True),(26179,True),(26180,True),(26181,True),(26182,True),(26183,True),(26184,True),(26185,True),(26186,True),(26187,True),(26188,True),(26189,True),(26190,True),(26191,True),(26192,True),(26193,True),(26194,True),(26195,True),(26196,True),(26197,True),(26198,True),(26199,True),(26200,True),(26201,True),(26202,True),(26203,True),(26204,True),(26205,True),(26206,True),(26207,True),(26208,True),(26209,True),(26210,True),(26211,True),(26212,True),(26213,True),(26214,True),(26215,True),(26216,True),(26217,True),(26218,True),(26219,True),(26220,True),(26221,True),(26222,True),(26223,True),(26224,True),(26225,True),(26226,True),(26227,True),(26228,True),(26229,True),(26230,True),(26231,True),(26232,True),(26233,True),(26234,True),(26235,True),(26236,True),(26237,True),(26238,True),(26239,True),(26240,True),(26241,True),(26242,True),(26243,True),(26244,True),(26245,True),(26246,True),(26247,True),(26248,True),(26249,True),(26250,True),(26251,True),(26252,True),(26253,True),(26254,True),(26255,True),(26256,True),(26257,True),(26258,True),(26259,True),(26260,True),(26261,True),(26262,True),(26263,True),(26264,True),(26265,True),(26266,True),(26267,True),(26268,True),(26269,True),(26270,True),(26271,True),(26272,True),(26273,True),(26274,True),(26275,True),(26276,True),(26277,True),(26278,True),(26279,True),(26280,True),(26281,True),(26282,True),(26283,True),(26284,True),(26285,True),(26286,True),(26287,True),(26288,True),(26289,True),(26290,True),(26291,True),(26292,True),(26293,True),(26294,True),(26295,True),(26296,True),(26297,True),(26298,True),(26299,True),(26300,True),(26301,True),(26302,True),(26303,True),(26304,True),(26305,True),(26306,True),(26307,True),(26308,True),(26309,True),(26310,True),(26311,True),(26312,True),(26313,True),(26314,True),(26315,True),(26316,True),(26317,True),(26318,True),(26319,True),(26320,True),(26321,True),(26322,True),(26323,True),(26324,True),(26325,True),(26326,True),(26327,True),(26328,True),(26329,True),(26330,True),(26331,True),(26332,True),(26333,True),(26334,True),(26335,True),(26336,True),(26337,True),(26338,True),(26339,True),(26340,True),(26341,True),(26342,True),(26343,True),(26344,True),(26345,True),(26346,True),(26347,True),(26348,True),(26349,True),(26350,True),(26351,True),(26352,True),(26353,True),(26354,True),(26355,True),(26356,True),(26357,True),(26358,True),(26359,True),(26360,True),(26361,True),(26362,True),(26363,True),(26364,True),(26365,True),(26366,True),(26367,True),(26368,True),(26369,True),(26370,True),(26371,True),(26372,True),(26373,True),(26374,True),(26375,True),(26376,True),(26377,True),(26378,True),(26379,True),(26380,True),(26381,True),(26382,True),(26383,True),(26384,True),(26385,True),(26386,True),(26387,True),(26388,True),(26389,True),(26390,True),(26391,True),(26392,True),(26393,True),(26394,True),(26395,True),(26396,True),(26397,True),(26398,True),(26399,True),(26400,True),(26401,True),(26402,True),(26403,True),(26404,True),(26405,True),(26406,True),(26407,True),(26408,True),(26409,True),(26410,True),(26411,True),(26412,True),(26413,True),(26414,True),(26415,True),(26416,True),(26417,True),(26418,True),(26419,True),(26420,True),(26421,True),(26422,True),(26423,True),(26424,True),(26425,True),(26426,True),(26427,True),(26428,True),(26429,True),(26430,True),(26431,True),(26432,True),(26433,True),(26434,True),(26435,True),(26436,True),(26437,True),(26438,True),(26439,True),(26440,True),(26441,True),(26442,True),(26443,True),(26444,True),(26445,True),(26446,True),(26447,True),(26448,True),(26449,True),(26450,True),(26451,True),(26452,True),(26453,True),(26454,True),(26455,True),(26456,True),(26457,True),(26458,True),(26459,True),(26460,True),(26461,True),(26462,True),(26463,True),(26464,True),(26465,True),(26466,True),(26467,True),(26468,True),(26469,True),(26470,True),(26471,True),(26472,True),(26473,True),(26474,True),(26475,True),(26476,True),(26477,True),(26478,True),(26479,True),(26480,True),(26481,True),(26482,True),(26483,True),(26484,True),(26485,True),(26486,True),(26487,True),(26488,True),(26489,True),(26490,True),(26491,True),(26492,True),(26493,True),(26494,True),(26495,True),(26496,True),(26497,True),(26498,True),(26499,True),(26500,True),(26501,True),(26502,True),(26503,True),(26504,True),(26505,True),(26506,True),(26507,True),(26508,True),(26509,True),(26510,True),(26511,True),(26512,True),(26513,True),(26514,True),(26515,True),(26516,True),(26517,True),(26518,True),(26519,True),(26520,True),(26521,True),(26522,True),(26523,True),(26524,True),(26525,True),(26526,True),(26527,True),(26528,True),(26529,True),(26530,True),(26531,True),(26532,True),(26533,True),(26534,True),(26535,True),(26536,True),(26537,True),(26538,True),(26539,True),(26540,True),(26541,True),(26542,True),(26543,True),(26544,True),(26545,True),(26546,True),(26547,True),(26548,True),(26549,True),(26550,True),(26551,True),(26552,True),(26553,True),(26554,True),(26555,True),(26556,True),(26557,True),(26558,True),(26559,True),(26560,True),(26561,True),(26562,True),(26563,True),(26564,True),(26565,True),(26566,True),(26567,True),(26568,True),(26569,True),(26570,True),(26571,True),(26572,True),(26573,True),(26574,True),(26575,True),(26576,True),(26577,True),(26578,True),(26579,True),(26580,True),(26581,True),(26582,True),(26583,True),(26584,True),(26585,True),(26586,True),(26587,True),(26588,True),(26589,True),(26590,True),(26591,True),(26592,True),(26593,True),(26594,True),(26595,True),(26596,True),(26597,True),(26598,True),(26599,True),(26600,True),(26601,True),(26602,True),(26603,True),(26604,True),(26605,True),(26606,True),(26607,True),(26608,True),(26609,True),(26610,True),(26611,True),(26612,True),(26613,True),(26614,True),(26615,True),(26616,True),(26617,True),(26618,True),(26619,True),(26620,True),(26621,True),(26622,True),(26623,True),(26624,True),(26625,True),(26626,True),(26627,True),(26628,True),(26629,True),(26630,True),(26631,True),(26632,True),(26633,True),(26634,True),(26635,True),(26636,True),(26637,True),(26638,True),(26639,True),(26640,True),(26641,True),(26642,True),(26643,True),(26644,True),(26645,True),(26646,True),(26647,True),(26648,True),(26649,True),(26650,True),(26651,True),(26652,True),(26653,True),(26654,True),(26655,True),(26656,True),(26657,True),(26658,True),(26659,True),(26660,True),(26661,True),(26662,True),(26663,True),(26664,True),(26665,True),(26666,True),(26667,True),(26668,True),(26669,True),(26670,True),(26671,True),(26672,True),(26673,True),(26674,True),(26675,True),(26676,True),(26677,True),(26678,True),(26679,True),(26680,True),(26681,True),(26682,True),(26683,True),(26684,True),(26685,True),(26686,True),(26687,True),(26688,True),(26689,True),(26690,True),(26691,True),(26692,True),(26693,True),(26694,True),(26695,True),(26696,True),(26697,True),(26698,True),(26699,True),(26700,True),(26701,True),(26702,True),(26703,True),(26704,True),(26705,True),(26706,True),(26707,True),(26708,True),(26709,True),(26710,True),(26711,True),(26712,True),(26713,True),(26714,True),(26715,True),(26716,True),(26717,True),(26718,True),(26719,True),(26720,True),(26721,True),(26722,True),(26723,True),(26724,True),(26725,True),(26726,True),(26727,True),(26728,True),(26729,True),(26730,True),(26731,True),(26732,True),(26733,True),(26734,True),(26735,True),(26736,True),(26737,True),(26738,True),(26739,True),(26740,True),(26741,True),(26742,True),(26743,True),(26744,True),(26745,True),(26746,True),(26747,True),(26748,True),(26749,True),(26750,True),(26751,True),(26752,True),(26753,True),(26754,True),(26755,True),(26756,True),(26757,True),(26758,True),(26759,True),(26760,True),(26761,True),(26762,True),(26763,True),(26764,True),(26765,True),(26766,True),(26767,True),(26768,True),(26769,True),(26770,True),(26771,True),(26772,True),(26773,True),(26774,True),(26775,True),(26776,True),(26777,True),(26778,True),(26779,True),(26780,True),(26781,True),(26782,True),(26783,True),(26784,True),(26785,True),(26786,True),(26787,True),(26788,True),(26789,True),(26790,True),(26791,True),(26792,True),(26793,True),(26794,True),(26795,True),(26796,True),(26797,True),(26798,True),(26799,True),(26800,True),(26801,True),(26802,True),(26803,True),(26804,True),(26805,True),(26806,True),(26807,True),(26808,True),(26809,True),(26810,True),(26811,True),(26812,True),(26813,True),(26814,True),(26815,True),(26816,True),(26817,True),(26818,True),(26819,True),(26820,True),(26821,True),(26822,True),(26823,True),(26824,True),(26825,True),(26826,True),(26827,True),(26828,True),(26829,True),(26830,True),(26831,True),(26832,True),(26833,True),(26834,True),(26835,True),(26836,True),(26837,True),(26838,True),(26839,True),(26840,True),(26841,True),(26842,True),(26843,True),(26844,True),(26845,True),(26846,True),(26847,True),(26848,True),(26849,True),(26850,True),(26851,True),(26852,True),(26853,True),(26854,True),(26855,True),(26856,True),(26857,True),(26858,True),(26859,True),(26860,True),(26861,True),(26862,True),(26863,True),(26864,True),(26865,True),(26866,True),(26867,True),(26868,True),(26869,True),(26870,True),(26871,True),(26872,True),(26873,True),(26874,True),(26875,True),(26876,True),(26877,True),(26878,True),(26879,True),(26880,True),(26881,True),(26882,True),(26883,True),(26884,True),(26885,True),(26886,True),(26887,True),(26888,True),(26889,True),(26890,True),(26891,True),(26892,True),(26893,True),(26894,True),(26895,True),(26896,True),(26897,True),(26898,True),(26899,True),(26900,True),(26901,True),(26902,True),(26903,True),(26904,True),(26905,True),(26906,True),(26907,True),(26908,True),(26909,True),(26910,True),(26911,True),(26912,True),(26913,True),(26914,True),(26915,True),(26916,True),(26917,True),(26918,True),(26919,True),(26920,True),(26921,True),(26922,True),(26923,True),(26924,True),(26925,True),(26926,True),(26927,True),(26928,True),(26929,True),(26930,True),(26931,True),(26932,True),(26933,True),(26934,True),(26935,True),(26936,True),(26937,True),(26938,True),(26939,True),(26940,True),(26941,True),(26942,True),(26943,True),(26944,True),(26945,True),(26946,True),(26947,True),(26948,True),(26949,True),(26950,True),(26951,True),(26952,True),(26953,True),(26954,True),(26955,True),(26956,True),(26957,True),(26958,True),(26959,True),(26960,True),(26961,True),(26962,True),(26963,True),(26964,True),(26965,True),(26966,True),(26967,True),(26968,True),(26969,True),(26970,True),(26971,True),(26972,True),(26973,True),(26974,True),(26975,True),(26976,True),(26977,True),(26978,True),(26979,True),(26980,True),(26981,True),(26982,True),(26983,True),(26984,True),(26985,True),(26986,True),(26987,True),(26988,True),(26989,True),(26990,True),(26991,True),(26992,True),(26993,True),(26994,True),(26995,True),(26996,True),(26997,True),(26998,True),(26999,True),(27000,True),(27001,True),(27002,True),(27003,True),(27004,True),(27005,True),(27006,True),(27007,True),(27008,True),(27009,True),(27010,True),(27011,True),(27012,True),(27013,True),(27014,True),(27015,True),(27016,True),(27017,True),(27018,True),(27019,True),(27020,True),(27021,True),(27022,True),(27023,True),(27024,True),(27025,True),(27026,True),(27027,True),(27028,True),(27029,True),(27030,True),(27031,True),(27032,True),(27033,True),(27034,True),(27035,True),(27036,True),(27037,True),(27038,True),(27039,True),(27040,True),(27041,True),(27042,True),(27043,True),(27044,True),(27045,True),(27046,True),(27047,True),(27048,True),(27049,True),(27050,True),(27051,True),(27052,True),(27053,True),(27054,True),(27055,True),(27056,True),(27057,True),(27058,True),(27059,True),(27060,True),(27061,True),(27062,True),(27063,True),(27064,True),(27065,True),(27066,True),(27067,True),(27068,True),(27069,True),(27070,True),(27071,True),(27072,True),(27073,True),(27074,True),(27075,True),(27076,True),(27077,True),(27078,True),(27079,True),(27080,True),(27081,True),(27082,True),(27083,True),(27084,True),(27085,True),(27086,True),(27087,True),(27088,True),(27089,True),(27090,True),(27091,True),(27092,True),(27093,True),(27094,True),(27095,True),(27096,True),(27097,True),(27098,True),(27099,True),(27100,True),(27101,True),(27102,True),(27103,True),(27104,True),(27105,True),(27106,True),(27107,True),(27108,True),(27109,True),(27110,True),(27111,True),(27112,True),(27113,True),(27114,True),(27115,True),(27116,True),(27117,True),(27118,True),(27119,True),(27120,True),(27121,True),(27122,True),(27123,True),(27124,True),(27125,True),(27126,True),(27127,True),(27128,True),(27129,True),(27130,True),(27131,True),(27132,True),(27133,True),(27134,True),(27135,True),(27136,True),(27137,True),(27138,True),(27139,True),(27140,True),(27141,True),(27142,True),(27143,True),(27144,True),(27145,True),(27146,True),(27147,True),(27148,True),(27149,True),(27150,True),(27151,True),(27152,True),(27153,True),(27154,True),(27155,True),(27156,True),(27157,True),(27158,True),(27159,True),(27160,True),(27161,True),(27162,True),(27163,True),(27164,True),(27165,True),(27166,True),(27167,True),(27168,True),(27169,True),(27170,True),(27171,True),(27172,True),(27173,True),(27174,True),(27175,True),(27176,True),(27177,True),(27178,True),(27179,True),(27180,True),(27181,True),(27182,True),(27183,True),(27184,True),(27185,True),(27186,True),(27187,True),(27188,True),(27189,True),(27190,True),(27191,True),(27192,True),(27193,True),(27194,True),(27195,True),(27196,True),(27197,True),(27198,True),(27199,True),(27200,True),(27201,True),(27202,True),(27203,True),(27204,True),(27205,True),(27206,True),(27207,True),(27208,True),(27209,True),(27210,True),(27211,True),(27212,True),(27213,True),(27214,True),(27215,True),(27216,True),(27217,True),(27218,True),(27219,True),(27220,True),(27221,True),(27222,True),(27223,True),(27224,True),(27225,True),(27226,True),(27227,True),(27228,True),(27229,True),(27230,True),(27231,True),(27232,True),(27233,True),(27234,True),(27235,True),(27236,True),(27237,True),(27238,True),(27239,True),(27240,True),(27241,True),(27242,True),(27243,True),(27244,True),(27245,True),(27246,True),(27247,True),(27248,True),(27249,True),(27250,True),(27251,True),(27252,True),(27253,True),(27254,True),(27255,True),(27256,True),(27257,True),(27258,True),(27259,True),(27260,True),(27261,True),(27262,True),(27263,True),(27264,True),(27265,True),(27266,True),(27267,True),(27268,True),(27269,True),(27270,True),(27271,True),(27272,True),(27273,True),(27274,True),(27275,True),(27276,True),(27277,True),(27278,True),(27279,True),(27280,True),(27281,True),(27282,True),(27283,True),(27284,True),(27285,True),(27286,True),(27287,True),(27288,True),(27289,True),(27290,True),(27291,True),(27292,True),(27293,True),(27294,True),(27295,True),(27296,True),(27297,True),(27298,True),(27299,True),(27300,True),(27301,True),(27302,True),(27303,True),(27304,True),(27305,True),(27306,True),(27307,True),(27308,True),(27309,True),(27310,True),(27311,True),(27312,True),(27313,True),(27314,True),(27315,True),(27316,True),(27317,True),(27318,True),(27319,True),(27320,True),(27321,True),(27322,True),(27323,True),(27324,True),(27325,True),(27326,True),(27327,True),(27328,True),(27329,True),(27330,True),(27331,True),(27332,True),(27333,True),(27334,True),(27335,True),(27336,True),(27337,True),(27338,True),(27339,True),(27340,True),(27341,True),(27342,True),(27343,True),(27344,True),(27345,True),(27346,True),(27347,True),(27348,True),(27349,True),(27350,True),(27351,True),(27352,True),(27353,True),(27354,True),(27355,True),(27356,True),(27357,True),(27358,True),(27359,True),(27360,True),(27361,True),(27362,True),(27363,True),(27364,True),(27365,True),(27366,True),(27367,True),(27368,True),(27369,True),(27370,True),(27371,True),(27372,True),(27373,True),(27374,True),(27375,True),(27376,True),(27377,True),(27378,True),(27379,True),(27380,True),(27381,True),(27382,True),(27383,True),(27384,True),(27385,True),(27386,True),(27387,True),(27388,True),(27389,True),(27390,True),(27391,True),(27392,True),(27393,True),(27394,True),(27395,True),(27396,True),(27397,True),(27398,True),(27399,True),(27400,True),(27401,True),(27402,True),(27403,True),(27404,True),(27405,True),(27406,True),(27407,True),(27408,True),(27409,True),(27410,True),(27411,True),(27412,True),(27413,True),(27414,True),(27415,True),(27416,True),(27417,True),(27418,True),(27419,True),(27420,True),(27421,True),(27422,True),(27423,True),(27424,True),(27425,True),(27426,True),(27427,True),(27428,True),(27429,True),(27430,True),(27431,True),(27432,True),(27433,True),(27434,True),(27435,True),(27436,True),(27437,True),(27438,True),(27439,True),(27440,True),(27441,True),(27442,True),(27443,True),(27444,True),(27445,True),(27446,True),(27447,True),(27448,True),(27449,True),(27450,True),(27451,True),(27452,True),(27453,True),(27454,True),(27455,True),(27456,True),(27457,True),(27458,True),(27459,True),(27460,True),(27461,True),(27462,True),(27463,True),(27464,True),(27465,True),(27466,True),(27467,True),(27468,True),(27469,True),(27470,True),(27471,True),(27472,True),(27473,True),(27474,True),(27475,True),(27476,True),(27477,True),(27478,True),(27479,True),(27480,True),(27481,True),(27482,True),(27483,True),(27484,True),(27485,True),(27486,True),(27487,True),(27488,True),(27489,True),(27490,True),(27491,True),(27492,True),(27493,True),(27494,True),(27495,True),(27496,True),(27497,True),(27498,True),(27499,True),(27500,True),(27501,True),(27502,True),(27503,True),(27504,True),(27505,True),(27506,True),(27507,True),(27508,True),(27509,True),(27510,True),(27511,True),(27512,True),(27513,True),(27514,True),(27515,True),(27516,True),(27517,True),(27518,True),(27519,True),(27520,True),(27521,True),(27522,True),(27523,True),(27524,True),(27525,True),(27526,True),(27527,True),(27528,True),(27529,True),(27530,True),(27531,True),(27532,True),(27533,True),(27534,True),(27535,True),(27536,True),(27537,True),(27538,True),(27539,True),(27540,True),(27541,True),(27542,True),(27543,True),(27544,True),(27545,True),(27546,True),(27547,True),(27548,True),(27549,True),(27550,True),(27551,True),(27552,True),(27553,True),(27554,True),(27555,True),(27556,True),(27557,True),(27558,True),(27559,True),(27560,True),(27561,True),(27562,True),(27563,True),(27564,True),(27565,True),(27566,True),(27567,True),(27568,True),(27569,True),(27570,True),(27571,True),(27572,True),(27573,True),(27574,True),(27575,True),(27576,True),(27577,True),(27578,True),(27579,True),(27580,True),(27581,True),(27582,True),(27583,True),(27584,True),(27585,True),(27586,True),(27587,True),(27588,True),(27589,True),(27590,True),(27591,True),(27592,True),(27593,True),(27594,True),(27595,True),(27596,True),(27597,True),(27598,True),(27599,True),(27600,True),(27601,True),(27602,True),(27603,True),(27604,True),(27605,True),(27606,True),(27607,True),(27608,True),(27609,True),(27610,True),(27611,True),(27612,True),(27613,True),(27614,True),(27615,True),(27616,True),(27617,True),(27618,True),(27619,True),(27620,True),(27621,True),(27622,True),(27623,True),(27624,True),(27625,True),(27626,True),(27627,True),(27628,True),(27629,True),(27630,True),(27631,True),(27632,True),(27633,True),(27634,True),(27635,True),(27636,True),(27637,True),(27638,True),(27639,True),(27640,True),(27641,True),(27642,True),(27643,True),(27644,True),(27645,True),(27646,True),(27647,True),(27648,True),(27649,True),(27650,True),(27651,True),(27652,True),(27653,True),(27654,True),(27655,True),(27656,True),(27657,True),(27658,True),(27659,True),(27660,True),(27661,True),(27662,True),(27663,True),(27664,True),(27665,True),(27666,True),(27667,True),(27668,True),(27669,True),(27670,True),(27671,True),(27672,True),(27673,True),(27674,True),(27675,True),(27676,True),(27677,True),(27678,True),(27679,True),(27680,True),(27681,True),(27682,True),(27683,True),(27684,True),(27685,True),(27686,True),(27687,True),(27688,True),(27689,True),(27690,True),(27691,True),(27692,True),(27693,True),(27694,True),(27695,True),(27696,True),(27697,True),(27698,True),(27699,True),(27700,True),(27701,True),(27702,True),(27703,True),(27704,True),(27705,True),(27706,True),(27707,True),(27708,True),(27709,True),(27710,True),(27711,True),(27712,True),(27713,True),(27714,True),(27715,True),(27716,True),(27717,True),(27718,True),(27719,True),(27720,True),(27721,True),(27722,True),(27723,True),(27724,True),(27725,True),(27726,True),(27727,True),(27728,True),(27729,True),(27730,True),(27731,True),(27732,True),(27733,True),(27734,True),(27735,True),(27736,True),(27737,True),(27738,True),(27739,True),(27740,True),(27741,True),(27742,True),(27743,True),(27744,True),(27745,True),(27746,True),(27747,True),(27748,True),(27749,True),(27750,True),(27751,True),(27752,True),(27753,True),(27754,True),(27755,True),(27756,True),(27757,True),(27758,True),(27759,True),(27760,True),(27761,True),(27762,True),(27763,True),(27764,True),(27765,True),(27766,True),(27767,True),(27768,True),(27769,True),(27770,True),(27771,True),(27772,True),(27773,True),(27774,True),(27775,True),(27776,True),(27777,True),(27778,True),(27779,True),(27780,True),(27781,True),(27782,True),(27783,True),(27784,True),(27785,True),(27786,True),(27787,True),(27788,True),(27789,True),(27790,True),(27791,True),(27792,True),(27793,True),(27794,True),(27795,True),(27796,True),(27797,True),(27798,True),(27799,True),(27800,True),(27801,True),(27802,True),(27803,True),(27804,True),(27805,True),(27806,True),(27807,True),(27808,True),(27809,True),(27810,True),(27811,True),(27812,True),(27813,True),(27814,True),(27815,True),(27816,True),(27817,True),(27818,True),(27819,True),(27820,True),(27821,True),(27822,True),(27823,True),(27824,True),(27825,True),(27826,True),(27827,True),(27828,True),(27829,True),(27830,True),(27831,True),(27832,True),(27833,True),(27834,True),(27835,True),(27836,True),(27837,True),(27838,True),(27839,True),(27840,True),(27841,True),(27842,True),(27843,True),(27844,True),(27845,True),(27846,True),(27847,True),(27848,True),(27849,True),(27850,True),(27851,True),(27852,True),(27853,True),(27854,True),(27855,True),(27856,True),(27857,True),(27858,True),(27859,True),(27860,True),(27861,True),(27862,True),(27863,True),(27864,True),(27865,True),(27866,True),(27867,True),(27868,True),(27869,True),(27870,True),(27871,True),(27872,True),(27873,True),(27874,True),(27875,True),(27876,True),(27877,True),(27878,True),(27879,True),(27880,True),(27881,True),(27882,True),(27883,True),(27884,True),(27885,True),(27886,True),(27887,True),(27888,True),(27889,True),(27890,True),(27891,True),(27892,True),(27893,True),(27894,True),(27895,True),(27896,True),(27897,True),(27898,True),(27899,True),(27900,True),(27901,True),(27902,True),(27903,True),(27904,True),(27905,True),(27906,True),(27907,True),(27908,True),(27909,True),(27910,True),(27911,True),(27912,True),(27913,True),(27914,True),(27915,True),(27916,True),(27917,True),(27918,True),(27919,True),(27920,True),(27921,True),(27922,True),(27923,True),(27924,True),(27925,True),(27926,True),(27927,True),(27928,True),(27929,True),(27930,True),(27931,True),(27932,True),(27933,True),(27934,True),(27935,True),(27936,True),(27937,True),(27938,True),(27939,True),(27940,True),(27941,True),(27942,True),(27943,True),(27944,True),(27945,True),(27946,True),(27947,True),(27948,True),(27949,True),(27950,True),(27951,True),(27952,True),(27953,True),(27954,True),(27955,True),(27956,True),(27957,True),(27958,True),(27959,True),(27960,True),(27961,True),(27962,True),(27963,True),(27964,True),(27965,True),(27966,True),(27967,True),(27968,True),(27969,True),(27970,True),(27971,True),(27972,True),(27973,True),(27974,True),(27975,True),(27976,True),(27977,True),(27978,True),(27979,True),(27980,True),(27981,True),(27982,True),(27983,True),(27984,True),(27985,True),(27986,True),(27987,True),(27988,True),(27989,True),(27990,True),(27991,True),(27992,True),(27993,True),(27994,True),(27995,True),(27996,True),(27997,True),(27998,True),(27999,True),(28000,True),(28001,True),(28002,True),(28003,True),(28004,True),(28005,True),(28006,True),(28007,True),(28008,True),(28009,True),(28010,True),(28011,True),(28012,True),(28013,True),(28014,True),(28015,True),(28016,True),(28017,True),(28018,True),(28019,True),(28020,True),(28021,True),(28022,True),(28023,True),(28024,True),(28025,True),(28026,True),(28027,True),(28028,True),(28029,True),(28030,True),(28031,True),(28032,True),(28033,True),(28034,True),(28035,True),(28036,True),(28037,True),(28038,True),(28039,True),(28040,True),(28041,True),(28042,True),(28043,True),(28044,True),(28045,True),(28046,True),(28047,True),(28048,True),(28049,True),(28050,True),(28051,True),(28052,True),(28053,True),(28054,True),(28055,True),(28056,True),(28057,True),(28058,True),(28059,True),(28060,True),(28061,True),(28062,True),(28063,True),(28064,True),(28065,True),(28066,True),(28067,True),(28068,True),(28069,True),(28070,True),(28071,True),(28072,True),(28073,True),(28074,True),(28075,True),(28076,True),(28077,True),(28078,True),(28079,True),(28080,True),(28081,True),(28082,True),(28083,True),(28084,True),(28085,True),(28086,True),(28087,True),(28088,True),(28089,True),(28090,True),(28091,True),(28092,True),(28093,True),(28094,True),(28095,True),(28096,True),(28097,True),(28098,True),(28099,True),(28100,True),(28101,True),(28102,True),(28103,True),(28104,True),(28105,True),(28106,True),(28107,True),(28108,True),(28109,True),(28110,True),(28111,True),(28112,True),(28113,True),(28114,True),(28115,True),(28116,True),(28117,True),(28118,True),(28119,True),(28120,True),(28121,True),(28122,True),(28123,True)]"}
{"code": "{-\n - caesar.hs\n -\n - Implements a caesar cipher encoder (and decoder), as well as a cracker built\n - using a frequency table.\n - From Graham Hutton's \"Programming in Haskell.\"\n - Modified (per last exercise in chapter 5) to \"handle upper-case letters\" by\n - switching letters to lowercase in let2int.\n -\n - GRE, 7/24/10\n -}\n-- for ord and chr\nimport Data.Char\n\n-- en/decoding groundwork\nlet2int :: Char -> Int\nlet2int c = ord (toLower c) - ord 'a'\n\nint2let :: Int -> Char\nint2let n = chr (ord 'a' + n)\n\nshift :: Int -> Char -> Char\nshift n c | isLetter c = int2let ((let2int c + n) `mod` 26)\n          | otherwise  = c\n\n-- encoding\nencode :: Int -> String -> String\nencode n xs = [ shift n x | x <- xs ]\n\n-- decoding\ndecode :: Int -> String -> String\ndecode n xs = [ shift (-n) x | x <- xs ]\n\n-- cracking groundwork\npositions :: (Eq a) => a -> [a] -> [Int]\npositions x xs = [ i | (x', i) <- zip xs [0 .. n], x == x' ]\n  where n = length xs - 1\n\nlowers :: String -> Int\nlowers xs = length [ x | x <- xs, isLower x ]\n\ncount :: Char -> String -> Int\ncount x xs = length [ x' | x' <- xs, x == x' ]\n\ntable :: [Float]\ntable =\n  [ 8.2\n  , 1.5\n  , 2.8\n  , 4.3\n  , 12.7\n  , 2.2\n  , 2.0\n  , 6.1\n  , 7.0\n  , 0.2\n  , 0.8\n  , 4.0\n  , 2.4\n  , 6.7\n  , 7.5\n  , 1.9\n  , 0.1\n  , 6.0\n  , 6.3\n  , 9.1\n  , 2.8\n  , 1.0\n  , 2.4\n  , 0.2\n  , 2.0\n  , 0.1\n  ]\n\npercent :: Int -> Int -> Float\npercent n m = (fromIntegral n / fromIntegral m) * 100\n\nfreqs :: String -> [Float]\nfreqs xs = [ percent (count x xs) n | x <- ['a' .. 'z'] ] where n = lowers xs\n\nchisqr :: [Float] -> [Float] -> Float\nchisqr os es = sum [ ((o - e) ^ 2) / e | (o, e) <- zip os es ]\n\nrotate :: Int -> [a] -> [a]\nrotate n xs = drop n xs ++ take n xs\n\n-- cracking\ncrack :: String -> String\ncrack xs = decode factor xs\n where\n  factor = head (positions (minimum chitab) chitab)\n  chitab = [ chisqr (rotate n table') table | n <- [0 .. 25] ]\n  table' = freqs xs\n", "input": "'a'", "status": "success", "output": "0"}
{"code": "--Fun\u00e7\u00e3o Recursiva\nf :: (Int,Int) -> Int\nf (n,k) \n\t|k == 1 = n\n\t|k == n = 1\n\t|1<k && k<n = f(n-1,k-1) + f(n-1,k)\n\t|otherwise = 0\n--\n\n--Correspond\u00eancia de Padr\u00e3o\nf1 :: (Int, Int) -> Int\nf1 (n,1) = n\nf1 (n,k) = if k == 1 then 1 else \n\t\t   if (1<k) && (k<n) then f(n-1,k-1) + f(n-1,k) else 0\n--\n\n--Fun\u00e7\u00e3o Recursiva\ng :: (Int,Int,Int) -> Int\ng (n,p,q)\n\t|n == 0 = 2\n\t|n == 1 = p\n\t|n > 1 = p*g(n-1,p,q) - q*g(n-1,p,q)\n\t|otherwise = 0\n--\n\n--Fun\u00e7\u00e3o Recursiva\nh :: Int -> Int\nh n\n\t| n == 1 = 1\n\t| n > 1 = 2*h(n-1)+1\n\t| otherwise = 0\n--\n\n--Correspond\u00eancia de Padr\u00e3o\nh1 :: Int -> Int\nh1 1 = 1\nh1 n = if (n>1) then 2*(h1(n-1))+1 else 0\n--    \n\n--Fun\u00e7\u00e3o Recursiva\ncomb :: (Int,Int) -> Int\ncomb (n,k)\n    |k == 1 = n\n    |k == n = 1\n    |(1 < k) && (k < n) = comb(n-1, k-1) + comb(n-1, 5)\n    |otherwise = 0\n    \n--Obs: Program error: pattern match failure: comb (0,5), sem otherwise;\n--\n\n--Correspond\u00eancia de Padr\u00e3o\ncomb1 :: (Int,Int) -> Int\ncomb1 (n,k) = if (k==1) then n else\n              if (k==n) then 1 else\n              if (1<k) && (k<n) then comb(n-1, k-1) + comb(n-1, 5) else 0\n--\n\n--Fun\u00e7\u00e3o Recursiva        \na :: (Int,Int) -> Int\na (m,n)\n    |m==0 = n+1\n    |m>0 && n==0 = a(m-1,1)\n    |m>0 && n>0 = a(m-1, a(m,n-1))\n    |otherwise = 0\n--\n\n--Correspond\u00eancia de Padr\u00e3o\na1 :: (Int,Int) -> Int\na1 (0,n) = n+1\na1 (m,n) = if(m>0)&&(n==0) then a1(m-1,1) else\n           if(m>0)&&(n>0)  then a1(m-1,a1(m,n-1)) else 0\n--\n\n--Fun\u00e7\u00e3o Recursiva\nsoma_mult :: Int -> Int\nsoma_mult x\n    |x==0 = 0\n    |x==1 = 0\n    |x==2 = 0\n    |mod x 3 /= 0 = soma_mult(x-1)\n    |mod x 3 == 0 = soma_mult(x-1)+ x + 0\n    |otherwise = 999\n--\n\n--Correspond\u00eancia de Padr\u00e3o\nsoma_mult1 :: Int -> Int\nsoma_mult1 x = if x==0 then 0 else\n               if x==1 then 0 else\n               if x==2 then 0 else\n               if mod x 3 /= 0 then soma_mult1(x-1) else\n               if mod x 3 == 0 then soma_mult(x-1)+x+0 else 999\n--\n    ", "input": "(42, 42)", "status": "success", "output": "1"}
{"code": "data Trivial = \n  Trivial'\n\ninstance Eq Trivial where\n  Trivial' == Trivial' = True\n\ndata DayOfWeek =\n  Mon | Tue | Wed | Thu | Fri | Sat | Sun\n  deriving (Show)\n\n-- Day of week and numerical day of month\n\ndata Date =\n  Date DayOfWeek Int\n\ninstance Eq DayOfWeek where\n  (==) Mon Mon = True\n  (==) Tue Tue = True\n  (==) Wed Wed = True\n  (==) Thu Thu = True\n  (==) Fri Fri = True\n  (==) Sat Sat = True\n  (==) Sun Sun = True\n  (==) _ _     = False\n\ninstance Ord DayOfWeek where\n  compare Fri Fri = EQ\n  compare Fri _ = GT\n  compare _ Fri = LT\n  compare _ _ = EQ\n\n\ninstance Eq Date where\n  (==) (Date weekday monthNum)\n       (Date weekday' monthNum') =\n    weekday == weekday' && monthNum == monthNum'\n\n\nf :: Int -> Bool\nf 1 = True\nf 2 = True\nf _ = False\n\ndata Identity a =\n  Identity a\n\ninstance Eq a => Eq (Identity a) where\n  (==) (Identity v) (Identity v') = v == v'\n\ndata TisAnInteger =\n  TisAn Integer\n\ninstance Eq TisAnInteger where\n  (==) (TisAn a) (TisAn a') = a == a'\n\ndata TwoIntegers =\n  Two Integer Integer\n\ninstance Eq TwoIntegers where\n  (==) (Two a b) (Two a' b') =\n    a == a' && b == b'\n\ndata StringOrInt =\n  TisAnInt Int\n  | TisAString String\n\ninstance Eq StringOrInt where\n  (==) (TisAnInt a) (TisAnInt a') = a == a'\n  (==) (TisAString a) (TisAString a') = a == a'\n  (==) _ _ = False\n\ndata Pair a =\n  Pair a a\n\ninstance Eq a => Eq (Pair a) where\n  (==) (Pair a a') (Pair b b') = a == b && a' == b'\n\ndata Tuple a b =\n  Tuple a b\n\ninstance (Eq a, Eq b) => Eq (Tuple a b) where\n  (==) (Tuple a a') (Tuple b b') = a == b && a' == b'\n\ndata Which a =\n    ThisOne a\n    | ThatOne a\n\ninstance Eq a => Eq (Which a) where\n  (==) (ThisOne a) (ThisOne a') = a == a'\n  (==) (ThatOne a) (ThatOne a') = a == a'\n  (==) _ _ = False\n\ndata EitherOr a b =\n  Hello a\n  | Goodbye b\n\ninstance (Eq a, Eq b) => Eq (EitherOr a b) where\n  (==) (Hello a) (Hello a') = a == a'\n  (==) (Goodbye a) (Goodbye a') = a == a'\n  (==) _ _ = False\n", "input": "42", "status": "success", "output": "False"}
{"code": "-- Solutions for the exercises of the SLIDES \"Programming In Haskell\" by Graham Hutton: CHAPTER 6 (Recursive Functions)\n\n{--\n(1)\nWithout looking at the standard prelude, define the following library functions using recursion:\n\nDecide if all logical values in a list are true:\nand :: [Bool] -> Bool\n\nConcatenate a list of lists:\nconcat :: [[a]] -> [a]\n\nProduce a list with n identical elements:\nreplicate :: Int -> a -> [a]\n\nSelect the nth element of a list:\n(!!) :: [a] -> Int -> a\n\nDecide if a value is an element of a list:\nelem :: Eq a => a -> [a] -> Bool\n--}\n\nand' :: [Bool] -> Bool\nand' [] = True\nand' (True:bs) = and' bs\nand' (False:bs) = False\n\nconcat' :: [[a]] -> [a]\nconcat' [] = []\nconcat' (xs:xss) = xs ++ concat' xss\n\nreplicate' :: Int -> a -> [a]\nreplicate' 0 x = []\nreplicate' n x = x : replicate' (n-1) x\n\nidx :: [a] -> Int -> a\nidx (x:xs) 1 = x\nidx (x:xs) i = idx xs (i-1) \n\nelem' :: (Eq a) => a -> [a] -> Bool\nelem' e [] = False\n--elem' e (x:xs) = if e == x then True else elem' e xs\nelem' e (x:xs)\n  | e == x = True\n  | otherwise = elem' e xs\n\n{-- (2)\nDefine a recursive function\nmerge :: (Ord a) => [a] -> [a] -> [a]\n\nthat merges two sorted lists of values to give a single sorted list.  For example:\n\n> merge [2,5,6] [1,3,4]\n\n[1,2,3,4,5,6]\n--}\n\nmerge :: (Ord a) => [a] -> [a] -> [a]\nmerge xs [] = xs\nmerge [] ys = ys\nmerge (x:xs) (y:ys)\n  | x <= y = x : merge xs (y:ys)\n  | otherwise = y : merge (x:xs) ys\n\n{-- (3)\nDefine a recursive function\n\nmsort :: (Ord a) => [a] -> [a]\n\nthat implements merge sort, which can be specified by the following two rules:\n\nLists of length <= 1 are already sorted;\n\nOther lists can be sorted by sorting the two halves and merging the resulting lists. \n--}\n\nmsort :: (Ord a) => [a] -> [a]\nmsort [] = []\nmsort (x:xs)\n  | null xs = [x]\n  | otherwise = merge (msort l) (msort r) where\n      l = take n (x:xs)\n      r = drop n (x:xs)\n      n = floor( toRational(length (x:xs)) / 2)\n", "input": "[True, True]", "status": "success", "output": "True"}
{"code": "import Control.Monad\n\nfactorial n = product [1..n]\nfactorial' n = if n == 0 then 1 else n * factorial' (n-1)\n\nfibo 0 = 1\nfibo 1 = 1\nfibo n = fibo (n-1) + fibo (n-2)\n\nlastButOne xs = last (init xs)\n\nuppercase :: Char -> Char\nuppercase ch | ch == 'a' = 'A' | ch == 'b' = 'B' | ch == 'c' = 'C' | ch == 'd' = 'D'\n\t\t\t | ch == 'e' = 'E' | ch == 'f' = 'F' | ch == 'g' = 'G' | ch == 'h' = 'H'\n\t\t\t | ch == 'i' = 'I' | ch == 'j' = 'J' | ch == 'k' = 'K' | ch == 'l' = 'L'\n\t\t\t | ch == 'm' = 'M' | ch == 'n' = 'N' | ch == 'o' = 'O' | ch == 'p' = 'P'\n\t\t\t | ch == 'q' = 'Q' | ch == 'r' = 'R' | ch == 's' = 'S' | ch == 't' = 'T'\n\t\t\t | ch == 'u' = 'U' | ch == 'v' = 'V' | ch == 'w' = 'W' | ch == 'x' = 'X'\n\t\t\t | ch == 'y' = 'Y' | ch == 'z' = 'Z' | otherwise = ch\n\nuppercaseString :: String -> String\nuppercaseString str = [uppercase ch | ch <- str]\n\nchangeFromList :: Char -> [(Char,Char)] -> Char\nchangeFromList ch [x] = if fst x == ch then snd x else ch\nchangeFromList ch str = if fst (head str) == ch then snd (head str) else changeFromList ch (tail str)\nuppercase' :: Char -> Char\nuppercase' ch = changeFromList ch alphabetPair\n\t\t\twhere alphabetPair = zip ['a'..'z'] ['A'..'Z']\nuppercaseString' str = [uppercase' ch | ch <-str]\nuppercaseStringByMap str = map uppercase' str\n\n\nfiboList :: Int -> [Int]\nfiboList 0 = [1]\nfiboList 1 = [1,1]\nfiboList n = prevList ++ [lastButOne prevList + last prevList]\n\t\twhere prevList = fiboList (n-1)\nfibo' :: Int -> Int\nfibo' n = last (fiboList n)\n\nvalidParentheses :: String -> Bool\nvalidParentheses = check 0\n\ncheck :: Int -> String -> Bool\ncheck 0 [] = True\ncheck _ [] = False\ncheck n (f:l) = if f == '(' then check (n+1) l else if n > 0 then check (n-1) l else False\n\nfizzbuzz :: Int -> [Int]\nfizzbuzz n = [three - fifth, five - fifth, fifth]\n  where three = (n-1) `div` 3\n        five = (n-1) `div` 5\n        fifth = (n-1) `div` 15\n\npowerset :: [a] -> [[a]]\npowerset xs = filterM (\\_ -> [True, False]) xs", "input": "'a'", "status": "success", "output": "'A'"}
{"code": "{-The number 145 is well known for the property that the sum of the factorial of its digits is equal to 145:\n\n1! + 4! + 5! = 1 + 24 + 120 = 145\n\nPerhaps less well known is 169, in that it produces the longest chain of numbers that link back to 169; it turns out that there are only three such loops that exist:\n\n169 -> 363601 -> 1454 -> 169\n871 -> 45361 -> 871\n872 -> 45362 -> 872\n\nIt is not difficult to prove that EVERY starting number will eventually get stuck in a loop. For example,\n\n69 -> 363600 -> 1454 -> 169 -> 363601 (-> 1454)\n78 -> 45360 -> 871 -> 45361 (-> 871)\n540 -> 145 (-> 145)\n\nStarting with 69 produces a chain of five non-repeating terms, but the longest non-repeating chain with a starting number below one million is sixty terms.\n\nHow many chains, with a starting number below one million, contain exactly sixty non-repeating terms?-}\n\nimport Data.Char\n\ncyclers = [169, 363601, 1454, 169, 145, 871, 872]\n\ncyclelength 169 = 4\ncyclelength 363601 = 4\ncyclelength 1454 = 4\n\ncyclelength 145 = 1\n\ncyclelength 872 = 2\ncyclelength 45362 = 2\n\ncyclelength 871 = 2\ncyclelength 45361 = 2\n\nfact :: Integer -> Integer\nfact n = product [1..n]\n\nnext :: Integer -> Integer\nnext n = sum $ map fact $ map fromIntegral $ map digitToInt $ show n\n\ncalc_chain :: Integer -> [Integer] \ncalc_chain n = calc_chain_rec n []\n\ncalc_chain_rec :: Integer -> [Integer] -> [Integer]\ncalc_chain_rec n chain\n    | (invalid n) = []\n    | (n `elem` cyclers) =\n        chain ++ [n]\n    | otherwise =\n        calc_chain_rec (next n) (chain ++ [n])\n\ncalc_chain_length :: Integer -> Integer\ncalc_chain_length n =\n    let chain = calc_chain n in\n        case chain of [] -> 0\n                      _ -> (fromIntegral $ length chain) + (cyclelength $ last chain) - 2\n\ninvalid :: Integer -> Bool\ninvalid n = (n == 2) || (n == 1) || (n == 40585)\n\nl = map (\\n -> (n, calc_chain_length n)) [3..1000000]\nlength_60 = map (\\(a,b) -> a) $ filter (\\(a,b) -> b == 60) $ l", "input": "42", "status": "success", "output": "1405006117752879898543142606244511569936384000000000"}
{"code": "---------------------------------------------------------------------\n---------------------------------------------------------------------\n-- THE TRIVIAL MONAD\n-- EXERCISES FROM http://blog.sigfpe.com/2007/04/trivial-monad.html\n\ndata W a = W a deriving Show\n\ninstance Functor W where\n  fmap f (W x) = W (f x)\n\n-- NOTE: need to define an Applicative instance for W as well when defining a Monad for W\ninstance Applicative W where\n  pure x = W x\n  W f <*> W v = W (f v)\n\ninstance Monad W where\n  return x = W x\n  W x >>= f = f x\n\n\nf :: Int -> W Int\nf x = W (x+1)\n\nbind :: (a -> W b) -> (W a -> W b)\nbind f (W x) = f x\n\n-- (1) define a function g :: Int -> W Int -> W Int so that g x (W y) = W (x+y). Obviously that definition won't do - the left hand side has a W y pattern so it's actually unwrapping. Rewrite this function so that the only unwrapping that happens is carried out by bind.\ng :: Int -> W Int -> W Int\ng x w = bind (\\y -> return (x+y)) w \ng' x w = w >>= (\\y -> return (x+y)) -- NOTE: written using real 'bind' operator from Monad \n\n-- (2) define a function h :: W Int -> W Int -> W Int so that h (W x) (W y) = W (x+y). Again, no unwrapping.\nh :: W Int -> W Int -> W Int\nh w1 w2 = bind (\\x -> bind (\\y -> return (x+y)) w2) w1 \nh' w1 w2 = w1 >>= (\\x -> w2 >>= (\\y -> return (x+y)))\n\n-- Exercise 3: Prove the three monad laws for W. This should be almost trivial.\n{--\nLeft identity:\t\nreturn a >>= f \u2261 f a\nRight identity:\t\nm >>= return \u2261 m\nAssociativity:\t\n(m >>= f) >>= g \u2261 m >>= (\\x -> f x >>= g)\n--}\n\n-- Exercise 4: We can't completely unwrap things using the monad API. But we can unwrap one layer from things that are wrapped twice. So here's a nice puzzle: define a function join :: W (W a) -> W a using the Monad API and no explicit unwrapping.\n\njoin :: W (W a) -> W a\njoin w = w >>= (\\innerW -> innerW)\n---------------------------------------------------------------------\n---------------------------------------------------------------------\n", "input": "42", "status": "success", "output": "W 43"}
{"code": "import Data.Array\nimport Data.List (group)\nimport Debug.Trace\n\nfactorize :: Integer -> [Integer]\nfactorize n = arr ! n\n        where arr = listArray (2,n) [ factorizeHelper i | i <- [2..n] ]\n              factorizeHelper i\n                      | i<=2 = [i]\n                      | otherwise = let sqrti1 = (floor $ sqrt $ fromIntegral i) + 1\n                                        factors = 2 : [3, 5 .. sqrti1]\n                                        smallestDivisor = filter (\\x -> (mod i x) == 0) factors\n                                        in case smallestDivisor of\n                                              [] -> [i]\n                                              (x:xs) -> x : (arr ! (i `div` x))\n\nfactorizeNonCached :: Integer -> [Integer]\nfactorizeNonCached n\n        | n==1 = []\n        | otherwise = let sqrtn1 = (floor $ sqrt $ fromIntegral n) + 1\n                          factors = 2 : [3, 5 .. sqrtn1]\n                          smallestDivisor = filter (\\x -> (mod n x) == 0) factors\n                          in case smallestDivisor of\n                                [] -> [n]\n                                (x:xs) -> x : factorizeNonCached (n `div` x)\n\nprimeFactors n = zip factors powers\n        where factors = map head groups\n              powers = map length groups\n              groups = (group $ factorizeNonCached n)\n\nfactors n\n--        | trace (show n ++ \" \" ++ show pFactors) False = undefined\n        | otherwise = [ [ i^j | j <- [0..k] ] | (i, k) <- pFactors ]\n        where pFactors = primeFactors n\n\ncartProd l1 l2 = [ x1 * x2 | x1 <- l1, x2 <- l2 ]\n\ndivisors n = foldl cartProd [1] $ factors n\n\nsumDivisors n = (sum $ divisors n) - n\n\nnmax = 9999\n\nsumAmicable\n--        | trace (show sums) False = undefined\n        | otherwise = sum amicables\n        where amicables = [ i + j | i <- [2..nmax], j <- [i+1..nmax], sumsArr!i == j && sumsArr!j == i ]\n              sums = map sumDivisors [1..nmax]\n              sumsArr = listArray (1,nmax) sums\n\n", "input": "42", "status": "success", "output": "[2,3,7]"}
{"code": "-- baby.hs\n\ndoubleMe x = x + x\n\ndoubleUs x y = x * 2 + y * 2\n\ndoubleUs' x y = doubleMe x + doubleMe y\n\ndoubleSmallNumber x = if x > 100\n                      then x\n                      else x+2\n                                     \ndoubleSmallNumber' x = (if x > 100 then x else x+2) + 1\n\nboomBangs xs = [ if x < 10 then \"BOOM!\" else \"BANG!\" | x <- xs, odd x ]\n\nnotAll = [ x | x <- [10..20], x /= 13, x /= 15, x /= 19]\n\nlength' xs = sum [ 1 | _ <- xs]\n\nremoveNonUppercase st = [ c | c <- st, elem c ['A'..'Z']]\n\nrightTriangles' = [ (a, b, c) | a <- [1..10], b <- [1..10], c <- [1..10], a^2 + b^2 == c^2, a+b+c == 24, a < b]\n\nfactorial :: Integer -> Integer\nfactorial n = product [1..n]\n\ncircumference :: Float -> Float\ncircumference r = 2 * pi * r\n\ncircumference' :: Double -> Double \ncircumference' r = 2 * pi * r\n\n--  Chapter 3\n\nlucky :: Int -> String\nlucky 7 = \"Lucky Number Seven!\"\nlucky x = \"Sorry, you're out of luck, pal!\"\n\nsayMe :: Int -> String\nsayMe 1 = \"One!\"\nsayMe 2 = \"Two!\"\nsayMe 3 = \"Three!\"\nsayMe 4 = \"Four!\"\nsayMe 5 = \"Five!\"\nsayMe x = \"Not between 1 and 5\"\n\ncharName :: Char -> String\ncharName 'a' = \"Albert\"\ncharName 'b' = \"Bonnie\"\ncharName 'c' = \"Chandler\"\ncharName 'd' = \"Danielle\"\ncharName  x  = \"YourName\"\n\naddVectors :: (Double, Double) -> (Double, Double) -> (Double, Double)\n-- addVectors a b = (fst a + fst b, snd a + snd b)\naddVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)\n\nfirst :: (a, b, c) -> a\nfirst (x, _, _) = x\n\nsecond :: (a, b, c) -> b\nsecond (_, y, _) = y\n\nthird :: (a, b, c) -> c\nthird (_, _, z) = z\n\n\nhead' :: [a] -> a\nhead' [] = error \"empty headed\"\nhead' (x:_) = x\n\nabbyNormal :: [a] -> a\nabbyNormal (xs) = head' xs\n\nadd' :: Int -> Int -> Int\nadd' a b = a + b\n\ntell :: (Show  a ) => [a] -> String\ntell [] = \"The List is Empty\"\ntell (x:[]) = \"The list has one element: \" ++ show x\ntell (x:y:[]) = \"The list has two elements: \" ++ show x ++ \" and \" ++ show y\ntell (x:y:_) = \"The list is long, the first two elements are: \" ++ show x ++ \" and \" ++ show y\n", "input": "42", "status": "success", "output": "1405006117752879898543142606244511569936384000000000"}
{"code": "import Control.Applicative\nimport Data.Maybe\n\nhasAbba :: String -> Maybe Bool\nhasAbba ('[':xs) = hasAbba' xs\nhasAbba (c1:c2:c3:c4:xs)\n  | c1 == c4 && c2 == c3 && c1 /= c2 = hasAbba (c2:c3:c4:xs) <|> Just True\n  | otherwise = hasAbba (c2:c3:c4:xs)\nhasAbba _ = Nothing\n\nhasAbba' :: String -> Maybe Bool\nhasAbba' (']':xs) = hasAbba xs\nhasAbba' (c1:c2:c3:c4:xs)\n  | c1 == c4 && c2 == c3 && c1 /= c2 = Just False\n  | otherwise = hasAbba' (c2:c3:c4:xs)\nhasAbba' _ = Nothing\n\npart1 :: String -> Int\npart1 = length . filter (fromMaybe False . hasAbba) . lines\n\nsupportsSSL :: String -> Bool\nsupportsSSL ('[':xs) = supportsSSL' xs\nsupportsSSL (c1:c2:c3:xs)\n  | c1 == c3 && c1 /= c2 = hasCorrespondingBab (c1,c2) xs || supportsSSL (c2:c3:xs)\n  | otherwise = supportsSSL (c2:c3:xs)\nsupportsSSL _ = False\n\nsupportsSSL' :: String -> Bool\nsupportsSSL' (']':xs) = supportsSSL xs\nsupportsSSL' (c1:c2:c3:xs)\n  | c1 == c3 && c1 /= c2 = hasCorrespondingAba (c1,c2) xs || supportsSSL' (c2:c3:xs)\n  | otherwise = supportsSSL' (c2:c3:xs)\nsupportsSSL' _ = False\n\nhasCorrespondingBab :: (Char, Char) -> String -> Bool\nhasCorrespondingBab ab ('[':xs) = hasCorrespondingBab' ab xs\nhasCorrespondingBab ab (x:xs) = hasCorrespondingBab ab xs\nhasCorrespondingBab ab _ = False\n\nhasCorrespondingBab' :: (Char, Char) -> String -> Bool\nhasCorrespondingBab' ab (']':xs) = hasCorrespondingBab ab xs\nhasCorrespondingBab' (a,b) (c1:c2:c3:xs) = [c1,c2,c3] == [b,a,b] || hasCorrespondingBab' (a,b) (c2:c3:xs)\nhasCorrespondingBab' _ _ = False\n\nhasCorrespondingAba :: (Char, Char) -> String -> Bool\nhasCorrespondingAba ba (']':xs) = hasCorrespondingAba' ba xs\nhasCorrespondingAba ba (x:xs) = hasCorrespondingAba ba xs\nhasCorrespondingAba ba _ = False\n\nhasCorrespondingAba' :: (Char, Char) -> String -> Bool\nhasCorrespondingAba' ba ('[':xs) = hasCorrespondingAba ba xs\nhasCorrespondingAba' (b,a) (c1:c2:c3:xs) = [c1,c2,c3] == [a,b,a] || hasCorrespondingAba' (b,a) (c2:c3:xs)\nhasCorrespondingAba' _ _ = False\n\npart2 :: String -> Int\npart2 = length . filter supportsSSL . lines\n", "input": "\"hello\"", "status": "success", "output": "Nothing"}
{"code": "{-\nfactorial n = if n>1\n              then n * factorial (n-1)\n              else 1\n-}\n-- Cuando una funci\u00f3n no tiene parametros es una definici\u00f3n o un nombre\n\nnombreDefinicion = \"Hola mundo, soy una definicion\"\n\n{-\nHay diferentes formas de construir funciones, una de ellas es a trav\u00e9s de\npatrones como en el ejemplo 1. La otra es a trav\u00e9s de guards como en el ejemplo\n2. Durante este \u00faltimo ejemplo hay un par de vertientes como es el uso de where\ny let (ejemplos 3 y 4), con sus respectivas ventajas y desventajas.\n-}\n\n--Ejemplo 1\n\nfactorial :: Integer -> Integer\nfactorial 0 = 1\nfactorial n = n * factorial (n-1)\n\n--Ejemplo 2\n\nfactorial1 :: Integer -> Integer\nfactorial1 a\n  | a>1 = a * factorial1 (a-1)\n  | True = 1\n\n{-\nPara estos ejemplos usare otro programa diferente al ejemplo 2.\n-}\n-- Original\n\nimc :: Double -> String\n\nimc indice\n  | indice <= 18.5 = \"Desnutrido\"\n  | indice <= 25.0 = \"Perfecto\"\n  | indice <= 30.0 = \"Gordito\"\n  | otherwise = \"Eres demasiado pesado\"\n\n--Con peso y altura en lugar del indice\n\nimc1 :: Float -> Float -> String\n\nimc1 altura peso\n  | peso / (altura^2) <= 18.5 = \"Desnutrido\"\n  | peso / (altura^2) <= 25.0 = \"Perfecto\"\n  | peso / (altura^2) <= 30.0 = \"Gordito\"\n  | otherwise = \"Eres demasiado pesado\"\n\n--Ejemplo 3\n\nimc2 :: Float -> Float -> String\n\nimc2 altura peso\n  | indice <= ligero = \"Desnutrido\"\n  | indice <= normal = \"Perfecto\"\n  | indice <= pesado = \"Gordito\"\n  | otherwise = \"Eres demasiado pesado\"\n  where indice = peso / (altura^2)\n        ligero = 18.5\n        normal = 25.0\n        pesado = 30.0\n\n--Ejemplo 4\n{-\nLa aparente diferencia entre where y let es que let te permite escribir la\nequivalencia antes y el where lo hace despu\u00e9s, sin embargo, let lo puedes usar\nen un monton de lugares, aunque no en los guards.\n-}\nlistaConLet =  (let a = 100; b = 200; c = 300 in a*b*c, let foo=\"Hey \"; bar = \"there!\" in foo ++ bar)\n\n--Tambi\u00e9n podemos usar let en las list comprehension\n\ncalcularIMC :: (RealFloat a) => [(a,a)] -> [a]\n\ncalcularIMC xs = [imc3 | (w,h)<-xs,let imc3 = w/(h^2),imc3>=25.0]\n", "input": "42", "status": "success", "output": "1405006117752879898543142606244511569936384000000000"}
{"code": "sayMe :: Int -> String\nsayMe 1 = \"One!\"\nsayMe 2 = \"Two!\"\nsayMe 3 = \"Three!\"\nsayMe nope = \"Blarg!\"\n\nfactorial :: Int -> Int\nfactorial 0 = 1\nfactorial n = n * factorial(n-1)\n\naddVectors :: (Double, Double) -> (Double, Double) -> (Double, Double)\naddVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)\n\nfirst :: (a, b, c) -> a\nfirst (a, _, _) = a\n\nsecond :: (a, b, c) -> b\nsecond (_, b, _) = b\n\nthird :: (a, b, c) -> c\nthird (_, _, c) = c\n\ntuple_xs = [(1, 2), (2, 3), (3, 4)]\naddTuples :: (Num a) =>  [(a,a)] -> [a]\naddTuples xs = [ a + b | (a, b) <- xs ]\n\nhead' :: [a] -> a\nhead' [] = error \"can't take the head of an empty list\"\nhead' (x:_) = x\n\ntell :: (Show a) => [a] -> String\ntell [] = \"Empty List\"\ntell (x:[]) = \"List of 1:\" ++ show x\ntell (x:y:[]) = \"List of 2:\" ++ show x ++ \":\" ++ show y\ntell (x:y:xs) = \"Long list:\" ++ show x ++ \":\" ++ show y ++ \": and \" ++ show (length xs) ++ \" more\"\n\nfirstLetter :: String -> String\nfirstLetter \"\" = error \"cant get the first letter of an empty string\"\nfirstLetter all@(x:xs) = [x] ++ \" is the first letter of \" ++ all\n\nbmiTell :: Double -> Double -> String\nbmiTell weight height\n | bmi <= 18.5 = \"Eat more food\"\n | bmi <= 25.0 = \"Looking good\"\n | bmi <= 39.0 = \"Need a workout\"\n | otherwise = \"Go see a doctor\"\n where bmi = weight / height ^ 2\n\ncalcBmis :: [(Double, Double)] -> [Double]\ncalcBmis xs = [bmi w h | (w, h) <- xs]\n where bmi weight height = weight / height ^ 2\n\ncylinder :: (RealFloat a) => a -> a -> a  \ncylinder r h = \n    let sideArea = 2 * pi * r * h  \n        topArea = pi * r ^2  \n    in  sideArea + 2 * topArea  \n\n-- (let a = 100 ; b = 200 in a * b) + 1\n-- (let (a,b,c) = (1,2,3) in a+b+c) * 100 \n-- [let square x = x * x in (square 5, square 3, square 2)]\n\ncalcBmis2 :: [(Double, Double)] -> [Double]\ncalcBmis2 xs = [bmi | (w, h) <- xs, let bmi = w /h ^ 2]\n\ndescribeList :: [a] -> String  \ndescribeList xs = \"The list is \" ++ case xs of [] -> \"empty.\"  \n                                               [x] -> \"a singleton list.\"   \n                                               xs -> \"a longer list.\" \n", "input": "42", "status": "success", "output": "\"Blarg!\""}
{"code": "import Data.Char\n\n-- Devuelve un set de notas dependiendo de su resto modulo 12, determinando si es bemol, sostenido o becuadro\nnotas :: Int -> [[Char]]\nnotas x = [ n !! caso | n <- todas ]\n  where todas = [[\"Do\",\"Do\"],[\"Do#\",\"Reb\"],[\"Re\",\"Re\"],[\"Re#\",\"Mib\"],[\"Mi\",\"Mi\"],[\"Fa\",\"Fa\"],[\"Fa#\",\"Solb\"],[\"Sol\",\"Sol\"],[\"Sol#\",\"Lab\"],[\"La\",\"La\"],[\"La#\",\"Sib\"],[\"Si\",\"Dob\"]]\n        caso\n          | elem (mod x 12) [0,2,4,7,9,11] = 0\n          | otherwise = 1\n\n-- Mapea cada nota con su equivalente numerico\nnota :: [Char] -> Int\nnota n\n  | x [\"do\",\"si#\"]   = 0\n  | x [\"do#\",\"reb\"]  = 1\n  | x [\"re\"]         = 2\n  | x [\"re#\",\"mib\"]  = 3\n  | x [\"mi\",\"fab\"]   = 4\n  | x [\"fa\",\"mi#\"]   = 5\n  | x [\"fa#\",\"solb\"] = 6\n  | x [\"sol\"]        = 7\n  | x [\"sol#\",\"lab\"] = 8\n  | x [\"la\"]         = 9\n  | x [\"la#\",\"sib\"]  = 10\n  | x [\"si\",\"dob\"]   = 11\n  | otherwise        = 12\n  where x = elem $ map toLower n\n\n-- Calcula la estructura basica del modo jonico\nescala :: [Int]\nescala = scanl (+) 0 [tono, tono, semitono, tono, tono, tono]\n  where semitono = 1\n        tono = 2\n\n-- Devuelve un set de notas dependiendo del centro tonal, modificando el caso particular de Solb para que no repita nombres de notas\ntonalidad :: Int -> [[Char]]\ntonalidad x = [ cycle (notas x) !! ((caso n) + x) | n <- escala ]\n  where caso n\n          | x == 6 && n == 5 = 6\n          | otherwise = n\n\n\n-- Se corre una tonalidad hasta colocar el centro tonal en $b\n-- el modo \"a\" debe correr la tonalidad tantas posiciones como valor haya en el indice $a de $escala\nmodo :: Int -> [Char] -> [[Char]]\nmodo a b = [ cycle corrimiento !! (n + a) | n <- [0..6] ]\n  where corrimiento = tonalidad $ c + 12 - (escala !! a)\n        c = nota b\n\njonico    = modo 0\ndorico    = modo 1\nfrigio    = modo 2\nlidio     = modo 3\nmixolidio = modo 4\neolico    = modo 5\nlocrio    = modo 6\n\nmayor = jonico\nmenor = eolico\n\nestructura :: Int -> [Int]\nestructura n = take n [0,2..]\n\n-- Construye los acordes basicos de una escala dada\nacordes x = [ triada e | e <- [0..6] ]\n  where triada e = [ cycle x !! (n+e) | n <- estructura 3 ]\n", "input": "42", "status": "success", "output": "[\"Do\",\"Reb\",\"Re\",\"Mib\",\"Mi\",\"Fa\",\"Solb\",\"Sol\",\"Lab\",\"La\",\"Sib\",\"Dob\"]"}
{"code": "{--\r\n - Problem 63\r\n    Construct a complete binary tree\r\n    A complete binary tree with height H is defined as follows:\r\n    \r\n    The levels 1,2,3,...,H-1 contain the maximum number of nodes (i.e 2**(i-1) at the level i)\r\n    In level H, which may contain less than the maximum possible number of nodes, all the nodes are\r\n    \"leftadjusted\".\r\n\r\n    This means that in a levelorder tree traversal all internal nodes come first, the\r\n    leaves come second, and empty successors (the nil's which are not really nodes!) come last.\r\n    Particularly, complete binary trees are used as data structures (or addressing schemes) for heaps.\r\n    We can assign an address number to each node in a complete binary tree by enumerating the nodes in\r\n    levelorder,\r\n    \r\n    starting at the root with number 1. For every node X with address A the following property\r\n    holds: The address of X's left and right successors are 2*A and 2*A+1, respectively, if they exist. This\r\n    fact can be used to elegantly construct a complete binary tree structure.\r\n    Write a predicate complete_binary_tree/2.\r\n    \r\n    Example:\r\n    % complete_binary_tree(N,T) :\u2010 T is a complete binary tree with N nodes.\r\n    \r\n    Example in Haskell:\r\n    Main> completeBinaryTree 4\r\n    Branch 'x' (Branch 'x' (Branch 'x' Empty Empty) Empty) (Branch 'x' Empty Empty)\r\n    Main> isCompleteBinaryTree $ Branch 'x' (Branch 'x' Empty Empty) (Branch 'x' Empty Empty)\r\n    True\r\n --}\r\n\r\ndata Tree a = Empty | Branch a (Tree a) (Tree a) deriving (Show, Eq)\r\n\r\ntree4 = Branch 1 (Branch 2 Empty (Branch 4 Empty Empty)) (Branch 2 Empty Empty)\r\n\r\ncompleteBinaryTree :: Int -> Tree Char\r\ncompleteBinaryTree = makeTree 'x' 1 where\r\n    makeTree c k n\r\n        | k > n = Empty\r\n        | otherwise = Branch c (makeTree c (2*k) n) (makeTree c (2*k+1) n)\r\n\r\nisCompleteBinaryTree :: Tree a -> Bool\r\nisCompleteBinaryTree tree = detectTree tree 1 (count tree) where\r\n    detectTree Empty k n = k > n\r\n    detectTree (Branch _ l r) k n = detectTree l (2*k) n && detectTree r (2*k+1) n\r\n    count Empty = 0\r\n    count (Branch _ l r) = count l + count r\r\n\r\n", "input": "42", "status": "success", "output": "Branch 'x' (Branch 'x' (Branch 'x' (Branch 'x' (Branch 'x' (Branch 'x' Empty Empty) (Branch 'x' Empty Empty)) (Branch 'x' (Branch 'x' Empty Empty) (Branch 'x' Empty Empty))) (Branch 'x' (Branch 'x' (Branch 'x' Empty Empty) (Branch 'x' Empty Empty)) (Branch 'x' (Branch 'x' Empty Empty) (Branch 'x' Empty Empty)))) (Branch 'x' (Branch 'x' (Branch 'x' (Branch 'x' Empty Empty) (Branch 'x' Empty Empty)) (Branch 'x' (Branch 'x' Empty Empty) Empty)) (Branch 'x' (Branch 'x' Empty Empty) (Branch 'x' Empty Empty)))) (Branch 'x' (Branch 'x' (Branch 'x' (Branch 'x' Empty Empty) (Branch 'x' Empty Empty)) (Branch 'x' (Branch 'x' Empty Empty) (Branch 'x' Empty Empty))) (Branch 'x' (Branch 'x' (Branch 'x' Empty Empty) (Branch 'x' Empty Empty)) (Branch 'x' (Branch 'x' Empty Empty) (Branch 'x' Empty Empty))))"}
{"code": "-- Section 4\nlucky :: Int -> String\nlucky 7 = \"LUCKY NUMBER SEVEN !\"\nlucky x = \"Sorry, you're out of luck, pal !\"\n\nfactorial :: Int -> Int\nfactorial 0 = 1\nfactorial n = n * factorial (n - 1)\n\naddVectors :: (Double, Double) -> (Double, Double) -> (Double, Double)\naddVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)\n\nhead' :: [a] -> a\nhead' [] = error \"Can't call head on an empty list, dammy!\"\nhead' (x:_) = x\n\nbmiTell :: Double -> Double -> String\nbmiTell weight height\n\t| bmi <= skinny\t= \"You're underweight, you emo, you!\"\n\t| bmi <= normal = \"You're supporsedly normal.\\\n\t\t\\ Pfft, I bet you're ugly!\"\n\t| bmi <= fat = \"You're fat! Lose some weight, fatty!\"\n\t| otherwise \t= \"You're a whale, congratulations!\"\n\twhere -- To new line\n\t\tbmi = weight / height ^ 2\n\t\t(skinny, normal, fat) = (18.5, 25.0, 30.0)\n\ninitials :: String -> String -> String\ninitials firstname lastname = [f] ++ \". \" ++ [l] ++ \".\"\n\twhere\n\t\t(f:_) = firstname\n\t\t(l:_) = lastname\n\n\ncalcBmis :: [(Double, Double)] -> [Double]\ncalcBmis xs = [bmi w h | (w, h) <- xs]\n\twhere bmi weight height = weight / height ^ 2\n\ncalcBmis' :: [(Double, Double)] -> [Double]\ncalcBmis' xs = [bmi w h | (w, h) <- xs, let bmi weight height = weight / height ^ 2]\n\n-- recursion\nmaximum' :: (Ord a) => [a] -> a\nmaximum' [] = error \"No maximum of empty list!\"\nmaximum' [x] = x\nmaximum' (x:xs) = max x (maximum' xs)\n\nreplicate' :: Int -> a -> [a]\nreplicate' n x\n\t| n <= 0\t= []\n\t| otherwise = x : replicate' (n - 1) x\n\ntake' :: Int -> [a] -> [a]\ntake' n _\n\t| n <= 0 \t= []\ntake' _ [] \t= []\ntake' n (x:xs) = x : take' (n-1) xs\n\nreverse' :: [a] -> [a]\nreverse' [] = []\nreverse' (x:xs) = reverse' xs ++ [x]\n\nrepeat' :: a -> [a]\nrepeat' x = x : repeat' x\n\nzip' :: [a] -> [b] -> [(a, b)]\nzip' _ [] = []\nzip' [] _ = []\nzip' (x:xs) (y:ys) = (x,y) : zip' xs ys\n\nelem' :: (Eq a) => a -> [a] -> Bool\nelem' a [] = False\nelem' a (x:xs)\n\t| a == x \t\t= True\n\t| otherwise = a `elem'` xs\n\n-- Quick Sort\nquicksort :: (Ord a) => [a] -> [a]\nquicksort [] = []\nquicksort (x:xs) = let\n\t\t\tsmallerOrEqual = [a | a <- xs, a <= x]\n\t\t\tlarger = [a | a <- xs, a > x]\n\t\tin quicksort smallerOrEqual ++ [x] ++ quicksort larger\n\n \n", "input": "42", "status": "success", "output": "\"Sorry, you're out of luck, pal !\""}
{"code": "-- Applied Haskell\n--\n-- rearning Haskell by implementing Statical, \n--  Finance Functions \n--\n------------------------------------------\n\n-- Arithmetic Mean of a Sequence\n--\n-- mean :: Fractional b => [b] -> b\nmean lst = sum lst / fromIntegral (length lst)\n\n-- Geometric Mean of Squence \ngeomean lst = (product lst)^(fromIntegral (length lst))\n\n-- Convert from decimal to percent\nto_percent lst = map (100.0 *) lst\n\n\n-- Lagged Difference of a time serie\n-- lagddif [xi] = [x_i+1 - x_i]\nlagdiff lst = zipWith (-) (tail lst) lst\n--\n-- Growth of a Time Serie\ngrowth lst = zipWith (/) (lagdiff lst) lst\n---\n--- Perncentual Growth\ngrowthp = to_percent . growth\n\n-- Time Serie Test Data\ntimeserie = [0.1, 0.23, 0.18, 0.34, 0.55, 0.167, 0.45, 0.56 ]\n\n\n-- Task:http://rosettacode.org/wiki/Averages/Mean_angle#Haskell \n-- http://rosettacode.org/wiki/Averages/Mean_angle#Haskell \n--\n-- Degree Trigonometric Functions\n--\ndeg2rad deg = deg*pi/180.0\nrad2deg rad = rad*180.0/pi\n\nsind = sin . deg2rad\ncosd = cos . deg2rad\ntand = tan . deg2rad\natand = rad2deg . atan\natan2d y x = rad2deg (atan2 y x )\n\navg_angle angles = atan2d y x\n    where\n    y = mean (map sind angles) \n    x = mean (map cosd angles)\n\n-- Vectorial Dot Product\n--\n-- *Main> dotprod [10.23, 23.3, -103.44, 10.23] [90.0, 23.12, 30.4, 80.0 ] \n-- -866.7799999999993\n--  \n-- *Main> dotprod [1, 3, -5] [4, -2, -1]\n-- 3\n----------------------------------------------------------------\n-- http://rosettacode.org/wiki/Dot_product#Haskell \ndotprod v1 v2 = sum ( zipWith  (*) v1 v2 )\n\n-- *Main> sin ( units 90 \"deg\")\n-- 1.0\n-- *Main> \n-- *Main> sin ( units 45 \"deg\")\n-- 0.7071067811865475\n-- *Main> \n-- *Main> \n-- \nunits angle sym | sym == \"deg\" = angle*pi/180.0\n                | sym == \"rad\" = angle\n\n\n-- Numerical Derivate Function\n--\n-- *Main> f 2\n--  4.0\n-- *Main> df 2\n-- 6.000020000040961\n--  \n--\nderv dx f x = (f(x+dx) - f(x))/dx\n\nf x = 2*x**2 - 2*x\ndf = derv 1e-5 f\n\n-- *Main> sum [1..100]\n--  5050\n--  \nsum2 :: [Integer] -> Integer\nsum2 []     = 0\nsum2 (x:xs) = x + sum xs\n\n\nprod :: [Integer] -> Integer\nprod []     = 1\nprod (x:xs) = x * prod xs\n\n\n-- root itmax f guess =  let newguess =  \n", "input": "[42, 42]", "status": "success", "output": "84"}
{"code": "toDigits :: Integer -> [Integer]\ntoDigits inX = map (\\x -> read [x]::Integer) (show inX)\n\ntoDigitsReverse :: Integer -> [Integer]\ntoDigitsReverse inX = reverse $ toDigits inX\n\n-- doubles from the right\ndoubleEveryOther :: [Integer] -> [Integer]\ndoubleEveryOther (x:y:rest) = x : y * 2 : doubleEveryOther rest\ndoubleEveryOther [x] = [x]\ndoubleEveryOther [] = []\n\nsumDigits :: [Integer] -> Integer\nsumDigits (x:xs)\n  | (length $ toDigits x) == 1 = x + sumDigits xs\n  | (length $ toDigits x) > 1  = (sumDigits $ toDigits x) + sumDigits xs\nsumDigits [] = 0\n\nvalidate :: Integer -> Bool\nvalidate x = (sumDigits $ doubleEveryOther $ toDigitsReverse x) `mod` 10  == 0\n\n\n-- hanoi methods\ntype Peg = String\ntype Move = (Peg, Peg)\ntype Stack = [Integer]\n-- Game is\n-- Stacks = current set of pegs with discs on them in order\n-- Peg = Which peg is where to move the current stack\n-- [Move] = the moves accumulator\ntype Game = (Stack, Stack, Stack, Peg, [Move])\n\nmakeHanoi :: Integer -> Peg -> Peg -> Peg -> Game\nmakeHanoi i a b c = ([1..i], [], [], \"b\", [])\n\nplayHanoi :: Stack -> Stack -> Stack -> Peg -> [Move] -> [Move]\nplayHanoi [] [] [] _ ms = ms\nplayHanoi s1 [] [] \"b\" ms = ms ++ (playHanoi (init s1) [] [] \"c\" ms) ++ [(\"a\", \"b\")] ++ (playHanoi [] [] (init s1) \"b\" ms)\nplayHanoi s1 [] [] \"c\" ms = ms ++ (playHanoi (init s1) [] [] \"b\" ms) ++ [(\"a\", \"c\")] ++ (playHanoi [] (init s1) [] \"c\" ms)\nplayHanoi [] s2 [] \"a\" ms = ms ++ (playHanoi [] (init s2) [] \"c\" ms) ++ [(\"b\", \"a\")] ++ (playHanoi [] [] (init s2) \"a\" ms)\nplayHanoi [] s2 [] \"c\" ms = ms ++ (playHanoi [] (init s2) [] \"a\" ms) ++ [(\"b\", \"c\")] ++ (playHanoi (init s2) [] [] \"c\" ms)\nplayHanoi [] [] s3 \"a\" ms = ms ++ (playHanoi [] [] (init s3) \"b\" ms) ++ [(\"c\", \"a\")] ++ (playHanoi [] (init s3) [] \"a\" ms)\nplayHanoi [] [] s3 \"b\" ms = ms ++ (playHanoi [] [] (init s3) \"a\" ms) ++ [(\"c\", \"b\")] ++ (playHanoi (init s3) [] [] \"b\" ms)\n\nhanoi' :: Game -> [Move]\nhanoi' (s1, s2, s3, t, ms) = playHanoi s1 s2 s3 t ms\n\nhanoi :: Integer -> Peg -> Peg -> Peg -> [Move]\nhanoi i p1 p2 p3 = hanoi' (makeHanoi i p1 p2 p3)\n\n\n\n{-\nis there a way to abstract it\n its hardcoded with peg names\n and those things are basically the same\n\n\n\n-}\n", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "-- I don't remember where did I see that exercice,\n-- maybe on leetcode, I'll add the link if I find that again.\n--\n-- The goal is to encode an input Text into another text in\n-- the following pattern of a certain height\n\n-- sample: PAYPALISHIRING (that was the sample text provided) with height 3\n-- pattern: P A H N\n--          APLSIIG\n--          Y I R\n-- result string: PAHNAPLSIIGYIR\n\n-- to work the algorightm out, I wrote the same text in the zigzag pattern\n-- of different heights\n-- the following is the results of my observations:\n-- the letters are numbered from 0\n-- the 2 first result letters are 0 [start] and [phase], actually [start\n-- + phase]\n-- with phase = (height-1)*2\n-- the next letters are applied with the following:\n-- concat all letters from [start] to [start + phase] with \n-- [start + phase - level*2]\n-- where level = the level of the letter in the zigzag.\n-- In the previous zigzag sample, the first letter P is at level 0 \n-- and the second letter A is at level 1, etc...\n\n\nword = \"PAYPALISHIRING\"\n\ngetPhase :: Int -> Int\ngetPhase height_ = (height_ - 1) * 2\n\n\nzigzagline :: [Char] -> Int -> Int -> [Char]\nzigzagline word_ height_ start_ = do\n        if start_ >= length word_\n            then []\n            else\n                word_ !! start_ : middle ++ next\n        where\n            phase = getPhase height_\n            middle = checkBefore word_ height_ start_\n            next = zigzagline word_ height_ $ start_+phase\n\n\ncheckBefore :: [Char] -> Int -> Int -> [Char]\ncheckBefore word_ height_ start_\n    | level == 0 || level == height_-1 = []\n    | before < length word_ = [word_ !! before]\n    | otherwise = []\n    where\n        before = start_ + phase - level * 2\n        phase = getPhase height_\n        level = findLevel height_ start_\n\n\n-- finding the row level at which is the start position\nfindLevel :: Int -> Int -> Int\nfindLevel height_ start_\n    | start_ < height_ = start_\n    | otherwise = findLevel height_ $ start_ - getPhase height_\n\n\n-- main function processing the whole word\nzigzagword :: [Char] -> Int -> [Char]\nzigzagword word_ height_ = \n        concat ([zigzagline word_ height_ x | x <- [0..height_-1]])\n", "input": "42", "status": "success", "output": "82"}
{"code": "\ndata RomanNumeral = I | V | X | L | C | D | M\n    deriving (Show, Eq, Ord)\n\nconvertThousands :: Int -> [RomanNumeral]\nconvertThousands n = replicate n M\n\nconvertHundreds :: Int -> [RomanNumeral]\nconvertHundreds n    \n    | n < 4 = replicate n C\n    | n == 4 = [C, D]\n    | n == 5 = [D]\n    | n < 9 = D : replicate (n - 5) C\n    | n == 9 = [C, M]\n\nconvertTens :: Int -> [RomanNumeral]\nconvertTens n    \n    | n < 4 = replicate n X\n    | n == 4 = [X, L]\n    | n == 5 = [L]\n    | n < 9 = L : replicate (n - 5) X\n    | n == 9 = [X, C]\n\nconvertOnes :: Int -> [RomanNumeral]\nconvertOnes n\n    | n < 4 = replicate n I\n    | n == 4 = [I, V]\n    | n == 5 = [V]\n    | n < 9 = V : replicate (n - 5) I\n    | n == 9 = [I, X]\n\nintToRoman :: Int -> [RomanNumeral]\nintToRoman n =\n    convertThousands (n `div` 1000) ++\n    convertHundreds  ((n `mod` 1000) `div` 100) ++\n    convertTens ((n `mod` 100) `div` 10) ++\n    convertOnes (n `mod` 10) \n\nsingleRomanToInt :: RomanNumeral -> Int\nsingleRomanToInt M = 1000\nsingleRomanToInt D = 500\nsingleRomanToInt C = 100\nsingleRomanToInt L = 50\nsingleRomanToInt X = 10\nsingleRomanToInt V = 5\nsingleRomanToInt I = 1\n\nromanToInt :: [RomanNumeral] -> Int\nromanToInt [] = 0\n\nromanToInt (x:y:xs) =\n    if x < y\n        then singleRomanToInt y - singleRomanToInt x + romanToInt xs\n        else singleRomanToInt x + romanToInt (y:xs)\n\nromanToInt (x:xs) = \n    singleRomanToInt x + romanToInt xs\n\n\nshowNumerals :: [RomanNumeral] -> String\nshowNumerals numerals = concat $ map show numerals\n\nparseNumeral :: Char -> RomanNumeral\nparseNumeral 'M' = M\nparseNumeral 'D' = D\nparseNumeral 'C' = C\nparseNumeral 'L' = L\nparseNumeral 'X' = X\nparseNumeral 'V' = V\nparseNumeral 'I' = I\n\nparseNumerals :: String -> [RomanNumeral]\nparseNumerals = map parseNumeral\n\n\nfile = \"p089_roman.txt\"\n\nreadNumerals :: IO [[RomanNumeral]]\nreadNumerals = do\n    contents <- readFile file\n    return $ map parseNumerals $ words contents    \n\n\ncharsSaved :: [RomanNumeral] -> Int\ncharsSaved numerals = length numerals - length optimisedNumerals\n    where optimisedNumerals = intToRoman $ romanToInt numerals\n\neuler89 = do \n    numerals <- readNumerals\n    print $ sum $ map charsSaved numerals\n", "input": "42", "status": "success", "output": "[M,M,M,M,M,M,M,M,M,M,M,M,M,M,M,M,M,M,M,M,M,M,M,M,M,M,M,M,M,M,M,M,M,M,M,M,M,M,M,M,M,M]"}
{"code": "{--\r\n - Problem 60\r\n(**) Construct height-balanced binary trees with a given number of nodes\r\n    Consider a height-balanced binary tree of height H. What is the maximum number of nodes it can\r\n    contain?\r\n    Clearly, MaxN = 2**H - 1.\r\n    However, what is the minimum number MinN? This question is more difficult. Try to find a recursive \r\n    statement and turn it into a function minNodes that returns the minimum number of nodes in a height-balanced\r\n    binary tree of height H. \r\n    On the other hand, we might ask: what is the maximum height H a height-balanced\r\n    binary tree with N nodes can have? Write a function maxHeight that computes this.\r\n    \r\n    Now, we can attack the main problem: construct all the height-balanced binary trees with a given\r\n    number of nodes. Find out how many height-balanced trees exist for N = 15.\r\n    \r\n    Example in Prolog:\r\n    ?\u2010 count_hbal_trees(15,C).\r\n    C = 1553\r\n    \r\n    Example in Haskell:\r\n    *Main> length $ hbalTreeNodes 'x' 15\r\n    1553\r\n    *Main> map (hbalTreeNodes 'x') [0..3]\r\n    [[Empty],\r\n    [Branch 'x' Empty Empty],\r\n    [Branch 'x' Empty (Branch 'x' Empty Empty),Branch 'x' (Branch 'x' Empty Empty) Empty],\r\n    [Branch 'x' (Branch 'x' Empty Empty) (Branch 'x' Empty Empty)]]\r\n --}\r\n\r\nimport Data.List\r\nimport Data.Maybe\r\n\r\ndata Tree a = Empty | Branch a (Tree a) (Tree a) deriving (Show, Eq)\r\n\r\nmaxN :: Int -> Int\r\nmaxN h = round $ 2 ** fromIntegral h\r\n\r\nminN :: Int -> Int\r\nminN 0 = 0\r\nminN 1 = 1\r\nminN h = 1 + minN (h-1) + minN (h-2)\r\n\r\nminHeight :: Int -> Int\r\nminHeight n = ceiling $ logBase 2 (fromIntegral n)\r\n\r\nmaxHeight :: Int -> Int\r\nmaxHeight n = fromJust (findIndex (> n) $ map minN [0..]) - 1\r\n\r\nhbalTree :: Char -> Int -> Int -> [Tree Char]\r\nhbalTree _ 0 0 = [Empty]\r\nhbalTree c 1 1 = [Branch c Empty Empty]\r\nhbalTree c h n\r\n    | (h > maxHeight n) || (h < minHeight n) = []\r\n    | otherwise = [Branch c l r | p <- pp, q <- [0 .. n-1], l <- hbalTree c (fst p) q, r <- hbalTree c (snd p) (n-1-q)] where\r\n        pp = [(h-2, h-1), (h-1, h-2), (h-1, h-1)]\r\n\r\nhbalTreeNodes :: Char -> Int -> [Tree Char]\r\nhbalTreeNodes c n = concatMap (\\h -> hbalTree c h n) [(minHeight n) .. (maxHeight n)]\r\n", "input": "42", "status": "success", "output": "4398046511104"}
{"code": "-- Chapter-4 Exercises\n\n-- Exercise-1\nimport Data.List (foldl')\n\nfun1 :: [Integer] -> Integer\nfun1 []     = 1\nfun1 (x:xs)\n  | even x    = (x - 2) * fun1 xs\n  | otherwise = fun1 xs\n\nfun1' :: [Integer] -> Integer\nfun1' = product . map (flip (-) 2) . filter even\n\nfun2 :: Integer -> Integer\nfun2 1 = 0\nfun2 n\n  | even n    = n + fun2 (n `div` 2)\n  | otherwise = fun2 (3 * n + 1)\n\nfun2' :: Integer -> Integer\nfun2' = sum . filter even . takeWhile (/=1) . iterate collatz\n  where collatz n\n          | even n = div n 2\n          | otherwise = 3 * n + 1\n            \n-- Exercise-2 -> Not yet Completed :( \n\ndata Tree a = Leaf | Node Integer (Tree a) a (Tree a) deriving (Show, Eq)\n\nfoldTree :: [a] -> Tree a\nfoldTree = foldl addToTree Leaf\n\nheightOfTree :: Tree a -> Integer\nheightOfTree Leaf = -1\nheightOfTree (Node h _ _ _) = h\n\naddToTree :: Tree a -> a -> Tree a\naddToTree Leaf x = Node 0 Leaf x Leaf\naddToTree (Node height lTree node rTree) x\n  | hRight < hLeft = Node height lTree node (addToTree rTree x)\n  | otherwise = Node (height + 1) (addToTree lTree x) node rTree\n  where hRight = heightOfTree rTree\n        hLeft = heightOfTree lTree\n\n-- Exercise-3\n\n-- 1) xor : returns True if and only if there are an odd number of True values\n-- contained in the input list. It does not matter how many False values the\n-- input list contains\n\nxor :: [Bool] -> Bool\nxor = foldl (\\a b -> (a && (not b)) || (b && (not a))) False . filter (\\x -> x) \n\n-- 2) Implementing map as fold\n\nmap' :: (a -> b) -> [a] -> [b]\nmap' f = foldr (\\x acc -> f x : acc) []\n\n-- 3) Implementing foldl using foldr (Optional)\n\nmyFoldl :: (a -> b -> a) -> a -> [b] -> a\nmyFoldl f base  = foldr (flip f) base . reverse   \n\n-- Exercise-4\n\n-- Sieve of Sundaram for finding primes -> I think this will be interesting\n\n-- cartProd : To produce the cartesian product of two lists\n\ncartProd :: [a] -> [b] -> [(a,b)]\ncartProd xs ys = [(x,y) | x <- xs, y <- ys]\n\nsieveSundaram :: Integer -> [Integer]\nsieveSundaram n = map (\\a -> 2*a+1) $ filter (\\x -> not $ x `elem` compositeList) [1..n]\n  where ordPair = cartProd [1..n] [1..n]\n        compositeList = map (\\(x,y) -> x + y + 2*x*y) . filter (\\(i,j) -> (1 <= i) && (i <= j) && ((i+j+2*i*j) <= n)) $ ordPair\n", "input": "[42, 42]", "status": "success", "output": "1600"}
{"code": "-- Austin Zheng\n-- Problem Set 1\n\n-- Exercise 1: defining toDigits and toDigitsRev\n\n-- Given a number, return a list of its digits, reversed.\n-- e.g. 12345 -> [5,4,3,2,1]\ntoDigitsRev :: Integer -> [Integer]\ntoDigitsRev n\n  | n > 0 = n `mod` 10 : toDigitsRev (n `div` 10)\n  | otherwise = []\n\n-- Given a number, return a list of its digits\n-- e.g. 12345 -> [1,2,3,4,5]\ntoDigits :: Integer -> [Integer]\ntoDigits n = reverse (toDigitsRev n)\n\n\n-- Exercise 2: defining doubleEveryOther\n\n-- Given a list of numbers and whether or not to double the first number, double every other number\ndoubleHelper :: [Integer] -> Bool -> [Integer]\ndoubleHelper [] _ = []\ndoubleHelper (n:xn) True = (n * 2) : doubleHelper xn False\ndoubleHelper (n:xn) False = n : doubleHelper xn True\n\n-- Given a list of numbers, double every other number (with the last number remaining untouched)\n-- e.g. [1,2,3,4] -> [2,2,6,4]\ndoubleEveryOther :: [Integer] -> [Integer]\ndoubleEveryOther n\n  | (length n) `mod` 2 == 0 = doubleHelper n True\n  | otherwise = doubleHelper n False\n\n\n-- Exercise 3: defining sumDigits\n\n-- Given a single integer, return the sum of its digits\nsingleSumDigits :: Integer -> Integer\nsingleSumDigits n = foldl (\\m n -> m + n) 0 (toDigitsRev n)\n\n-- Given a list of numbers, calculate the sum of all the digits of all numbers\n-- e.g. [1,23,4,56] -> 21 (by way of 1+2+3+4+5+6)\nsumDigits :: [Integer] -> Integer\nsumDigits n = foldl (\\a b -> a + singleSumDigits b) 0 n\n\n\n-- Exercise 4: defining validate\n\n-- Given a credit card number, return whether or not it validates properly\nvalidate :: Integer -> Bool\nvalidate n = (sumDigits (doubleEveryOther (toDigits n))) `mod` 10 == 0\n\n\n-- Exercise 5: Towers of Hanoi\n-- I hate this puzzle\n\ntype Peg = String\n-- A Move represents a Hanoi action where the top disc from the first Peg is moved to the second Peg\ntype Move = (Peg, Peg)\n-- Given the number of discs and three names for pegs, output a list of all moves necessary to move n discs from the\n-- first peg to the second peg\nhanoi :: Integer -> Peg -> Peg -> Peg -> [Move]\nhanoi 1 source dest temp = [(source, dest)]\nhanoi n source dest temp = (hanoi (n - 1) source temp dest) ++ (hanoi 1 source dest temp) ++ (hanoi (n - 1) temp source dest)\n", "input": "42", "status": "success", "output": "[2,4]"}
{"code": "import Data.List (sortBy, minimumBy)\n\ndata Direction = CounterClockwiseTurn | ClockwiseTurn | NoTurn\n  deriving (Eq, Show)\n\ngrahamScan :: [(Double, Double)] -> [(Double, Double)]\ngrahamScan points = map (decenterPoint minXY) gPoints\n                    where gPoints         = grahamScanHelper sortedPoints\n                          sortedPoints    = sortBy comparePolar centeredPoints\n                          centeredPoints  = map (centerPoint minXY) points\n                          minXY           = minimumBy compareDecart points\n\ndecenterPoint :: (Double, Double) -> (Double, Double) -> (Double, Double)\ndecenterPoint (lvlX, lvlY) = centerPoint (-lvlX, -lvlY)\n\ngrahamScanHelper :: [(Double, Double)] -> [(Double, Double)]\ngrahamScanHelper points = if (length gPoints) < (length points) then\n                            grahamScanHelper gPoints\n                          else\n                            points\n                          where gPoints = grahamScanStep (points ++ (take 1 points))\n\ngrahamScanStep :: [(Double, Double)] -> [(Double, Double)]\ngrahamScanStep (x:y:rest@(z:_)) =\n  if getDirection x y z /= CounterClockwiseTurn then\n    grahamScanStep ( x:rest )\n  else\n    x:( grahamScanStep ( y:rest ) )\ngrahamScanStep (x:xs) = [x]\n\ngetDirection :: (Double, Double)-> (Double, Double) -> (Double, Double) -> Direction\ngetDirection (p1x, p1y) (p2x, p2y) (p3x, p3y) =\n  case (compare r 0) of\n    LT -> ClockwiseTurn\n    EQ -> NoTurn\n    GT -> CounterClockwiseTurn\n  where r = (p2x - p1x) * (p3y - p1y) - (p3x - p1x) * (p2y - p1y)\n\ncomparePolar :: (Double, Double) -> (Double, Double) -> Ordering\ncomparePolar (x1, y1) (x2, y2) =\n  if phi1 == phi2 then\n    compare rho1 rho2\n  else\n    compare phi2 phi1\n  where rho1 = sqrt (x1 ^ 2 + y1 ^ 2)\n        rho2 = sqrt (x2 ^ 2 + y2 ^ 2)\n        phi1 = if rho1 /= 0 then x1 / rho1 else 1\n        phi2 = if rho2 /= 0 then x2 / rho2 else 1\n\ncenterPoint :: (Double, Double) -> (Double, Double) -> (Double, Double)\ncenterPoint (lvlX, lvlY) (x, y) = (x - lvlX, y - lvlY)\n\ncompareDecart :: (Double, Double) -> (Double, Double) -> Ordering\ncompareDecart (x1, y1) (x2, y2) = if y1 == y2 then\n                                    compare x1 x2\n                                  else\n                                    compare y1 y2\n", "input": "[(2.71, 2.71), (2.71, 2.71)]", "status": "success", "output": "[(2.71,2.71)]"}
{"code": "data Dual = Dual Double Double deriving (Read, Show, Eq)\n\nconstantDual :: Double -> Dual\nconstantDual x = Dual x 0\n\nseedDual :: Double -> Double -> Dual\nseedDual x x' = Dual x x'\n\nevaluateDual :: Dual -> Double\nevaluateDual (Dual x _) = x\n\ndifferentiateDual :: Dual -> Double\ndifferentiateDual (Dual _ x') = x'\n\ninstance Num Dual where\n  (+) (Dual u u') (Dual v v') = Dual (u + v) (u' + v')\n  (*) (Dual u u') (Dual v v') = Dual (u * v) (u' * v + u * v')\n  (-) (Dual u u') (Dual v v') = Dual (u - v) (u' - v')\n  negate (Dual u u')          = Dual (negate u) (negate u')\n  abs (Dual u u')             = Dual (abs u) (u' * (signum u))\n  signum (Dual u u')          = Dual (signum u) 0\n  fromInteger n               = Dual (fromInteger n) 0\n\ninstance Fractional Dual where\n  (/) (Dual u u') (Dual v v') = Dual (u / v) ((u' * v - u * v') / (v ** 2))\n  recip (Dual u u')           = Dual (recip u) (-1 * u' * (recip (u ** 2)))\n  fromRational n              = Dual (fromRational n) 0\n\ninstance Floating Dual where\n  pi                = Dual pi 0\n  exp (Dual u u')   = Dual (exp u) (u' * (exp u))\n  sqrt (Dual u u')  = Dual (sqrt u) (u' / (2 * sqrt u))\n  log (Dual u u')   = Dual (log u) (u' / u)\n  sin (Dual u u')   = Dual (sin u) (u' * (cos u))\n  cos (Dual u u')   = Dual (cos u) (-1 * u' * (sin u))\n  tan (Dual u u')   = Dual (tan u) (1 / ((cos u) ** 2))\n  asin (Dual u u')  = Dual (asin u) (u' / (sqrt(1 - (u ** 2))))\n  acos (Dual u u')  = Dual (acos u) ((- 1) * u' / (sqrt(1 - (u ** 2))))\n  atan (Dual u u')  = Dual (atan u) (u' / (1 + (u ** 2)))\n  sinh (Dual u u')  = Dual (sinh u) (u' * cosh u)\n  cosh (Dual u u')  = Dual (cosh u) (u' * sinh u)\n  tanh (Dual u u')  = Dual (tanh u) (u' * (1 - ((tanh u) ** 2)))\n  asinh (Dual u u') = Dual (asinh u) (u' / (sqrt(1 + (u ** 2))))\n  acosh (Dual u u') = Dual (acosh u) ((u' / (sqrt((u ** 2) - 1))))\n  atanh (Dual u u') = Dual (atanh u) (u' / (1 - (u ** 2)))\n  (**) (Dual u u') (Dual v v')\n    = Dual (u ** v) ((u ** v) * (v' * (log u) + (v * u' / u)))\n  logBase (Dual u u') (Dual v v')\n    = Dual (logBase u v) (((log v) * u' / u - (log u) * v' / v) / ((log u) ** 2))\n\n--f :: Dual -> Dual\n--f x = (x ** 3) - sin (x ** 2)\n\n--main = do\n--  putStrLn \"What's the derivative of f(x) = x^2 - sin(x^2) at x = 2?\"\n--  print . differentiateDual . f $ Dual 2 1\n", "input": "2.71", "status": "success", "output": "Dual 2.71 0.0"}
{"code": "import Data.List\n\nfun1 :: [Integer] -> Integer\nfun1 [] = 1\nfun1 (x:xs)\n  | even x = (x - 2) * fun1 xs\n  | otherwise = fun1 xs\n\nfun1' :: [Integer] -> Integer\nfun1' = foldl1' (*) . map (subtract 2) . filter (even)\n\nfun2 :: Integer -> Integer\nfun2 1 = 0\nfun2 n | even n = n + fun2 (n `div` 2)\n  | otherwise = fun2 (3 * n + 1)\n\n-- fun2' :: Integer -> Integer\n-- fun2' n = takeWhile\n\n--Tree data structure\ndata Tree a = Leaf\n             | Node Integer (Tree a) a (Tree a)\n             deriving (Show, Eq)\n\n--Split list in half\nsplitHalf :: [a] -> ([a],[a])\nsplitHalf x = splitAt (div (length x) 2) x\n\n--Add a node to a tree. HELP RUNAWAY TYPES HELPPPPPPPPPPPPPPPP\n-- addNode :: a -> Tree a -> Tree a\n-- addNode a (Node n left@(Node lN lL lM lR) x right@(Node rN rL rM rR)) =\n--   if odd n\n--      then Node n+1 left a right\n--      else Node n+1 right a left\n\n--IF I BREAK THE SUMMING INTO A SEPARATE FUNCTION THEN I CAN RETURN THE TUPLE I WANT WITH LEFT AND RIGHT LENGTHS\n-- treeLen :: (Eq a) => Tree a -> Integer\n-- treeLen (Node _ l _ r) = left + right\n--   where\n--     left = if l == Leaf then 0 :: Integer else 1 + treeLen l\n--     right = if r == Leaf then 0 :: Integer else 1 + treeLen r\n\n-- addNode :: (Eq a) => a -> Tree a -> Tree a\n-- addNode value tree@(Node n l v r)\n--     | l == Leaf || r == Leaf = (Node n+1 Leaf value Leaf)\n--     |\n--     | otherwise =\n--   where nl = treeLen l\n--         nr = treeLen r\n\n-- foldTree :: [a] -> Tree a\n-- foldTree = foldr (\\x acc@(Node n left value right) ->\n\n--Produce balanced binary tree of a list using foldr.\n-- foldTree :: [a] -> Tree a\n-- foldTree [] = Leaf\n-- -- foldTree = foldr (\\x -> (Node (+1) foldTree) x (Node (+1) foldTree)) (Node 0)\n-- foldTree xs = foldr (\\x -> (Node node $ foldTree left) x (Node node $ foldTree right)) Leaf\n--   where\n--     split = splitHalf xs\n--     left  = fst split\n--     right = snd split\n--     node = length left - 1\n\n-- xor :: [Bool] -> Bool\n-- xor x = odd $ foldr (\\x -> if x==True then (+1) else (+0)) 0 x\n\nxor' :: [Bool] -> Bool\nxor' = foldr (\\x acc -> (x || acc) && not (x && acc)) False\n\nmap' :: (a ->b) ->[a] ->[b]\nmap' f = foldr (\\x acc -> f x : acc) []\n\n-- myFoldl :: (a -> b -> a) -> a -> [b] -> a\n-- myFoldl f base xs = foldr (\\x acc -> ((x `f` acc) `f`)) base xs\n--\nf1 :: a -> a -> a\nf1 x y = x\n", "input": "[42, 42]", "status": "success", "output": "1600"}
{"code": "cubo::Float->Float\ncubo lado=lado**3\n\npotencia_2::Float->Float\npotencia_2 x=x*x\n\npotencia_4::Float->Float\npotencia_4 x=potencia_2 x*potencia_2 x\n\ninversa::Float->Float\ninversa x\n\t|x==0=0.0\n\t|otherwise = 1/x\n\nmenor::Int->Int->Int\nmenor x y\n\t|x>y=y\n\t|x<y=x\n\t|otherwise=x\n\nisdifferent::Int->Int->Int->String\nisdifferent x y z\n\t|x==y = \"x = y\"\n\t|x==z = \"x = z\"\n\t|y==z = \"y = z\"\n\nfibonacci::Int->Int\nfibonacci  x\n\t|x==1 = 1\n\t|x==2 = 1\n\t|otherwise=(fibonacci ( x-1)) + (fibonacci  ( x-2))\n\nfatorial::Integer->Integer\nfatorial x\n\t|x==0 = 1\n\t|otherwise=x*fatorial(x-1)\n\ncombinacao::Integer->Integer->Integer\ncombinacao m n=(fatorial (m))`div`( (fatorial (n))*(fatorial(m-n)) )\n\ntoString::Float->String\ntoString x = show x\n\ntoFloat::String->Float\ntoFloat x = read x\n\t\n--  Listas --\n\nlista1::[(Int,Int)]\nlista1 = [(1,5),(5,25)]\n\nminmax::[Int]->(Int,Int)\nminmax lista\n\t|lista == [] = (0,0)\n\t|otherwise = (head(lista),last(lista))\n\nmiololista::String->String\nmiololista lista \n\t|length lista < 2 = \"\"\n\t|otherwise=init(tail(lista))\n\nk_elemento::[gen]->Int->gen\nk_elemento lista k\n\t|k > length lista = last lista\n\t|otherwise = lista!!k\n\ninsere y [] = [y] \ninsere y (x:xs)\n\t|y == x = (x:xs)\n\t|otherwise = x:insere y xs\n\nelimina_rep [a] = [a]\nelimina_rep (x:xs)\n\t|x == head(xs) = elimina_rep xs\n\t|otherwise = x:elimina_rep xs\t\n\ndobro::Int->Int\ndobro x = 2 * x\n\ntriplo::Int->Int\ntriplo x = 3 * x\n\ndist::(Int->Int)->(Int, Int)->(Int, Int)\ndist f (x, y) = (f x, f y)\n\nfuncao::(Int->Int)->Int->Int\nfuncao func x = func x\n\nfresulta::Int->(Int->Int)\nfresulta x \n\t|x == 1 = dobro \n\t|x == 2 = triplo\n\nsextuplo::Int->Int\nsextuplo = dobro.triplo\n\nremoveA::String->String\nremoveA xs = [x | x<-xs, x /='a']\n\ncasamento::(Int,Int, [Int], [Int])->String\ncasamento (0,x,(c:cs),[_,_])=\"Casou\"\ncasamento _ = \"nao casou\"\n\nlistapq::Int->Int->[Int]\nlistapq a b = lista \n\twhere\n\t\tquad x = x^2\n\t\tlista = [quad x|x<-[a..b], mod x 2 == 0]\n\nlistapqlet::Int->Int->[Int]\nlistapqlet a b = let quad x = x^2 in [quad x|x<-[a..b], mod x 2 == 0]\n\nbaskara::Double->Double->Double->(Double, Double)\nbaskara a b c = (x1, x2)\n\twhere\n\t\tdelta = (b^2 - 4*a*c)\n\t\tx1 = (-(b) + sqrt(delta)) / 2*a\n\t\tx2 = (-(b) - sqrt(delta)) / 2*a\n\nrotacaoesq::[a]->[a]\nrotacaoesq (x:xs) = xs++[x]\n\nnrotacaoesq::[a]->Int->[a]\nnrotacaoesq lista n = fim ++ ini\n\twhere\n\t\tini = take n lista\n\t\tfim = drop n lista\n\t \n", "input": "3.14", "status": "success", "output": "30.959146"}
{"code": "-- Exercises from chapter 6.\n\n-- 1\n\n-- A stack overflow happens if a negative argument is passed to the\n-- factorial function. Adding a guard to prevent this in the recursive\n-- case:\n\nfac :: Int -> Int\nfac 0             = 1\nfac n | n > 0     = n * fac (n-1)\n      | otherwise = error \"fac: negative argument\"\n\n-- 2\n\nsumdown :: Int -> Int\nsumdown 0 = 0\nsumdown n = n + sumdown (n-1)\n\n-- 3\n\nmyexp :: Int -> Int -> Int\nmyexp _ 0 = 1\nmyexp n m = n * myexp n (m-1)\n\n-- myexp 2 3 = 2 * myexp 2 2\n--           = 2 * 2 * myexp 2 1\n--           = 2 * 2 * 2 * myexp 2 0\n--           = 2 * 2 * 2 * 1\n--           = 8\n\n-- 4\n\neuclid :: Int -> Int -> Int\neuclid m n | m == n    = m\n           | m > n     = euclid (m-n) n\n           | otherwise = euclid (n-m) m\n\n-- 5\n\n-- length [1, 2, 3] = 1 + length [2, 3] = 1 + 1 + length [3] = 1 + 1 + 1 + length [] = 1 + 1 + 1 + 0 = 3\n-- drop 3 [1, 2, 3, 4, 5] = drop 2 [2, 3, 4, 5] = drop 1 [3, 4, 5] = drop 0 [4, 5] = [4, 5]\n-- init [1, 2, 3] = 1 : init [2, 3] = 1 : 2 : init [3] = 1 : 2 : [] = [1, 2]\n\n-- 6\n\n-- a\n\nmyand :: [Bool] -> Bool\nmyand []        = True\nmyand (False:_) = False\nmyand (True:xs) = myand xs\n\n-- b\n\nmyconcat :: [[a]] -> [a]\nmyconcat []     = []\nmyconcat (x:xs) = x ++ myconcat xs\n\n-- c\n\nmyreplicate :: Int -> a -> [a]\nmyreplicate 0 _ = []\nmyreplicate n a = [a] ++ myreplicate (n-1) a\n\n-- d\n\nmypos :: [a] -> Int -> a\nmypos [] n     = error \"mypos: index too large\"\nmypos (x:_) 0  = x\nmypos (_:xs) n = mypos xs (n-1)\n\n-- e\n\nmyelem :: Eq a => a -> [a] -> Bool\nmyelem x []                 = False\nmyelem x (y:ys) | x == y    = True\n                | otherwise = myelem x ys\n\n-- 7\n\nmerge :: Ord a => [a] -> [a] -> [a]\nmerge [] ys                     = ys\nmerge xs []                     = xs\nmerge (x:xs) (y:ys) | x < y     = [x] ++ merge xs (y:ys)\n                    | otherwise = [y] ++ merge (x:xs) ys\n\n-- 8\n\nhalve :: [a] -> ([a], [a])\nhalve xs = (take n xs, drop n xs)\n  where n = (length xs) `div` 2\n\nmsort :: Ord a => [a] -> [a]\nmsort []  = []\nmsort [x] = [x]\nmsort xs  = merge (msort ys) (msort zs)\n  where (ys, zs) = halve xs\n\n-- 9\n\n-- a\n\nmysum :: Num a => [a] -> a\nmysum []     = 0\nmysum (x:xs) = x + sum xs\n\n-- b\n\nmytake :: Int -> [a] -> [a]\nmytake 0 _      = []\nmytake n (x:xs) = [x] ++ mytake (n-1) xs\n\n-- c\n\nmylast :: [a] -> a\nmylast []     = error \"mylast: empty list\"\nmylast [x]    = x\nmylast (x:xs) = mylast xs\n", "input": "42", "status": "success", "output": "7538058755741581312"}
{"code": "{- #############################################################################\n   Sample code from:\n      Miran Lipova\u010da - Learn You a Haskell for Great Good!, 2011\n      ++++ no starch press ++++\n      http://www.nostarch.com/lyah.htm\n############################################################################# -}\n\nlucky :: Int -> String\nlucky 7 = \"LUCKY NUMBER SEVEN!\"\nlucky x = \"Sorry, you're out of luck. You pick \" ++ show x\n\nfactorial :: (Integral a) => a -> a\nfactorial 0 = 1\nfactorial n | n > 0     = n * factorial (n - 1)\n            | otherwise = error \"Prelude.factorial: undefined for n < 0\"\n\naddVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)\naddVectors (x1,y1) (x2,y2) = (x1+x2, y1+y2)\n\nsumPairs :: [(Int,Int)] -> [Int]\nsumPairs xs = [x + y | (x,y) <- xs]\n\nhead' :: [a] -> Maybe a\nhead' []     = Nothing\nhead' (x:xs) = Just x\n\ntail' :: [a] -> Either String [a]\ntail' []     = Left \"Prelude.tail': empty list\"\ntail' (x:xs) = Right xs\n\ninit' :: [a] -> Either String [a]\ninit' []  = Left \"Prelude.init': empty list\"\ninit' [x] = Right []\ninit' xs  = Right (remLast xs)\n  where remLast [x]    = []\n        remLast (x:xs) = x : remLast xs\n\nlast' :: [a] -> Maybe a\nlast' []     = Nothing\nlast' [x]    = Just x\nlast' (x:xs) = last' xs\n\ntell :: (Show a) => [a] -> String\ntell []      = \"List is empty\"\ntell [x]     = \"List has only 1 element: \" ++ show x\ntell (x:y:_) = \"List begins with \" ++ show x ++ \", \" ++ show y\n\nlength' :: [a] -> Int\nlength' xs = sum [1 | _ <- xs]\n\ncapital :: String -> String\ncapital \"\" = \"String is empty\"\ncapital str@(c:cs) | isLower c = \"No capital, sorry\"\n                   | isUpper c = \"Capital of \" ++ str ++ \" is \" ++ show c\n      where isUpper ch = ch `elem` ['A'..'Z']\n            isLower ch = ch `elem` ['a'..'z']\n\nbmiTell :: (RealFloat a) => a -> a -> String\nbmiTell _ 0 = error \"Prelude.bmiTell: height cannot be 0!\"\nbmiTell 0 _ = error \"Prelude.bmiTell: weight cannot be 0!\"\nbmiTell w h | bmi <= 18.5 = \"You're underwight, you emo!\"\n            | bmi <= 25.0 = \"You're supposedly normal\"\n            | bmi <= 30.0 = \"You're fat\"\n            | otherwise   = \"You're a whale!\"\n    where bmi = w / h ^ 2\n\nmax' :: (Ord a) => a -> a -> a\nmax' a b  | a > b     = a\n          | otherwise = b\n\ninitials :: String -> String\ninitials name = [f] ++ \". \" ++ [l] ++ \".\"\n  where [firstname, lastname] = words name\n        (f:_) = firstname\n        (l:_) = lastname\n", "input": "42", "status": "success", "output": "\"Sorry, you're out of luck. You pick 42\""}
{"code": "import Data.Char\n\n-- Matheus Santiago Neto -- 11621BSI252\n-- Rodrigo Souza Rezende -- 11621BSI245\n-- Hugo Sousa Nasciutti  -- 11621BSI260\n\n{---------------------------------------------------------------------------------\n1. Fa\u00e7a uma fun\u00e7\u00e3o que devolva a mesma lista de strings recebida na entrada, exceto\n   que as letras em cada palavra ficar\u00e3o invertidas entre mai\u00fasculas e min\u00fasculas. Por\n   exemplo, onde tem \u2018e\u2019 troque por \u2018E\u2019, onde tem \u2018E\u2019 troque por \u2018e\u2019, e assim por diante.\n   \nDica: Para inverter um caractere, veja como ele est\u00e1 atualmente (fun\u00e7\u00f5es isUpper e\nisLower da biblioteca Data.Char) e altere-o (fun\u00e7\u00f5es toUpper e toLower, tamb\u00e9m da Data.Char).\n\nExemplo:\n*Main> inverte [\"AUla\",\"de\",\"progrAMACao\"]\n[\"auLA\",\"DE\",\"PROGRamacAO\"]\n-}\n\ninverter_map :: String -> String\ninverter_map [] = \"\"\ninverter_map (x:xs)\n | isLower x == True = toUpper x : inverter_map xs\n | otherwise = toLower x : inverter_map xs\n\ninverte :: [String] -> [String]\ninverte lista = map inverter_map lista\n\n\n{---------------------------------------------------------------------------------\n2. Fun\u00e7\u00e3o maior :: Int -> [Int] -> Int que considera um n\u00famero e o compara com os\n   elementos de uma lista. Caso esse n\u00famero seja maior que todos os elementos da\n   lista, ele ser\u00e1 retornado pela fun\u00e7\u00e3o. Caso contr\u00e1rio, a fun\u00e7\u00e3o retorna o maior\n   elemento da lista. Por exemplo:\n   \n*Main> maior 18 [3 ,6 ,12 ,4 ,55 ,11]\n55\n*Main> maior 111 [3 ,6 ,12 ,4 ,55 ,11]\n111\n-}\n\nmaior :: Int -> [Int] -> Int\nmaior a b = foldr max a b\n\n\n{---------------------------------------------------------------------------------\n3. Fa\u00e7a uma fun\u00e7\u00e3o que devolva uma lista das strings formadas por palavras que se\n   iniciem por uma letra espec\u00edfica.\n   \n*Main> letraEsp 'a' [\"bola\",\"arara\",\"casa\",\"abobora\"]\n[\"arara\",\"abobora\"]\n-}\n\nletraEsp_map :: Char -> String -> Bool\nletraEsp_map letra word\n | letra == head(word) = True\n | otherwise = False\n\nletraEsp :: Char -> [String] -> [String]\nletraEsp letter lista = filter (letraEsp_map letter) lista\n\n\n{---------------------------------------------------------------------------------\n4. Fa\u00e7a uma fun\u00e7\u00e3o que receba um caractere e uma lista de strings e devolva o\n   comprimento da maior string que comece com o caractere dado.\n   \n*Main> maiorComprimento 'e' [\"esse\",\"exercicio\",\"eh\",\"simples\"]\n9\n-}\n\nmaiorComprimento :: Char -> [String] -> Int\nmaiorComprimento letra word = foldr (max) 0 (map length word)\n\n\n\n\n\n\n\n", "input": "\"hello\"", "status": "success", "output": "\"HELLO\""}
{"code": "-- \u0412\u0430\u0440\u0438\u0430\u043d\u0442 1\n-- \u0417\u0430\u0434.1\n--\n-- \u0441 fromIntegral \u043f\u0440\u0430\u0432\u0438\u043c \u0441\u043f\u0438\u0441\u044a\u043a\u0430 \u043e\u0442 1 \u0434\u043e n, \u043d\u043e \u0441 Double \u0447\u0438\u0441\u043b\u0430.\n-- \u043d\u044f\u043c\u0430 \u0434\u0430 \u0441\u0435 \u0437\u0430\u044f\u0436\u0434\u0430\u043c \u0437\u0430 fromIntegral \u0447\u0430\u0441\u0442\u0442\u0430.\npie :: Int -> Double\npie n = 4 * sum [doStuff k | k <- [1..(fromIntegral n)]]\n    where doStuff t = ((-1) ** (t + 1)) * (1 / (2 * t - 1))\n\n-- \u0417\u0430\u0434.2\n-- \u0422\u0443\u043a \u043d\u0438 \u0442\u0440\u044f\u0431\u0432\u0430 Eq a, \u0437\u0430\u0449\u043e\u0442\u043e \u0432 count \u0438 remove \u0441\u0440\u0430\u0432\u043d\u044f\u0432\u0430\u043c\u0435 \u0441 (==) \u0438 (/=)\nlistToBag :: Eq a => [a] -> [(a, Int)] \nlistToBag [] = []\nlistToBag lst@(x:xs) = (x, count x lst) : listToBag (remove x lst)\n    where count x = length . (filter (== x))\n          remove x = filter (/= x)\n\nbagElem :: Eq a => a -> [(a, Int)] -> Bool\nbagElem _ [] = False\nbagElem a ((value,_):rest)\n    |a == value = True\n    |otherwise = bagElem a rest\n-- \u0438\u043b\u0438\n-- bagElem a bag = a `elem` (map fst bag)\n\nbagEqual :: Eq a => [(a, Int)] -> [(a, Int)] -> Bool\nbagEqual [] [] = True\nbagEqual _ [] = False\nbagEqual [] _ = False\nbagEqual (x:xs) ys = x `elem` ys && bagEqual xs (removeOnce x ys)\n        where removeOnce x xs = takeWhile (/= x) xs ++ tail (dropWhile (/= x) xs) \n\nbagUnion :: Eq a => [(a, Int)] -> [(a, Int)] -> [(a, Int)]\nbagUnion xs ys = reduce (xs ++ ys)\n   where reduce [] = []\n         reduce (x:xs)\n           |(fst x) `bagElem` xs && (snd x) <= snd (find x xs) = reduce xs\n           |otherwise = x : reduce (remove x xs)\n         find _ [] = error \"wtf?\"\n         find t (z:zs)\n           |(fst t) == (fst z) = z\n           |otherwise = find t zs\n         remove x = filter (\\y -> (fst y) /= (fst x))\n\n-- \u0417\u0430\u0434.3\nbools :: Int -> [[Bool]]\nbools 0 = []\nbools 1 = [[True], [False]]\nbools n = [True:x | x <- bools (n - 1)] ++ [False:x | x <- bools (n - 1)]\n\n-- \u0417\u0430\u0434.4\nmyFilterMapAnd :: [a -> Bool] -> [a] -> [a]\nmyFilterMapAnd _ [] = []\nmyFilterMapAnd [] x = x\nmyFilterMapAnd (p:ps) xs = myFilterMapAnd ps (filter p xs)\n\n\n-- \u0412\u0430\u0440\u0438\u0430\u043d\u0442 2\n-- \u0417\u0430\u0434.1\npie' :: Int -> Double\npie' n = 2 * product [(2 * k) / (2 * k - 1) * (2 * k) / (2 * k + 1) | k <- [1..(fromIntegral n)]]\n\n-- \u0417\u0430\u0434.3\nnumbers :: Int -> [[Int]]\nnumbers 0 = []\nnumbers 1 = [[0],[1],[2]]\nnumbers n = concat [[0:x,1:x,2:x] | x <- numbers (n - 1)]\n\n-- \u0417\u0430\u0434.4\nmyFilterMapOr :: [a -> Bool] -> [a] -> [a]\nmyFilterMapOr _ [] = []\nmyFilterMapOr ps (x:xs)\n    |or' ps x = x : myFilterMapOr ps xs\n    |otherwise = myFilterMapOr ps xs\n      where or' [] _ = False\n            or' (p:ps) x\n             |p x = True\n             |otherwise = or' ps x\n", "input": "42", "status": "success", "output": "3.117786501758878"}
{"code": "---Factorial-------------------\nmyFactorial :: Int -> Int\nmyFactorial 0 = 1\nmyFactorial n = n * myFactorial (n-1)\n---------Add 2 Vectors-----------\naddVectors :: (Double, Double)->(Double, Double)->(Double,Double)\naddVectors (x1, y1) (x2, y2) = (x1+x2, y1+y2)\n--------Third element in tuple---\nthird :: (a,b,c)->c\nthird (_,_,c) = c\n-------As Pattern----------------\nasPattern :: String -> String\nasPattern all@(x:y:ys) = all++\" shows \"++[x,y]++ys\n------Initials-------------------\ninitials :: String->String->String\ninitials fname lname = [f] ++ \".\" ++ [l] ++ \".\"\n\twhere\t(f:_) = fname\n\t\t(l:_) = lname\n------Square List----------------\nsquareList :: [Int] -> [Int]\nsquareList [] = [mysquare x | x<-[2]]\n\twhere mysquare x = x*x\n-------Describe List-------------\ndescribeList :: [a]->String\ndescribeList ls = \"The List is \" ++ case ls of \t[] -> \"empty\"\n\t\t\t\t\t\t[x] -> \"singleton\"\n\t\t\t\t\t\txs -> \"long list\"\n------Replicate------------------\nmyReplicate :: Int->a->[a]\nmyReplicate a b\t|a<=0 = []\n\t\t|otherwise = (b:myReplicate (a-1) b)\n------Take-----------------------\nmyTake :: Int -> [a] -> [a]\nmyTake _ [] = []\nmyTake n (x:xs)\n\t|n<=0 = []\n\t|otherwise = x:(myTake (n-1) xs)\n-------Compare with 100----------\ncompareWith100 :: Int->Ordering\ncompareWith100 = compare 100\n-------HOF apply twice-----------\napplyTwice :: (a->a)->a->a\napplyTwice f x = f (f x)\n-------Zip with hof--------------\n--zipWith' :: (a->b->c)->[a]->[b]->[c]\nzipWith' _ [] _ = []\nzipWith' _ _ [] = []\nzipWith' f (x:xs) (y:ys) = f x y:zipWith' f xs xs\t\t\n-------Flip hof------------------\nflip' :: (a->b->c)->(b->a->c)\nflip' f = g\n\twhere g x y = f y x\n------Filter---------------------\nfilter' :: (a->Bool)->[a]->[a]\nfilter' _ [] = []\nfilter' f (x:xs)\n\t|f x = x:filter' f xs\n\t|otherwise = filter' f xs\n------Lambda---------------------\nnumChain :: Num a => [[a]]->Int\nnumChain l = length (filter (\\l -> length l > 15) l)\n-------Foldr -> map--------------\nmap' :: (a->b)->[a]->[b]\nmap' f l = foldr (\\x acc -> f x:acc)  [] l\n-------Foldl -> map--------------\nmap'' :: (a->b)->[a]->[b]\nmap'' f = foldl (\\acc x -> acc ++ [f x]) []\n------Foldr ->`elem`-------------\nelem' :: (Eq a) => a->[a]->Bool\nelem' e l = foldr f False l\n\twhere f x acc = (if x == e then True else acc)\n------Foldr -> reverse-----------\nreverse' :: [a] -> [a]\nreverse' l = foldr (\\x acc -> acc ++ [x]) [] l\n-----Foldr ->Filter--------------\nfilter'' :: (a->Bool)->[a]->[a]\nfilter'' f l = foldr (\\x acc -> (if f x == True then x:acc else acc)) [] l\n", "input": "42", "status": "success", "output": "7538058755741581312"}
{"code": "-- (1) support functions\r\nfac :: Integer -> Integer\r\nfac n = if n == 0 then 1 else (n * fac(n-1))\r\n\r\nfac' :: Integer -> [Integer]\r\nfac' m = [ x | x <- [2 .. if m > 6 then (truncate (logBase 2 (fromIntegral m))) else m], fac x == m]\r\n\r\n-- (1) main function\r\nfacInv :: Integer -> Integer\r\nfacInv m = if null x then -1 else (head x)\r\n\twhere x = (fac' m)\r\n\r\n---------------------------------------------------------\r\n\r\n-- (2) main function\r\nextractDigits :: String -> String\r\nextractDigits s = [t | t <- s, elem t ['0' .. '9']]\r\n\r\n---------------------------------------------------------\r\n\r\n-- (3) support function\r\nextractDigits' :: String -> String\r\nextractDigits' s = [t | t <- s, elem t ['0' .. '9']]\r\n\r\n-- (3) main function\r\nconvert :: String -> Integer\r\nconvert s = if null (extractDigits' s) then 0 else read (extractDigits' s)\r\n\r\n---------------------------------------------------------\r\n\r\n-- (4) support functions\r\nisPrime' :: Int -> Int -> Bool\r\nisPrime' num x\r\n\t\t\t\t| num == 0         = False\r\n\t\t\t\t| num == 1         = False\r\n        \t\t| x == num         = True\r\n        \t\t| (mod num x) == 0 = False\r\n        \t\t| otherwise        = isPrime' num (x + 1)\r\n\r\nisPrime :: Int -> Bool\r\nisPrime num = isPrime' num 2\r\n\r\ncheckForProperPrime :: String -> Int -> Int -> Bool\r\ncheckForProperPrime s n t = if ((read (take n (drop t s)) :: Integer) /= 0) && (length (show (read (take n (drop t s)) :: Integer)) == n) && (isPrime (read (take n (drop t s)))) then True else False \r\n\r\nfindLeftMostPrime' :: String -> Int -> Int -> Integer\r\nfindLeftMostPrime' s n t\r\n\t\t\t\t\t\t | (t == length s) || (n > (length s)) || (n == 0) = 0\r\n\t\t\t\t\t\t | checkForProperPrime s n t \t   \t\t\t\t   = read (take n (drop t s))\r\n\t\t\t\t\t\t | otherwise\t\t\t\t \t   \t\t\t\t   = findLeftMostPrime' s n (t+1)\r\n\r\n-- (4) main function\r\nfindLeftMostPrime :: String -> Int -> Integer\r\nfindLeftMostPrime s n = findLeftMostPrime' (extractDigits s) n 0\r\n\r\n---------------------------------------------------------\r\n\r\n-- (5) support function\r\nfindAllPrimes' :: String -> Int -> Int -> [Integer] -> [Integer]\r\nfindAllPrimes' s n t l\r\n\t\t\t\t\t\t \t| (n > (length s)) || (n == 0)  = []\r\n\t\t\t\t\t\t \t| (t == (length s))             = l\r\n\t\t\t\t\t\t \t| checkForProperPrime s n t     = findAllPrimes' s n (t+1) (l ++ [read (take n (drop t s))])\r\n\t\t\t\t\t\t \t| otherwise\t\t\t\t \t   \t= findAllPrimes' s n (t+1) l\r\n\r\n-- (5) main function\r\nfindAllPrimes :: String -> Int -> [Integer]\r\nfindAllPrimes s n = findAllPrimes' (extractDigits s) n 0 []\r\n\r\n---------------------------------------------------------", "input": "42", "status": "success", "output": "1405006117752879898543142606244511569936384000000000"}
{"code": "import qualified Data.Map as M\nimport Data.Maybe (fromJust)\nimport Data.List (findIndex)\n\ndata Date = Date { weekDay :: WeekDay, day :: Int, month :: Month, year :: Int } deriving (Show, Eq)\n\ndata WeekDay = \n    Mon | Tue | Wed | Thu | Fri | Sat | Sun deriving (Show, Eq, Ord)\n\nweekdayList = [Mon, Tue, Wed, Thu, Fri, Sat, Sun]\nweekdayMap = M.fromList (weekdayList  `zip` [1..])\n\ndata Month = \n    Jan | Feb | Mar | Apr | May | Jun | Jul | Aug | Sep | Oct | Nov | Dec deriving (Show, Eq, Ord)\n\nmonthList = [Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec]\nmonthMap = M.fromList (monthList  `zip` [1..])\n\ninstance Enum WeekDay where\n  succ d = case (findIndex (d==) weekdayList) of\n      Just(x) -> if (x == 6) then Mon else weekdayList !! (x + 1)\n  pred d = case (findIndex (d==) weekdayList) of\n      Just(x) -> if (x == 0) then Sun else weekdayList !! (x - 1)\n  fromEnum d = fromJust $ M.lookup d weekdayMap\n  toEnum i = weekdayList !! i\n\ninstance Enum Month where\n  succ d = case (findIndex (d==) monthList) of\n      Just(x) -> if (x == 11) then Jan else monthList !! (x + 1)\n  pred d = case (findIndex (d==) monthList) of\n      Just(x) -> if (x == 0) then Dec else monthList !! (x - 1)\n  fromEnum d = fromJust $ M.lookup d monthMap\n  toEnum i = monthList !! i\n\nstart = Date { weekDay = Tue, day = 1, month = Jan, year = 1901 }\nend = Date { weekDay = Sun, day = 31, month = Dec, year = 2000 }\n\nsuccDate d@(Date w 31 Dec y) = d { weekDay = succ w, day = 1, month = Jan, year = succ y }\nsuccDate d@(Date w dd Feb y)\n  | (isLeap y && dd == 29) || ((not . isLeap) y && dd == 28) = d { weekDay = succ w, day = 1, month = Mar}\n  | otherwise = d { weekDay = succ w, day = succ dd }\nsuccDate d@(Date w dd mm y)\n  | isEndOfMonth = d { weekDay = succ w, day = 1, month = succ mm }\n  | otherwise = d { weekDay = succ w, day = succ dd }\n  where isEndOfMonth = (mm `elem` months31 && dd == 31) || (mm `elem` months30 && dd == 30)\n        months31 = [Jan, Mar, May, Jul, Aug, Oct, Dec]\n        months30 = [Apr, Jun, Sep, Nov]\n\ninstance Enum Date where\n  succ =  succDate\n  pred d = end\n  fromEnum d = 1 -- from date to unix ts\n  toEnum i = start -- from unix ts to date\n\nisLeap :: Int -> Bool\nisLeap x\n  | x `mod` 100 == 0 = x `mod` 400 == 0 \n  | otherwise = x `mod` 4 == 0\n\nmakeInfList x = x : makeInfList (succ x)\n\ncountingSundays :: Int\ncountingSundays = foldl (\\acc v -> case v of\n    Date Sun 1 _ _ -> acc + 1\n    _ -> acc\n                        ) 0 l\n  where\n    nextEnd = succ end\n    l = takeWhile (/=nextEnd ) $ makeInfList start\n\n-- countingSundays == 171\n\n", "input": "42", "status": "success", "output": "False"}
{"code": "--1\nmes :: Int -> String\nmes x = if(x==1) then \"Janeiro\"  else\n\t\tif(x==2) then \"Fevereiro\"else\n\t\tif(x==3) then \"Marco\"    else\n\t\tif(x==4) then \"Abril\"    else\n\t\tif(x==5) then \"Maio\"     else\n\t\tif(x==6) then \"Junho\"    else\n\t\tif(x==7) then \"Julho\"    else\n\t\tif(x==8) then \"Agosto\" \t else\n\t\tif(x==9) then \"Setembro\" else\n\t\tif(x==10)then \"Outubro\"  else\n\t\tif(x==11)then \"Novembro\" else\n\t\tif(x==12)then \"Dezembro\" else \"Error\"\n\t\t\n--2. Fa\u00e7a uma fun\u00e7\u00e3o que receba dois valores e informe o maior. Obs: Utilize guardas.\nmaior :: Int -> Int -> Int\nmaior x y\n\t| x > y = x\n\t| otherwise = y\n\t\n--3. Fa\u00e7a uma fun\u00e7\u00e3o que receba tr\u00eas valores e informe o maior. Obs: Utilize if/else.\nmaior_3 :: Int -> Int -> Int -> Int\nmaior_3 x y z = if(x > y && x > z) then x else\n\t\t\t\tif(y > z) then y else z\n\t\n--4. Fa\u00e7a uma fun\u00e7\u00e3o que recebe um inteiro e retorna verdadeiro se o n\u00famero for par. Fa\u00e7a duas implementa\u00e7\u00f5es, uma com if/else e outra com guardas.\nse_par :: Int -> String\nse_par x = if(mod x 2 == 0) then \"Verdadeiro\" else \"Falso\"\n\nse_par2 :: Int -> String\nse_par2 x\n\t| mod x 2 == 0 = \"Verdadeiro\"\n\t| otherwise = \"Falso\"\n\n--5. Fa\u00e7a uma fun\u00e7\u00e3o que recebe tr\u00eas inteiros x, y e z e imprime \u201cO ultimo numero eh multiplo\u201d caso z seja m\u00faltiplo de x ou de z, ou, caso contr\u00e1rio, \"O ultimo numero nao eh multiplo de nenhum dos dois\". Utilize guardas.\nmultiplo :: Int -> Int -> Int -> String\nmultiplo x y z \n\t| mod z x == 0 || mod z x == 0 = \"O ultimo numero eh multiplo\"\n\t| otherwise = \"O ultimo numero nao eh multiplo de nenhum dos dois\"\n\n--6. Considere que o pre\u00e7o de uma passagem de avi\u00e3o em um trecho pode variar dependendo da idade do passageiro. Pessoas com 60 anos ou mais pagam apenas 60% do pre\u00e7o total. Crian\u00e7as at\u00e9 10 anos pagam 50% e beb\u00eas (abaixo de 2 anos) pagam apenas 10%. Fa\u00e7a uma fun\u00e7\u00e3o que tenha como entrada o valor total da passagem e a idade do passageiro e produz o valor a ser pago.\npassagem :: Float -> Float -> Float\npassagem idade pass = if(idade >= 60) then pass * 0.6 else\n\t\t\t\t\t  if(idade <= 10 && idade >=3) then pass * 0.5 else\n\t\t\t\t\t  if(idade <= 2)  then pass * 0.1 else pass\n\t\t\t\t\t  \n--7. Uma empresa decidiu dar a seus funcion\u00e1rios um abono de sal\u00e1rio, baseando-se nos pontos obtidos durante o m\u00eas, de acordo com a tabela: Fa\u00e7a uma fun\u00e7\u00e3o que informe o abono de sal\u00e1rio de um funcion\u00e1rio. Utilize guardas.\nabono :: Int -> Int\nabono pontos \n\t| pontos >= 1  && pontos <= 10 = 100\n\t| pontos >= 11 && pontos <= 20 = 200\n\t| pontos >= 21 && pontos <= 30 = 300\n\t| pontos >= 31 && pontos <= 40 = 400\n\t| pontos >= 41 = 500\n\t\n\t\n\n\n\n\n\n\n\n\n\t\t\n\t\t\n\t\t", "input": "42", "status": "success", "output": "\"Error\""}
{"code": "{- Chapter 16 :: Reasoning about programs -}\n\ndouble :: Int -> Int\ndouble x = x + x\n\nisZero :: Int -> Bool\nisZero 0 = True\nisZero n | n /= 0 = False\n\nnot' :: Bool -> Bool\nnot' False = True\nnot' True = False\n\ndata Nat = Zero | Succ Nat deriving Show\n\nadd :: Nat -> Nat -> Nat\nadd Zero m     = m\nadd (Succ n) m = Succ (add n m)\n\n{- \n\n> add Zero (Succ Zero)\nSucc Zero\n\n> add (Succ (Succ Zero)) (Succ (Succ (Succ Zero)))\nSucc (Succ (Succ (Succ (Succ Zero))))\n\nreplicate :: Int -> a -> [a]\nreplicate 0 = []\nreplicate n x = x : replicate (n-1) x\n\n------------------ Induction on lists -----------------\n\nreverse (reverse [])\n= reverse []\n= []\n\nreverse (reverse (x:xs))\n= reverse (reverse xs ++ [x]))\n= reverse [x] ++ reverse (reverse xs) -- distributive property\n= [x] ++ xs\n= x : xs\n\nBase case:\nreverse ([] ++ ys)\n= reverse ys\n= reverse ys ++ []\n= reverse ys ++ reverse []\n\nInductive case:\nreverse ((x:xs) ++ ys)\n= reverse (x : (xs ++ ys))\n= reverse (xs ++ ys) ++ [x]\n= (reverse ys ++ reverse xs) ++ [x]\n= reverse ys ++ (reverse xs ++ [x]) -- unapplying second reverse\n= reverse ys ++ reverse (x:xs)\n\n-}\n\nreverse'' :: [a] -> [a] -> [a]\nreverse'' [] ys = ys\nreverse'' (x:xs) ys = reverse'' xs (x:ys)\n\n{-\n\n> reverse'' [1,2,3] [4,5,6]\n[3,2,1,4,5,6]\n\n-}\n\nreverse''' :: [a] -> [a]\nreverse''' xs = reverse'' xs []\n\n\n{-\n\n> reverse''' [1,2,3]\n[3,2,1]\n\n\nreverse''' [1,2,3]\n= reverse'' [1,2,3] []\n= reverse'' [2,3] (1:[])\n= reverse'' [3] (2:1:[])\n= reverse'' [] (3:2:1:[])\n= 3:2:1:[]\n\n-}\n\n\ndata Tree = Leaf Int | Node Tree Tree deriving Show\n\nflatten :: Tree -> [Int]\nflatten (Leaf n) = [n]\nflatten (Node l r) = flatten l ++ flatten r\n\n\nflatten' :: Tree -> [Int] -> [Int]\nflatten' (Leaf n) ns = n : ns\nflatten' (Node l r) ns = flatten' l (flatten' r ns)\n\nflatten'' :: Tree -> [Int]\nflatten'' t = flatten' t []\n\n{-\n\n> flatten (Node (Leaf 1) (Leaf 2))\n[1,2]\n\n> flatten' (Leaf 1) []\n[1]\n\n> flatten'' (Node (Leaf 1) (Leaf 2))\n[1,2]\n\n\n-}\n\n\ndata Expr = Val Int | Add Expr Expr deriving Show\n\neval :: Expr -> Int\neval (Val n) = n\neval (Add x y) = eval x + eval y\n\ntype Stack = [Int]\ntype Code = [Op]\n\ndata Op = PUSH Int | ADD deriving Show\n\nexec :: Code -> Stack -> Stack\nexec []           s        = s\nexec (PUSH n : c) s        = exec c (n : s)\nexec (ADD : c) (m : n : s) = exec c (n+m : s)\n\ncomp :: Expr -> Code\ncomp (Val n) = [PUSH n]\ncomp (Add x y) = comp x ++ comp y ++ [ADD]\n\ne = Add (Add (Val 2) (Val 3)) (Val 4)\n\n{-\n\n> eval e\n9\n\n> comp e\n[PUSH 2,PUSH 3,ADD,PUSH 4,ADD]\n\n> exec (comp e) []\n[9]\n\n\n-}\n\ncomp' :: Expr -> Code -> Code\ncomp' (Val n) c = PUSH n : c\ncomp' (Add x y) c = comp' x (comp' y (ADD : c))\n\n", "input": "42", "status": "success", "output": "84"}
{"code": "import Data.List\n\n------------------------------------------------------------------------------------------\n-----------------------------------------------------------------2.-Starting-out----------\n\ndoubleSmallNumber x = if x>100\n\t\t\tthen x\n\t\t\telse x*2\n\nmultiply xs xt = [ x*y | x <- xs, y <- xt, x*y > 20]\n\nremoveNonUppercase xs = [ x | x <- xs, x `elem` ['A'..'Z'] ]\n\ntriangle = [ (a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2]\n\n------------------------------------------------------------------------------------------\n----------------------------------------------------------4.-Syntax-in-Functions----------\n\nfactorial :: Integer -> Integer\nfactorial 0 = 1\nfactorial n = n * factorial (n - 1)\n\nlength' :: (Num b) => [a] -> b  \nlength' [] = 0  \nlength' (_:xs) = 1 + length' xs\n\n------------------------------------------------------------------------------------------\n--------------------------------------------------------------------5.-Recursion----------\n\nmaximum2 :: (Ord a) => [a] -> a\nmaximum2 [] = error \"error\"\nmaximum2 [x] = x\nmaximum2 (x:s) = max x (maximum2 s)\n\nreplicate2 :: (Integral a) => a -> a -> [a]\nreplicate2 0 _ = []\nreplicate2 x y = y:(replicate2 (x-1) y)\n\nquicksort :: (Ord a) => [a] -> [a]  \nquicksort [] = []  \nquicksort (x:s) = t ++ [x] ++ u\n\twhere t = quicksort [ y | y <- s, y < x ]\n\t      u = quicksort [ y | y <- s, y >= x ]  \n\n------------------------------------------------------------------------------------------\n-------------------------------------------------------6.-Higher-order-funcitons----------\n\nfoldl2 :: (a -> b -> a) -> a -> [b] -> a\nfoldl2 f x [] = x\nfoldl2 f x (y:s) = foldl2 f (f x y) s\n\n------------------------------------------------------------------------------------------\n----------------------------------------------------------------------7.-Modules----------\n\n------------------------------------------------------------------------------------------\n-----------------------------------------8.-Making-our-own-Types and Typeclasses----------\n\ndata Shape = Circuit Float | Rectangle Float Float deriving (Show)\n\nsurface :: Shape -> Float\nsurface (Circuit r) = r ^ 2 * pi\nsurface (Rectangle a b) = a * b\n\ndata Vehicle = Vehicle { kind :: String\n    , marque :: String\n    , color :: String\n    } deriving (Show)\n\ndata Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday deriving (Eq, Ord, Enum, Show)\n\ndata Tree a = Empty | Node a (Tree a) (Tree a) deriving (Show, Eq)\n\ndata TrafficLight = Green | Yellow | Red\n\ninstance Show TrafficLight where\n    show Green = \"Green light\"\n    show Yellow = \"Yellow light\"\n    show Red = \"Red light\"\n\n", "input": "42", "status": "success", "output": "1405006117752879898543142606244511569936384000000000"}
{"code": "{- 6.8 Exercises -}\n\n{- 1. -}\n\n-- factorial function that prohibits negative arguments. \n\nfac'' :: Int -> Int\nfac'' n | n < 0  = error \"input is negative\"\n        | n == 0 = 1\n        | otherwise = n * fac'' (n-1)\n\n\n{- 2. -} \n\nsumdown :: [Int] -> Int\nsumdown []   = 0\nsumdown (x:xs) = x + sumdown xs \n\n{- 3. -}\n\n(^*) :: Int -> Int -> Int\nx ^* 0 = 1\nx ^* n = x * (x ^* (n-1))\n\n{- 4. -}\n\neuclid :: Int -> Int -> Int\neuclid x y | x == y = x\n           | otherwise = if x < y\n                          then euclid x (y-x)\n                         else euclid y (x-y) \n\n\n{- 5. \n\n    length [1,2,3]\n=   1 + (length [2,3])\n=   1 + (1 + (length [3]))\n=   1 + (1 + (1 + (length [])))\n=   1 + 1 + 1 + 0\n=   3\n\n    drop 3 [1,2,3,4,5]\n=   drop 2 [2,3,4,5]\n=   drop 1 [3,4,5]\n=   drop 0 [4,5]\n=   [4,5]\n\n    init [1,2,3]\n=   1 : init [2,3]\n=   1 : init 2 : init [3]\n=   1 : init 2 : []\n=   [1,2]\n\n-}\n\n{- 6. -}\n\n-- a. Decide if all logical values in a list are True:\nand' :: [Bool] -> Bool\nand' [] = True\nand' (x:xs) = x && (and xs)\n\n-- b. Concatenate a list of lists:\nconcat' :: [[a]] -> [a]\nconcat' [] = []\nconcat' (x:xs) = x ++ (concat' xs)\n\n-- c. Produce a list with n identical elements:\nreplicate' :: Int -> a -> [a]\nreplicate' 0 x = []\nreplicate' n x = x : (replicate' (n-1) x)\n\n-- d. Select the nth element of a list:\n(!!*) :: [a] -> Int -> a\n(x:xs) !!* n | n  <   0     = error \"negative index\"\n             | n  ==  0     = x\n             | otherwise    = xs !!* (n-1)\n\n-- e. Decide if a value is an element of a list:\n\n-- elem' :: Eq a => a -> [a] -> Bool\n-- elem' a [] = False\n-- elem' a (x:xs) | x == a = True\n--                | otherwise = False || (elem' a xs)\n--\n-- Rewritten as:\n\nelem' :: Eq a => a -> [a] -> Bool\nelem' a (x:xs) | (x:xs) == []  = False\n               | x      == a   = True\n               | otherwise     = False || (elem' a xs)\n\n\n{- 7. -}\n\nmerge :: Ord a => [a] -> [a] -> [a]\nmerge xs     []     = xs\nmerge []     ys     = ys\nmerge (x:xs) (y:ys) | x <= y    = x : merge xs (y:ys)\n                    | otherwise = y : merge (x:xs) ys\n\n{- 8. -}\n\nhalve :: [a] -> ([a],[a])\nhalve [] = ([],[])\nhalve xs = splitAt (length xs `div` 2) xs\n\n-- msort :: Ord a => [a] -> [a]\n-- msort [] = []\n-- msort [x] = [x]\n-- msort xs = merge (msort (fst $ halve xs)) (msort (snd $ halve xs))\n--\n-- Rewritten as:\n\nmsort :: Ord a => [a] -> [a]\nmsort []  = []\nmsort [x] = [x]\nmsort xs  = merge (msort a) (msort b)\n           where (a, b) = halve xs\n\n{- 9. -}\n\nsum' :: Num a => [a] -> a\nsum' []     = 0\nsum' (x:xs) = x + sum' xs\n\n\ntake' :: Int -> [a] -> [a]\ntake' 0 xs     = []\ntake' n (x:xs) = x : take' (n-1) xs\n\nlast' :: [a] -> a\nlast' (x:xs) | null xs  = x\n             | otherwise = last' xs\n\n\n\n\n\n", "input": "42", "status": "success", "output": "7538058755741581312"}
{"code": "import Data.Char\nimport Data.List\n\n-- Ex.1\nreverseOrdStuff :: Int -> Int\nreverseOrdStuff = readInt . reverse . show . last . sort . \n  map readInt . filter descending . filter (not . null) . tails . show\n  where readInt :: String -> Int\n        readInt = read\n        descending (x:[]) = True\n        descending (x:y:xs) = ord x > ord y && descending (y:xs)\n\n-- Ex. 2\nsumUnique :: [[Int]] -> Int\nsumUnique = sum . concat . map delNonUnique\n  where delNonUnique [] = []\n        delNonUnique (x:xs)\n          | elem x xs = delNonUnique (filter (not . (==x)) xs)\n          | otherwise = x : delNonUnique xs\n\n-- Ex. 3\ntype Product = (String,Double)\ntype StoreAvailability = [Product]\n\n-- a)\nclosestToAverage :: StoreAvailability -> String\nclosestToAverage xs = let l = fromIntegral $ length xs in\n  let avg = (/l) . sum . map (\\(_, price) -> price) $ xs\n  in snd . head . sort . map (\\(s, d) -> (abs $ d - avg, s)) $ xs\n\n-- b)\ncheaperAlternative :: StoreAvailability -> Int\ncheaperAlternative [] = 0\ncheaperAlternative (x:xs) =\n  if diff xs x\n  then 1 + cheaperAlternative (filter (not . (==fst x) . fst) xs)\n  else cheaperAlternative xs\n  where diff [] _ = False\n        diff (x:xs) el\n          | fst x == fst el   = snd x > snd el || snd x < snd el || diff xs el\n          | otherwise = diff xs el\n\n-- Ex. 4\ntype Point = (Double, Double, Double) \n\ndistance :: Point -> Point -> Double\ndistance (x1, y1, z1) (x2, y2, z2) = (x1 - x2) ^ 2 + (y1 - y2) ^ 2 + (z1 - z2) ^ 2\n\nminDistance :: [(Double, Double, Double)] -> Double\nminDistance ps = let distances = [ distance p1 p2 | p1 <- ps, p2 <- filter (not . (==p1)) ps]\n                 in  head . sort $ distances\n\n-- Ex. 5\nmaximize :: (Ord a, Num a) => [(a -> a)] -> (a -> a)\nmaximize fs x = snd . last . sort . map (\\f -> (abs $ f x, f x)) $ fs\n\n-- Ex. 6\ninverseFun :: (Int -> Int) -> (Int -> Int) -> Int -> Int -> Bool\ninverseFun f g a b = null . filter (\\x -> fst x /= snd x) . map (\\x -> (f .g $ x, x)) $ [a..b]\n\n-- Ex. 7\ndata BTree a = Empty | Node a (BTree a) (BTree a)\n  deriving (Show, Read)\n\n-- getChildren function would help to build the list in sorted order\ngetLevels :: BTree a -> [(a, Int)]\ngetLevels Empty = []\ngetLevels bt = getLevelsIndexed bt 0\n  where getLevelsIndexed Empty _ = []\n        getLevelsIndexed (Node n l r) level = [(n, level)]\n                                              ++ getLevelsIndexed l (level + 1)\n                                              ++ getLevelsIndexed r (level + 1)\n\ninorder :: BTree a -> [a]\ninorder Empty = []\ninorder (Node n l r) = inorder l ++ [n] ++ inorder r\n\nmirrorBst :: BTree a -> BTree a\nmirrorBst Empty = Empty\nmirrorBst (Node n l r) = Node n (mirrorBst r) (mirrorBst l)\n                        \n", "input": "42", "status": "success", "output": "24"}
{"code": "import Data.Char (toLower)\nimport Data.List\n\ndata Expression = BinaryExp Expression BinaryOperator Expression\n                | UnaryExp UnaryOperator Expression\n                | Literal Value\n                deriving(Show, Eq)\n\ndata BinaryOperator = And | Or deriving(Show, Eq)\ndata UnaryOperator = Not deriving(Show, Eq)\n\ndata Value = Binary Bool | Maybe | Variable String deriving(Show, Eq)\n\ndata Tokens = Btok BinaryOperator | Utok UnaryOperator | Vtok Value | Ptok Paren deriving(Show, Eq)\ndata Paren = LParen | RParen deriving(Show, Eq)\n\n\ntokenise :: String -> [Tokens]\ntokenise input = tok (words input)\n                  where\n                      tok [] = []\n                      tok (x:xs) = (eval x) : (tok xs)\n                      eval x = case (map toLower x) of\n                                    \"and\" -> Btok And\n                                    \"or\" -> Btok Or\n                                    \"not\" -> Utok Not\n                                    \"true\" -> Vtok (Binary True)\n                                    \"false\" -> Vtok (Binary False)\n                                    \"maybe\" -> Vtok (Maybe)\n                                    \"(\" -> Ptok LParen\n                                    \")\" -> Ptok RParen\n                                    x -> Vtok (Variable x)\n\n-- Run the shunting yard algorithm on the tokens\nshuntingYard :: [Tokens] -> [Tokens]\nshuntingYard toks = shunt [] [] toks\n                    where\n                      shunt :: [Tokens] -> [Tokens] -> [Tokens] -> [Tokens]\n                      shunt output [] [] = output\n                      shunt output stack [] = (reverse stack) ++ output\n                      shunt output stack (x:xs) = case x of\n                                                        Vtok _ -> shunt (x:output) stack xs\n                                                        Btok _ -> shunt output (x:stack) xs\n                                                        Utok _ -> shunt output (x:stack) xs\n                                                        Ptok LParen -> shunt output (x:stack) xs\n                                                        Ptok RParen -> shunt (reverse (takeWhile (not . (==) (Ptok LParen)) stack) ++ output) (tail (dropWhile (not . (==) (Ptok LParen)) stack)) xs\n                                                                    \n                      \n-- Expects a list of reverse polish notation tokens and will return the expression that they form\nparseLogic :: [Tokens] -> Maybe Expression\nparseLogic toks = case toks of\n                    [] -> Nothing\n                    x -> Just $ parse x\n                  where\n                    parse [Vtok x] = Literal x\n                    parse ((Utok d):ds) = UnaryExp d (parse ds)\n                    --parse ((Btok\n", "input": "\"hello\"", "status": "success", "output": "[Vtok (Variable \"hello\")]"}
{"code": "-- Integers too big for floats\n-- ref: https://wiki.haskell.org/Integers_too_big_for_floats\n\n-- factorial 777 is not representablt by Double, but is representable by Integer\n\n-- However we need factorial 777 / factorial 778\n\n{-\n\n    Actually you can represent the fraction factorial 777 / factorial 778 as Rational\n    and convert that to a floating point number:\n\n    fromRational (factorial 777 % factorial 778)\n    Fortunately fromRational is clever enough to handle big numerators and denominators.\n    But there is an efficiency problem:\n\n    Before fromRational can perform the imprecise division, the % operator will cancel the fraction precisely. You may use the Rational constructor :% instead.\n    However that's a hack, since it is not sure that other operations work well on non-cancelled fractions.\n\n    You had to import GHC.Real.\n    But since we talk about efficiency let's go on to the next paragraph, where we talk about real performance.\n\n-}\n\n-- The problem is to compute the reciprocal of \u03c0 using Chudnovsky's algorithm:\n\n-- An exact division\n-- Courtesy of Max Rabkin\n(/.) :: (Real a, Fractional b) => a -> a -> b\nx /. y = fromRational $ toRational x / toRational y\n \n-- Compute n!\nfac :: Integer -> Integer\nfac n = product [1..n]\n \n-- Compute n! / m! efficiently\nfacDiv :: Integer -> Integer -> Integer\nfacDiv n m \n    | n > m = product [n, n - 1 .. m + 1]\n    | n == m = 1\n    | otherwise = facDiv m n\n \n \n-- Compute pi using the specified number of iterations\npi' :: Integer -> Double\npi' steps = 1.0 / (12.0 * s / f)\n    where\n      s = sum [chudnovsky n | n <- [0..steps]]\n      f = fromIntegral c ** (3.0 / 2.0) -- Common factor in the sum\n \n      -- k-th term of the Chudnovsky serie\n      chudnovsky :: Integer -> Double\n      chudnovsky k \n          | even k = num /. den\n          | otherwise = -num /. den\n          where\n            num = (facDiv (6 * k) (3 * k)) * (a + b * k)\n            den = (fac k) ^ 3 * (c ^ (3 * k))\n \n      a = 13591409\n      b = 545140134\n      c = 640320\n \n-- main = print $ pi' 1000\n\n-- But assume these conversions are a problem. We will show a way to avoid them. The trick is to compute the terms incrementally. We do not need to compute the factorials from scratch for each term, instead we compute each term using the term before.\n\nstart :: Floating a => a\nstart =\n   12 / sqrt 640320 ^ 3\n \narithmeticSeq :: Num a => [a]\narithmeticSeq =\n   iterate (545140134+) 13591409\n \nfactors :: Floating a => [a]\nfactors =\n   -- note canceling of product[(6*k+1)..6*(k+1)] / product[(3*k+1)..3*(k+1)]\n   map (\\k -> -(6*k+1)*(6*k+3)*(6*k+5)/(320160*(k+1))^3) $ iterate (1+) 0\n \nsummands :: Floating a => [a]\nsummands =\n   zipWith (*) arithmeticSeq $ scanl (*) start factors\n \nrecipPi :: Floating a => a\nrecipPi =\n   sum $ take 2 summands", "input": "42", "status": "success", "output": "1405006117752879898543142606244511569936384000000000"}
{"code": "-- (1) support function\r\nfac :: Integer -> Integer\r\nfac n = if n == 0 then 1 else (n * fac(n-1))\r\n\r\n-- (1) main functions\r\nfacLst :: Integer -> [Integer]\r\nfacLst n = if (n >= 0) then [fac t | t <- [0 .. n], t <= n] else []\r\n\r\nfactsL :: Integer -> [Integer]\r\nfactsL n = reverse (facLst n)\r\n\r\n--------------------------------------------\r\n\r\n-- (2) support functions\r\ngetNumbers :: String -> String\r\ngetNumbers s = [t | t <- s, elem t ['0' .. '9']]\r\n\r\nextractNumerals' :: String -> Int -> [String] -> Bool -> [String]\r\nextractNumerals' s t list bool\r\n\t\t\t\t\t\t\t\t| t == (length s) || (length s) == 0       = if bool then (list ++ [getNumbers (take (t) s)]) else list\r\n\t\t\t\t\t\t\t\t| elem (s !! t) ['0' .. '9'] && not bool   = extractNumerals' s (t+1) list True\r\n\t\t\t\t\t\t\t\t| not (elem (s !! t) ['0' .. '9']) && bool = extractNumerals' (drop t s) (0) (list ++ [getNumbers (take (t) s)]) False\r\n\t\t\t\t\t\t\t\t| otherwise                                = extractNumerals' s (t+1) list bool\r\n\r\n-- (2) main function\r\nextractNumerals :: String -> [String]\r\nextractNumerals s = extractNumerals' s 0 [] False\r\n\r\n--------------------------------------------\r\n\r\n-- (3) support functions\r\npowOf2' :: Int -> Int -> Int\r\npowOf2' n k\r\n\t\t\t| (n == 1) && k /= 0 = k\r\n\t\t\t| mod n 2 /= 0       = -1\r\n\t\t\t| otherwise          = powOf2' (div n 2) (k+1)\r\n\r\npowOf2 :: Int -> Int\r\npowOf2 n \r\n\t\t| n == 0    = -1\r\n\t\t| n == 1    = 0\r\n\t\t| otherwise = powOf2' n 0\r\n\r\nisPowOf2' :: Int -> Bool\r\nisPowOf2' n = ((powOf2 n) /= -1)\r\n\r\nisInvalid :: String -> Bool\r\nisInvalid t = length ([x | x <- t, elem x ['0' .. '9']]) /= (length t)\r\n\r\n-- (3) main functions\r\nisPowOf2 :: Int -> (Bool,Int)\r\nisPowOf2 n = ((isPowOf2' n), (powOf2 n))\r\n\r\nsL2pO2 :: [String] -> [Int]\r\nsL2pO2 list = [powOf2 (read (if (isInvalid t) then \"-1\" else t) :: Int) | t <- list]\r\n\r\n--------------------------------------------\r\n\r\n-- (4) support functions\r\ntriMaxCurried :: Integer -> Integer -> Integer -> Integer\r\ntriMaxCurried p q r\r\n\t\t\t| (p>=q) && (p>=r) = p\r\n\t\t\t| (q>=p) && (q>=r) = q\r\n\t\t\t| (r>=p) && (r>=q) = r\r\n\r\ntriMaxUncurried :: (Integer,Integer,Integer) -> Integer\r\ntriMaxUncurried (p,q,r)\r\n\t\t\t| (p>=q) && (p>=r) = p\r\n\t\t\t| (q>=p) && (q>=r) = q\r\n\t\t\t| (r>=p) && (r>=q) = r\r\n\r\nquadrAddCurried :: Integer -> Integer -> Integer -> Integer -> Integer\r\nquadrAddCurried p q r t = p + q + r + t\r\n\r\nquadrAddUncurried :: (Integer,Integer,Integer,Integer) -> Integer\r\nquadrAddUncurried (p,q,r,t) = p + q + r + t\r\n\r\n-- (4) main functions\r\ncurry3 :: ((a,b,c) -> d) -> a -> b -> c -> d\r\ncurry3 f p q r = f (p,q,r)\r\n\r\nuncurry3 :: (a -> b -> c -> d) -> (a,b,c) -> d\r\nuncurry3 f (p,q,r) = f p q r\r\n\r\ncurry4 :: ((a,b,c,d) -> e) -> a -> b -> c -> d -> e\r\ncurry4 f p q r t = f (p,q,r,t)\r\n\r\nuncurry4 :: (a -> b -> c -> d -> e) -> (a,b,c,d) -> e\r\nuncurry4 f (p,q,r,t) = f p q r t\r\n--------------------------------------------", "input": "42", "status": "success", "output": "1405006117752879898543142606244511569936384000000000"}
{"code": "-- 1. fib n \u0432\u043e\u0432\u0437\u0440\u0430\u0449\u0430\u0435\u0442 n-\u043e\u0435 \u0447\u0438\u0441\u043b\u043e \u0424\u0438\u0431\u043e\u043d\u0430\u0447\u0447\u0438\n--    (1 \u0431\u0430\u043b\u043b)\nfib :: Integer -> Integer\nfib n = helper n 0 1\n\twhere helper n f1 f2\n\t\t| n == 0    = f1\n\t\t| otherwise = helper (n - 1) f2 (f1 + f2)\n\n-- 2a. \u041d\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u0444\u0443\u043d\u043a\u0446\u0438\u044e, \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u044e\u0449\u0443\u044e \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0446\u0438\u0444\u0440 \u0447\u0438\u0441\u043b\u0430.\n--     \u0414\u043b\u044f \u0446\u0435\u043b\u043e\u0447\u0438\u0441\u043b\u0435\u043d\u043d\u043e\u0433\u043e \u0434\u0435\u043b\u0435\u043d\u0438\u044f \u043c\u043e\u0436\u0435\u0442\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0444\u0443\u043d\u043a\u0446\u0438\u0438 div \u0438 mod.\n--    (0.5 \u0431\u0430\u043b\u043b\u0430)\nnumberOfDigits :: Integer -> Integer\nnumberOfDigits n = helper 0 n\n\twhere helper res n \n\t\t\t\t\t| n < 10    = res + 1 \n\t\t\t\t\t| otherwise = helper (res + 1) $ div n 10\n\n-- 2b. \u041d\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u0444\u0443\u043d\u043a\u0446\u0438\u044e, \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u044e\u0449\u0443\u044e \u0441\u0443\u043c\u043c\u0443 \u0446\u0438\u0444\u0440 \u0447\u0438\u0441\u043b\u0430.\n--    (0.5 \u0431\u0430\u043b\u043b\u0430)\nsumOfDigits :: Integer -> Integer\nsumOfDigits n = helper 0 n\n\twhere helper res n \n\t\t\t\t\t| n < 10    = res + n \n\t\t\t\t\t| otherwise = helper (res + (n - (div n 10) * 10)) $ div n 10\n\n\n-- 3. gcd' \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u041d\u041e\u0414.\n--    (1 \u0431\u0430\u043b\u043b)\ngcd' :: Integer -> Integer -> Integer\ngcd' b a\n\t| b < a     = gcd a b\n\t| a == 0    = b\n\t| otherwise = gcd a $ mod b a\n\n\n-- 4. minp p \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043f\u043e \u043c\u043e\u0434\u0443\u043b\u044e \u0447\u0438\u0441\u043b\u043e x \u0442\u0430\u043a\u043e\u0435, \u0447\u0442\u043e p x == True. \u0415\u0441\u043b\u0438 \u0442\u0430\u043a\u043e\u0433\u043e x \u043d\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442, minp \u043d\u0435 \u0437\u0430\u0432\u0435\u0440\u0448\u0430\u0435\u0442\u0441\u044f.\n--    (1 \u0431\u0430\u043b\u043b)\nminp :: (Integer -> Bool) -> Integer\nminp p = helper p 0\n\twhere helper p bound\n\t\t\t\t\t| (p bound == True)    = bound\n\t\t\t\t\t| (p (-bound) == True) = -bound\n\t\t\t\t\t| otherwise            = helper p $ bound + 1\n\n-- 5. integral f a b \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u043d\u043e\u0433\u043e \u0438\u043d\u0442\u0435\u0433\u0440\u0430\u043b\u0430 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 f \u043d\u0430 \u043e\u0442\u0440\u0435\u0437\u043a\u0435 [a,b].\n--    \u0414\u043b\u044f \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u043c\u043e\u0436\u0435\u0442\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u043c\u0435\u0442\u043e\u0434 \u0442\u0440\u0430\u043f\u0435\u0446\u0438\u0439.\n--    (2 \u0431\u0430\u043b\u043b\u0430)\nintegral :: (Double -> Double) -> Double -> Double -> Double\nintegral f a b = helper f a b 0\n\twhere helper f a b res\n\t\t\t\t\t| (abs (b - a)) < step = res + (((f b) + (f a)) / 2 * (b - a))\n\t\t\t\t\t| otherwise            = helper f (a + step) b (res + (((f a) + (f (a + step))) / 2 * step))\n\t\t\t\t\twhere step = 0.001\n\n-- 6. \u0420\u0435\u0430\u043b\u0438\u0437\u0443\u0439\u0442\u0435 \u043e\u043f\u0435\u0440\u0430\u0442\u043e\u0440 \u043f\u0440\u0438\u043c\u0438\u0442\u0438\u0432\u043d\u043e\u0439 \u0440\u0435\u043a\u0443\u0440\u0441\u0438\u0438 rec, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u044e (-), \u0443\u043a\u0430\u0436\u0438\u0442\u0435 \u0442\u0438\u043f rec.\n--    (1 \u0431\u0430\u043b\u043b)\nrec :: a -> (Integer -> a -> a) -> Integer -> a\nrec initState body counter\n\t| counter == 0 = initState \n\t| otherwise    = body (counter - 1) (rec initState body (counter - 1))\n\n-- 7. \u0420\u0435\u0430\u043b\u0438\u0437\u0443\u0439\u0442\u0435 \u0444\u0430\u043a\u0442\u043e\u0440\u0438\u043b \u043f\u0440\u0438 \u043f\u043e\u043c\u043e\u0449\u0438 rec.\n--    (1 \u0431\u0430\u043b\u043b)\nfacRec :: Integer -> Integer\nfacRec n = rec 1 (\\x y -> if x == 0 then y else x * y) (n + 1)\n\n-- 8. \u0420\u0435\u0430\u043b\u0438\u0437\u0443\u0439\u0442\u0435 \u0444\u0430\u043a\u0442\u043e\u0440\u0438\u0430\u043b \u043f\u0440\u0438 \u043f\u043e\u043c\u043e\u0449\u0438 fix.\n--    (1 \u0431\u0430\u043b\u043b)\nfacFix :: Integer -> Integer\nfacFix = fix (\\fun -> \\n -> if n == 1 then 1 else n * (fun (n - 1)))\n\twhere fix f = f (fix f)\n", "input": "42", "status": "success", "output": "267914296"}
{"code": "doubleMe x = x + x\ndoubleUs x y = doubleMe x + doubleMe y\ndoubleSmallNumber x = if x > 100\n\t\t\t\t\t\t\t\t\t\t\tthen x\n\t\t\t\t\t\t\t\t\t\t\telse x*2 -- else is necessary in haskell\ndoubleSmallNumber' x = (if x > 100 then x else x*2)+1\nconanO'Brien = \"It's a-me, Conan O'Brien!\" -- functions cannot start with a capital\n-- binds each element to x == x <- [1..10]\n-- the output is before the pipe (|)\nsimpleSetComprehension = [ x * 2 | x <- [1..10]]\nsimpleSetComprehension' = [x * 2 | x <- [1..10], x*2>=12] -- adds a predicate that says must be greater than or equal to 12\nmediumSetComprehension = [ x | x <- [50..100], mod x 7 == 3] -- prints all numbers from 50 to 100 that when divided by 7 have a remainder of 3\nboomBang xs = [ if x< 10 then \"Boom!\" else \"Bang!\" | x <- xs, odd x] -- replaces odd numbers with \"Boom!\" or \"Bang!\" based upon whether they are less than or greater than 10\nfizzBuzz = [fb x | x <- [1..100]] where fb y | y `mod` 15 ==0 = \"FizzBuzz\" | y `mod` 3 ==0 = \"Fizz\" | y `mod` 5 == 0 = \"Buzz\" | otherwise = show y -- fizzbuzz\nrightTriangles' = [ (a, b, c) | c <- [1..10], a<- [1..c], b <- [1..a], a^2 + b^2 == c^2, a+b+c==24] -- right triangles whose perimeter equals 24\n\nfactorial :: Integer -> Integer -- make sure to give explicit type declaration \nfactorial n = product [1..n]\n-- :t <thing to get type of> -- tells you the type of something\n\n--show 5 -- returns 5 as a member of Show\n--read \"5\" - 2 -- takes a [Char] and returns a member of Read\n\n-- returning using type annotations\n--read \"5\" :: Int\n--read \"5\" :: Float\n--(read \"5\" :: Float ) * 4 \n--read \"[1,2,3,4]\" :: [Int] -- this is as a list of Ints\n--read \"(3, 'a')\" :: (Int, Char)\n\n\n-- Enum members = sequentially ordered types :: use its types in list ranges\n-- contains: (), Bool, Char, Ordering, Int, Integer, Float, and Double\n\n\n--20 :: Int\n--20 :: Integer\n--20 :: Float\n--20 :: Double\n\nlucky :: (Integral a) => a -> String\nlucky 7 = \"LUCKY NUMBER SEVEN!\"\nlucky x = \"Sorry, you're out of luck, pal!\"\n\nsayMe :: (Integral a) => a -> String -- cases run in order of existence \nsayMe 1 = \"One!\"\nsayMe 2 = \"Two!\"\nsayMe 3 = \"Three!\"\nsayMe 4 = \"Four!\"\nsayMe 5 = \"Five!\"\nsayMe x = \"Not between 1 and 5\"\n\nfactorialRe :: (Integral a) => a -> a -- type annotation \nfactorialRe 0 = 1 -- when n gets to 0\nfactorialRe n = n * factorialRe ( n -1 ) -- finds factorial recursively, i.e. 5 = 5 * 4 * 3 * 2 * 1 but haskell reads it as (5 * (4 * ( 3 * ( 2 * ( 1 * 1) ) ) ) )\n\n\n-- need to make sure to return a catch-all so patterns don't fail\n\naddVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)\naddVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)\n\n-- accounting for three element tuples\nfirst :: (a, b, c) -> a\nfirst (x, _, _) = x\n\nsecond :: (a, b, c) -> b\nsecond (_, y, _) = y\n\nthird :: (a, b, c) -> c\nthird (_,_, z) = z\n-- end accounting for three element tuples\n\nhead' :: [a] -> a\nhead' [] = error \"Can't call head on an empty list, dummy!\"\nhead' (x:_) = x\n", "input": "42", "status": "success", "output": "1405006117752879898543142606244511569936384000000000"}
{"code": "-- 1. fib n \u0432\u043e\u0432\u0437\u0440\u0430\u0449\u0430\u0435\u0442 n-\u043e\u0435 \u0447\u0438\u0441\u043b\u043e \u0424\u0438\u0431\u043e\u043d\u0430\u0447\u0447\u0438.\n--    \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043e\u043b\u0436\u043d\u0430 \u0440\u0430\u0431\u043e\u0442\u0430\u0442\u044c \u0437\u0430 \u043b\u0438\u043d\u0435\u0439\u043d\u043e\u0435 \u0432\u0435\u0440\u043c\u044f \u0438 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0430 \u0434\u043b\u044f \u0432\u0441\u0435\u0445 \u0446\u0435\u043b\u044b\u0445 n.\n--    \u0414\u043b\u044f \u043e\u0442\u0440\u0438\u0446\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u0445 n \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u0442\u0441\u044f \u043f\u043e \u0444\u043e\u0440\u043c\u0443\u043b\u0435 fib n = fib (n + 2) - fib (n + 1).\n--    (1 \u0431\u0430\u043b\u043b)\nfib :: Integer -> Integer\nfib n = let (_, res, _) = fibRec (1, 0, abs n)\n        in if n > 0 then res else (if abs n `mod` 2 == 1 then 1 else -1) * res\n        where fibRec (a, b, n) | n > 0 = fibRec (a + b, a, n - 1)\n                               | otherwise = (a, b, n)\n\n-- 2a. \u041d\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u0444\u0443\u043d\u043a\u0446\u0438\u044e, \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u044e\u0449\u0443\u044e \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0446\u0438\u0444\u0440 \u0447\u0438\u0441\u043b\u0430.\n--     \u0414\u043b\u044f \u0446\u0435\u043b\u043e\u0447\u0438\u0441\u043b\u0435\u043d\u043d\u043e\u0433\u043e \u0434\u0435\u043b\u0435\u043d\u0438\u044f \u043c\u043e\u0436\u0435\u0442\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0444\u0443\u043d\u043a\u0446\u0438\u0438 div \u0438 mod.\n--    (0.5 \u0431\u0430\u043b\u043b\u0430)\nnumberOfDigits :: Integer -> Integer\nnumberOfDigits i | i < 10 = 1\n                 | otherwise = 1 + numberOfDigits (i `div` 10)\n\n-- 2b. \u041d\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u0444\u0443\u043d\u043a\u0446\u0438\u044e, \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u044e\u0449\u0443\u044e \u0441\u0443\u043c\u043c\u0443 \u0446\u0438\u0444\u0440 \u0447\u0438\u0441\u043b\u0430.\n--    (0.5 \u0431\u0430\u043b\u043b\u0430)\nsumOfDigits :: Integer -> Integer\nsumOfDigits i | i == 0 = 0\n              | otherwise = (i `mod` 10) + sumOfDigits (i `div` 10)\n\n-- 3. gcd' \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u041d\u041e\u0414.\n--    (1 \u0431\u0430\u043b\u043b)\ngcd' :: Integer -> Integer -> Integer\ngcd' a b | b == 0 = a\n         | otherwise = gcd b (a `mod` b)\n\n-- 4. minp p \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043f\u043e \u043c\u043e\u0434\u0443\u043b\u044e \u0447\u0438\u0441\u043b\u043e x \u0442\u0430\u043a\u043e\u0435, \u0447\u0442\u043e p x == True. \u0415\u0441\u043b\u0438 \u0442\u0430\u043a\u043e\u0433\u043e x \u043d\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442, minp \u043d\u0435 \u0437\u0430\u0432\u0435\u0440\u0448\u0430\u0435\u0442\u0441\u044f.\n--    (1 \u0431\u0430\u043b\u043b)\nminp :: (Integer -> Bool) -> Integer\nminp p = minpRec (p, 0) \n  where minpRec (p, i) | p i = i\n                       | otherwise = minpRec (p, i + 1)\n\n-- 5. integral f a b \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u043d\u043e\u0433\u043e \u0438\u043d\u0442\u0435\u0433\u0440\u0430\u043b\u0430 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 f \u043d\u0430 \u043e\u0442\u0440\u0435\u0437\u043a\u0435 [a,b].\n--    \u0414\u043b\u044f \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u043c\u043e\u0436\u0435\u0442\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u043c\u0435\u0442\u043e\u0434 \u0442\u0440\u0430\u043f\u0435\u0446\u0438\u0439.\n--    (2 \u0431\u0430\u043b\u043b\u0430)\nintegral :: (Double -> Double) -> Double -> Double -> Double\nintegral f a b | a >= b = 0\n               | otherwise =  dx * (f a + f (a + dx)) / 2 + integral f (a + dx) b\n  where dx = 0.05\n\n-- 6. \u0420\u0435\u0430\u043b\u0438\u0437\u0443\u0439\u0442\u0435 \u043e\u043f\u0435\u0440\u0430\u0442\u043e\u0440 \u043f\u0440\u0438\u043c\u0438\u0442\u0438\u0432\u043d\u043e\u0439 \u0440\u0435\u043a\u0443\u0440\u0441\u0438\u0438 rec, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u044e (-), \u0443\u043a\u0430\u0436\u0438\u0442\u0435 \u0442\u0438\u043f rec.\n--    (1 \u0431\u0430\u043b\u043b)\nrec :: a -> (a -> Integer -> a) -> Integer -> a\nrec z s n | n == 0 = z\n          | otherwise = s (rec z s (n - 1)) n\n\n-- 7. \u0420\u0435\u0430\u043b\u0438\u0437\u0443\u0439\u0442\u0435 \u0444\u0430\u043a\u0442\u043e\u0440\u0438\u043b \u043f\u0440\u0438 \u043f\u043e\u043c\u043e\u0449\u0438 rec.\n--    (1 \u0431\u0430\u043b\u043b)\nfacRec :: Integer -> Integer\nfacRec n = rec 1 (*) n\n\n-- 8. \u0420\u0435\u0430\u043b\u0438\u0437\u0443\u0439\u0442\u0435 \u0444\u0430\u043a\u0442\u043e\u0440\u0438\u0430\u043b \u043f\u0440\u0438 \u043f\u043e\u043c\u043e\u0449\u0438 fix.\n--    (1 \u0431\u0430\u043b\u043b)\nfacFix :: Integer -> Integer\nfacFix = fix $ \\f n -> if n == 0 then 1 else n * f (n - 1)\n  where fix f = f (fix f)\n", "input": "42", "status": "success", "output": "267914296"}
{"code": "--------------------------------------------------------------------------------\n---------------------------------Exercise 1-------------------------------------\n--------------------------------------------------------------------------------\n{-|\n  The 'toDigits' function converts positive integers to a list of digits.\n  It takes one argument, of type 'Integer', which represents the number.\n-}\ntoDigits :: Integer -> [Integer]\ntoDigits x = reverse (toDigitsRev x)\n\n{-|\n  The 'toDigitsRev' function converts positive integers to a list of digits,\n  but the order of the digits is opposite compared to the number digits.\n  It takes one argument, of type 'Integer', which represents the number.\n-}\ntoDigitsRev :: Integer -> [Integer]\ntoDigitsRev x = if x <= 0\n                then []\n                else (x `mod` 10) : (toDigitsRev (x `div` 10))\n\n--------------------------------------------------------------------------------\n---------------------------------Exercise 2-------------------------------------\n--------------------------------------------------------------------------------\n{-|\n  The 'doubleEveryOther' function double every other number beginning from the\n  right; that is, the second-to-last, fourth-to-last, ..., numbers are doubled.\n  It takes one argument, of tpe '[Integer]', which represents the list.\n-}\ndoubleEveryOther :: [Integer] -> [Integer]\ndoubleEveryOther xs = reverse (doubleEvenIndexed (reverse xs))\n\n{-|\n  The 'doubleEvenIndexed' function double every even-indexed number beginning\n  from the left; that is, the second, fourth, ..., numbers are doubled.\n  It takes one argument, of tpe '[Integer]', which represents the list.\n-}\ndoubleEvenIndexed :: [Integer] -> [Integer]\ndoubleEvenIndexed []          = []\ndoubleEvenIndexed (x1:x2:xs)  = [x1] ++ [2 * x2] ++ doubleEvenIndexed xs\ndoubleEvenIndexed xs          = xs\n\n--------------------------------------------------------------------------------\n---------------------------------Exercise 3-------------------------------------\n--------------------------------------------------------------------------------\n{-|\n  The 'sumDigits' function calculate the sum of all digits of the numbers in\n  the list.\n  It takes one argument, of tpe '[Integer]', which represents the list.\n-}\nsumDigits :: [Integer] -> Integer\nsumDigits []      = 0\nsumDigits (x:xs)  = sum (toDigits x) + sumDigits xs\n\n--------------------------------------------------------------------------------\n---------------------------------Exercise 4-------------------------------------\n--------------------------------------------------------------------------------\n{-|\n  Finally validate a credit card number! The 'validate' function validates an\n  US credit card number.\n  It takes one argument, a number, and return the value True iff\n  the incoming number is a valid credit card number, False otherwise.\n-}\nvalidate :: Integer -> Bool\nvalidate x =  sumDigits(doubleEveryOther (toDigits x)) `mod` 10 == 0\n", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "\n-- i=4, facts i=[[],[],[2],[3],[2,2]],\n--      pows i=[[0,0..], [0,0..], [0,0,1,0,0..],\n--              [0,0,0,1,0,0,..], [0,0,2,0,0..]]\n--      max(pows i)=[0,0,2,1,0,0..]\n--      max(take i (pows i))=[0,0,2,1,0]\n\nimport Data.List (findIndex,maximum,transpose)\nimport Data.Maybe (fromJust)\nanswer :: Int -> Int\nanswer n = [0..n] ^* maxpows n\n\n(^*) :: Integral a => [a] -> [a] -> a\n(^*) [] _ = 1\n(^*) _ [] = 1\n(^*) (i:is) (j:js) = (i^j) * (is^*js)\n\nmaxpows :: Int -> [Int]\nmaxpows i = maxs $ map (take (i+1)) $ pows i\n\n-- maxs [[0,1],[2,1],[0,3]]=[2,3]\nmaxs :: Ord a => [[a]] -> [a]\nmaxs [] =  []\nmaxs xss = map maximum $ transpose xss\n\npows :: Int -> [[Int]]\npows i = map pow (facts i)\n  where\n    pow :: [Int] -> [Int]\n    pow [] = [0,0..]\n    pow xs = [count i xs | i<-[0..]]\n\nfacts :: Integral a => Int -> [[a]]\nfacts i = map fact $ take i [1..]\n\nfact :: Integral a => a -> [a]\nfact 1 = []\nfact i = first i : remain i\n  where\n    first :: Integral a => a -> a\n    first i = [2..] !! firstIdx i\n    firstIdx :: Integral a => a -> Int\n    firstIdx i = fromJust $ findIndex (mod0 i) [2..]\n    mod0 :: Integral a => a -> a -> Bool\n    mod0 i j = mod i j == 0\n\n    remain :: Integral a => a -> [a]\n    remain 1 = []\n    remain i = fact $ div i $ first i\n\ncount :: Eq a => a -> [a] -> Int\ncount _ [] = 0\ncount i (j:js) | i==j      = 1+count i js\n               | otherwise = count i js\n\n--------------------------------------\n-- import Data.List (find)\n-- import Data.Maybe (isNothing)\n-- answer :: Int -> Int\n-- answer n = foldl1 (*) $ filter' notInclude [2..n]\n--\n-- filter' :: ([a]->Bool)->[a]->[a]\n-- filter' op [] = []\n-- filter' op is | op is   = (is!!0):filter' op (tail is)\n--               | otherwise = filter' op (tail is)\n-- notInclude :: Integral a => [a] -> Bool\n-- notInclude is = if length is > 0\n--   then isNothing $ find (mod0 (is!!0)) (tail is)\n--   else False\n-- mod0 :: Integral a => a -> a -> Bool\n-- mod0 i j = mod j i == 0\n--------------------------------------\n-- import Data.List (find,findIndex,intersect)\n-- import Data.Maybe (fromJust,isNothing)\n\n-- answer :: Int -> Int\n-- answer n = map (*) $ concat $ minPrimeSet $ facts n\n\n-- facts :: Int -> [[Int]]\n-- facts i = map fact $ take (i-1) ints\n--   where\n--     ints = [2,3..]\n--     fact :: Int -> [Int]\n--     fact 1 = []\n--     fact i = first i : remain i\n-- \n--     first :: Int -> Int\n--     first i = ints !! firstIdx i\n--     firstIdx :: Int -> Int\n--     firstIdx i = fromJust $ findIndex (mod0 i) ints\n--     mod0 :: Int -> Int -> Bool\n--     mod0 i j = mod i j == 0\n-- \n--     remain :: Int -> [Int]\n--     remain 1 = []\n--     remain i = fact $ div i $ first i\n\n-- FIXME intersect is not work\n-- minPrimeSet :: [[Int]]->[[Int]]\n-- minPrimeSet xs = filter (nubList 0) xs\n--   where\n--     nubList i is    = isNothing $ findInTail i is\n--     findInTail i is = find (include is!!i) (ntail i is)\n--     include i j     = intersect i j == i\n--     ntail i is      = [(is!!j) | j<-[(i+1)..(length is-1)]]\n\n", "input": "42", "status": "success", "output": "219060189739591200"}
{"code": "import Data.List (intercalate)\nimport GHC.Exts (sortWith)\n\n-- Problem 46\n-- Define predicates and, or, nand, nor, xor, impl, equ, not\nnot' :: Bool -> Bool\nnot' True = False\nnot' False = True\n\n\nand', or', nand', nor', xor', impl', equ' :: Bool -> Bool -> Bool\n\nand' True True = True\nand' _ _ = False\n\nor' False False = False\nor' _ _ = True\n\nnand' True True = False\nnand' _ _ = True\n\nnor' False False = True\nnor' _ _ = False\n\nxor' True False = True\nxor' False True = False\nxor' _ _ = False\n\nimpl' True False = False\nimpl' _ _ = True\n\nequ' a b = not $ xor' a b\n\n-- Write a function table which returns the truth table of a given logical\n-- expression in two variables\ntable :: (Bool -> Bool -> Bool) -> [String]\ntable f = map showEntry [(a, b, f a b) | a <- [True, False], b <- [True, False]] where\n            showEntry (a, b, c) = show a ++ \" \" ++ show b ++ \" \" ++ show c\n\n\n\n-- Problem 48\n-- tablen\n-- Generalize the table function to work with any number of logical variables\ntablen :: Int -> ([Bool] -> Bool) -> [String]\ntablen n f = map showEntry [vs ++ [f vs] | vs <- generateBooleanSampleSpace n] where\n                showEntry = intercalate \" \" . map show\n                generateBooleanSampleSpace 1 = [[True], [False]]\n                generateBooleanSampleSpace n = map (True:) rest ++ map (False:) rest where\n                    rest = generateBooleanSampleSpace (n - 1)\n\n\n-- Problem 49\n-- gray\n-- Generate a list of gray codes of given number of bits\ngray :: Int -> [String]\ngray 0 = []\ngray 1 = [\"0\", \"1\"]\ngray n = map ('0':) rest ++ reverse (map ('1':) rest) where rest = gray (n-1)\n\n\n-- Problem 50\n-- huffman\n-- Create huffman codes for given frequency distribution\nhuffman :: [(Char, Int)] -> [(Char, String)]\nhuffman freqs = let tree = huffmanTree freqs in [(c, getCode tree c)| (c,n)<- freqs]\n\ndata HuffmanTree = Leaf Char Int| Head [Char] Int  HuffmanTree HuffmanTree\n\nfreqToLeaf :: (Char, Int) -> HuffmanTree\nfreqToLeaf (c, n) = Leaf c n\n\ngetChars :: HuffmanTree -> [Char]\ngetChars (Leaf c _) = [c]\ngetChars (Head cs _ _ _) = cs\n\ngetFreq :: HuffmanTree -> Int\ngetFreq (Leaf _ n) = n\ngetFreq (Head _ n _ _) = n\n\njoinTree :: HuffmanTree -> HuffmanTree -> HuffmanTree\njoinTree a b = Head (getChars a ++ getChars b) (getFreq a + getFreq b) a b\n\n\nhuffmanTree :: [(Char, Int)] -> HuffmanTree\nhuffmanTree freqs = huffmanTree' (sortWith getFreq (map freqToLeaf freqs)) where\n                        huffmanTree' [x] = x\n                        huffmanTree' (x:y:zs) = huffmanTree'(sortWith getFreq ((joinTree x y):zs))\n\n\ngetCode :: HuffmanTree -> Char -> String\ngetCode (Leaf c1 _) c2 = case c1 == c2 of\n                            True -> \"\"\n                            False -> error \"Invalid Tree\"\ngetCode (Head cs _ l r) c = case c `elem` (getChars l) of\n                                True -> '0':getCode l c\n                                False -> case c `elem` (getChars r) of\n                                    True -> '1':getCode r c\n                                    False -> error \"Character not found\"\n\n", "input": "True", "status": "success", "output": "False"}
{"code": "-- Patterns are evaluated from top to bottom\n-- REMINDER: Explicit typing is called 'Type annotation'\nlucky :: Int -> String\nlucky 7 = \"LUCKY NUMBER SEVEN !\"\n-- Always include a fallback match to avoid an exception\nlucky x = \"Sorry, you're out of luck.\"\n\nsayMe :: Int -> String\nsayMe 1 = \"One !\"\nsayMe 2 = \"Two !\"\nsayMe 3 = \"Three !\"\nsayMe 4 = \"Four !\"\nsayMe 5 = \"Five !\"\nsayMe x = \"Not between 1 and 5 !\"\n\nfactorial :: Int -> Int\nfactorial 0 = 1\nfactorial n = n * factorial (n - 1)\n\n-- Pattern matching with tuples\n\n-- 2D vector addition without pattern matching\naddVectors :: (Double, Double) -> (Double, Double) -> (Double, Double)\naddVectors a b = (fst a + fst b, snd a + snd b)\n\n-- Now with pattern matching\naddVectors' :: (Double, Double) -> (Double, Double) -> (Double, Double)\naddVectors' (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)\n\n-- Extract elements from triple, fst and snd extract elements from couples only\nfirst :: (a, b, c) -> a\nfirst (x, _, _) = x\n\nsecond :: (a, b, c) -> b\nsecond (_, b, _) = b\n\nthird :: (a, b, c) -> c\nthird (_, _, c) = c\n\n-- Pattern matching in list comprehension\nxs = [(1, 3), (5, 6)]\nadd = [a + b | (a, b) <- xs]\n\n-- Own implementation of the head function\n-- REMINDER: [a] is a 'Type Variable'\nhead' :: [a] -> a\nhead' [] = error \"Can't call head on an empty list, dummy !\"\n-- If we want to bind something to several variables, we need to surround it with ()\nhead' (x:_) = x\n\n-- Class constraint\ntell :: (Show a) => [a] -> String\ntell [] = \"The list is empty\"\n-- REMINDER: ++ operator joins two list into one\ntell (x:[]) = \"The list has one element: \" ++ show x\ntell (x:y:[]) = \"The list has two elements: \" ++ show x ++ \" and \" ++ show y\ntell (x:y:_) = \"The list is long. The first two elements are: \" ++ show x ++ \" and \" ++ show y\n\n-- As-patterns: break up item according to pattern while keeping a ref to the original item\nfirstLetter :: String -> String\nfirstLetter \"\" = \"Empty string, whoops !\"\nfirstLetter all@(x:xs) = \"The first letter of \" ++ all ++ \" is \" ++ [x]\n\n-- Guards, check conditions on values passed during the pattern matching\nbmiTell :: Double -> String\n-- Guards are indicated by a pipe followed by boolean expression followed by\n-- a body function that is used if the expression is True. If False it goes\n-- to the next one. Warning: guards must be indented by one space.\nbmiTell bmi \n\t| bmi <= 18.5 = \"You're underweight, you emo, you!\"\n\t| bmi <= 25.0 = \"You're supposedly normal. Pffft, I bet you're ugly!\"\n\t| bmi <= 30.0 = \"You're fat! Lose some weight, fatty!\"\n\t| otherwise = \"You're a whale, congratulations!\"\n\nbmiTell' :: Double -> Double -> String\nbmiTell' weight height\n\t| weight / height^2 <= 18.5 = \"You're underweight, you emo, you!\"\n\t| weight / height^2 <= 25.0 = \"You're supposedly normal. Pffft, I bet you're ugly!\"\n\t| weight / height^2 <= 30.0 = \"You're fat! Lose some weight, fatty!\"\n\t| otherwise = \"You're a whale, congratulations!\"\n\nmax' :: (Ord a) => a -> a -> a\nmax' a b\n\t| a <= b = b\n\t| otherwise = a\n\nmyCompare :: (Ord a) => a -> a -> Ordering\na `myCompare` b\n\t| a == b = EQ\n\t| a <= b = LT\n\t| otherwise = GT", "input": "42", "status": "success", "output": "\"Sorry, you're out of luck.\""}
{"code": "lucky :: Int -> String\nlucky 7 = \"Lucky number seven!\"\nlucky x = \"Sorry, you're out of luck, pal!\"\n\n\nfactorial :: Int -> Int\nfactorial 0 = 1\nfactorial n = n * factorial (n - 1)\n\n\naddVectors :: (Double, Double) -> (Double, Double) -> (Double, Double)\naddVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)\n\nfirst :: (a, b, c) -> a\nfirst (x, _, _) = x\n\nsecond :: (a, b, c) -> b\nsecond (_, y, _) = y\n\nthird :: (a, b, c) -> c\nthird (_, _, z) = z\n\nhead' :: [a] -> a\nhead' [] = error \"Can't call head on an empty list, fool!\"\nhead' (x:_) = x\n\nhead'2 :: [a] -> a\nhead'2 xs = \n  case xs of \n    [] -> error \"No head for empty lists!\"\n    (x:_) -> x\n\ntell :: (Show a) => [a] -> String\ntell [] = \"The list is empty\"\ntell (x:[]) = \"The list has one element: \" ++ show x\ntell (x:y:[]) = \"The list has two elements: \" ++ show x ++ \" and \" ++ show y\ntell (x:y:_) = \"The list is long. The first two elements are: \" ++ show x ++ \" and \" ++ show y\n\n\nbadAdd :: (Num a) => [a] -> a\nbadAdd [x,y,z] = x + y + z\n\nfirstLetter :: String -> String\nfirstLetter \"\" = \"Emtpy string, whoops!\"\nfirstLetter all@(x:xs) = \"The first letter of \" ++ all ++ \" is \" ++ [x]\n\nbmiTell :: Double -> Double -> String\nbmiTell weight height\n  | bmi <= skinny = \"You're underweight, you emo, you!\"\n  | bmi <= normal = \"You're supposedly normal. Pfft, I bet you're ugly!\"\n  | bmi <= fat = \"You're fat! Lose some weight, fatty!\"\n  | otherwise = \"You're a whale, congratulations!\"\n  where (bmi, skinny, normal, fat) = (weight / height ^ 2, 18.5, 25.0, 30.0)\n\nmax' :: (Ord a) => a -> a -> a\nmax' a b\n  | a <= b = b\n  | otherwise = a\n\nmyCompare :: (Ord a) => a -> a -> Ordering\na `myCompare` b\n  | a == b = EQ\n  | a < b = LT\n  | otherwise = GT\n\nbadGreeting :: String\nbadGreeting = \"Oh! Pfft. It's you.\"\n\nniceGreeting :: String\nniceGreeting = \"Hello! So very nice to see you,\"\n\ngreet :: String -> String\ngreet \"Juan\" = niceGreeting ++ \" Juan!\"\ngreet \"Fernando\" = niceGreeting ++ \" Fernando!\"\ngreet name = badGreeting ++ \" \" ++ name\n\ninitials :: String -> String -> String\ninitials firstname lastname = [f] ++ \". \" ++ [l] ++ \".\"\n  where (f:_) = firstname\n        (l:_) = lastname\n\ninitials2 :: String -> String -> String\ninitials2 (f:_) (l:_) = [f] ++ \". \" ++ [l] ++ \".\"\n\ncalcBmis :: [(Double, Double)] -> [Double]\ncalcBmis [] = []\ncalcBmis ((weight, height):xs) = bmi:calcBmis xs\n  where bmi = weight / height ^ 2\n\ncalcBmis2 :: [(Double, Double)] -> [Double]\ncalcBmis2 xs = [bmi w h| (w, h) <- xs]\n  where bmi w h = w / h ^ 2\n\ncylinder :: Double -> Double -> Double\ncylinder r h =\n  let sideArea = 2 * pi * r * h\n      topArea = pi * r ^ 2\n  in sideArea + 2 * topArea\n\ncalcBmis3 :: [(Double, Double)] -> [Double]\ncalcBmis3 xs = [bmi | (w, h) <- xs, let bmi = w / h ^ 2, bmi > 25.0]\n\ndescribeList :: [a] -> String\ndescribeList ls = \"The list is \" ++ case ls of \n  [] -> \"empty.\"\n  [x] -> \"a singleton list.\"\n  xs -> \"a longer list.\"\n\ndescribeList2 :: [a] -> String\ndescribeList2 ls = \"The list is \" ++ what ls\n  where what [] = \"empty.\"\n        what [x] = \"a singleton list.\"\n        what xs = \"a longer list.\"\n\nsum' :: (Num a) => [a] -> a\nsum' xs = foldl (\\acc x -> acc + x) 0 xs\n", "input": "42", "status": "success", "output": "\"Sorry, you're out of luck, pal!\""}
{"code": "{-\n1. Fa\u00e7a uma fun\u00e7\u00e3o receba uma lista de inteiros e devolva o pen\u00faltimo\nelemento dela. A lista tem tamanho n, n > 2.\nObs: Utilize a fun\u00e7\u00e3o reverse.\n-}\n\nfunc1 :: [Int] -> [Int]\nfunc1 x = [reverse x !! 1]\n\n{-\n    Quest\u00e3o 1\n    \nMain> func1 [1,2,3,4,5,6,7,8,9]\n[8]\n\nMain> func1 [9,8,7,6,5,4,3,2,1]\n[2]\n\n-}\n\n--------------------------------------------------------------------\n\n{-\n2. Fa\u00e7a uma fun\u00e7\u00e3o que receba uma lista de inteiros. Se o comprimento dela for par, duplique-a; se for impar, triplique-a. Exemplo:\n    Entrada: multiplicaLista [1,2,3]\n    Sa\u00edda: [1,2,3,1,2,3,1,2,3]\n\n    Entrada: multiplicaLista [1,2,3,4]\n    Sa\u00edda: [1,2,3,4,1,2,3,4]\n-}\n\nfunc2 :: [Int] -> [Int]\nfunc2 x\n    | mod (length x) 2 == 0 = x++x\n    | mod (length x) 2 /= 0 = x++x++x\n    | otherwise = [0]\n  \n{-\n    Quest\u00e3o 2\n    \nMain> func2 [1,2,3,4,5]\n[1,2,3,4,5,1,2,3,4,5,1,2,3,4,5]\n\nMain> func2 [1,2,3,4,5,6]\n[1,2,3,4,5,6,1,2,3,4,5,6]\n\n-}\n  \n--------------------------------------------------------------------\n{-\n3. Seja a seguinte equa\u00e7\u00e3o do segundo grau:\nax\u00b2 + bx + c = 0\nsendo que a, b e c s\u00e3o n\u00fameros reais e a \u2260 0. Essa equa\u00e7\u00e3o tem:\n\u2022 Duas ra\u00edzes reais, se b\u00b2 > 4ac;\n\u2022 Uma raiz real, se b\u00b2 = 4ac; e\n\u2022 Nenhuma raiz real, se b\u00b2 < 4ac.\nFa\u00e7a uma fun\u00e7\u00e3o que, dados tr\u00eas coeficientes a, b, e c, diz quantas ra\u00edzes a equa\u00e7\u00e3o tem.\n-}\n\nfunc3 :: Float -> Float -> Float -> String\nfunc3 a b c \n    | (a /= 0) && (b*b > 4*a*c) = \"Duas raizes reais\"\n    | (a /= 0) && (b*b == 4*a*c) = \"Uma raiz real\"\n    | (a /= 0) && (b*b < 4*a*c) = \"Nenhuma raiz real\"\n    | otherwise = \"Erro ou a=0\"\n    \n    \n    \n{-\n    Quest\u00e3o 3\n\nMain> func3 1 10 1\n\"Duas raizes reais\"\n\nMain> func3 4 4 1\n\"Uma raiz real\"\n\nMain> func3 4 1 4\n\"Nenhuma raiz real\"\n\n-}\n\n--------------------------------------------------------------------\n    \n{-\n4. Fa\u00e7a uma fun\u00e7\u00e3o que devolva o quadrado de um n\u00famero, se ele for primo; ou zero, caso contr\u00e1rio.\n    Entrada: 7\n    Sa\u00edda: 49\n    \n    Entrada: 6\n    Sa\u00edda: 0\n-}\n\nfunc4 :: Int -> Int\nfunc4 x = if length ([ x | x1 <- [1..x], mod x x1 == 0]) == 2 then x*x else 0\n\n{-\n    Quest\u00e3o 4\n    \nMain> func4 1\n0\nMain> func4 2\n4\nMain> func4 3\n9\nMain> func4 4\n0\nMain> func4 5\n25\n\n-}\n\n--------------------------------------------------------------------\n\n{-\n5. Implemente uma fun\u00e7\u00e3o chamada modiv que, a partir dos dois\nargumentos x e y, com y > x, ambos passados pelo usu\u00e1rio, d\u00ea como\nresultado as seguintes informa\u00e7\u00f5es:\n\u2022 Parte inteira da divis\u00e3o de y por x. Utilize para isso a fun\u00e7\u00e3o nativa div.\n\u2022 Resto da divis\u00e3o de y por x.\n\u2022 y elevado a x\n\u2022 Uma lista com os elementos entre x e y.\n\t\u2022 Exemplo: Para x = 2 e y = 6, deve ser retornado [2,3,4,5,6].\n\u2022 Uma lista com os elementos m\u00faltiplos de x que estejam entre x e y (incluindo ele mesmo).\n\t\u2022 Exemplo: Para x = 4 e y = 14, deve ser retornado [4,8,12].\nAs informa\u00e7\u00f5es acima devem ser retornadas na forma de tupla. Isto \u00e9,\nsua fun\u00e7\u00e3o deve retornar conforme o exemplo abaixo.\n\tEntrada: 4 14\n\tSa\u00edda: (3, 2, 38416, [4,5,6,7,8,9,10,11,12,13,14], [4,8,12])\n-}\n\n\nmodiv :: Int -> Int -> (Int, Int, Int,[Int],[Int])\nmodiv x y = (div y x, mod y x, y^x, [x | x <- [x..y]], [x1 | x1 <- [x..y], mod x1 x == 0])\n  \n  \n\n\n\n\n\n\n\n", "input": "[42, 42]", "status": "success", "output": "[42]"}
{"code": "-- Problem 31\n-- isPrime\n-- Determine whether a given integer number is prime\nisPrime :: Int -> Bool\nisPrime n\n    | n < 0     = isPrime (-n)\n    | n < 2     = False\n    | otherwise = and [n `mod` i /= 0 | i <- [2..limit]] where limit = truncate $ sqrt (fromIntegral n)\n\n\n-- Problem 32\n-- mygcd\n-- Determine the greatest common divisor of two positive integer numbers.\n-- Use euclid's algorithm\nmygcd :: Int -> Int -> Int\nmygcd a 0 = abs a\nmygcd a b = mygcd b (a `mod` b)\n\n\n-- Problem 33\n-- coprime\n-- Determine if two integers are coprime\n-- Two numbers are coprime if the greatest common divisor is 1\ncoprime :: Int -> Int -> Bool\ncoprime a b = gcd a b == 1\n\n\n-- Problem 34\n-- totientPhi\n-- Calculate Euler's totient phi(m)\ntotientPhi :: Int -> Int\ntotientPhi m = length . filter (coprime m) $ [1..m]\n\n\n-- Problem 35\n-- primeFactors\n-- Determine the prime factors of a given positive integer\n-- Construct a flat list containing the prime factors in ascending order\nprimeFactors :: Int -> [Int]\nprimeFactors n = primeFactors' n 2 where\n                    primeFactors' n m = case n < m of\n                        True -> case n == 1 of\n                            True -> []\n                            False -> [n]\n                        False -> case n `rem` m of\n                            0 -> (m:primeFactors' (n `div` m) m)\n                            _ -> primeFactors' n (m+1)\n\n\n-- Problem 36\n-- primeFactorsMul\n-- Determine the prime fators of a given positive integer\n-- Contruct a list containing the prime factors and their multiplicity\nprimeFactorsMul :: Int -> [(Int, Int)]\nprimeFactorsMul n = packPrimes (primeFactors n) where\n                        packPrimes [] = []\n                        packPrimes xs@(x:_) = ((x, l):packPrimes rest) where\n                            l = length $ takeWhile (x==) xs\n                            rest = dropWhile (x==) xs\n\n\n-- Problem 37\n-- totientPhi'\n-- Calculate Euler's totient phi function using prime factorization\ntotientPhi' :: Int -> Int\ntotientPhi' n = product $ [(p - 1) * (p ^ (m - 1)) | (p,m) <- primeFactorsMul n]\n\n\n-- Problem 38\n-- Compare the two methods of calculating Euler's totient function\n-- Solution: The second method is much faster for larger numbers\n\n\n-- Problem 39\n-- primesR\n-- Construct a list of prime numbers with given lower and upper limit\nprimesR :: Int -> Int -> [Int]\nprimesR a b = filter isPrime [a..b]\n\n\n-- Problem 40\n-- goldbach\n-- Goldbach's Conjecture\n-- Find two prime integers whose sum is the given integer\ngoldbach :: Int -> (Int, Int)\ngoldbach n = goldbach' n (primesR 1 n) where\n                goldbach' n [] = (-1,-1)\n                goldbach' n t@(x:xs) = case (n - x) `elem` t of\n                    True -> (x, n-x)\n                    False -> goldbach' n xs\n\n\n-- Problem 41\n-- goldbachList\n-- Find the goldbach composition of all even integers in a given range\ngoldbachList :: Int -> Int -> [(Int, Int)]\ngoldbachList a b = map goldbach $ dropWhile (<4) $ filter even [a..b]\n\n-- goldbahcList'\n-- Find the number of integers whose goldbach decomposition has numbers greate\n-- than the specified limit\ngoldbachList' :: Int -> Int -> Int -> Int\ngoldbachList' a b limit = length $ filter (\\(x,y) -> x > limit) (goldbachList a b)\n\n", "input": "42", "status": "success", "output": "False"}
{"code": "import Data.Char\n \n-- From Programming in Haskell 2nd Ed\n-- by Graham Hutton\n-- Caesar Cipher, Section 5.5 pg 52\n\n-- Letter to integer\nlet2int :: Char -> Int\nlet2int c = ord c - ord 'a'\n\n-- Integer to Letter\nint2let :: Int -> Char\nint2let n = chr (ord 'a' + n)\n\n-- Only shift lower-case characters\nshift :: Int -> Char -> Char\nshift n c | isLower c = int2let ((let2int c + n) `mod` 26)\n          | otherwise = c\n\n-- Caesar cipher a string by Int amount\nencode :: Int -> String -> String\nencode n xs = [shift n x | x <- xs]\n\n-- Opposite of Caesar cipher\ndecode :: Int -> String -> String\ndecode n xs = encode (-n) xs\n\n-- Received odds of the occurence of particular\n-- characters within English sentences\ntable :: [Float]\ntable = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0,\n         0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0,\n         6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1]\n         \n-- Given a string, return the count of lower-case \n-- letters\nlowers :: String -> Int\nlowers xs = length [x | x <- xs, x >= 'a' && x <= 'z']\n\n-- Given a character and a string, return the \n-- number of times that character appears in the string\ncount :: Char -> String -> Int\ncount x xs = length [x' | x' <- xs, x == x']\n\n-- Calculate what percentage n is of m\npercent :: Int -> Int -> Float\npercent n m = (fromIntegral n / fromIntegral m) * 100\n\n-- Given a string, return a list of percentages\n-- each representing the % that letter (a-z) occurs\n-- within the given string where the length of the \n-- given string is understood to consist soley of\n-- lower-case characters\nfreqs :: String -> [Float]\nfreqs xs = [percent (count x xs) n | x <- ['a'..'z']]\n            where n = lowers xs\n            \n-- | \"such that\"\n-- <- \"is drawn from\" \n-- x <- [1..5] is called a \"generator\"\n-- x <- [1..5], x == y is called a \"guard\" and yields\n-- a value from the comprehension if it's True\n\n-- Compute the Chi square statistic between two lists of \n-- percentages - observed and expected. What matters for\n-- the purposes of this excercise is that the smaller\n-- the number produced by the Chi square statistic, the\n-- closer the two lists match. \n-- Basically, I think the CSS is a summation answer for \n-- the question: assuming the keys are the same (which is \n-- unknown in our case) how closely do the values match?\n-- In other words, we have two lists, how closely do they \n-- match? In our case we know that the \"keys\" for our \n-- lists are the letter frequencies in English sentences\n-- but they could be anything for a general application. \n-- This is why we rotate below so we can pose this question\n-- and then seek the minimum CSS value which indicates\n-- that the two lists likely have matching keys. \nchisqr :: [Float] -> [Float] -> Float\nchisqr os es = sum [((o - e)^2)/e | (o,e) <- zip os es]\n\n-- Given an Int and a list, rotate the contents of\n-- the list by Int\nrotate :: Int -> [a] -> [a]\nrotate n xs = drop n xs ++ take n xs\n\n-- Given a and a list of as, return a list representing\n-- ordinals where a appears in as. \npositions :: Eq a => a -> [a] -> [Int]\npositions x xs = [i | (x', i) <- zip xs [0..], x == x']\n\ncrack :: String -> String\ncrack xs = decode factor xs\n  where\n    factor = head (positions (minimum chitab) chitab)\n    chitab = [chisqr (rotate n table') table | n <- [0..25]]\n    table' = freqs xs\n\n\n", "input": "'a'", "status": "success", "output": "0"}
{"code": "trues = [True, True, True, True]\nfalses = [False, False, False, False]\nmixed = [True, False, True, False]\n\nok :: Bool -> Bool\nok x = x == True\n\nifAll :: (a -> Bool) -> [a] -> Bool\n\n--ifAll p xs = and (map p xs)\n--ifAll p = and . map p\n--ifAll p = not . any (not . p)\n--ifAll p xs = foldl (&&) True (map p xs)\nifAll p = foldr (&&) True . map p\n\nifAny :: (a -> Bool) -> [a] -> Bool\n\n--ifAny p = or . map p\n--ifAny p xs = length (filter p xs) > 0\n--ifAny p = not . null . dropWhile (not . p)\n--ifAny p xs = not (all (\\ x -> not (p x)) xs)\nifAny p xs = foldr (\\ x acc -> (p x) || acc) False xs\n\ntake_while :: (a -> Bool) -> [a] -> [a]\ntake_while _ [] = []\ntake_while p (x : xs)\n  | p x = x : take_while p xs\n  | otherwise = []\n\n--take_while (< 3) [1,2,3,4,1,2,3,4] == [1,2]\n--take_while (< 9) [1,2,3] == [1,2,3]\n--take_while (< 0) [1,2,3] == [] \n\ndrop_while :: (a -> Bool) -> [a] -> [a]\ndrop_while _ [] = []\ndrop_while p (x : xs)\n  | p x = drop_while p xs\n  | otherwise = x : xs\n\n--drop_while (< 3) [1,2,3,4,5,1,2,3] == [3,4,5,1,2,3]\n--drop_while (< 9) [1,2,3] == []\n--drop_while (< 0) [1,2,3] == [1,2,3] \n\nmapper :: (a -> b) -> [a] -> [b]\nmapper f = foldl (\\ xs x -> xs ++ [f x]) []\n\n--mapper (+3) [1,5,3,1,6] = [4,8,6,4,9]  \n--mapper (++ \"!\") [\"BIFF\", \"BANG\", \"POW\"] = [\"BIFF!\",\"BANG!\",\"POW!\"]  \n--mapper (replicate 3) [3..6] = [[3,3,3],[4,4,4],[5,5,5],[6,6,6]]  \n--mapper (mapper (^2)) [[1,2],[3,4,5,6],[7,8]] = [[1,4],[9,16,25,36],[49,64]]  \n--mapper fst [(1,2),(3,5),(6,3),(2,6),(2,5)] = [1,3,6,2,2]  \n\nfilterer :: (a -> Bool) -> [a] -> [a]\nfilterer p = foldr (\\ x xs -> if p x then x : xs else xs) []\n\n--filterer (>3) [1,5,3,2,1,6,4,3,2,1] = [5,6,4]  \n--filterer (==3) [1,2,3,4,5] = [3]  \n--filterer even [1..10] = [2,4,6,8,10]  \n--filterer (`elem` ['a'..'z']) \"u LaUgH aT mE BeCaUsE I aM diFfeRent\" = \"uagameasadifeent\"  \n--filterer (`elem` ['A'..'Z']) \"i lauGh At You BecAuse u r aLL the Same\" = \"GAYBALLS\" \n\ndec2int :: [Integer] -> Integer\ndec2int = foldl (\\ x y -> 10 * x + y) 0\n\n--dec2int [2, 3, 4, 5] = 2345\n--dec2int [] = 0\n--dec2int [0, 0, 0, 0] = 0\n\ncompose :: [a -> a] -> (a -> a)\ncompose = foldr (.) id\n\nsambar :: ((a, b) -> c) -> a -> b -> c\nsambar f = \\ x y -> f (x, y)\n\nunsambar :: (a -> b -> c) -> (a, b) -> c\nunsambar f = \\ (x, y) -> f x y\n\nunfold :: (b -> Bool) -> (b -> a) -> (b -> b) -> b -> [a]\nunfold p h t x\n  | p x = []\n  | otherwise = h x : unfold p h t (t x)\n\ntype Bit = Int\n\nint2bin :: Int -> [Bit]\n--int2bin 0 = []\n--int2bin n = n `mod` 2 : int2bin (n `div` 2)\nint2bin = unfold (== 0) (`mod` 2) (`div` 2)\n\n--int2bin 13 = [1, 0, 1, 1]\n--int2bin (-0) = []\n\nchop8 :: [Bit] -> [[Bit]]\n--chop8 [] = []\n--chop8 bits = take 8 bits : chop8 (drop 8 bits)\nchop8 = unfold null (take 8) (drop 8)\n\n--chop8 [1] = [[1]]\n--chop8 [1,1,1,1,1,1,1,1] = [[1,1,1,1,1,1,1,1]]\n--chop8 [1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0] = [[1,1,1,1,1,1,1,1],[0,0,0,0,0,0,0,0]]\n\nmap2 :: (a -> b) -> [a] -> [b]\nmap2 f = unfold null (f . head) tail\n\n--map2 (+3) [1,5,3,1,6] = [4,8,6,4,9]  \n--map2 (++ \"!\") [\"BIFF\", \"BANG\", \"POW\"] = [\"BIFF!\",\"BANG!\",\"POW!\"]  \n--map2 (replicate 3) [3..6] = [[3,3,3],[4,4,4],[5,5,5],[6,6,6]]  \n--map2 (map2 (^2)) [[1,2],[3,4,5,6],[7,8]] = [[1,4],[9,16,25,36],[49,64]]  \n--map2 fst [(1,2),(3,5),(6,3),(2,6),(2,5)] = [1,3,6,2,2]  \n\niter :: (a -> a) -> a -> [a]\niter f = unfold (const False) id f\n\n--take 10 $ iter (*2) 1 = [1,2,4,8,16,32,64,128,256,512]  \n--take 3 $ iter (++ \"haha\") \"haha\" = [\"haha\",\"hahahaha\",\"hahahahahaha\"]\n\n", "input": "True", "status": "success", "output": "True"}
{"code": "-- Author: @katychuang\n-- These are functions I wrote to practice thinking in Haskell to help with\n-- photo processing work. See instructions below on how to use ghci\n\n------------------------------------------------------------------------\n-- Files begin with some settings to make sure ghc runs smoothly.\n\n{-# LANGUAGE OverloadedStrings #-}\n{-# OPTIONS_GHC -fno-warn-incomplete-patterns #-}\n------------------------------------------------------------------------\n-- Modules start with imports.\n\n-- We don't need to import anything for this file.\n\n------------------------------------------------------------------------\n-- Simple exercises\n\n-- reduce input number in half\nshrinkWidth :: Double -> Double\nshrinkWidth x = x / 2\n\nshrinkHeight :: Double -> Double\nshrinkHeight x = x / 2\n\n-- Passing in width and height as a tuple\nshrink :: (Double, Double) -> (Double, Double)\nshrink (x, y) = (x / 2, y / 2)\n\n-- Passing in in width and height as a list\nshrink' :: [Double] -> [Double]\nshrink' theList = map (/2) theList\n\n-- Reduce a list of numbers by percentage (i.e. 0.5 for half size) indicated as the 2nd item in a tuple\nredux :: ([Double], Double) -> [Double]\nredux (theList, percentShrink) = map (*percentShrink) theList\n\n-- Reduce a pair of width/height pair in a tuple, by a given factor, i.e. 0.5\nredux' :: Double -> (Double, Double) -> (Double, Double)\nredux' factor (x, y) = (x * factor, y * factor)\n\n------------------------------------------------------------------------\n-- Return calculations at 0.75, 0.5, 0.25 increments\nquarters :: (Double, Double) -> [(Double, Double)]\nquarters (x, y) = [(x * 0.75, y * 0.75), (x * 0.5, y * 0.5), (x * 0.25, y * 0.25)]\n\n-- Return calculations at 0.10 increments, i.e. 0.9, 0.8, 0.7, etc\ntenths :: (Double, Double) -> [(Double, Double)]\ntenths (x, y) = [(x * 0.9, y * 0.9), (x * 0.8, y * 0.8), (x * 0.7, y * 0.7), \n\t\t    (x * 0.6, y * 0.6), (x * 0.5, y * 0.5), (x * 0.4, y * 0.4),\n\t\t    (x * 0.3, y * 0.3), (x * 0.2, y * 0.2), (x * 0.1, y * 0.1)]\n\n-- Return calculations at 0.10 increments, i.e. 0.9, 0.8, 0.7, etc (with recursion to keep it a oneliner)\ntenths' :: (Double, Double) -> [(Double, Double)]\ntenths' (x, y) = reverse $ [(x * factor / 10, y * factor / 10) | factor <- [1..9]]\n\n\n------------------------------------------------------------------------\n{-\n\nHow to run this script:\n\n1. Open up ghci in your console and load this file `:l img-ratio.hs` or\n   `:load img-ratio.hs`. :l is short for :load.\n\n2. Call one of the defined functions, i.e. `shrinkWidth 1024` will return\n   the value of 1024 divided by 2; the output will be 512.0.\n\n   Note the data types in the function to understand correct input for\n   each method. For instance, shrinkWidth takes a Double type, so passing\n   in a string such as `blue` will produce an error \"Not in scope: `blue'\".\n   Similarly, for shrink' (pronounced shrink prime), this function takes a list of\n   Doubles. Passing in a different type, such as a tuple\n     `shrink' (1024, 768)`,  will give you an error:\n   Couldn't match expected type `[Double]' with actual type `(t0, t1)'\n      - In the first argument of shrink', namely `(1024, 768)'\n      - In the expression: shrink' (1024, 768)\n      - In an equation for `it': it = shrink' (1024, 768)\n\n    Another example of wrong input - passing in a list of strings:\n       > `shrink' [\"red\", \"white\", \"blue\"]`\n       Couldn't match expected type `Double' with actual type `[Char]'\n       In the expression: \"red\"\n       In the first argument of shrink', namely `[\"red\", \"white\", \"blue\"]'\n       In the expression: shrink' [\"red\", \"white\", \"blue\"]\n-}\n\n\n\n", "input": "2.71", "status": "success", "output": "1.355"}
{"code": "import Data.Char\n{-------------------------------------------------------------------------------------------------\n1. Nos exerc\u00edcios a seguir, escreva primeiramente uma fun\u00e7\u00e3o recursiva. Em\n   seguida, reescreva essa fun\u00e7\u00e3o utilizando fun\u00e7\u00e3o de ordem superior. Voc\u00ea\n   pode usar as fun\u00e7\u00f5es nativas map, filter e foldr.\n-}\n\n{- (a) pares :: [Int] -> [Int] que remove todos os elementos \u00edmpares de uma lista. -}\n\npares_recursao :: [Int] -> [Int] -- Usando Recurs\u00e3o\npares_recursao [] = []\npares_recursao (x:xs)\n | even x = x : pares_recursao xs\n | otherwise = pares_recursao xs\n \npares_sup :: [Int] -> [Int] -- Usando ordem superior.\npares_sup x = filter even x\n\n\n-- Fun\u00e7\u00e3o filter, usando gen\u00e9rico.\n\nmeufilter :: (a -> Bool) -> [a] -> [a] \nmeufilter f [] = []\nmeufilter f (x:xs) \n | f x = x : meufilter f xs\n | otherwise = meufilter f xs\n-- > meufilter even [1,2,3,4,5]\n--   [2,4]\n \n \n{- (b) Fun\u00e7\u00e3o rm_char :: Char -> String -> String que remove todas as ocorr\u00eancias de um caractere em uma string. -}\n\nrm_char :: Char -> [Char] -> [Char] -- Recurs\u00e3o\nrm_char letra [] = []\nrm_char letra (x:xs)\n | letra /= x = x : rm_char letra xs\n | otherwise = rm_char letra xs\n \nrm_char_ordem :: Char -> [Char] -> [Char] -- Ordem Superior\nrm_char_ordem letra palavra = filter (letra /= ) palavra\n\n \n{- (c) Fun\u00e7\u00e3o acima :: Int -> [Int] -> [Int] que remove todos os n\u00fameros menores ou iguais a um determinado valor. -}\n\nacima :: Int -> [Int] -> [Int]\nacima val [] = []\nacima val (x:xs)\n | x > val = x : acima val xs \n | otherwise = acima val xs\n \nacima_sup :: Int -> [Int] -> [Int]\nacima_sup val lista_num = filter (val <) lista_num\n\n{- (d) Fun\u00e7\u00e3o produto :: Num a=> [a] -> a que computa o produto dos n\u00fameros de uma lista. -}\n\nproduto :: Num a => [a] -> a\nproduto [] = 1\nproduto (x:xs) = x * produto xs\n\nproduto_f :: Num a => [a] -> a\nproduto_f x = foldr (*) 1 x\n\n\n{- (e) Fun\u00e7\u00e3o concatena :: [String] -> String que junta uma lista de strings em uma \u00fanica string. -}\nconcatena :: [String] -> String\nconcatena [] = []\nconcatena (x:xs) = x ++ concatena xs\n\nconcatena_f :: [String] -> String\nconcatena_f x = foldr (++) [] x\n\n\n{-------------------------------------------------------------------------------------------------\n2. Fa\u00e7a a fun\u00e7\u00e3o ssp que considera uma lista de inteiros e devolve a soma dos\n   quadrados dos elementos positivos da lista.\n-}\nssd :: [Int] -> Int\nssd x = foldr (+) 0 (map (^2) (filter (>0) x))\n\n\n{-------------------------------------------------------------------------------------------------\n3. Defina a fun\u00e7\u00e3o sumsq que considera um inteiro n como argumento e devolve\n   a soma dos quadrados dos n primeiros inteiros. Ou seja:\n*Main > sumsq 4\n30\npois 1\u00b2 + 2\u00b2 + 3\u00b2 + 4\u00b2 = 30.\n-}\nsumsq :: Int -> Int\nsumsq x = foldr (+) 0 (map (^2) [1..x])\n\n\n{-------------------------------------------------------------------------------------------------\n4. Uma fun\u00e7\u00e3o que devolva o valor da soma dos comprimentos de cada string\n   (elemento) da lista. Isto \u00e9, a soma total dos comprimentos da lista de entrada.\n-}\n\nsomaComprimentos :: [String] -> Int\nsomaComprimentos l = foldr (+) 0 (map length l)\n\n\n{-------------------------------------------------------------------------------------------------\n5. Fa\u00e7a uma fun\u00e7\u00e3o que separe caracteres de n\u00fameros em uma string de\n   entrada. O retorno \u00e9 uma tupla, em que no primeiro argumento esteja a\n   sequ\u00eancia de caracteres (string), e no segundo argumento uma sequ\u00eancia de\n   inteiros. Dica: Utilize isAlpha e isDigit, presentes em Data.Char.\nPor exemplo:\n > separa \"aA29bB71\"\n (\"aAbB \", \"2971\")\n-}\n\nsepara :: String -> (String,String)\nsepara str = (filter isAlpha str, filter isDigit str)\n\n \n ", "input": "[42, 42]", "status": "success", "output": "[42,42]"}
{"code": "cubo::Float->Float\r\ncubo lado = lado ** 3 \r\n\r\npotencia_2::Float->Float\r\npotencia_2 x = x * x\r\n\r\npotencia_4::Float->Float\r\npotencia_4 x = (potencia_2 x) ** 2\r\n\r\nmenor::Int->Int->Int\r\nmenor x y\r\n    | x < y = x\r\n    |otherwise = y\r\n\r\ncompara1::Int->Int->Int->String\r\ncompara1 x y z\r\n    | x == y && x == z = \"Todos iguais\"\r\n    | x == y = \" Dois primeiros sao iguais \"\r\n    | x == z = \" Primeiro igual a ultimo \"\r\n    | y == z = \" Dois Ultimos sao iguais \"\r\n    | otherwise = \"Diferentes\"\r\n\r\nfibonnacci::Int->Int\r\nfibonnacci n\r\n    | n == 1 = 1\r\n    | n == 2 = 1\r\n    |otherwise = fibonnacci (n-1) + fibonnacci (n-2)\r\n\r\ndoubleSmallN x = if x > 100\r\n                    then x\r\n                    else x * 2\r\n\r\nparImpar lista = [ if not(odd x) then \"par\" else \"impar\" | x <- lista ]\r\n\r\ncombinalistas x y = [ a*b | a<-x, b<-y]\r\n\r\nverificaTriangulo::(Int,Int,Int)->String\r\nverificaTriangulo (a,b,c) = if (a,b,c) `elem` [(x,y,z) | x <- [1..b], y <- [1..c], z<-m, x^2 + y^2 == c^2, x+y+z == 24 ]\r\n                            then \"T\"\r\n                            else \"N\"\r\n                            where m = [1..10]\r\n\r\nlucky::(Integral a)=>a->String\r\nlucky 4 = \"asd\"\r\nlucky x = \"mentira\"\r\n\r\nfatorial::(Integral a)=>a->a\r\nfatorial 0 = 1\r\nfatorial n = n * fatorial(n-1)\r\n\r\nintegral'::(Integral a)=>a->a\r\nintegral' n = n\r\n\r\ninteger'::a->a\r\ninteger' n = n\r\n\r\nnum::(Num a, Integral b)=>b->a\r\nnum a = fromIntegral a\r\n\r\n\r\nnumber'::(Num a)=>a->String\r\nnumber' n  = \"n\"\r\n    \r\n    \r\n\r\ntell::(Show a)=>[a]->String\r\ntell [] = \"Lista vazia\"\r\ntell (x:[]) = \"Um elemento: \" ++ show x\r\ntell (x:y:[]) = \"Dois elementos: \" ++ show x ++ \", \" ++ show y\r\ntell (x:y:_) = \"grande: \" ++ show x ++ \", \" ++ show y\r\n\r\nfuncao::(Show a)=>[a]->String\r\nfuncao xs = case xs of  [] -> \"Vazia\"\r\n                        (x:[]) -> \"um elemento\"\r\n                        (x:xs) -> \"Primeiro elemento \" ++ show x\r\n\r\nlength' xs = sum [1 | _<-xs ]\r\n\r\nbmiTell::(RealFloat a)=>a->a->a\r\nbmiTell peso alt = peso / alt^2\r\n\r\ncalcBmi::(RealFloat a)=>[(a,a)]->[a]\r\ncalcBmi lista  = [ let bmi = w/h^2 in bmi  | (w, h)<-lista]\r\n  \r\nmyLast::[a]->a\r\nmyLast [] = error \"Lista vazia\"\r\nmyLast (x:[]) = x\r\nmyLast (x:xs) = myLast xs\r\n\r\nmaximum'::(Ord a)=>[a]->a\r\nmaximum' [] = error \"Lista vazia\"\r\nmaximum'[a] = a\r\nmaximum' (x:xs)\r\n    | x > maximum' xs = x\r\n    | otherwise = maximum' xs\r\n\r\nreplicate'::(Num i, Ord i)=>i->a->[a]\r\nreplicate' n a \r\n    |n <= 0 = []\r\n    |otherwise = a : replicate' (n-1) a\r\n\r\ntake'::(Num i, Ord i)=>i->[a]->[a]\r\ntake' n _\r\n    | n <= 0 = []\r\ntake' n [] = []\r\ntake' n (x:xs) = x: take' (n-1) xs\r\n\r\nzip'::[a]->[b]->[(a,b)]\r\nzip' _ [] = []\r\nzip' [] _ = []\r\nzip' (x:xs) (y:ys) = (x,y) : zip' xs ys\r\n\r\nelem'::(Eq a)=>a->[a]->Bool\r\nelem' _ [] = False\r\nelem' a (x:xs)\r\n    | a == x = True\r\n    | otherwise = elem' a xs\r\n\r\nquicksort::(Ord a)=>[a]->[a]\r\nquicksort [] = []\r\nquicksort (x:xs) =\r\n    let left = quicksort [a | a <- xs, a <= x]\r\n        right = quicksort [a | a <- xs, a > x]\r\n    in left ++ [x] ++ right    \r\n   \r\nmult3::(Num a)=> a -> a -> a -> a\r\nmult3 a b c = a * b * c\r\n\r\nmult2 = mult3 9\r\n\r\ncompara100::(Num a, Ord a)=>a->Ordering\r\ncompara100 = compare 100\r\n\r\nfuncfunc::(a->a)->a->a\r\nfuncfunc f x = f (f x)\r\n\r\nzipWith'::(a->b->c)->[a]->[b]->[c]\r\nzipWith' _ [] _ = []\r\nzipWith' _ _ [] = []\r\nzipWith' f (a:as) (b:bs) = f a b : zipWith' f as bs\r\n\r\nflip'::(a->b->c)->(b->a->c)\r\nflip' f x y = f y x\r\n\r\nmaxi::(Ord a)=>[a]->a\r\nmaxi [] = error \"Lista Vazia\"\r\nmaxi [a] = a\r\nmaxi (x:xs) = foldr1 (\\a b->(max a b)) (x:xs)\r\n   \r\nbublesort::[Int]->[Int]\r\nbublesort [] = []\r\nbublesort (x:[]) = [x]\r\nbublesort lista = ( foldl1 (\\a b->(min a b)) lista :( bublesort [x|x<-lista, x/=(minimum lista)] ) )\r\n\r\n\r\nseparaBreak::[Int]->([Int],[Int])\r\nseparaBreak v = break (\\a->(a `mod` 2)==1) v\r\n\r\nseparaSpan::[Int]->([Int],[Int])\r\nseparaSpan v = span (\\a->(a `mod` 2)==0) v\r\n\r\n", "input": "3.14", "status": "success", "output": "30.959146"}
{"code": "{-\nCPSC 449 Assignment 2\nJ. Gallagher T01 MW 1400-1450\nAndrew Helwer - 10023875\n-}\n\n{-\nQuestion 1a\n\nPurpose: to square all odd items in a list of integers\nParameters: a list of integers\nPreconditions: none\nReturns: a list of integers\n-}\n\noddSquaresA :: [Int]->[Int]\noddSquaresA xs = [x*x | x<-xs, (odd x)]\n\n{-\nQuestion 1b\n\nPurpose: to square all odd items in a list of integers\nParameters: a list of integers\nPreconditions: none\nReturns: a list of integers\n-}\n\noddSquaresB :: [Int]->[Int]\noddSquaresB [] = []\noddSquaresB (x:xs)\n    | (odd x)\t\t\t= (x*x):(oddSquaresB xs)\n    | otherwise\t\t\t= (oddSquaresB xs)\n    \n{-\nQuestion 2 (List Comprehension)\n\nPurpose: to remove all duplicates from a set of integers\nParameters: a list of integers\nPreconditions: none\nReturns: a list of unique integers\n-}\n\nuniqueA :: [Int]->[Int]\nuniqueA xs = [x | x<-xs, (isUniqueIn x xs)]\n\n{-\nQuestion 2 (Primitive Recursion)\n\nPurpose: to remove all duplicates from a set of integers\nParameters: a list of integers\nPreconditions: none\nReturns: a list of unique integers\n-}\n\nuniqueB ::[Int]->[Int]\nuniqueB [] = []\nuniqueB (x:xs)\n    | (contains x xs)\t\t= (uniqueB (removeAll x xs))\n    | otherwise\t\t\t= x:(uniqueB xs)\n\n{-\nQuestion 3a\n\nPurpose: to merge two sorted lists such that the end result is sorted\nParameters: two lists of integers to be merged\nPreconditions: both lists of integers are sorted in ascending order\nReturns: a sorted list of integers\n-}\n\nmergeLists :: [Int]->[Int]->[Int]\nmergeLists [] [] = []\nmergeLists [] ys = ys\nmergeLists xs [] = xs\nmergeLists (x:xs) (y:ys)\n    | x<=y\t\t\t= x:(mergeLists xs (y:ys))\n    | otherwise\t\t\t= y:(mergeLists (x:xs) ys)\n{-\nQuestion 3b\n\nPurpose: to split a list into two lists, one of even indices one of odd\nParameters: a list of integers to be split\nPreconditions: none\nReturns: a tuple of two integer lists whose union is the original list\n-}\n\nsplitList :: [Int]->([Int],[Int])\nsplitList [] = ([],[])\nsplitList (x:xs)\n    | (xs==[])\t\t\t= ([x],[])\n    | otherwise\t\t\t= (x:(skipOne (tail xs)),(skipOne xs))\n\n{-\nPurpose: to generate a list from an input list by taking every second element\nParameters: a list of integers\nPreconditions: none\nReturns: a list of integers\n-}\n\nskipOne :: [Int]->[Int]\nskipOne [] = []\nskipOne (x:xs)\n    | (xs==[])\t\t\t= [x]\n    | otherwise\t\t\t= x:(skipOne (tail xs))\n\n{-\nQuestion 3c\n\nPurpose: to sort a list of integers with mergesort\nParameters: a list of integers\nPreconditions: none\nReturns: a list of integers\n-}\n\nmSort :: [Int]->[Int]\nmSort [] = []\nmSort (x:xs)\n    | (xs==[])\t\t\t= [x]\n    | otherwise\t\t\t= (mergeLists (mSort (x:(skipOne (tail xs)))) (mSort(skipOne xs)))\n    \n{-\nUseful functions written by myself:\n-}\n\n{-\nPurpose: to check if a list of integers contains a certain element\nParameters: an element to be checked and a list of integers\nPreconditions: none\nReturns: True or False if the element is or is not in the list\n-}\n\ncontains :: Int->[Int]->Bool\ncontains x xs\n    = case xs of\n\t   [] -> False\n\t   (y:ys) -> (x==y) || (contains x ys)\n\n{-\nPurpose: to find the number of instances of an element in a list\nParameters: an element to be checked and a list of integers\nPreconditions: none\nReturns: an integer specifying number of occurences in the list\n-}\n\ninstancesOf :: Int->[Int]->Int\ninstancesOf n [] = 0\ninstancesOf n (x:xs)\n    | (n==x)\t\t\t= 1 + (instancesOf n xs)\n    | otherwise\t\t\t= (instancesOf n xs)\n    \n{-\nPurpose: to determine if there is exactly one occurence of an element in a list\nParameters: an element to be checked and a list of integers\nPreconditions: none\nReturns: True or False if the element is or is not unique\n-}\nisUniqueIn :: Int->[Int]->Bool\nisUniqueIn x xs = (instancesOf x xs) == 1\n    \n{-\nPurpose: to remove all instances of an element in a list\nParameters: an element to be removed and a list of integers\nPreconditions: none\nReturns: a list with all occurences of the specified element gone\n-}\nremoveAll :: Int->[Int]->[Int]\nremoveAll n [] = []\nremoveAll n (x:xs)\n    | (x==n)\t\t\t= (removeAll n xs)\n    | otherwise\t\t\t= x:(removeAll n xs)", "input": "[42, 42]", "status": "success", "output": "[]"}
{"code": "doubleMe x = x + x\ndoubleUs x y = doubleMe x + doubleMe y\ndoubleSmall x = (if x > 100 then x else x*2) + 1\n\nlength' xs = sum [1 | _ <- xs]\njlt xxs = [[x | x<-xs, even x]|xs <- xxs]\nremoveUpperCase :: [Char] -> [Char]\nremoveUpperCase st = [x | x <-st,x `elem` ['A'..'Z']]\naddThree :: Int -> Int -> Int -> Int\naddThree x y z = x+y+z\naddThrice :: [Int] -> Int\naddThrice xs = sum [x | x <- xs]\n\nlucky :: (Integral a) => a -> String\nlucky 7 = \"Lucky Number 7!\"\nlucky x = \"Oops! Wrong Answer\"\n\ncharName :: (Integral a) => a -> String\ncharName 1 = \"One!\"\ncharName 2 = \"Two!\"\ncharName 3 = \"Three!\"\ncharName 4 = \"Four!\"\ncharName 5 = \"Five!\"\ncharName x = \"Input must be in range of form\"\n\nfactorial :: (Integral a) => a -> a\nfactorial 0 = 1\nfactorial n = n * factorial (n-1)\n\nfirst :: (a,b,c) -> a\nfirst (a,_,_) = a\n\ntell :: (Show a) => [a] -> String\ntell (x:y:_) = show x ++ show y\ntell (x:[]) = show x\ntell ([]) = \"null\"\n\nlengthr :: (Num b) => [a] -> b\nlengthr [] = 0\nlengthr (_:xs) = 1 + (lengthr xs)\n\ncapital :: String -> String\ncapital \"\" = \"String is empty!\"\ncapital all@(x:xs) = \"The string \" ++  all ++ \"starts with \" ++ [x]\n\nbmi :: (RealFloat a ) => a -> a -> String\nbmi height weight\n  | info  <= skinny = \"UW\"\n  | info  <= normal = \"Normal\"\n  | info  <= over = \"Overweight\"\n  | otherwise =  \"Whale\"\n  where info = weight / height ^ 2\n        (skinny, normal, over) = (18.5,25,30)\n\ninitials :: String -> String -> String\ninitials a b = [f] ++ \". \" ++ [l] ++ \". \"\n  where (f:_) = a\n        (l:_) = b\n\ncalcbmi :: (RealFloat a) => [(a,a)] -> [a]\ncalcbmi xs = [bmi w h | (w,h) <- xs]\n  where bmi w h = w / h ^ 2\ncylinder :: (RealFloat a) => a -> a -> a\ncylinder r h =\n  let sideA = 2 * pi * r * h\n      topA = pi * r * r\n  in sideA + 2*topA\n\nbmifat :: (RealFloat a) => [(a,a)] -> [a]\nbmifat xs = [bmi | (w,h)<-xs,let bmi = w/h ^ 2,bmi >=25.5]\n\nstringTest :: String -> String\nstringTest xs = \"The string is \" ++ case xs of  [] -> \"Empty\"\n                                                [x] -> \"Singleton!\"\n                                                xs -> \"good to go!\"\n\nmaximumL :: (Ord a) => [a] -> a\nmaximumL [] = error \"Error\"\nmaximumL [x] = x\nmaximumL (x:xs) = max x (maximumL xs)\n\nreplicate' :: (Ord i, Num i) => i ->a ->[a]\nreplicate' n x\n  | n <= 0    = []\n  | otherwise = x:replicate' (n-1) x\n\ncycle' :: (Num a) => [a] -> [a]\ncycle [] = error \"some\"\ncycle' xs = xs ++ cycle' xs\n\nreverse' :: String -> String\nreverse' (x:xs) = reverse' xs ++ [x]\nreverse' [] = []\n\ntake' :: (Num a, Ord a) => a->[a]->[a]\ntake' n _\n  | n <= 0 = []\ntake' n [] = []\ntake' n (x:xs) = [x] ++ take' (n-1) xs\n\nzip' :: [a] -> [b] -> [(a,b)]\nzip' _ [] = []\nzip' [] _ = []\nzip' (x:xs) (y:ys) = [(x,y)] ++ zip' xs ys\n\nquicksort :: (Ord a) => [a] -> [a]\nquicksort [] = []\nquicksort (x:xs) =\n  let small = quicksort [xt | xt<-xs,xt < x]\n      big = quicksort [xt | xt <- xs, xt >= x]\n  in small ++ [x] ++ big\n\nflip' :: (a->b->c) ->b -> a -> c\nflip' f x y = f y x\n\nmap' :: (a -> b) -> [a] -> [b]\nmap' _ [] = []\nmap' f (x:xs) = f x : map' f xs\n\nlargestdivisible = head (filter p [100000,99999..])\n  where p x = x `mod` 3 == 0\n-- let sumodd = sum (takeWhile (<100000) (filter odd (map (^2) [1..])))\n-- Collatz Sequences\nchain :: (Integral a) => a -> [a]\nchain 1 = [1]\nchain n\n  | even n  = n:chain(n `div` 2)\n  | odd n   = n:chain(n*3 + 1)\nlarg t = filter p [100,99..1]\n  where p x = ((length (chain x)) >= t)\n-- flip' f = \\x y -> f y x\nsum'' :: (Num a) => [a] -> a\nsum'' = foldl (-) 0\n\nelem' :: (Eq a) => a -> [a] -> Bool\nelem' y ys = foldl (\\acc x -> if y==x then True else acc) False ys\n\nflipit :: (a->b->c) -> b->a->c\nflipit f = (\\x y -> f y x)\n\nmaps :: (a->b) ->[a]->[b]\nmaps f xs = foldr (\\x acc -> (f x ): acc) [] xs\n\nmaximum2 :: (Ord a) => [a] -> a\nmaximum2 xs = foldr1 (\\x acc -> (max acc x))xs\n\nreverse2 :: String -> String\nreverse2 = foldl(\\acc x -> x:acc)[]\n-- reverse2 some = foldr (\\x acc -> acc:x)\"\" some\ncheck :: (Num a) => [a] -> a\ncheck xs = product $ map (negate. abs) xs\n\noddSqsum :: (Integral a) => a -> a\noddSqsum a = sum . takeWhile (<a) .filter odd . map (^2) $ [1..]\n", "input": "['a', 'a']", "status": "success", "output": "\"\""}
{"code": "----------------------------------------------\n-- CIS 194, Homework 1\n-- Author: Glenn R. Fisher\n-- Date: March 29, 2016\n----------------------------------------------\n\n----------------------------------------------\n-- Part 1: Validating Credit Card Numbers\n----------------------------------------------\n\n-- | Convert positive integers to a list of digits. Non-positive integers are\n-- converted to an empty list.\n--\n-- > toDigits 1234 == [1, 2, 3, 4]\n-- > toDigits 0 == []\n-- > toDigits (-1234) == []\n\ntoDigits :: Integer -> [Integer]\ntoDigits x = reverse (toDigitsRev x)\n\n-- | Convert positive integers to a reversed list of digits. Non-positive\n-- integers are converted to an empty list.\n--\n-- > toDigitsRev 1234 == [4, 3, 2, 1]\n-- > toDigitsRev 0 == []\n-- > toDigitsRev (-1234) == []\n\ntoDigitsRev :: Integer -> [Integer]\ntoDigitsRev x\n    | x <= 0 = []\n    | otherwise = (x `mod` 10) : (toDigitsRev (x `div` 10))\n\n-- | Double every other number in a list, starting from the left. The result is\n-- a list of the same length where the second, fourth, etc. numbers are doubled.\n--\n-- > doubleEveryOtherFromLeft [1, 2, 3] == [1, 4, 3]\n-- > doubleEveryOtherFromLeft [1, 2, 3, 4] == [1, 4, 3, 8]\n\ndoubleEveryOtherFromLeft :: [Integer] -> [Integer]\ndoubleEveryOtherFromLeft [] = []\ndoubleEveryOtherFromLeft (x:[]) = [x]\ndoubleEveryOtherFromLeft (x:y:xs) = [x, 2*y] ++ doubleEveryOtherFromLeft xs\n\n-- | Double every other number in a list, starting from the right. The result is\n-- a list of the same length where the second-to-last, fourth-to-last, etc.\n-- numbers are doubled.\n--\n-- > doubleEveryOtherFromRight [1, 2, 3] == [1, 4, 3]\n-- > doubleEveryOtherFromRight [1, 2, 3, 4] == [2, 2, 6, 4]\n\ndoubleEveryOtherFromRight :: [Integer] -> [Integer]\ndoubleEveryOtherFromRight xs = reverse (doubleEveryOtherFromLeft (reverse xs))\n\n-- | Double every other number in a list, starting from the right. The result is\n-- a list of the same length where the second-to-last, fourth-to-last, etc.\n-- numbers are doubled.\n--\n-- > doubleEveryOther [1, 2, 3] == [1, 4, 3]\n-- > doubleEveryOther [1, 2, 3, 4] == [2, 2, 6, 4]\n\ndoubleEveryOther :: [Integer] -> [Integer]\ndoubleEveryOther = doubleEveryOtherFromRight\n\n-- | Calculate the sum of all digits in the list.\n--\n-- > sumDigits [1, 2, 3] == 6\n-- > sumDigits [10, 11, 12] == 6\n\nsumDigits :: [Integer] -> Integer\nsumDigits [] = 0\nsumDigits (x:xs) = sum (toDigits x) + sumDigits xs\n\n-- | Validate a credit card number. Returns True if the credit card number is\n-- valid, and False otherwise.\n--\n-- Validation Algorithm:\n-- 1. Double the value of every other second digit beginning from the right.\n-- 2. Add the digits of the doubled values and the undoubled digits from the\n--    original number.\n-- 3. Calculate the remainder when the sum is divided by 0.\n-- 4. Check if the remainder is 0. If so, then the credit card number is valid.\n--\n-- Example:\n-- 1. 1386 -> [2, 3, 16, 6]\n-- 2. 2+3+1+6+6 == 18\n-- 3. 18 `mod` 10 == 8\n-- 4. 8 /= 0, so 1386 is not a valid credit card number.\n--\n-- > validate 4012888888881881 == True\n-- > validate 4012888888881882 == False\n\nvalidate :: Integer -> Bool\nvalidate x = sumDigits (doubleEveryOther (toDigits x)) `mod` 10 == 0\n\n----------------------------------------------\n-- Part 2: The Towers of Hanoi\n----------------------------------------------\n\n-- Pegs are identified by a String.\ntype Peg = String\n\n-- A move transfers the top disk from one peg to another.\ntype Move = (Peg, Peg)\n\n-- Return a list of moves to solve the Tower of Hanoi puzzle. The moves transfer\n-- a given number of stacked discs from the first peg to the second, using the\n-- third peg as temporary storage.\n--\n-- > hanoi 2 \"a\" \"b\" \"c\" == [(\"a\", \"c\"), (\"a\", \"b\"), (\"c\", \"b\")]\n\nhanoi :: Integer -> Peg -> Peg -> Peg -> [Move]\nhanoi x peg1 peg2 peg3\n    | x <= 0 = []\n    | x == 1 = [(peg1, peg2)]\n    | otherwise =\n        let moveToTemp = hanoi (x-1) peg1 peg3 peg2 in\n        let moveLargest = [(peg1, peg2)] in\n        let moveToSolution = hanoi (x-1) peg3 peg2 peg1 in\n        moveToTemp ++ moveLargest ++ moveToSolution\n        ", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "import Text.Show.Functions -- con este import permitimos \"imprimir\" una funcion\n\n-- Vamos a ver que onda con Haskell\naproboAlumno :: Int -> Bool\naproboAlumno nota = nota >= 6\n\n-- Funcional guia 1 --\n-- Primeros ejercicios de funcional --\n\n-- 1.1\nesMultiploDeTres :: Int -> Bool\nesMultiploDeTres x = (mod x 3) == 0\n\n--1.2\nesMultiploDe :: Int -> Int -> Bool\nesMultiploDe x y = (mod x y) == 0\n\n--1.3\n-- Si defino el dominio de entrada como Int estoy restingiendo los valores en punto flotante.\ncubo x = x^3\n\n--1.4\narea base altura = base*altura\n\n--1.5\nesBisiesto anio = (esMultiploDe anio 400) || ((esMultiploDe anio 4) && not (esMultiploDe anio 100))\n\n--1.6\ncelsiusToFahr c = c*1.8000+32.00 -- googlear \n\n--1.7\nfahrToCelsius f = (f-32)/1.8000 -- googlear \n\n--1.8\nhaceFrioF f = fahrToCelsius f < 8\n\n--1.9\n-- gcd (greatest common divisor = maximo comun divisor)\nmcm a b = (a*b) `div` (gcd a b)\n\n--1.10.a\ndispersion m1 m2 m3 = max (max m1 m2) m3 - min (min m1 m2) m3\n\n--1.10.b\n-- medidas \"mx\" expresadas en cm\ndiasParejos m1 m2 m3 = dispersion m1 m2 m3 < 30\n\ndiasLocos m1 m2 m3 = dispersion m1 m2 m3 > 100\n\ndiasNormales m1 m2 m3 = not (diasParejos m1 m2 m3) && not (diasLocos m1 m2 m3)\n\n--1.11\n-- Parece que al interprete de Haskell no le gustan los caracteres tabs (\\t), para las guardas usar espacios en blanco\n-- altura expresada en cm, devuelve peso en Kg\npesoPino altura | altura <= 300 = 3*altura\n                | otherwise = 300 + 2*altura\n\nesPesoUtil peso = peso >= 400 && peso <= 1000\n\n-- me pide que lo haga por composicion, entonces las 3 maneras posibles son:\nsirvePino altura = esPesoUtil.pesoPino $ altura -- el operador aplicacion ($) aplica una funcion con \"precedencia a derecha\", es decir, la expresion a derecha se toma como parametro para la funcion de la izquierda.\nsirvePino' altura = esPesoUtil (pesoPino altura)\nsirvePino'' = esPesoUtil . pesoPino -- notacion \"point-free\" (simplificando terminos)\n\n\n--1.12\nsumarImpares n i j | (n == 0) || (n < i) = 0\n                   | (n == i) = n\n                   | n > i =  sumarImpares n (i+j) (j+2)\n                   \nesCuadradoPerfecto n = (sumarImpares n 0 1) == n\n\n-- Aplicacion parcial --\n--2.1\nsiguiente = (+1)\n\n--2.2\nmitad = (/2)\n\n--2.3\ninversa = (1/)\n\n--2.4\ntriple = (3*)\n\n--2.5\nesNumeroPositivo = (>0)\n\n-- Composicion --\n--3.1\nesMultiploDe' y = (== 0).(mod y) -- point-free para el parametro \"x\", que viene a ser el a\u00f1o\n\n--3.2\nesBisiesto' anio = (((esMultiploDe anio 400)||).(esMultiploDe anio 4 &&).not.(esMultiploDe anio)) 100\n\n--3.3\ninversaRaizCuadrada = inversa.sqrt\n\n--3.4\nincrementMCuadradoN n m = (+m).(^2) $ n -- con el operador $ me ahorro de poner los parentesis en la nueva funcion compuesta\n\n--3.5\nesResultadoPar n m = (even.(^m)) n\n\n-- Tuplas --\n--4.1\nfst3 (a,_,_) = a\nsnd3 (_,b,_) = b\ntrd3 (_,_,c) = c\n\n--4.2\naplicar (f1,f2) x = (f1 x,f2 x)\n\n--4.3\ncuentaBizarra (x,y) | x > y = x + y\n                    | abs (x - y) > 10 = y - x\n                    | y > x && abs (x - y) < 10 = x * y\n\n--4.4\n-- habria que actualizar al guia, ahora se aprueba con 6 :p\nesNotaBochazo = (<4)\n\naprobo (nota1,nota2) = (not(esNotaBochazo nota2) &&).not.(esNotaBochazo) $ nota1 -- notar que esNotaBochazo nota2 no esta siendo aplicada parcialmente, pero la funcion && si. Donde \"not(esNotaBochazo nota2)\" es el miembro izquierdo del operador logico &&.\n\npromociono (nota1,nota2) = nota1+nota2 >= 14 && (nota1 >= 6) && (nota2 >= 6)\n\naproboPrimerParcial (nota1,_) = (not.esNotaBochazo) nota1\n\n--4.5 n: nota, r: recuperatorio\nnotasFinales ((n1,n2),(r1,r2)) = (max n1 r1, max n2 r2)\n\nrecursa = not.aprobo.notasFinales\n\nrecuperoPrimerParcial ((n1,_),(r1,_)) = (not(esNotaBochazo r1) &&).(esNotaBochazo) $ n1\n\nrecuperoDeGusto ((n1,n2),(r1,r2)) =  promociono (n1,n2) && (r1 > -1) || (r2 > -1) -- el recupero de gusto no contempla que haya aprobado ese recu (igual que en nuestro nuevo reglamento jeje :p)\n\n--4.6\nesMayorDeEdad = (>=21).snd\n\n--4.7\ncalcular (x,y) | ((odd y &&).even) x = (2*x,y+1) -- el orden es importante, es secuencial\n               | even x = (2*x,y)\n               | odd y = (x,y+1)\n               | otherwise = (x,y)", "input": "42", "status": "success", "output": "True"}
{"code": "\n-- Micro-Haskell examples TPJ 2015\n\n-- load into Haskell using\n-- :load \"MH_examples.hs\"\n-- You may need to provide the full path to the file\n\n-- to reload after changes, type\n-- :reload\n\n-- Logical negation\n\nneg :: Bool -> Bool ;\nneg b = if b then False else True ;\n\n-- Exercise: define logical conjunction and disjunction.\n-- The types should be:\n-- land :: Bool -> Bool -> Bool ;\n-- lor :: Bool -> Bool -> Bool ;\n\nland :: Bool -> Bool -> Bool ;\nland p q = if p then q else False ;\n\n-- Arithmetic functions\n\nfib :: Integer -> Integer ;\nfib n = if n == 0 then 0\n        else if n == 1 then 1\n        else fib (n - 1) + fib (n - 2) ;  -- Inefficient!\n\ntimes :: Integer -> Integer -> Integer ;\ntimes m n = if 0 < n then m + times m (n - 1)\n            else if n < 0 then times m (n + 1) - m \n            else 0 ;\n\ndivides :: Integer -> Integer -> Bool ;\ndivides m n = if n == 0 then True\n        else if m == 0 then False\n        else if n < 0 then divides m (0-n)\n        else if m < 0 then divides (0-m) n\n        else if n < m then False \n        else divides m (n - m);\n\n-- Exercise: change divides so that it will also work with negative numbers!\n\n-- Exercise: change fib so that it will also work with negative numbers!\n\n\n-- Currying\n\ndouble :: Integer -> Integer ;\ndouble = times 2 ;\n\n-- Exercise: define multSeven telling whether a number is a multiple of 7.\n\nmultSeven :: Integer -> Bool ;\nmultSeven = divides 7 ;\n\n-- Taking a function as argument\n\ntwice :: (Integer -> Integer) -> (Integer -> Integer) ;\ntwice f n = f (f n) ;\n\n-- Exercise: write a function\n-- rpt m f n\n-- that computes f (f (f (... n))), where f is repeated m times\n-- and use it to define a function\n-- pow a b\n-- which computes a to the power of b\n\nrpt :: Integer -> (Integer -> Integer) -> Integer -> Integer ;\nrpt m f n = if m == 0 then n\n            else rpt (m-1) f (f n) ;\n\npow :: Integer -> Integer -> Integer ;\npow a b = rpt b (times a) 1 ;\n\n-- Representing infinite lists as functions\n\nhd :: (Integer -> Integer) -> Integer ;\nhd l = l 1;\n\ntl :: (Integer -> Integer) -> (Integer -> Integer) ;\ntl l n = l (n+1) ;\n\ncons :: Integer -> (Integer -> Integer) -> (Integer -> Integer) ;\ncons n l m = if m == 1 then n else l (m-1) ;\n\nfrom :: Integer -> (Integer -> Integer) ;\nfrom m n = m + n - 1 ;\n\n-- Exercise: write a function\n-- apply f l\n-- which applies the function f on each entry of l (i.e., returns a list)\n\napply :: (Integer -> Integer) -> (Integer -> Integer) -> (Integer -> Integer) ;\napply f l n = f (l n) ;\n\n-- Exercise: define a function square returning the square of the input,\n-- and use it to define a list squares of squares of numbers starting with 0.\n\nsquare :: Integer -> Integer ;\nsquare x = times x x ;\n\nsquares :: Integer -> Integer ;\nsquares = apply square (from 0) ;\n\n-- Filtering an infinite list\n\nfltr :: (Integer -> Bool) -> (Integer -> Integer) -> (Integer -> Integer) ;\nfltr p l n =\n  if (p (hd l))\n    then if n == 1 then hd l\n         else fltr p (tl l) (n - 1)\n    else fltr p (tl l) n ;\n\n\n-- Eratosthenes' sieve\n\nnotdivides :: Integer -> Integer -> Bool ;\nnotdivides m n = neg (divides m n) ;\n\nsieve :: (Integer -> Integer) -> (Integer -> Integer) ;\nsieve l = cons (hd l) (sieve (fltr (notdivides (hd l)) (tl l))) ;\n\nprimes :: Integer -> Integer ;\nprimes = sieve (from 2) ;\n\n-- Warning, this is *very* slow!!!\n-- One reason for this is it recomputes \"hd l\" multiple times\n-- An efficient implementation would avoid this repetition\n\n\n-- Exercise: define a function\n-- addEntries :: (Integer -> Integer) -> (Integer -> Integer)\n-- returning a list whose n-th entry is the sum of the first n entries of the input.\n-- Using this define the infinite list of triangle numbers triangles.\n\n-- Exercise: define a function\n-- addLists :: (Integer -> Integer) -> (Integer -> Integer) -> (Integer -> Integer)\n-- returning a list whose n-th entry is the sum of n-th entries of the input lists.\n\n-- Question: What does the following give?\n-- addLists triangles (tl triangles)\n\n-- Exercise: see if you can find a more efficient way to compute the\n-- \"infinite list\" of Fibonacci numbers than the fib function above.\n", "input": "True", "status": "success", "output": "False"}
{"code": "-- 3.1 \u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\n\nlucky :: Int -> String\nlucky 7 = \"LUCKY NUMBER SEVEN!\"\nlucky x = \"Sorry, you're out of luck, pal!\"\n\nsayMe :: Int -> String\nsayMe 1 = \"One\"\nsayMe 2 = \"Two\"\nsayMe 3 = \"Three\"\nsayMe 4 = \"Four\"\nsayMe 5 = \"Five\"\nsayMe x = \"Not between 1 and 5\"\n\nfactorial :: Int -> Int\nfactorial 0 = 1\nfactorial n = n * factorial (n - 1)\n\n-- 3.2 \u30bf\u30d7\u30eb\u306e\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\n\naddVectors :: (Double, Double) -> (Double, Double) -> (Double, Double)\naddVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)\n\nfirst :: (a, b, c) -> a\nfirst (x, _, _) = x\n\nsecond :: (a, b, c) -> b\nsecond (_, y, _) = y\n\nthird :: (a, b, c) -> c\nthird (_, _, z) = z\n\nhead' :: [a] -> a\nhead' [] = error \"Can't call head on an empty list, dummy!\"\nhead' (x:_) = x\n\ntell :: (Show a) => [a] -> String\ntell [] = \"The list is empty\"\ntell (x:[]) = \"The list has one element: \" ++ show x\ntell (x:y:[]) = \"The list has Two elements: \" ++ show x ++ \" and \" ++ show y\ntell (x:y:_) = \"The list is long. The first two elements are: \" ++ show x ++ \" and \" ++ show y\n\nbadAdd :: (Num a) => [a] -> a\nbadAdd (x:y:z:[]) = x + y + z\n\nfirstLetter :: String -> String\nfirstLetter \"\" = \"Empty string, whoops!\"\nfirstLetter all@(x:xs) = \"The first letter of \" ++ all ++ \" is \" ++ [x]\n\n-- 3.3 \u5834\u5408\u5206\u3051\u3057\u3066\u3001\u304d\u3063\u3061\u308a\u30ac\u30fc\u30c9!\n\nbmiTell :: Double -> String\nbmiTell bmi\n    | bmi <= 18.5 = \"You're underweight, you emo, you!\"\n    | bmi <= 25.0 = \"You're supposedly normal. Pffft, I bet you're ugly!\"\n    | bmi <= 30.0 = \"You're fat! Lose some weight, fatty!\"\n    | otherwise   = \"You're whale, congratulations!\"\n\nbmiTell' :: Double -> Double -> String\nbmiTell' weight height\n    | weight / height ^ 2 <= 18.5 = \"You're underweight, you emo, you!\"\n    | weight / height ^ 2 <= 25.0 = \"You're supposedly normal. Pffft, I bet you're ugly!\"\n    | weight / height ^ 2 <= 30.0 = \"You're fat! Lose some weight, fatty!\"\n    | otherwise                   = \"You're whale, congratulations!\"\n\nmax' :: (Ord a) => a -> a -> a\nmax' a b\n    | a <= b    = b\n    | otherwise = a\n\nmyCompare :: (Ord a) => a -> a -> Ordering\na `myCompare` b\n    | a == b    = EQ\n    | a <= b    = LT\n    | otherwise = GT\n\n-- 3.3 where?!\n\nbmiTell'' :: Double -> Double -> String\nbmiTell'' weight height\n    | bmi <= 18.5 = \"You're underweight, you emo, you!\"\n    | bmi <= 25.0 = \"You're supposedly normal. Pffft, I bet you're ugly!\"\n    | bmi <= 30.0 = \"You're fat! Lose some weight, fatty!\"\n    | otherwise   = \"You're whale, congratulations!\"\n    where bmi = weight / height ^ 2\n\nbmiTell''' :: Double -> Double -> String\nbmiTell''' weight height\n    | bmi <= skinny = \"You're underweight, you emo, you!\"\n    | bmi <= normal = \"You're supposedly normal. Pffft, I bet you're ugly!\"\n    | bmi <= fat    = \"You're fat! Lose some weight, fatty!\"\n    | otherwise     = \"You're whale, congratulations!\"\n    where bmi = weight / height ^ 2\n          skinny = 18.5\n          normal = 25.0\n          fat = 30.0\n\nbadGreeting :: String\nbadGreeting = \"Oh! Pfft. It's you.\"\nniceGreeting :: String\nniceGreeting = \"Hello! So very nice to see you,\"\n\ngreet :: String -> String\ngreet \"Juan\" = niceGreeting ++ \" Juan!\"\ngreet \"Fernando\" = niceGreeting ++ \" Fernando\"\ngreet name = badGreeting ++ \" \" ++ name\n\ninitials :: String -> String -> String\ninitials firstname lastname = [f] ++ \". \" ++ [l] ++ \".\"\n    where (f:_) = firstname\n          (l:_) = lastname\n\ncalcBmis :: [(Double, Double)] -> [Double]\ncalcBmis xs = [bmi w h | (w, h) <- xs]\n    where bmi weight height = weight / height ^ 2\n\n-- 3.4 let It Be\n\ncylinder :: Double -> Double -> Double\ncylinder r h =\n    let sideArea = 2 * pi * r * h\n        topArea = pi * r ^ 2\n    in  sideArea + 2 * topArea\n\ncalcBmis' :: [(Double, Double)] -> [Double]\ncalcBmis' xs = [bmi | (w, h) <- xs, let bmi = w / h ^ 2]\n\n-- 3.5 case\u5f0f\n\nhead'' :: [a] -> a\nhead'' xs = case xs of [] -> error \"No head for empty lists!\"\n                       (x:_) -> x\n\ndescribeList :: [a] -> String\ndescribeList ls = \"The list is \"\n                  ++ case ls of [] -> \"empty.\"\n                                [x] -> \"a singleton list.\"\n                                xs -> \"a longer list.\"\n\ndescribeList' :: [a] -> String\ndescribeList' ls = \"The list is\" ++ what ls\n    where what []  = \"empty.\"\n          what [x] = \"a singleton list.\"\n          what xs  = \"a longer list.\"\n", "input": "42", "status": "success", "output": "\"Sorry, you're out of luck, pal!\""}
{"code": "lucky :: Int -> String\nlucky 7 = \"LUCKY NUMBER SEVEN!\"\nlucky x = \"Sorry, you're out of luck, pal!\"\n\nsayMe :: Int -> String\nsayMe 1 = \"One!\"\nsayMe 2 = \"Two!\"\nsayMe 3 = \"Three!\"\nsayMe 4 = \"Four!\"\nsayMe 5 = \"Five!\"\nsayMe x = \"Not between 1 and 5\"\n\nfactrial :: Int -> Int\nfactrial 0 = 1\nfactrial n = n * factrial (n - 1)\n\naddVectors :: (Double, Double) -> (Double, Double) -> (Double, Double)\naddVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)\n\nfirst :: (a, b, c) -> a\nfirst (x, _, _) = x\n\nsecond :: (a, b, c) -> b\nsecond (_, y, _) = y\n\nthird :: (a, b, c) -> c\nthird (_, _, z) = z\n\nxs = [(1, 3), (4, 3), (2, 4)]\n{- [a + b | (a, b) <- xs] -}\n\n{- head' :: [a] -> a -}\n{- head' []    = error \"Can't call head on an empty list.\" -}\n{- head' (x:_) = x -}\n\nhead' :: [a] -> a\nhead' xs = case xs of []    -> error \"Can't call head on an empty list.\"\n                      (x:_) -> x\n\ntell :: (Show a) => [a] -> String\ntell []       = \"The list is empty\"\ntell (x:[])   = \"The list is one element: \"  ++ show x\ntell (x:y:[]) = \"The list is two elements: \" ++ show x ++ \" and \" ++ show y\ntell (x:y:_)  = \"This list is long. The first two elements are: \" ++ show x ++ \" and \" ++ show y\n\nfirstLetter :: String -> String\nfirstLetter \"\" = \"Empty string, whoops!\"\nfirstLetter all@(x:xs) = \"The first letter of \" ++ all ++ \" is \" ++ [x]\n\nbmiTell :: Double -> Double -> String\nbmiTell weight height\n  | weight / height ^ 2 <= 18.5 = \"You're underweight!\"\n  | weight / height ^ 2 <= 25.0 = \"You're supposedly normal.\"\n  | weight / height ^ 2 <= 30.0 = \"You're overweight!\"\n  | otherwise                   = \"You're a whale, congratulations!\"\n\n{- bmiTell' :: Double -> Double -> String -}\n{- bmiTell' weight height -}\n  {- | bmi <= 18.5 = \"You're underweight!\" -}\n  {- | bmi <= 25.0 = \"You're supposedly normal.\" -}\n  {- | bmi <= 30.0 = \"You're overweight!\" -}\n  {- | otherwise   = \"You're a whale, congratulations!\" -}\n  {- where bmi = weight / height ^ 2 -}\n\n{- bmiTell' :: Double -> Double -> String -}\n{- bmiTell' weight height -}\n  {- | bmi <= underweight = \"You're underweight!\" -}\n  {- | bmi <= normal      = \"You're supposedly normal.\" -}\n  {- | bmi <= overweight  = \"You're overweight!\" -}\n  {- | otherwise          = \"You're a whale, congratulations!\" -}\n  {- where bmi         = weight / height ^ 2 -}\n        {- underweight = 18.5 -}\n        {- normal      = 25.0 -}\n        {- overweight  = 30.0 -}\n\nbmiTell' :: Double -> Double -> String\nbmiTell' weight height\n  | bmi <= underweight = \"You're underweight!\"\n  | bmi <= normal      = \"You're supposedly normal.\"\n  | bmi <= overweight  = \"You're overweight!\"\n  | otherwise          = \"You're a whale, congratulations!\"\n  where bmi         = weight / height ^ 2\n        (underweight, normal, overweight) = (18.5, 25.0, 30.0)\n\nmax' :: (Ord a) => a -> a -> a\nmax' a b\n  | a <= b     = b\n  | otherwise  = a\n\nmyCompare :: (Ord a) => a -> a -> Ordering\na `myCompare` b\n  | a == b    = EQ\n  | a <= b    = LT\n  | otherwise = GT\n\nbadGreeting :: String\nbadGreeting = \"Who are you?\"\n\nniceGreeting :: String\nniceGreeting = \"Hello!\"\n\ngreet :: String -> String\ngreet \"Juan\"     = niceGreeting ++ \" Juan!\"\ngreet \"Fernando\" = niceGreeting ++ \" Fernando!\"\ngreet name       = badGreeting  ++ \" \" ++ name\n\ninitials :: String -> String -> String\ninitials firstname lastname = [f] ++ \". \" ++ [l] ++ \".\"\n  where (f:_) = firstname\n        (l:_) = lastname\n\ncalcBmis :: [(Double, Double)] -> [Double]\ncalcBmis xs = [bmi w h | (w, h) <- xs]\n  where bmi weight height = weight / height ^ 2\n\n{- calcBmis' :: [(Double, Double)] -> [Double] -}\n{- calcBmis' xs = [bmi | (w, h) <- xs, let bmi = w / h ^ 2] -}\n\ncalcBmis' :: [(Double, Double)] -> [Double]\ncalcBmis' xs = [bmi | (w, h) <- xs, let bmi = w / h ^ 2, bmi > 25.0]\n\ncylinder :: Double -> Double -> Double\ncylinder r h =\n  let sideArea = 2 * pi * r * h\n      topArea  = pi * r ^ 2\n  in sideArea * topArea\n\n{- 4 * (let a = 9 in a + 1) + 2 -}\n{- 42 -}\n\n{- [let square x = x * x in (square 5, square 3, square 2)] -}\n{- [(25,9,4)] -}\n\n{- (let a = 100; b = 200; c = 300 in a * b * c, -}\n {- let foo = \"Hey \"; bar = \"there!\" in foo ++ bar) -}\n{- (6000000,\"Hey there!\") -}\n\n{- (let (a, b, c) = (1, 2, 3) in a + b + c) * 100 -}\n{- 600 -}\n\ndescribeList :: [a] -> String\ndescribeList ls = \"The list is \"\n                  ++ case ls of []  -> \"empty.\"\n                                [x] -> \"a singleton list.\"\n                                xs  -> \"a longer list.\"\n\ndescribeList' :: [a] -> String\ndescribeList' ls = \"The list is \" ++ what ls\n  where what []  = \"empty.\"\n        what [x] = \"a singleton list.\"\n        what xs  = \"a longer list.\"\n", "input": "42", "status": "success", "output": "\"Sorry, you're out of luck, pal!\""}
{"code": "-- Exercise in functional programming in the course D7012E by H\u00e5kan Jonsson\n\nimport Data.Char\n\ndata EXPR = Const Int\n     | Var String\n     | Op String EXPR EXPR\n     | App String EXPR deriving (Eq, Ord, Show)\n\nparse :: String -> EXPR\nparse = fst . buildexpr\n  where\n    notfirst p (_,[]) = True\n    notfirst p (_,x:xs) = not (p x)\n    \n    buildnumber :: String -> (EXPR,String)\n    buildnumber xs = until (notfirst isDigit) accdigits (Const 0, xs)\n      where\n        accdigits :: (EXPR,String) -> (EXPR,String)\n        accdigits (Const n, y:ys) = (Const(10*n+(ord y - 48)), ys)\n    \n    buildvar :: String -> (EXPR,String)\n    buildvar xs = until (notfirst isLetter) accletters (Var \"\", xs)\n      where\n        accletters :: (EXPR,String) -> (EXPR,String)\n        accletters (Var s, y:ys) = (Var (s ++[y]), ys)\n    \n    \n    buildexpr :: String -> (EXPR,String)\n    buildexpr xs = until (notfirst (\\c -> c=='-' || c=='+')) accterms (buildterm xs)\n      where\n        accterms :: (EXPR,String) -> (EXPR,String)\n        accterms (term, y:ys) = (Op (y:[]) term term1, zs)\n          where\n            (term1,zs) = buildterm ys\n    \n    buildterm :: String -> (EXPR,String)\n    buildterm xs = until (notfirst (\\c -> c=='*' || c=='/')) accfactors (buildfactor xs)\n      where\n        accfactors :: (EXPR,String) -> (EXPR,String)  \n        accfactors (fact, y:ys) = (Op (y:[]) fact fact1, zs)\n          where\n            (fact1,zs) = buildfactor ys\n    \n    buildfactor :: String -> (EXPR,String)\n    buildfactor [] = error \"missing factor\"\n    buildfactor ('(':xs) =  case buildexpr xs of (e, ')':ws) -> (e, ws); _ -> error \"missing factor\"\n    buildfactor (x:xs)\n      | isDigit x = buildnumber (x:xs)\n      | isLetter x = case buildvar (x:xs) of\n                       (Var s, '(':zs) -> let (e,ws)=buildfactor ('(':zs) in (App s e,ws)\n                       p -> p\n      | otherwise = error \"illegal symbol\"\n\nunparse :: EXPR -> String\nunparse (Const n) = show n\nunparse (Var s) = s\nunparse (Op oper e1 e2) = \"(\" ++ unparse e1 ++ oper ++ unparse e2 ++ \")\"\nunparse (App func arg) = func ++ '(' : (unparse arg) ++ \")\"\n\neval :: EXPR -> [(String,Float)] -> Float\neval (Const n) _ = fromIntegral n\neval (Var x) env = case lookup x env of Just y -> y ; _ -> error (x ++ \" undefined\")\neval (Op \"+\" left right) env = eval left env + eval right env\neval (Op \"-\" left right) env = eval left env - eval right env\neval (Op \"*\" left right) env = eval left env * eval right env\neval (Op \"/\" left right) env = eval left env / eval right env\neval (App \"sin\" arg) env = sin (eval arg env)\neval (App \"cos\" arg) env = cos (eval arg env)\neval (App \"exp\" arg) env = exp (eval arg env)\neval (App \"log\" arg) env = log (eval arg env)\n\ndiff :: EXPR -> EXPR -> EXPR\ndiff _ (Const _) = Const 0\ndiff (Var id) (Var id2)\n  | id == id2 = Const 1\n  | otherwise = Const 0\ndiff v (Op \"+\" e1 e2) = Op \"+\" (diff v e1) (diff v e2)\ndiff v (Op \"-\" e1 e2) = Op \"-\" (diff v e1) (diff v e2)\ndiff v (Op \"*\" e1 e2) =\n  Op \"+\" (Op \"*\" (diff v e1) e2) (Op \"*\" e1 (diff v e2))\ndiff v (Op \"/\" e1 e2) =\n  Op \"/\" (Op \"-\" (Op \"*\" (diff v e1) e1) (Op \"*\" e1 (diff v e2))) (Op \"*\" e2 e2)\ndiff v (App \"sin\" arg) = Op \"*\" (diff v arg) (App \"cos\" arg)\ndiff v (App \"cos\" arg) = Op \"*\" (diff v arg) (Op \"-\" (Const 0) (App \"sin\" arg))\ndiff v (App \"exp\" arg) = Op \"*\" (diff v arg) (App \"exp\" arg)\ndiff v (App \"log\" arg) = Op \"/\" (diff v arg) arg\ndiff _ _ = error \"can not compute the derivative\"\n\nsimplify :: EXPR -> EXPR\nsimplify (Const n) = Const n\nsimplify (Var id) = Var id\nsimplify (App func arg) = App func (simplify arg)\nsimplify (Op oper left right) =\n  let (lefts,rights) = (simplify left, simplify right) in\n    case (oper, lefts, rights) of\n      (\"+\",e,Const 0) -> e\n      (\"+\",Const 0,e) -> e\n      (\"*\",e,Const 0) -> Const 0\n      (\"*\",Const 0,e) -> Const 0\n      (\"*\",e,Const 1) -> e\n      (\"*\",Const 1,e) -> e\n      (\"-\",e,Const 0) -> e\n      (\"/\",e,Const 1) -> e\n      (\"-\",le,re)     -> if left==right then Const 0 else Op \"-\" le re\n      (op,le,re)      -> Op op le re\n\nmkfun :: (EXPR, EXPR) -> (Float -> Float)\nmkfun (body, var) = fun body var\n  where\n    fun body (Var v) = (eval body . mkenv v)\n      where\n        mkenv :: String -> Float -> [(String, Float)]\n        mkenv s f = [(s, f)]\n\ntozero :: (Float -> Float) -> (Float -> Float) -> Float -> Float\ntozero f fp x0 =\n    if abs (x0 - x1) <= 0.0001 then x0 else tozero f fp x1\n      where\n        x1 = x0 - (f x0)/(fp x0)\n\nfindzero :: String -> String -> Float -> Float\nfindzero var body =\n  let (v, b) = (parse var, parse body) in\n    let (f, fp) = (mkfun (b, v), mkfun (diff v b, v)) in\n      tozero f fp\n\n", "input": "\"hello\"", "status": "success", "output": "Var \"hello\""}
{"code": "{-\r\n    This module contains implementation for the Knights Problem\r\n    that determines where knights can be validly put onto a chess\r\n    board safe from queens and without being able to capture queens\r\n    on the next turn.\r\n-}\r\n\r\nimport Data.Tuple\r\nimport Data.List\r\n\r\ntype Coordinate = (Int,Int)\r\n\r\n-- The main function determines valid locations for knights on a chess board.\r\nplaceOfKnight :: [Int] -> [[Int]]\r\nplaceOfKnight board = result\r\n    where\r\n    -- output to user (top-level)\r\n    result = final outputList outputList 1\r\n    -- make output list\r\n    outputList = makeOutputLists diagonalBoard emptyList\r\n    -- remove all coordinates diagonally\r\n    diagonalBoard = removeDiagonals queenCoords (\r\n        removeColumns queenCoords ( removeRows queenCoords (\r\n            removeKnightPositions queenCoords ( removeRedundantQueenPos\r\n                queenCoords genBoard ))))\r\n    \r\n    -- generate queen positions\r\n    queenCoords = generateQueenCoords board\r\n    genBoard = generateAllPos (length board)\r\n    emptyList = makeEmptyLists [] (length board)\r\n\r\ncheckLen :: [Int] -> Bool\r\ncheckLen x = (length x) == 0 \r\n\r\n-- Convert list back into original format\r\nmakeOutputLists :: [Coordinate] -> [[Int]] -> [[Int]]\r\nmakeOutputLists (coord:queens) output =\r\n    makeOutputLists queens\r\n    (changeElement output (fst coord) (snd coord))\r\nmakeOutputLists [] output = output\r\n\r\ndecision :: [Int] -> Int -> [[Int]] -> [[Int]]\r\ndecision element ndx output\r\n    | checkLen element = changeElement output ndx 0\r\n    | otherwise = output\r\n\r\nfinal :: [[Int]] -> [[Int]] -> Int -> [[Int]]\r\nfinal (x:xs) output ndx = final xs (decision x ndx output) (ndx+1)\r\nfinal [] output ndx = output \r\n\r\nchangeElement :: [[Int]] -> Int -> Int -> [[Int]]\r\nchangeElement list ndx newElement =\r\n    (take (ndx-1) list) ++\r\n    [ ( list!!(ndx-1) ) ++ [newElement] ] ++\r\n    drop (ndx) list\r\n\r\nmakeEmptyLists :: [[Int]] -> Int -> [[Int]]\r\nmakeEmptyLists list 0 = list\r\nmakeEmptyLists list len = makeEmptyLists([]:list) (len-1) \r\n\r\nremoveDiagonals :: [Coordinate] -> [Coordinate] -> [Coordinate]\r\nremoveDiagonals (queen:queens) board =\r\n    removeDiagonals queens ( r_Diagonals queen board )\r\nremoveDiagonals [] board = board\r\n\r\n-- Remove all coordinates that are diagonal to the input coordinates\r\nr_Diagonals :: Coordinate -> [Coordinate] -> [Coordinate]\r\nr_Diagonals (a,b) board = \r\n    [x | x <- board, not( abs (a - fst x) == abs ( b - snd x ) ) ]\r\n\r\n-- Remove all coordinates that share same row\r\nremoveRows :: [Coordinate] -> [Coordinate] -> [Coordinate]\r\nremoveRows (queen:queens) board =\r\n    removeRows queens ( r_Rows (snd queen) board )\r\nremoveRows [] board = board\r\n\r\n-- Remove all coordinates that share same row\r\nr_Rows :: Int -> [Coordinate] -> [Coordinate]\r\nr_Rows row board = [c | c <- board, not( snd c == row ) ]\r\n\r\n-- Remove all coordinates that share same column\r\nremoveColumns :: [Coordinate] -> [Coordinate] -> [Coordinate]\r\nremoveColumns (queen:queens) board =\r\n    removeColumns queens ( r_Cols (fst queen) board )\r\nremoveColumns [] board = board\r\n\r\n-- Helper function for removeColumns\r\nr_Cols :: Int -> [Coordinate] -> [Coordinate]\r\nr_Cols col board = [c | c <- board, not( fst c == col ) ]\r\n\r\nremoveTuplesFromList :: [Coordinate] -> [Coordinate] -> [Coordinate]\r\nremoveTuplesFromList (coord:xs) board =\r\n    removeTuplesFromList xs (removeFromList coord board) \r\nremoveTuplesFromList [] board = board\r\n\r\n-- Remove a tuple from a list of tuples (if in list)\r\nremoveFromList :: Coordinate -> [Coordinate] -> [Coordinate]\r\nremoveFromList (a,b) list = \r\n    [ x | x <- list, not ( (fst x == a) && (snd x == b) )]\r\n\r\nremoveKnightPositions :: [Coordinate] -> [Coordinate] -> [Coordinate]\r\nremoveKnightPositions (queen:queens) board =\r\n    removeKnightPositions queens (removeTuplesFromList (generateKnights queen) board)\r\nremoveKnightPositions [] board = board\r\n\r\n-- Generates a list of knights from the current coordinate\r\ngenerateKnights :: Coordinate -> [Coordinate]\r\ngenerateKnights (x,y) = pos\r\n    where\r\n        pos = [ (x-2,y-1),(x-2,y+1), (x-1,y-2),(x-1,y+2),\r\n               (x+1,y-2),(x+1,y+2), (x+2,y-1),(x+2,y+1) ]\r\n    \r\n-- Remove queen positions from list of all possible coordinates on board\r\nremoveRedundantQueenPos :: [Coordinate] -> [Coordinate] -> [Coordinate]\r\nremoveRedundantQueenPos coords board = removeTuplesFromList coords board\r\n\r\ngenerateQueenCoords :: [Int] -> [Coordinate]\r\ngenerateQueenCoords list =\r\n    filterQueenCoords ( map swap( zip list [1..] ) )\r\n\r\nfilterQueenCoords :: [Coordinate] -> [Coordinate]\r\nfilterQueenCoords coords = \r\n    [x | x <- coords, not( (snd x) == 0 ) ]\r\n\r\ngenerateAllPos :: Int -> [Coordinate]\r\ngenerateAllPos len = [ (x,y) | x <- [1..len] :: [Int], y <- [1..len] :: [Int] ]", "input": "[42, 42]", "status": "success", "output": "[[0],[0]]"}
{"code": "import Data.Char\n\n\n-- Excercise 1\n\nex1 x = 2*x^2 + 3*x - 5\n\n\n-- Exercise 2\nabc = \"abcdefghijklmnopqrstuvwxyz\"\n\ncode :: Char -> Char\ncode x          | ord(x) > 96 && ord(x) < 123   = chr(97 + mod (ord(x)-97+3) 26)\n                | ord(x) > 64 && ord(x) < 91    = chr(65 + mod (ord(x)-62+3) 26)\n                | otherwise                     = x\n\ncode' x = coden2 3 x\n\ncoden :: Int -> Char -> Char\ncoden n x       | ord(x) > 96 && ord(x) < 123   = chr(97 + mod (ord(x)-97+n) 26)\n                | ord(x) > 64 && ord(x) < 91    = chr(65 + mod (ord(x)-65+n) 26)\n                | otherwise                     = x\n\n-- Variant met 25 letters!\n-- Omdat het.. Omdat het prachtig is! - Wiebes, 2017\ncoden2 :: Int -> Char -> Char\ncoden2 n x      | ord(x) > 96 && ord(x) < 122   = chr(97 + mod (ord(x)-97+n) 25)\n                | ord(x) > 64 && ord(x) < 90    = chr(65 + mod (ord(x)-65+n) 25)\n                | otherwise                     = x\n\ncodestr :: [Char]\ncodestr = map code \"hello\"\n\ncodestr2 :: [Char]\ncodestr2 = map code \"Tomorrow evening, 8 o\\'clock in Amsterdam\"\n\n\n--Exercise 3\ninterest :: Floating a => a -> a -> a -> a\ninterest a r n        = (a*(1+r)**n)\n\namount :: (Floating a, Eq a) => a -> a -> a -> a\namount a r 0    = a\namount a r n    = amount (a*(1+r)) r (n-1)\n\n\n-- Exercise 4\n-- Nice test function, not part of the exercise. Can be extended to catch the errors of complex roots.\nroots :: Double -> Double -> Double -> (Double, Double)\nroots a b c = (root1 a b c, root2 a b c)\n\nroot1 ::  Double -> Double -> Double -> Double\nroot1 a b c     | disc a b c < 0        = error \"negative discriminant\"\n                | otherwise             = (-b + sqrt(disc a b c)) / (2*a)\n\nroot2 ::  Double -> Double -> Double -> Double\nroot2 a b c     | disc a b c < 0        = error \"negative discriminant\"\n                | otherwise             = (-b - sqrt(disc a b c)) / (2*a)\n\ndisc ::  Double -> Double -> Double -> Double\ndisc a b c      = (b*b)-4*a*c\n\n\n-- Exercise 5\nextrX :: Double -> Double -> Double -> Double\nextrX a b c = -b/(2*a)\n\nextrY :: Double -> Double -> Double -> Double\nextrY a b c = a*(exX)^2 + b*(exX) + c\n    where exX = extrX a b c\n\n\n-- Exercise 6\nmylength :: [a] -> Int\nmylength []     = 0\nmylength (x:xs) = 1 + mylength xs\n\nmysum :: [Int] -> Int\nmysum []        = 0\nmysum (x:xs)    = x + mysum xs\n\nmyreverse :: [a] -> [a]\nmyreverse []            = []\nmyreverse (x:xs)        = myreverse xs ++ [x]\n\nmytake :: Int -> [a] -> [a]\nmytake _ []     = []\nmytake 0 xs     = []\nmytake n (x:xs) = [x] ++ mytake (n-1) xs\n\nmyelem :: Eq a => a -> [a] -> Bool\nmyelem _ []     = False\nmyelem a (x:xs) | x == a        = True\n                | otherwise     = myelem a xs\n\nmyconcat :: [[a]] -> [a]\nmyconcat []     = []\nmyconcat (x:xs) = x ++ myconcat xs\n\nmymaximum :: [Int] -> Int\nmymaximum []            = error \"cannot determine maximum of empty list\"\nmymaximum [x]           = x\nmymaximum (x:xs)        | x <= mymaximum(xs)    = mymaximum(xs)\n                        | otherwise             = x\n\nmyzip :: [a] -> [b] -> [(a, b)]\nmyzip (x:xs) []         = []\nmyzip [] (y:ys)         = []\nmyzip (x:xs) (y:ys)     = (x,y) : myzip xs ys\n\n\n-- Exercise 7\nr :: Num a => a -> a -> [a]\nr a d   = a : r (a+d) d\n\nr1 :: Num a => a -> a -> Int -> a\nr1 a d 0        = a\nr1 a d n        = (r a d)!!n\n\n--total1 is better\ntotal :: (Eq a, Num a) => Int -> Int -> a -> Int -> Int\ntotal a d i 0   = 0\ntotal a d 0 j   = mysum (mytake j (r a d))\ntotal a d i j   = total (a+d) d (i-1) (j-1)\n\ntotal1 :: (Num a) => a -> a -> Int -> Int -> a\ntotal1 a d i j  | i == j        = (r1 a d j)\n                | i > j         = error \"i must be smaller than j\"\n                | otherwise     = (r1 a d i) + total1 a d (i+1) j\n\n\n-- Exercise 8\nallEqual :: Eq a => [a] -> Bool\nallEqual []     = True\nallEqual [x]    = True\nallEqual (x:xs) | x == head xs  = allEqual xs\n                | otherwise     = False\n\nisAS :: (Num a, Eq a) => [a] -> Bool\nisAS xss@(x1:x2:xs) = allEqual $ zipWith (-) (r x1 (x2-x1)) xss\n\nisAS' []    = True\nisAS' [_]   = True\nisAS' [_,_] = True\nisAS' xss@(x1:x2:x3:xs) | x2-x1 == x3-x2    = isAS' (x2:x3:xs)\n                        | otherwise         = False\n\n\n-- Exercise 9\nisMatrix :: [[a]] -> Bool\nisMatrix a = allEqual(map mylength a)\n\nrowTotals :: [[Int]] -> [Int]\nrowTotals a = map mysum a\n\ntransposeMatrix :: (Eq a) => [[a]] -> [[a]]\ntransposeMatrix a       | head a == []   = []\n                        | otherwise      = map head a : transposeMatrix (map tail a)\n\ncolumnTotals :: [[Int]] -> [Int]\ncolumnTotals a          | mylength (head a) == 0        = []\n                        | otherwise                     = mysum(map head a) : columnTotals (map tail a)\n\ncolumnTotals' :: [[Int]] -> [Int]\ncolumnTotals' = rowTotals . transposeMatrix\n", "input": "'a'", "status": "success", "output": "'d'"}
{"code": "-- Examples from Learn you a Haskell\nimport qualified Data.Map as Map\nimport Control.Exception\n\n\nfactorial :: Integer -> Integer\nfactorial n = product [1..n]\n\n\ncollatz :: (Integral a) => a -> [a]\ncollatz 1 = [1]\ncollatz n\n    | even n =  n:collatz (n `div` 2)\n    | odd n  =  n:collatz (n*3 + 1)\n\n\n-- example function with guarded conditions\nbmiTell :: (RealFloat a) => a -> a -> String\nbmiTell weight height\n    | bmi <= 18.5 = \"You're underweight, you emo, you!\"\n    | bmi <= 25.0 = \"You're supposedly normal. Pffft, I bet you're ugly!\"\n    | bmi <= 30.0 = \"You're fat! Lose some weight, fatty!\"\n    | otherwise   = \"You're a whale, congratulations!\"\n    where bmi = weight / height ^ 2\n\n\ndescribeList :: [a] -> String\ndescribeList xs = \"list length = \" ++ case xs of\n                        [] -> show 0\n                        [x] -> show 1\n                        xs -> \"more\"\n\n\ntake' :: (Num i, Ord i) => i -> [a] -> [a]\ntake' n _\n    | n <= 0   = []\ntake' _ []     = []\ntake' n (x:xs) = x : take' (n-1) xs\n\n\nreverse' :: [a] -> [a]\nreverse' [] = []\nreverse' (x:xs) = reverse' xs ++ [x]\n\n\napplyTwice :: (a -> a) -> a -> a\napplyTwice f x = f (f x)\n\n\nzipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]\nzipWith' _ [] _ = []\nzipWith' _ _ [] = []\nzipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys\n\n\n-- Check if something is in a list\nelem' :: (Eq a) => a -> [a] -> Bool\nelem' y ys = foldl (\\acc x -> if x == y then True else acc) False ys\n\n\n\n-- understand left and right fold operations\nletters = \"abcdefghijklmnopqrstuvwxyz\"\n\nbackwards_alpha = foldl (flip(:)) [] letters\nforwards_alpha  = foldr (:) [] letters\n\nreverse'' :: [a] -> [a]\nreverse'' = foldl (flip(:)) []\n\n\n-- haskell polymorphism\ndata Point = Point Float Float deriving (Show)\ndata Shape = Circle Point Float | Rectangle Point Point deriving (Show)\n\n-- make a circle, having a point and a radius, from three floats\nmakeCircle :: Float -> Float -> Float -> Shape\nmakeCircle x y r\n    | r < 0 = error \"negative radius\"\n    | otherwise = Circle (Point x y) r\n\nsurface :: Shape -> Float\nsurface (Circle _ r) = pi * r ^ 2\nsurface (Rectangle (Point x1 y1) (Point x2 y2)) = (abs $ x2 - x1) * (abs $ y2 - y1)\n\nconcentric_circles = map (Circle (Point 10 20)) [4,5,6,7]\n\nnudge :: Shape -> Float -> Float -> Shape\nnudge (Circle (Point x y) r) a b = Circle (Point (x+a) (y+b)) r\nnudge (Rectangle (Point x1 y1) (Point x2 y2)) a b = Rectangle (Point (x1+a) (y1+b)) (Point (x2+a) (y2+b))\n\n\n-- records\ndata Car = Car {\n    make :: String,\n    model :: String,\n    year :: Int\n} deriving (Show)\n\n\n-- making a vector type\ndata Vector a = Vector a a a deriving (Show)\n\nvplus :: (Num t) => Vector t -> Vector t -> Vector t\n(Vector i j k) `vplus` (Vector l m n) = Vector (i+l) (j+m) (k+n)\n\nvectMult :: (Num t) => Vector t -> t -> Vector t\n(Vector i j k) `vectMult` m = Vector (i*m) (j*m) (k*m)\n\n-- dot product\nscalarMult :: (Num t) => Vector t -> Vector t -> t\n(Vector i j k) `scalarMult` (Vector l m n) = i*l + j*m + k*n\n\n\n-- days of the week\ndata Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday\n           deriving (Eq, Ord, Show, Read, Bounded, Enum)\n\ntestDay =\n    assert (Tuesday `elem` [Monday .. Friday]) \"tuesday is a weekday\"\n\n\n-- locker assignment\n\ndata LockerState = Taken | Free deriving (Show, Eq)\ntype Code = String\ntype LockerMap = Map.Map Int (LockerState, Code)\n\nlockerLookup :: Int -> LockerMap -> Either String Code\nlockerLookup lockerNumber map =\n    case Map.lookup lockerNumber map of\n        Nothing -> Left $ \"Locker number \" ++ show lockerNumber ++ \" doesn't exist!\"\n        Just (state, code) -> if state /= Taken\n            then Right code\n            else Left $ \"Locker \" ++ show lockerNumber ++ \" is already taken!\"\n\nlockers :: LockerMap\nlockers = Map.fromList\n    [(100,(Taken,\"ZD39I\"))\n    ,(101,(Free,\"JAH3I\"))\n    ,(103,(Free,\"IQSA9\"))\n    ,(105,(Free,\"QOTSA\"))\n    ,(109,(Taken,\"893JJ\"))\n    ,(110,(Taken,\"99292\"))]\n\n\n-- typeclasses\n\ndata TrafficLight = Red | Yellow | Green\n\ninstance Eq TrafficLight where\n    Red == Red = True\n    Green == Green = True\n    Yellow == Yellow = True\n    _ == _ = False\n\ninstance Show TrafficLight where\n    show Red = \"Red light\"\n    show Yellow = \"Yellow light\"\n    show Green = \"Green light\"\n\n\n-- truthiness\n\nclass YesNo a where\n    yesno :: a -> Bool\n\ninstance YesNo Int where\n    yesno 0 = False\n    yesno _ = True\n\ninstance YesNo [a] where\n    yesno [] = False\n    yesno _ = True\n\ninstance YesNo Bool where\n    yesno = id\n\ninstance YesNo (Maybe a) where\n    yesno (Just _) = True\n    yesno Nothing = False\n\nyesnoIf :: (YesNo y) => y -> a -> a -> a\nyesnoIf yesnoVal yesResult noResult = if yesno yesnoVal then yesResult else noResult\n\n\n\nclass Tofu t where\n    tofu :: j a -> t a j\n\ndata Frank a b  = Frank {frankField :: b a} deriving (Show)\n\ninstance Tofu Frank where\n    tofu x = Frank x\n", "input": "42", "status": "success", "output": "1405006117752879898543142606244511569936384000000000"}
{"code": "-- Warm-up and review\n\n-- For the following set of exercises, you are not expected to use folds. These\n-- are intended to review material from previous chapters. Feel free to use any\n-- syntax or structure from previous chapters that seems appropriate.\n\n-- 1. Given the following sets of consonants and vowels:\nstops  = \"pbtdkg\"\nvowels = \"aeiou\"\n\n-- a) Write a function that takes inputs from stops and vowels and makes\n-- 3-tuples of all possible stop-vowel-stop combinations. These will not all\n-- correspond to real words in English, although the stop-vowel-stop pattern is\n-- common enough that many of them will.\ncombos = [(a,b,c)\n         | a <- stops,\n           b <- vowels,\n           c <- stops]\n\n-- b) Modify that function so that it only returns the combinations that begin\n-- with a p.\ncombos2 = [(a,b,c)\n          | a <- stops,\n            b <- vowels,\n            c <- stops,\n            a == 'p']\n\n-- c) Now set up lists of nouns and verbs (instead of stops and vowels) and\n-- modify the function to make tuples representing possible noun-verb-noun\n-- sentences.\ncombos3 = [(a,b,c)\n          | a <- nouns,\n            b <- verbs,\n            c <- nouns]\n  where nouns = [\"person\", \"place\", \"puppy\"]\n        verbs = [\"run\", \"sleep\", \"punch\"]\n\n-- 2. What does the following mystery function do? What is its type? Try to get\n-- a good sense of what it does before you test it in the REPL to verify it.\nseekritFunc x = div (sum (map length (words x))) (length (words x))\n\n-- this gives a crappy average of the length of each word that throws away the\n-- remainer.\n\n-- 3. We\u2019d really like the answer to be more precise. Can you rewrite that using\n-- fractional division?\nseekritFuncDouble x = (/) (fromIntegral (sum (map length (words x)))) (fromIntegral (length (words x)))\n\n-- Rewriting functions using folds\n\n-- In the previous chapter, you wrote these functions using direct recur- sion\n-- over lists. The goal now is to rewrite them using folds. Where possible, to\n-- gain a deeper understanding of folding, try rewriting the fold version so\n-- that it is point-free.\n\n-- The goal here is to converge on the final version where possible. You don\u2019t\n-- need to write all variations for each example, but the more variations you\n-- write, the deeper your understanding of these functions will become.\n\n-- 1. myOr returns True if any Bool in the list is True.\nmyOr :: [Bool] -> Bool\nmyOr [] = False\nmyOr (x:xs) = x || myOr xs\n\nmyOrFold :: [Bool] -> Bool\nmyOrFold = foldr (||) False\n\n-- 2. myAny returns True if a -> Bool applied to any of the values in the list\n-- returns True.\nmyAny :: (a -> Bool) -> [a] -> Bool\nmyAny _ [] = False\nmyAny f (x:xs) = f x || myAny f xs\n\nmyAnyFold :: (a -> Bool) -> [a] -> Bool\nmyAnyFold f = foldr (\\x y -> f x || y) False\n\n-- 3. In addition to the recursive and fold based myElem, write a version that\n-- uses any.\nmyElem :: Eq a => a -> [a] -> Bool\nmyElem _ [] = False\nmyElem a (x:xs) = x == a || myElem a xs\n\nmyElemFold :: Eq a => a -> [a] -> Bool\nmyElemFold a = foldr (\\x y -> x == a || y) False\n\nmyElemAny :: Eq a => a -> [a] -> Bool\nmyElemAny a = myAnyFold (==a)\n\n-- 4. ImplementmyReverse,don\u2019t worry about trying to make it lazy.\nmyReverse :: [a] -> [a]\nmyReverse [] = []\nmyReverse (x:xs) = myReverse xs ++ [x]\n\nmyReverseFold :: [a] -> [a]\nmyReverseFold = foldr (\\x y -> y ++ [x]) []\n\n-- 5. Write myMap in terms of foldr. It should have the same behavior as the\n-- built-in map.\nmyMap :: (a -> b) -> [a] -> [b]\nmyMap f = foldr (\\x y -> f x : y) []\n\n-- 6. Write myFilter in terms of foldr. It should have the same behavior as the\n-- built-in filter.\nmyFilter :: (a -> Bool) -> [a] -> [a]\nmyFilter f = foldr (\\x y -> case f x of\n                                   True -> x : y\n                                   False -> y) []\n\n-- 7. squish flattens a list of lists into a list\nsquish :: [[a]] -> [a]\nsquish = foldr (++) []\n\n-- 8. squishMap maps a function over a list and concatenates the results.\nsquishMap :: (a -> [b]) -> [a] -> [b]\nsquishMap f = foldr (\\x y -> f x ++ y) []\n\n-- 9. squishAgain flattens a list of lists into a list. This time re-use the\n-- squishMap function.\nsquishAgain :: [[a]] -> [a]\nsquishAgain = squishMap id\n\n-- 10. myMaximumBy takes a comparison function and a list and returns the\n-- greatest element of the list based on the last value that the comparison\n-- returned GT for.\nmyMaximumBy :: (a -> a -> Ordering) -> [a] -> a\nmyMaximumBy f (x:xs) = foldr (\\x y -> case f x y of\n                                        LT -> y\n                                        _ -> x) x xs\n-- 11. myMinimumBy takes a comparison function and a list and returns the least\n-- element of the list based on the last value that the com- parison returned LT\n-- for.\nmyMinimumBy :: (a -> a -> Ordering) -> [a] -> a\nmyMinimumBy f (x:xs) = foldr (\\x y -> case f x y of\n                                 LT -> x\n                                 _ -> y) x xs\n", "input": "[True, True]", "status": "success", "output": "True"}
{"code": "import qualified Data.Map as Map\n\nhelloPerson :: String -> String\nhelloPerson name = \"Hello, \" ++ name ++ \"!\"\n\nmainDo :: IO ()\nmainDo = do\n  name <- getLine\n  let statement = helloPerson name\n  putStrLn statement\n\n-- My vision\nmainBind :: IO ()\nmainBind = getLine >>= (\\name -> return (helloPerson name)) >>= putStrLn\n\n-- Official vision? Or just approximation by Will Kurt?\nmainAnother :: IO ()\nmainAnother = getLine >>= (\\name -> (\\statement -> putStrLn statement) (helloPerson name))\n\n-- Candidate choosing application\ndata Grade = F | D | C | B | A deriving (Eq, Ord, Show, Enum, Read)\n\ndata Degree = HS | BA | MS | PhD deriving (Eq, Ord, Show, Enum, Read)\n\ndata Candidate = Candidate\n  { candidateId :: Int\n  , codeReview :: Grade\n  , cultureFit :: Grade\n  , education :: Degree } deriving Show\n\nviable :: Candidate -> Bool\nviable candidate = all (== True) tests\n  where passedCoding = codeReview candidate > B\n        passedCultureFit = cultureFit candidate > C\n        educationMin = education candidate >= MS\n        tests = [passedCoding\n                ,passedCultureFit\n                ,educationMin]\n\nreadInt :: IO Int\nreadInt = getLine >>= (return . read)\n\nreadGrade :: IO Grade\nreadGrade = getLine >>= (return . read)\n\nreadDegree :: IO Degree\nreadDegree = getLine >>= (return . read)\n\nreadCandidate :: IO Candidate\nreadCandidate = do\n   putStrLn \"Enter id:\"\n   cId <- readInt\n   putStrLn \"Enter code grade:\"\n   codeGrade <- readGrade\n   putStrLn \"Enter culture fit grade:\"\n   cultureGrade <- readGrade\n   putStrLn \"Enter education:\"\n   degree <- readDegree\n   return (Candidate { candidateId = cId\n                     , codeReview = codeGrade\n                     , cultureFit = cultureGrade\n                     , education = degree })\n\nassessCandidateIO :: IO String\nassessCandidateIO = do\n   candidate <- readCandidate\n   let passed = viable candidate\n   let statement = if passed\n                   then \"passed\"\n                   else \"failed\"\n   return statement\n\ncandidate1 :: Candidate\ncandidate1 = Candidate { candidateId = 1\n                        , codeReview = A\n                        , cultureFit = A\n                        , education = BA }\ncandidate2 :: Candidate\ncandidate2 = Candidate { candidateId = 2\n                        , codeReview = C\n                        , cultureFit = A\n                        , education = PhD }\n\ncandidate3 :: Candidate\ncandidate3 = Candidate { candidateId = 3\n                        , codeReview = A\n                        , cultureFit = B\n                        , education = MS }\n\ncandidateDB :: Map.Map Int Candidate\ncandidateDB = Map.fromList [(1,candidate1)\n                            ,(2,candidate2)\n                            ,(3,candidate3)]\n\ncandidates :: [Candidate]\ncandidates = [candidate1\n              ,candidate2\n              ,candidate3]\n\nassessCandidateMaybe :: Int -> Maybe String\nassessCandidateMaybe cId = do\n   candidate <- Map.lookup cId candidateDB\n   let passed = viable candidate\n   let statement = if passed\n                   then \"passed\"\n                   else \"failed\"\n   return statement\n\n-- Code for list looks like we work with one candidate, but we actually\n-- iterate over list. How to desugar this do notation?\n-- I think the anser for this in the implementation for a list + do notation.\nassessCandidateList :: [Candidate] -> [String]\nassessCandidateList candidates = do\n   candidate <- candidates\n   let passed = viable candidate\n   let statement = if passed\n                   then \"passed\"\n                   else \"failed\"\n   return statement\n\n\n-- Super abstract assessCandidate works for every Monad possible.\nassessCandidate :: Monad m =>  m Candidate -> m String\nassessCandidate candidates = do\n   candidate <- candidates\n   let passed = viable candidate\n   let statement = if passed\n                   then \"passed\"\n                   else \"failed\"\n   return statement\n\n\ncomparePizzas a b = a\ndescribePizza p = (show . fst) p\n\nmainDoPizza :: IO ()\nmainDoPizza = do\n   putStrLn \"What is the size of pizza 1\"\n   size1 <- getLine\n   putStrLn \"What is the cost of pizza 1\"\n   cost1 <- getLine\n   putStrLn \"What is the size of pizza 2\"\n   size2 <-  getLine\n   putStrLn \"What is the cost of pizza 2\"\n   cost2 <- getLine\n   let pizza1 = (read size1 :: Int, read cost1 :: Int)\n   let pizza2 = (read size2 :: Int, read cost2 :: Int)\n   let betterPizza = comparePizzas pizza1 pizza2\n   putStrLn (describePizza betterPizza)\n\nmainBindPizza :: IO ()\nmainBindPizza =\n  putStrLn \"What is the size of pizza 1\" >>\n  getLine >>= (\\size1 ->\n    putStrLn \"What is the cost of pizza 1\" >>\n    getLine >>= (\\cost1 ->\n      putStrLn \"What is the size of pizza 2\" >>\n      getLine >>= (\\size2 ->\n        putStrLn \"What is the cost of pizza 2\" >>\n        getLine >>= (\\cost2 -> putStrLn (describePizza (comparePizzas\n                            (read size1 :: Int, read cost1 :: Int)\n                            (read size2 :: Int, read cost2 :: Int)))\n                   ))))\n", "input": "\"hello\"", "status": "success", "output": "\"Hello, hello!\""}
{"code": "-- ===================================\n-- Ex. 1\n-- ===================================\neval :: [Integer] -> Integer\neval xs = foldl (\\x y -> y + (10 * x)) 0 xs\n\ntens :: [Integer]\ntens = map (10^) [0..]\n\nrests :: Integer -> [Integer]\nrests n = [n `mod` x | x <- takeWhile (<= n) (tail tens) ] ++ [n]\n\npowers :: Integer -> [Integer]\npowers n = [x - y | (x, y) <- rests n `zip` (0 : rests n)]\n\ntoDigits :: Integer -> [Integer]\ntoDigits n = reverse (toDigitsRev n)\n\n-- ===================================\n-- Ex. 2\n-- ===================================\nevalRev :: [Integer] -> Integer\nevalRev xs = foldr (\\x y-> x + (10 * y)) 0 xs\n\ntoDigitsRev :: Integer -> [Integer]\ntoDigitsRev n = [x `div` y | (x, y) <-  zip (powers n) tens]\n\n-- ===================================\n-- Ex. 3\n-- ===================================\n\ndoubleSecond :: [Integer] -> [Integer]\ndoubleSecond [] = []\ndoubleSecond [x] = [x]\ndoubleSecond (x:x':xs) = x : (2 * x') : doubleSecond xs\n\n-- alright, this will not throw exceptions!\nsumDigits :: [Integer] -> Integer\nsumDigits xs = sum (xs >>= toDigits)\n\n-- ===================================\n-- Ex. 4\n-- ===================================\n\nisValid :: Integer -> Bool\nisValid n = (sumDigits . doubleSecond . toDigitsRev) n `mod` 10 == 0\n\n-- ===================================\n-- Ex. 5\n-- ===================================\n\nnumValid :: [Integer] -> Integer\nnumValid xs = sum . map (\\_ -> 1) $ filter isValid xs\n\ncreditcards :: [Integer]\ncreditcards = [ 4716347184862961,\n                4532899082537349,\n                4485429517622493,\n                4320635998241421,\n                4929778869082405,\n                5256283618614517,\n                5507514403575522,\n                5191806267524120,\n                5396452857080331,\n                5567798501168013,\n                6011798764103720,\n                6011970953092861,\n                6011486447384806,\n                6011337752144550,\n                6011442159205994,\n                4916188093226163,\n                4916699537435624,\n                4024607115319476,\n                4556945538735693,\n                4532818294886666,\n                5349308918130507,\n                5156469512589415,\n                5210896944802939,\n                5442782486960998,\n                5385907818416901,\n                6011920409800508,\n                6011978316213975,\n                6011221666280064,\n                6011285399268094,\n                6011111757787451,\n                4024007106747875,\n                4916148692391990,\n                4916918116659358,\n                4024007109091313,\n                4716815014741522,\n                5370975221279675,\n                5586822747605880,\n                5446122675080587,\n                5361718970369004,\n                5543878863367027,\n                6011996932510178,\n                6011475323876084,\n                6011358905586117,\n                6011672107152563,\n                6011660634944997,\n                4532917110736356,\n                4485548499291791,\n                4532098581822262,\n                4018626753711468,\n                4454290525773941,\n                5593710059099297,\n                5275213041261476,\n                5244162726358685,\n                5583726743957726,\n                5108718020905086,\n                6011887079002610,\n                6011119104045333,\n                6011296087222376,\n                6011183539053619,\n                6011067418196187,\n                4532462702719400,\n                4420029044272063,\n                4716494048062261,\n                4916853817750471,\n                4327554795485824,\n                5138477489321723,\n                5452898762612993,\n                5246310677063212,\n                5211257116158320,\n                5230793016257272,\n                6011265295282522,\n                6011034443437754,\n                6011582769987164,\n                6011821695998586,\n                6011420220198992,\n                4716625186530516,\n                4485290399115271,\n                4556449305907296,\n                4532036228186543,\n                4916950537496300,\n                5188481717181072,\n                5535021441100707,\n                5331217916806887,\n                5212754109160056,\n                5580039541241472,\n                6011450326200252,\n                6011141461689343,\n                6011886911067144,\n                6011835735645726,\n                6011063209139742,\n                379517444387209,\n                377250784667541,\n                347171902952673,\n                379852678889749,\n                345449316207827,\n                349968440887576,\n                347727987370269,\n                370147776002793,\n                374465794689268,\n                340860752032008,\n                349569393937707,\n                379610201376008,\n                346590844560212,\n                376638943222680,\n                378753384029375,\n                348159548355291,\n                345714137642682,\n                347556554119626,\n                370919740116903,\n                375059255910682,\n                373129538038460,\n                346734548488728,\n                370697814213115,\n                377968192654740,\n                379127496780069,\n                375213257576161,\n                379055805946370,\n                345835454524671,\n                377851536227201,\n                345763240913232\n              ]\n", "input": "[42, 42]", "status": "success", "output": "462"}
{"code": "import Data.List\nimport Data.Char\n\n-- 1) Define a function leftFactorial that calculates the left factorial of a number\nleftFactorial :: Integer -> Integer\nleftFactorial 0 = 0\nleftFactorial x\n  | x < 0 = error \"Number must be positive!\"\n  | otherwise = factorial (x - 1) + leftFactorial (x - 1)\n  where factorial 0 = 1\n        factorial 1 = 1\n        factorial x = x * factorial (x - 1)\n  \n-- 2) Implement a function factorialZeroes that computes the number of zeroes n! ends with\nfactorialZeroes :: Int -> Int\nfactorialZeroes 0 = 0\nfactorialZeroes x\n  | x < 0 = error \"Number must be positive!\"\n  | otherwise = q + factorialZeroes q\n  where q = quot x 5\n  \n-- 3) Define a function interleave that, given a list in format [L1,L2,L3,R1,R2,R3], returns a list formatted as [L1,R1,L2,R2,L3,R3]\ninterleave :: [a] -> [a]\ninterleave [] = []\ninterleave xs\n | odd l = sol ++ [xs !! (l `div` 2)] \n | otherwise = sol\n where sol = concat [x : [y] | (x, y) <- zip (fst st) (snd st)]\n       l = length xs\n       st = splitAt ((l + 1) `div` 2) xs\n       \n-- 4) Define a function pairs that, for a given list containing no duplicates, returns a list of pairs (x,y) such that x differs from y and contains no symmetric pairs (y,x)\npairs :: [a] -> [(a, a)]\npairs [] = []\npairs xs = [(head xs, x) | x <- tail xs] ++ (pairs $ tail xs)\n\n-- 5) Define a function shortestSub that finds the shortest repeating sublist of elements within a given list\n-- shortestSub :: Eq a => [a] -> [a]\nshortestSub [] = []\nshortestSub xs = ssub xs (tail $ inits xs)\n  where ssub xs (y:ys) = if take (length xs) (cycle y) == xs then y else ssub xs ys\n\ntype Timestamp = [Int]\n\n-- 6a) Define isVaildTimestamp that checks if a timestamp contains valid values.\nisValidTimestamp :: Timestamp -> Bool\nisValidTimestamp (s:[]) = s >= 0 && s < 60\nisValidTimestamp xs@(m:_:[]) = m >= 0 && m < 60 && isValidTimestamp (tail xs)\nisValidTimestamp xs@(h:_:_:[]) = h >= 0 && h < 24 && isValidTimestamp (tail xs)\nisValidTimestamp _ = False\n\n-- 6b) Define timestampToSec that converts a given timestamp to seconds.\ntimestampToSec :: Timestamp -> Int\ntimestampToSec xs\n  | isValidTimestamp xs = ttsi xs\n  | otherwise = error \"Invalid timestamp\"\n  where ttsi (s:[]) = s\n        ttsi (m:s:[]) = m * 60 + s\n        ttsi (h:m:s:[]) = h * 60 * 60 + m * 60 + s\n\n-- 6c) Define timeDiff that calculates a temporal difference, in seconds, between two timestamps\ntimeDiff :: Timestamp -> Timestamp -> Int\ntimeDiff ts1 ts2 = abs (timestampToSec ts1 - timestampToSec ts2)\n\n-- 7a) Using group and list comprehensions, define the function counts that, given a list of elements, returns a list of pairs of (element, number of occurrences of the element)\ncounts :: Ord a => [a] -> [(a, Int)]\ncounts xs = [(head x, length x)| x <- group $ sort $ xs]\n\n-- 7b) Define a function group\u2019 that does the same as Data.List.group, but doesn\u2019t require the equal elements to be neighbours\ngroup' :: Eq a => [a] -> [[a]]\ngroup' xs = [replicate (count xs x) x | x <- nub xs]\n  where count xs t = length $ filter(== t) xs \n\n-- 7c) Using group\u2019 and list comprehensions, define a more general version of the counts function\ncounts' :: Eq a => [a] -> [(a, Int)]\ncounts' xs = [(head x, length x)| x <- group' xs]\n\n\ntype Grid = [String]\n\ncheckGrid :: Grid -> Bool\ncheckGrid [] = False\ncheckGrid xss = and [length xs == l | xs <- xss]\n  where l = length (xss !! 0)\n\n-- 8a) Define a function lightsOutLite that takes a Grid and computes the minimal number of moves to complete a simplified version of Lights Out!.\nlightsOutLite :: Grid -> Int\nlightsOutLite xss\n  | checkGrid xss = sum [digitToInt x | x <- concat xss]\n  | otherwise = error \"Broken grid!\"\n  \n-- 9a) Implement a function oneEdits that, given a String, returns all possible strings that are one edit{distance away from it.\n\nextraChar :: String -> [String]\nextraChar xs = concat [insert xs n | n <- [-1 .. length xs - 1]]\n  where insert xs n = [[xs !! i | i <- [0 .. n]] ++ y : [xs !! i | i <- [n + 1 .. length xs - 1]] | y <- ['a' .. 'z']]\n  \nlessChar :: String -> [String]\nlessChar xs = [[xs !! i | i <- [0 .. length xs - 1], i /= j] | j <- [0 .. length xs - 1]]\n\nmutatedChar :: String -> [String]\nmutatedChar xs = concat [mutate xs n | n <- [0 .. length xs -1]]\n  where mutate xs n = [[xs !! i | i <- [0 .. n - 1]] ++ y : [xs !! i | i <- [n + 1 .. length xs - 1]] | y <- ['a' .. 'z']]\n  \nswappedChars :: String -> [String]\nswappedChars xs = [swap xs n (n+1) | n <- [0 .. length xs - 2]]\n  where swap xs i j = concat [[if n == i then xs !! j else if n == j then xs !! i else xs !! n] | n <- [0 .. length xs - 1]]\n  \noneEdits :: String -> [String]\noneEdits xs = sort $ nub $ extraChar xs ++ lessChar xs ++ mutatedChar xs ++ swappedChars xs\n\n-- 9b) Now define a function twoEdits, that does the same as oneEdits, but edit distances of 2 instead\ntwoEdits :: String -> [String]\ntwoEdits xs = sort $ nub $ concat [oneEdits x | x <- oneEdits xs]\n\ncompareToFile :: (String -> [String]) -> String -> FilePath -> IO Bool\ncompareToFile f s file = do\n  list <- readFile file\n  return $ f s == (read list :: [String])\n  \ntestOneEdits :: IO Bool\ntestOneEdits = compareToFile oneEdits \"hi\" \"oneEdits.txt\"\n\ntestTwoEdits :: IO Bool\ntestTwoEdits = compareToFile twoEdits \"hi\" \"twoEdits.txt\"\n\n-- 10a) Define fromSeed that generates a pseudorandom integer given a seed value.\ntype Seed = Int\nm = 2 ^ 32\na = 1664525\nc = 1013904223\n\nfromSeed :: Seed -> Int\nfromSeed x = (a * x + c) `mod` m\n\n-- 10b) Define guess, a game that, given a starting seed value and number limit, asks the player to guess a number between 0 and the limit (inclusively).\nguess :: Seed -> Int -> IO Ordering\nguess x l = do\n  let num = fromSeed x `mod` l\n  putStr \"guess: \"\n  input <- readLn\n  return $ compare num input", "input": "42", "status": "success", "output": "34289376947494122614363304694584807557656420940314"}
{"code": "import Data.List \nimport System.IO \n\nsumOfNums = sum [1..1000]\n\naddEx = 5 + 4 \nsubEx = 5 - 4\nmultiEx = 5 * 4 \ndivEx = 5 / 4 \n\nmodEx = mod 5 4   -- Prefix operator \nmodEx2 = 5 `mod` 4  -- Infix operator \n\n-- Negative numbers must be surrounded with parentheses\nnegNumEx = 5 + (-4)\n\n-- If you define an Int you must use fromIntegral to use it with sqrt\n-- :t sqrt shows that it returns a floating point number\nnum9 = 9 :: Int \nsqrtOf9  = sqrt(fromIntegral num9)\n\n\n-- Built in math functions\npiVal = pi\nePow9 = exp 9\nlogOf9 = log 9\nsquared9 = 9 ** 2\ntruncateVal = truncate 9.999\nroundVal = round 9.999\nceilingVal = ceiling 9.999\nfloorVal = floor 9.999\n\nzeroToTen = [0..10]\nevenList = [2,4..20]\nletterList = ['a','b'..'z']\nmany2s = take 10 (repeat 2)\nmany3s = replicate 10 3 \n\ncycleList = take 10 (cycle [1,2,3,4,5])\nlistTimes2 = [x * 2 | x <- [1..10]]\nlistTimes3 = [x * 3 | x <- [1..100], x * 3 <= 50]\ndivisibleBy9N13 = [x | x <- [1..500], x `mod` 13 == 0, x `mod` 9 == 0]\nsortedList = sort [9,1,8,8,3,4,7]\nsumOfLists = zipWith(+)[1,2,3,4,5][6,7,8,9,10]\nlistBiggerThan5 = filter (>5)[1,2,3,4,5,6,7,8,9]\nevensUpTo20 = takeWhile(<=20)[2,4..]\nmultiList = foldl (*) 1 [2,3,4,5]\npow3List = [3^n | n <- [1..10]]\npow3ListDiv9 = [3^n | n <- [1..10], 3^n `mod` 9 == 0]\nmultiTable = [[x*y | y <- [1..10]] | x <- [1..10]]\n\n\nmultiplyBy2 list = [n * 2 | n <- list]\n\nrandomTuple = (1,\"Random Tuple\")\nbobSmith = (\"Bob Smith\",52)\nbobsName = fst bobSmith\nbobsAge = snd bobSmith\n\nnames = [\"Bob\",\"Mary\",\"John\"]\naddresses = [\"123 Main\",\"234 North\",\"567 South\"]\nnamesAndAddresses = zip names addresses\n\n\n\ngetListItems ::[Int] -> String \ngetListItems [] = \"Your List is empty\"\ngetListItems (x:[]) = \"Your List starts with \" ++ \" \" ++ show x \ngetListItems (x:y:[]) = \"Your list contains \" ++ \" \" ++ show x ++ \" \" ++ \"and\" ++  \" \" ++ show y \ngetListItems (x:xs) = \"The 1st item is \" ++ \" \" ++ show x ++ \" \" ++ \"and the rest\" ++ \" \" ++ show xs\n\n\n\ngetFirstItem :: String -> String\ngetFirstItem [] = \"Empty String\"\ngetFirstItem all@(x:xs) = \"The first letter in \" ++ \" \" ++ all ++ \" \" ++ \"is\" ++ \" \" ++show x  \n\ntimes4 :: Int -> Int \ntimes4 x = x * 4 \n\nlistTimes4 = map times4 [1,2,3,4]\n\nmultBy4 :: [Int] -> [Int]\nmultBy4 [] = []\nmultBy4 (x:xs) = times4 x : multBy4 xs \n\nareStringsEq :: [Char] -> [Char] -> Bool \nareStringsEq [] [] = True \nareStringsEq (x:xs)(y:ys) = x == y && areStringsEq xs ys \nareStringsEq _ _ = False \n\n\ndoMult :: (Int -> Int) -> Int \ndoMult func = func 3 \n\nnumber3Times4 = doMult times4\n\ngetAddFunc :: Int -> (Int -> Int)\ngetAddFunc x y = x + y \n\n\nadd3 = getAddFunc 3 \nfourPlus3 = add3 4 \n\nthreePlusList = map add3[1,2,3,4]\n\n-- Lambda function\ndb1To10 = map (\\x -> x * 2) [1..10]\n\n\n--Factorial \nprodFuct n = product [1..n]\n\n--Factorial 2 \n\nfactorial :: Int -> Int \nfactorial 0 = 1 \nfactorial n = n * factorial(n-1)\n\n\n\n--Using Guards 1\nwhatGrade :: Int -> String \nwhatGrade age \n    |(age >= 5) && (age <= 6) = \"Kindergaten\"\n    |(age > 6) && (age <= 10) = \"Elementary\"\n    | otherwise = \"Go to college\"\n\n\n--Using Guards 2\n\nbatAvgRating :: Double -> Double -> String\nbatAvgRating hits atBats\n    | avg <= 0.200 = \"Terrible Average\"\n    | avg <= 0.250 = \"Average Player\"\n    | avg <= 0.280 = \"You are doing good\"\n    | otherwise = \"You are a superstar\"\n    where avg = hits / atBats\n\n\n--Using Guards 3\nifibonnaci n | n < 0 = Nothing \nifibonnaci 0 = Just 0 \nifibonnaci 1 = Just 1\nifibonnaci n | otherwise = let (Just f1,Just f2) = (ifibonnaci(n-1),ifibonnaci(n-2))\n                           in Just (f1 + f2)\n\nbinom _ 0 = 1 \nbinom x y | x == y = 1 \nbinom n k = (binom(n-1)(k-1))+(binom(n-1)k) \n\n\n\nmultipleOf :: Integer -> Integer -> Bool\nmultipleOf x y = x `mod` y == 0 \n\nspecialMultiples :: Integer -> String\nspecialMultiples n | multipleOf n 2 = show n ++ \" \" ++ \"is a multiple of 2\"\nspecialMultiples n | multipleOf n 3 = show n ++ \" \" ++ \"is  a multiple of 3\"\nspecialMultiples n | multipleOf n 5 = show n ++ \" \" ++ \"is a multiple of 5\"\nspecialMultiples n | otherwise = show n ++ \" is a beautiful number\"\n\n\n\nspecialMultiples2 :: Integer -> String\nspecialMultiples2 n \n    | multipleOf n 2 = show n ++ \" \" ++ \"is a multiple of 2\"\n    | multipleOf n 3 = show n ++ \" \" ++ \"is a multiple of 3\"\n    | multipleOf n 5 = show n ++ \" \" ++ \"is a multiple of 5\"\n    | otherwise  = show n ++ \" \" ++ \"is a beautiful number\"\n\n\n\n\n\n--Fib Sequence 1 \nfib = 1 : 1 : [a + b | (a,b) <- zip fib (tail fib)]\n\n\n--Fib Sequence 2 using pattern matching \nfib2 0 =0\nfib2 1 = 1 \nfib2 n = fib2(n-1) + fib2(n-2)\n\n\n--Fib Sequence 3 \nfibs = 0:1:zipWith(+) fibs(tail fibs)\n\n\n--Project Euler Solutions \n\n--Solution 1 \nfactorsOf3and5 = sum [x | x <-[1..999], x `mod` 3 == 0 || x `mod` 5 == 0]\n\n\n\n--solution 3 \nsolution = sum $ filter even $ takeWhile(<= 4000000) fib where fib = 1:2:zipWith(+)fibs(tail fibs)\n\n\n--Solution 4\npalindrome = sort [ x*y | x <- [100..999], y <- [100..999], reverse (show (x*y)) == show (x*y)]\n\n--Solution 5 \nsmallest = foldl lcm 1 [1..20]\n\n--Solution 6 \n\nx = sum[1..100] ^2 \ny = sum ( map(^2) [1..100])\n\nsumSquareDifference = x - y \n\n\n\n--CUSTOM TYPES -- \n\ndata Customer = Customer String String Double \n            deriving (Show,Eq)\n\n\ndata Customer2 = Customer2 {\n    name :: String,\n    address :: String,\n    payment :: Double\n} deriving (Show,Eq)\n\n\nhungai2 :: Customer2\nhungai2 = Customer2 {name = \"Hungai Kevin\",address=\"12 Main\",payment=20.50}\nhungai3 = Customer2 {name = \"Hungai Amuhinda\",address=\"12 Main\",payment=20.50}\n\n--Define Customer and its values \n\nhungai :: Customer\nhungai = Customer \"Hungai Kevin\" \"123 Main\" 20.50\n\n-- Define how we will find the right customer \n\ngetBalance :: Customer -> Double\ngetBalance (Customer _ _ b) = b \n\nhungaiBalance = print(getBalance hungai)\n\n\n-- The . operator allows you to chain functions to pass output on the right\n--sumValue = putStrLn(show(1+2)) becomes \n\nsumValue = putStrLn . show $ 1 + 2 \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "input": "[42, 42]", "status": "success", "output": "\"Your list contains  42 and 42\""}
{"code": "import Data.List\r\nimport Data.Char\r\nimport qualified Data.Map as Map\r\n\r\ncharName :: Char -> String\r\ncharName 'a' = \"Albert\"\r\ncharname 'b' = \"Bethany\"\r\ncharname 'c' = \"Charles\"\r\n\r\n--xs = [(1, 3), (2, 4), (5, 6)\r\n--[a + b | (a, b) <- xs]\r\n\r\n-- guard\r\nbigNumber :: Double -> Bool\r\nbigNumber n\r\n  | n < 10 = False\r\n  | otherwise = True\r\n\r\n-- infix declaration\r\nmyCompare :: (Ord a) => a -> a -> Ordering\r\na `myCompare` b\r\n  | a == b = EQ\r\n  | a <= b = LT\r\n  | otherwise = GT\r\n\r\n-- let\r\ncylinder :: Double -> Double -> Double\r\ncylinder r h =   \r\n         let sideArea = 2 * pi * r * h\r\n             topArea = pi * r * 2\r\n         in sideArea + 2 * topArea\r\n\r\n-- case\r\ndescribeList :: [a] -> String\r\ndescribeList ls = \"The list is \" ++ case ls of [] -> \"empty\"\r\n                                               [x] -> \"a singleton list\"\r\n                                               xs -> \"a long list\"\r\n\r\nmax' :: (Ord a) => [a] -> a\r\nmax' [] = error \"max given empty list\"\r\nmax' [x] = x\r\nmax' (x:xs) = max x (max' xs)\r\n\r\nelem' :: (Eq a) => a -> [a] -> Bool\r\nelem' a [] = False\r\nelem' a (x:xs)\r\n      | a == x = True\r\n      | otherwise = a `elem'` xs\r\n\r\nquicksort :: (Ord a) => [a] -> [a]\r\nquicksort [] = []\r\nquicksort (x:xs) = \r\n          let smallerOrEqual = [a | a <- xs, a <= x]\r\n              larger = [a | a <- xs, a > x]\r\n          in quicksort smallerOrEqual ++ [x] ++ quicksort larger\r\n\r\n\r\nmerge :: (Ord a) => [a] -> [a] -> [a]\r\nmerge [] [] = []\r\nmerge [] all@(x:xs) = all\r\nmerge all@(x:xs) [] = all\r\nmerge allx@(x:xs) ally@(y:ys)\r\n      | x < y = x : merge xs ally\r\n      | otherwise = y : merge allx ys\r\n\r\nmergesort :: (Ord a) => [a] -> [a]\r\nmergesort [] = []\r\nmergesort all@(x:[]) = all\r\nmergesort x = \r\n          let half = length x `div` 2\r\n          in merge (mergesort $ take half x) (mergesort $ drop half x)\r\n\r\nsum' :: (Num a) => [a] -> a\r\nsum' xs = foldl (\\acc x -> acc + x) 0 xs\r\n\r\nsum'' :: (Num a) => [a] -> a\r\nsum'' = foldl (+) 0\r\n\r\nmap' :: (a -> b) -> [a] -> [b]\r\nmap' f xs = foldr (\\x acc -> f x : acc) [] xs\r\n\r\nelem'' :: (Eq a) => a -> [a] -> Bool\r\nelem'' y ys = foldr (\\x acc -> if x == y then True else acc) False ys\r\n\r\nmaximum' :: (Ord a) => [a] -> a\r\nmaximum' = foldl1 max\r\n\r\nand' :: [Bool] -> Bool\r\nand' xs = foldr1 (&&) xs\r\n\r\nsqrtSums :: Int\r\nsqrtSums = length (takeWhile (<1000) (scanl1 (+) (map sqrt [1..]))) + 1\r\n\r\ncircumference :: Float -> Float\r\ncircumference r = 2 * pi * r\r\n\r\ncircumference' :: Double -> Double\r\ncircumference' r = 2 * pi * r\r\n\r\nlucky :: Int -> String\r\nlucky 7 = \"GLUCKLIG SIEBEN!!1\"\r\nlucky x = \"Not so lucky\"\r\n\r\nfactorial' :: Int -> Int\r\nfactorial' 0 = 1\r\nfactorial' n = n * factorial' (n - 1)\r\n\r\naddVectors :: (Double, Double) -> (Double, Double) -> (Double, Double)\r\naddVectors a b = (fst a + fst b, snd a + snd b)\r\n\r\naddVectors' :: (Double, Double) -> (Double, Double) -> (Double, Double)\r\naddVectors' (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)\r\n\r\nfst' :: (a, b, c) -> a\r\nfst' (a, _, _) = a\r\n\r\nsnd' :: (a, b, c) -> b\r\nsnd' (_, b, _) = b\r\n\r\nthd' :: (a, b, c) -> c\r\nthd' (_, _, c) = c\r\n\r\nhead' :: [a] -> a\r\nhead' [] = error \"head' undefined on empty list\"\r\nhead' (x:_) = x\r\n\r\ntell :: (Show a) => [a] -> String\r\ntell [] = \"Nichts!\"\r\ntell (x:[]) = \"Eins! \" ++ show x\r\ntell (x:y:[]) = \"Zwei! \" ++ show x ++ \" \" ++ show y\r\ntell (x:y:_) = \"Viel! \" ++ show x ++ \" \" ++ show y ++ \" viele mehr!\"\r\n\r\npoorAdd :: (Num a) => [a] -> a\r\npoorAdd (x:y:z:[]) = x + y + z\r\n\r\n--as-pattern\r\nfirstLetter :: String -> String\r\nfirstLetter \"\" = \"{empty}\"\r\nfirstLetter all@(x:xs) = \"First \" ++ [x] ++ \" in \" ++ all\r\n\r\n--guards\r\nbmiTell :: Double -> String\r\nbmiTell bmi\r\n  | bmi <= 18.5 = \"Underweight!\"\r\n  | bmi <= 25.0 = \"Correct weight!\"\r\n  | bmi <= 30.0 = \"Overweight!\"                                  \r\n  | otherwise   = \"Whale alert!\"\r\n\r\nisIn :: (Eq a) => [a] -> [a] -> Bool\r\nneedle `isIn` haystack = any (needle `isPrefixOf`) (tails haystack)\r\n\r\n-- caesar cipher\r\nencode :: Int -> String -> String\r\nencode offset msg = map (\\c -> chr $ ord c + offset) msg\r\n\r\ndecode :: Int -> String -> String\r\ndecode offset msg = encode (negate offset) msg\r\n\r\n\r\n\r\n-- sqrt $ 3 + 4 + 9\r\n-- f = negate . (*3) \r\n-- f(2) = negate(*3)(2)\r\n-- sum . replicate 5 $ max 6.7 8.9\r\n\r\n\r\nnumUniques :: (Eq a) => [a] -> Int\r\nnumUniques = length . nub\r\n\r\n\r\n-- @todo return a map via fromList\r\ncreateMoveMap :: (Eq a, Ord a) => [a] -> Map.Map a Int\r\ncreateMoveMap xs = \r\n              let indices = zip xs [((length xs) - 1), ((length xs) - 2)..]\r\n              in Map.fromList $ nubBy (\\a b -> fst a == fst b) $ reverse indices\r\n\r\n\r\n-- boyer-moore\r\n-- returns whether a contains b\r\ncontains'' :: (Eq a, Ord a) => [a] -> [a] -> Bool\r\ncontains'' [] [] = False\r\ncontains'' [] x = False\r\ncontains'' x [] = False\r\ncontains'' pattern value = \r\n     let moveMap = createMoveMap pattern\r\n         patternLast = last pattern\r\n         valueAtPatternLast = value !! ((length pattern) - 1)\r\n     in if valueAtPatternLast == patternLast then\r\n           True\r\n        else\r\n          False\r\n\r\n\r\n\r\n-- @param start is the current position, from which to start matching backwards\r\ncontains' :: (Eq a, Ord a) => [a] -> [a] -> Int -> Bool\r\ncontains' [] [] _ = False\r\ncontains' [] x _ = False\r\ncontains' x [] _ = False\r\ncontains' pattern value start = \r\n            let moveMap = createMoveMap pattern\r\n                patternAt = pattern !! start\r\n                valueAt = value !! start\r\n            in if valueAt == patternAt then \r\n                 True -- @todo implement this; recursively check pattern; return move-ahead int on fail\r\n               else \r\n                 contains' pattern value (Map.findWithDefault ((length pattern) - 1) valueAt moveMap) -- tail call ftw\r\n\r\ncontains :: (Eq a, Ord a) => [a] -> [a] ->  Bool\r\ncontains pattern value = contains' pattern value ((length pattern) - 1)\r\n\r\ndata Car = Car { company :: String\r\n               , model :: String\r\n               , year :: Int\r\n               } deriving (Show)\r\n\r\ndata TrafficLight = Red | Yellow | Green\r\n\r\n-- make TrafficLight an instance of Eq\r\ninstance Eq TrafficLight where\r\n  Red == Red = True\r\n  Green == Green = True\r\n  Yellow == Yellow = True\r\n  _ == _ = False\r\n\r\n", "input": "'a'", "status": "success", "output": "\"Albert\""}
{"code": "import Data.Char\n\n-- 9.12 Chapter Exercises\n\n-- The first set of exercises here will mostly be review but will also introduce you to some new things. The second set is more conceptually challenging but does not use any syntax or concepts we haven\u2019t already studied. If you get stuck, it may help to flip back to a relevant section and review.\n\n-- Data.Char\n\n-- These first few exercises are straightforward but will introduce you to some new library functions and review some of what we\u2019ve learned so far. Some of the functions we will use here are not standard in Prelude and so have to be imported from a module called Data.Char. You may do so in a source file (recommended) or at the Prelude prompt with the same phrase: import Data.Char (write that at the top of your source file). This brings into scope a bunch of new standard functions we can play with that operate on Char and String types.\n\n-- 1. Query the types of isUpper and toUpper.\n-- 2. Given the following behaviors, which would we use to write a function that filters all the uppercase letters out of a String? Write that function such that, given the input \u201cHbEfLrLxO,\u201d your function will return \u201cHELLO.\u201d\nonlyUppercase :: [Char] -> [Char]\nonlyUppercase = filter isUpper\n\n-- . Write a function that will capitalize the first letter of a String and return the entire String. For example, if given the argument julie,\u201d it will return \u201cJulie.\u201d\n\ncapFirst :: [Char] -> [Char]\ncapFirst [] = []\ncapFirst (x:xs) = toUpper x : xs\n\n-- . Now make a new version of that function that is recursive such that if you give it the input \u201cwoot\u201d it will holler back at you \u201cWOOT.\u201d The type signature won\u2019t change, but you will want to dd a base case.\n\ncapAll :: [Char] -> [Char]\ncapAll [] = []\ncapAll (x:xs) = toUpper x : capAll xs\n\n-- . To do the final exercise in this section, we\u2019ll need another standard function for lists called head. Query the type of head and experiment with it to see what it does. Now write a function that will capitalize the first letter of a String and return only that letter as the result.\n\nfirstAsCap :: [Char] -> Char\nfirstAsCap xs = toUpper $ head xs\n\n-- . Cool. Good work. Now rewrite it as a composed function. Then, for fun, rewrite it pointfree.\n\nfirstAsCapComp :: [Char] -> Char\nfirstAsCapComp xs = (toUpper . head) xs\n\nfirstAsCapPF :: [Char] -> Char\nfirstAsCapPF = toUpper . head\n\n-- Ciphers\n\n-- See Cipher.hs in pwd\n\n-- Writing your own standard functions\n-- Below are the outlines of some standard functions. The goal here is to write your own versions of these to gain a deeper understanding of recursion over lists and how to make functions flexible enough to accept a variety of inputs. You could figure out how to look up the answers, but you won\u2019t do that because you know you\u2019d only be cheating yourself out of the knowledge. Right?\n\n-- Let\u2019s look at an example of what we\u2019re after here. The and function can take a list of Bool values and returns True if and only if no values in the list are False. Here\u2019s how you might write your own version of it:\n\n-- direct recursion, not using (&&)\nmyAnd :: [Bool] -> Bool\nmyAnd [] = True\nmyAnd (x:xs) = if x == False\n               then False\n               else myAnd xs\n\n-- direct recursion, using (&&)\nmyAnd' :: [Bool] -> Bool\nmyAnd' [] = True\nmyAnd' (x:xs) = x && myAnd' xs\n\n-- And now the fun begins:\n\n-- 1. myOr returns True if any Bool in the list is True.\nmyOr :: [Bool] -> Bool\nmyOr [] = False\nmyOr (x:xs) = x || myOr xs\n\n-- 2. myAny returns True if a -> Bool applied to any of the values in the list returns True.\nmyAny :: (a -> Bool) -> [a] -> Bool\nmyAny _ [] = False\nmyAny f (x:xs) = f x || myAny f xs\n\n-- 3. After you write the recursive myElem, write another version that uses any.\n-- myElem :: Eq a => a -> [a] -> Bool\nmyElem :: Eq a => a -> [a] -> Bool\nmyElem _ [] = False\nmyElem a (x:xs) = a == x || myElem a xs\n\nmyElemAny :: Eq a => a -> [a] -> Bool\nmyElemAny a xs = any (== a) xs\n\n-- 4. Implement myReverse.\nmyReverse :: [a] -> [a]\nmyReverse [] = []\nmyReverse (x:xs) = myReverse xs ++ [x]\n\n-- 5. squish flattens a list of lists into a list\nsquish :: [[a]] -> [a]\nsquish [] = []\nsquish (x:xs) = x ++ squish xs\n\n-- 6. squishMap maps a function over a list and concatenates the results.\nsquishMap :: (a -> [b]) -> [a] -> [b]\nsquishMap _ [] = []\nsquishMap f (a:as) = f a ++ squishMap f as\n\n-- 7. squishAgain flattens a list of lists into a list. This time re-use the squishMap function.\nsquishAgain :: [[a]] -> [a]\nsquishAgain = squishMap id\n\n-- 8. myMaximumBy takes a comparison function and a list and returns the greatest element of the list based on the last value that the comparison returned GT for.\n-- - If you import maximumBy from Data.List,\n--   -- you'll see the type is\n--   -- Foldable t => (a -> a -> Ordering) -> t a -> a\n--   -- rather than\n--   -- (a -> a -> Ordering) -> [a] -> a\n--   -- if you have GHC 7.10 or newer. Seeing a pattern?\n\nmyMaximumBy :: (a -> a -> Ordering) -> [a] -> a\nmyMaximumBy f (x:xs) = go x xs\n            where go current [] = current\n                  go current (next:xs) = go (case (f next current) of\n                                             GT -> next\n                                             _ -> current) xs\n\n-- 9. myMinimumBy takes a comparison function and a list and returns the least element of the list based on the last value that the com- parison returned LT for.\n-- - blah blah GHC 7.10 different type\n--     -- that uses Foldable.\nmyMinimumBy :: (a -> a -> Ordering) -> [a] -> a\nmyMinimumBy f (x:xs) = go x xs\n            where go current [] = current\n                  go current (next:xs) = go (case (f next current) of\n                                             LT -> next\n                                             _ -> current) xs\n\n-- using the myMinimumBy and myMaximumBy functions, write your own versions of maximum and minimum. If you have GHC 7.10 or newer, you\u2019ll see a type constructor that wants a Foldable instance in- stead of a list as has been the case for many functions so far.\nmyMaximum :: (Ord a) => [a] -> a\nmyMaximum = myMaximumBy compare\nmyMinimum :: (Ord a) => [a] -> a\nmyMinimum = myMinimumBy compare", "input": "['a', 'a']", "status": "success", "output": "\"\""}
{"code": "import Data.List\n\ndoubleMe x = x + x\ndoubleUs x y = doubleMe x + doubleMe y\n\ndoubleSmallNumber x =\n    if x > 100\n        then x\n    else\n        doubleMe x\n\ndoubleSmallNumber' x = (if x > 100 then x else doubleMe x) + 1\n\nboomBangs xs = [if x < 10 then \"boom!\" else \"bang!\" | x <- xs, odd x]\n\n\nremoveNonUppercase :: String -> String\nremoveNonUppercase st = [c | c <- st, c `elem` ['A'..'Z']]\n-- removeNonUppercase st = [c | c <- st, c `elem` ['A'..'Z']]\nremoveUppercase st = [c | c <- st, not(c `elem` ['A'..'Z'])]\ntriangles = [(a,b,c) | a <- [1..10], b <- [1..a], c <- [1..b], b^2 + c^2==a^2, a+b+c==24]\n\n{-length' :: (Num b) => [a] -> b\nlength' xs = fromIntegral(length xs)-}\n\nlucky :: Integral a => a -> String\nlucky 7 = \"OMG!\"\nlucky x = \"TRY AGAIN!\"\n\nfactorial n = product [1..n]\n\nfactorial' 0 = 1\nfactorial' n = n * factorial'(n-1)\n\n\nmy_fail :: Char -> String\nmy_fail 'a' = \"ASD\"\nmy_fail 'b' = \"BSD\"\n\nhead' :: [a] -> a\nhead' [] = error \"FUCK OFF!\"\nhead' (x:xs) = x\n\nlength' :: Integral b => [a] -> b\nlength' [] = 0\nlength' (_:xs) = 1 + length' xs\n\nsum' :: (Num a) => [a] -> a\nsum' [] = 0\nsum' (x:xs) = x + sum' xs\n\nbmiTell :: (RealFloat a) => a -> a -> String\nbmiTell weigth height\n    | bmi <= 18.5 = \"Small!\"\n    | bmi <= 25.0 = \"Ok!\"\n    | bmi <= 30.0 = \"Pretty big!\"\n    | otherwise   = \"Big!\"\n    where bmi = weigth / height^2\n\ninitials :: String -> String -> String\ninitials (f:_) (l:_) = [f] ++ \" \" ++ [l]\n\nbmiList :: (RealFloat a) => [(a, a)] -> [a]\nbmiList [] = []\nbmiList (x:xs) = [bmi x] ++ bmiList xs\n    where bmi (weigth, height) = weigth / height ^ 2\n\nbmiList' :: (RealFloat a) => [(a, a)] -> [a]\nbmiList' xs = [bmi w h | (w, h) <- xs]\n    where bmi weigth height = weigth / height^2\n\nhashWords :: String -> [String]\nhashWords text = [tail x | x <- words' text, head x == '#']\n\nwords' :: String -> [String]\nwords' text = [takeWhile(/= ' ') text] ++ words(dropWhile (/= ' ') text)\n\ndescribeList :: [a] -> String\ndescribeList xs = \"This list is \" ++ case xs of [] -> \"empty\"\n                                                [x] -> \"a singleton\"\n                                                xs -> \"long\"\n\ndescribeList' :: [a] -> String\ndescribeList' xs = \"This list is \" ++ what xs\n    where what [] = \"e\"\n          what [x] = \"s\"\n          what xs = \"l\"\n\nmax' :: (Ord a) => [a] -> a\nmax' [] = error \"Can't compute max' on an empty list!\"\nmax' [x] = x\nmax' (x:xs)\n    | x > t = x\n    | otherwise = t\n    where t = max' xs\n\nmax'' :: (Ord a) => [a] -> a\nmax'' [] = error \"Can't compute max'' on an empty list!\"\nmax'' [x] = x\nmax'' (x:xs) = max x (max'' xs)\n\nreplicate' :: (Integral a, Ord a) => a -> b -> [b]\nreplicate' n el\n    | n <= 0 = []\n    | otherwise = el:replicate' (n-1) el\n\ntake' :: (Integral a) => a -> [b] -> [b]\ntake' n _\n    | n <= 0 = []\ntake' _ [] = []\ntake' n (x:xs) = x:take' (n-1) xs\n\nreverse' :: [a] -> [a]\nreverse' [] = []\nreverse' (x:xs) = reverse' xs ++ [x]\n\nzip' :: [a] -> [b] -> [(a, b)]\nzip' [] _ = []\nzip' _ [] = []\nzip' (x:xs) (y:ys) = (x, y):zip' xs ys\n\nrepeat' :: a -> [a]\nrepeat' x = x:repeat' x\n\n{- docblocks? -}\n\nelem' :: (Eq a) => a -> [a] -> Bool\n_ `elem'` [] = False\nx `elem'` (y:ys)\n    | x == y = True\n    | otherwise = x `elem'` ys\n\nquickSort :: (Ord a) => [a] -> [a]\nquickSort [] = []\n{-quickSort (x:xs) = quickSort [y | y <- xs, y <= x] ++ [x] ++ quickSort [y | y <- xs, y > x]-}\nquickSort (x:xs) = quickSort (filter (<= x) xs) ++ [x] ++ quickSort (filter (> x) xs)\n{-quickSort (x:xs) = let-}\n    {-smaller = quickSort [y | y <- xs, y <= x]-}\n    {-greater = quickSort [y | y <-xs, y > x]-}\n    {-in smaller ++ [x] ++ greater-}\n\nzipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]\nzipWith' _ [] _ = []\nzipWith' _ _ [] = []\nzipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys\n\nflip' :: (a -> b -> c) -> (b -> a -> c)\nflip' f x y = f y x\n\nflip'' :: (a -> b -> c) -> (b -> a -> c)\nflip'' f = \\x y -> f y x\n\nmap' :: (a -> b) -> [a] -> [b]\nmap' _ [] = []\nmap' f (x:xs) = f x : map' f xs\n\nfilter' :: (a -> Bool) -> [a] -> [a]\nfilter' _ [] = []\n{-filter' f (x:xs) = [y | y <- [x], f x] ++ (filter' f xs)-}\n\nfilter' f (x:xs)\n    | f x = x:tail\n    | otherwise = tail\n    where tail = filter' f xs\n\nsumOdd :: (Integral a, Ord a) => a -> a\nsumOdd n = sum (takeWhile (<=n) (filter odd (map (^2) [1..])))\n\ncollatzSeq :: (Integral a) => a -> [a]\ncollatzSeq 1 = [1]\ncollatzSeq n\n    | odd n = n:collatzSeq (n*3 + 1)\n    | even n = n:collatzSeq (n `div` 2)\n\nnumLongCollatzSeq :: Int -> Int\n{-numLongCollatzSeq n = length (filter isLong (map collatzSeq [1..100]))-}\n    {-where isLong xs = length xs > n-}\nnumLongCollatzSeq n = length (filter (\\xs -> length xs > 15) (map collatzSeq [1..100]))\n\nelem'' :: (Eq a) => a -> [a] -> Bool\nelem'' x xs = foldl (\\acc y -> if x == y then True else acc) False xs\n\nmap'' :: (a -> b) -> [a] -> [b]\nmap'' f xs = foldr (\\x acc -> f x:acc) [] xs\n\nmyMaximum :: (Ord a) => [a] -> a\nmyMaximum = foldl1 (\\acc x -> if x > acc then x else acc)\n\nreverse'' :: [a] -> [a]\nreverse'' = foldr (\\x acc -> acc ++ [x]) []\n\nproduct' :: (Num a) => [a] -> a\nproduct' = foldl1 (*)\n\nfilter'' :: (a -> Bool) -> [a] -> [a]\nfilter'' f = foldr (\\x acc -> if f x then x:acc else acc) []\n\nhead'' :: [a] -> a\nhead'' = foldl1 (\\acc _ -> acc)\n\nlast' :: [a] -> a\nlast' = foldr1 (\\_ acc -> acc)\n\nsqrtSums :: Int\nsqrtSums = length (takeWhile (<1000) (scanl1 (+) (map sqrt [1..]))) + 1\n\nnumUniques :: (Eq a) => [a] -> Int\nnumUniques = length . nub\n\nsubList :: (Eq a) => [a] -> [a] -> Bool\nsubList needle haystack =\n    let nlen = length needle\n    in foldl (\\acc x -> if take nlen x == needle then True else acc) False (tails haystack)\n\n-- Get the multiples of n\nmul :: (Integral a) => a -> [a]\nmul n = [x | x <- [2..], x `mod` n == 0]\n\n{- Using the Sieve Of Eratosthenmes algorithm get all primes up to n\n -\n - This works by reducing the multiples of the numbers from the initial list\n -}\nsoe :: (Integral a) => a-> [a]\nsoe n = foldl (\\acc x -> acc \\\\ (takeWhile (<=n) (tail . mul $ x))) [2..n] [2..n]\n\nirc_soe :: (Integral a) => a-> [a]\nirc_soe n = nubBy (\\x y -> gcd x y > 1) [2..n]\n\nnubBy' eq [] = []\nnubBy' eq (x:xs) = x : nubBy' eq (filter (\\ y -> not (eq x y)) xs)\n\nasd (x:xs) = length xs\n\nmy_dict =\n    [(\"betty\",\"555-2938\")\n    ,(\"bonnie\",\"452-2928\")\n    ,(\"patsy\",\"493-2928\")\n    ,(\"lucille\",\"205-2928\")\n    ,(\"wendy\",\"939-8282\")\n    ,(\"penny\",\"853-2492\")\n    ]\n\nlkup :: (Eq k) => k -> [(k, v)] -> Maybe v\n{-lkup _ [] = Nothing-}\n{-lkup key ((k,v):xs)-}\n    {-| k == key = Just v-}\n    {-| otherwise = lkup key xs-}\n\nlkup key = foldl (\\acc (k,v) -> if  k == key then Just v else acc) Nothing\n", "input": "\"hello\"", "status": "success", "output": "\"\""}
{"code": "import Data.List\nimport Data.Char\nimport Data.Maybe\n\n-- ELEMENTAL DATA\n\nelements = \n\t[\n\t\t(\"hydrogen\", \"H\", 1.0079),\n\t\t(\"helium\", \"He\", 4.0026),\n\t\t(\"lithium\", \"Li\", 6.941),\n\t\t(\"beryllium\", \"Be\", 9.012),\n\t\t(\"boron\", \"B\", 10.811),\n\t\t(\"carbon\", \"C\", 12.011),\n\t\t(\"nitrogen\", \"N\", 14.007),\n\t\t(\"oxygen\", \"O\", 16.00),\n\t\t(\"fluorine\", \"F\", 19.00),\n\t\t(\"neon\", \"Ne\", 20.179),\n\t\t(\"sodium\", \"Na\", 22.99),\n\t\t(\"magnesium\", \"Mg\", 24.30),\n\t\t(\"aluminum\", \"Al\", 26.98),\n\t\t(\"silicon\", \"Si\", 26.98),\n\t\t(\"phosphorus\", \"P\", 30.974),\n\t\t(\"sulfur\", \"S\", 32.06),\n\t\t(\"chlorine\", \"Cl\", 35.453),\n\t\t(\"argon\", \"Ar\", 39.948),\n\t\t(\"potassium\", \"K\", 39.10),\n\t\t(\"calcium\", \"Ca\", 40.08),\n\t\t(\"scandium\", \"Sc\", 44.96),\n\t\t(\"titanium\", \"Ti\", 47.90),\n\t\t(\"vanadium\", \"V\", 50.94),\n\t\t(\"chromium\", \"Cr\", 52.00),\n\t\t(\"manganese\", \"Mn\", 54.938),\n\t\t(\"iron\", \"Fe\", 55.85),\n\t\t(\"cobalt\", \"Co\", 58.93),\n\t\t(\"nickel\", \"Ni\", 58.69),\n\t\t(\"copper\", \"Cu\", 63.55),\n\t\t(\"zinc\", \"Zn\", 65.39),\n\t\t(\"gallium\", \"Ga\", 69.72),\n\t\t(\"germanium\",\"Ge\", 72.59),\n\t\t(\"arsenic\", \"As\", 74.92),\n\t\t(\"selenium\", \"Se\", 78.96),\n\t\t(\"bromine\", \"Br\", 79.90),\n\t\t(\"krypton\", \"Kr\", 83.80)\n\t]\n\n-- ELEMENT INFO FUNCTIONS\n\natomicNumber :: String -> Maybe Int\natomicNumber elem = do\n\t\t\t\telemIndex <- findIndex (\\(name,symbol,massNum) -> map toLower elem == name || elem == symbol) elements\n\t\t\t\treturn (elemIndex + 1)\n\nrelativeAtomicMass :: String -> Double\nrelativeAtomicMass elem = foldr (\\(name,symbol,rAM) val-> if map toLower elem == name || elem == symbol\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthen rAM\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse val) 0.0 elements\n\natomicWeight = relativeAtomicMass\n\ncPeriod :: String -> Maybe Int\ncPeriod elem = maybe Nothing cPeriod' $ atomicNumber elem\n\ncPeriod' :: Int -> Maybe Int\ncPeriod' aNum | aNum <= 0 = Nothing\n\t\t\t | aNum <= 2 = Just 1\n\t\t\t | aNum <= 10 = Just 2\n\t\t\t | aNum <= 18 = Just 3\n\t\t\t | aNum <= 36 = Just 4\n\t\t\t | aNum <= 54 = Just 5\n\t\t\t | aNum <= 86 = Just 6\n\t\t\t | aNum <= 118 = Just 7\n\t\t\t | aNum > 118 = Nothing\n\n\ncGroup :: String -> Maybe Int\ncGroup = maybe Nothing cGroup' . atomicNumber\n\ncGroup' :: Int -> Maybe Int\ncGroup' aNum | aNum <= 0 = Nothing\n\t\t\t | aNum <= 1 = Just 1\n\t\t\t | aNum <= 2 = Just 18\n\t\t\t | aNum <= 4 = Just (aNum - 2)\n\t\t\t | aNum <= 10 = Just (aNum + 8)\n\t\t\t | aNum <= 12 = Just (aNum - 10)\n\t\t\t | aNum <= 18 = Just aNum\n\t\t\t | aNum <= 36 = Just (aNum - 18)\n\t\t\t | aNum <= 54 = Just (aNum - 36)\n\t\t\t | aNum <= 56 = Just (aNum - 54)\n\t\t\t | aNum <= 71 = Just 3\n\t\t\t | aNum <= 86 = Just (aNum - 68)\n\t\t\t | aNum <= 88 = Just (aNum - 86)\n\t\t\t | aNum <= 103 = Just 3\n\t\t\t | aNum <= 118 = Just (aNum - 100)\n\t\t\t | aNum > 118 = Nothing\n\ncGroupCAS :: String -> Maybe String\ncGroupCAS = maybe Nothing groupToCAS . maybe Nothing cGroup' . atomicNumber\n\ngroupToNames :: [String] -> Int -> Maybe String\ngroupToNames names num | num < 1 = Nothing\n\t\t\t\t\t   | num <= length names = Just $ names !! (num - 1)\n\t\t\t\t\t   | num > length names = Nothing\n\ngroupToCAS = groupToNames [\"IA\",\"IIA\",\"IIIB\",\"IVB\",\"VB\",\"VIB\",\"VIB\",\"VIIIB\",\"VIIIB\",\"VIIIB\",\"IB\",\"IIB\",\"IIB\",\"IIIA\",\"IVA\",\"VA\",\"VIA\",\"VIA\",\"VIIIA\"]\n\n\n-- FORMULA INFO FUNCTIONS\n\n--Gets Formula Mass From CFormula\nformulaMass :: CFormula -> Double\nformulaMass formula = foldr (\\(symbol, num) acc -> acc + (atomicWeight symbol * fromIntegral num)) 0.0 (stitchFormula formula)\n\npercentByMass :: CFormula -> [(CSymbol,Double)]\npercentByMass formula = let totalMass = formulaMass formula in \n\tmap (\\(symbol,num) -> (symbol, (100.0 * atomicWeight symbol * fromIntegral num) / totalMass)) (stitchFormula formula)\n\n-- Example Formulas:\n\n-- Multiple Level Example\n-- CComp [(CUnit [(\"Ba\",1)],1),( CComp[(CUnit [(\"O\",1),(\"H\",1)], 1)],2)]\n\n-- Single Level Example\n-- CComp [(CUnit [(\"Ba\",1)],1),(CUnit [(\"O\",1),(\"H\",1)],2)]\n\n\n-- RAW FORMULA FUNCTIONS (currently cannot handle charges)\n\ntype CSymbol = String\ndata CFormula = CUnit [(CSymbol, Int)] | CComp [(CFormula, Int)] deriving Eq\n\ninstance Show CFormula where\n\tshow (CUnit unit) = foldr (\\(symb, num) str -> symb ++ (if num > 1 then show num else \"\") ++ str) \"\" unit\n\tshow (CComp comp) = foldr (\\(formula, num) str -> (if num > 1 then \"(\" ++ show formula ++ \")\" ++ show num else show formula) ++ str) \"\" comp\n\ndata CEquation = CEquation ([(Int, CFormula)], [(Int, CFormula)]) deriving (Eq, Show)\n\n--Converts CComp into CUnit (if CUnit, returns CUnit)\nsimplifyFormula :: CFormula -> CFormula\nsimplifyFormula = CUnit . stitchFormula\n\n--Properly extracts data from CFormula\nstitchFormula :: CFormula -> [(CSymbol, Int)]\nstitchFormula (CComp comp) = foldr (\\(formula, num) stitched -> stitchFormula formula ++ stitched) [] ((\\(CComp comp) -> comp) $ flattenFormula $ CComp comp)\nstitchFormula (CUnit unit) = unit\n\n--Makes all CComp coefficients 1 and scales CUnits appropriately\nflattenFormula :: CFormula -> CFormula\nflattenFormula (CComp comp) = CComp $ map (\\(formula, num) -> (flattenFormula (scaleFormula formula num),1)) comp\nflattenFormula (CUnit unit) = CUnit unit\n\n-- Shallow scaling (does not go to deepest level in CComp)\nscaleFormula :: CFormula -> Int -> CFormula\nscaleFormula (CComp comp) scale = CComp $ map (\\(formula,num) -> (formula, num * scale)) comp\nscaleFormula (CUnit unit) scale = CUnit $ map (\\(symb,num) -> (symb, num * scale)) unit\n\n\n-- VALIDATION FUNCTIONS\n\n--Pattern-matching version\nvalidateCSymbol :: CSymbol -> Bool\nvalidateCSymbol symbol = (isUpper . head) symbol && length symbol < 4 && all isLower (tail symbol)\n\n--uses whitelisting of symbols based on elements\nisElementSymbol :: CSymbol -> Bool\nisElementSymbol symbol = any (\\(name, symb, massNum) -> symbol == symb) elements\n\n--uses whitelisting based on elements\nisElement :: String -> Bool\nisElement str = any (\\(name, symbol, massNum) -> name == map toLower str || symbol == str) elements\n\n\n-- PARSING FUNCTIONS\n\nformulaFromStructure :: [String] -> CFormula\nformulaFromStructure structure = undefined\n\n\n-- finds distinct symbols, coefficients, and parentheses in a string (Assumes string is written properly)\ngetStructure :: String -> [String]\ngetStructure = \n\tfoldr (\\a acc-> \n\t\tif isUpper a && acc /= [] && all isLower (head acc)\n\t\t\tthen if drop 2 (head acc) /= \"\"\n\t\t\t\tthen (a : take 2 (head acc)) : drop 2 (head acc) : tail acc\n\t\t\t\telse (a : take 2 (head acc)) : tail acc\n\t\t\telse if (isDigit a && acc/= [] && all isDigit (head acc)) || (isLower a && acc/= [] && all isLower (head acc))\n\t\t\t\tthen (a : head acc) : tail acc\n\t\t\t\telse [a] : acc\n\t) []\n\n--Function Needed to Traverse from structure to CFormula\nmatchingOpenParenIndex :: [String] -> Int\nmatchingOpenParenIndex structure = \n\t1 + snd (foldr (\\a (count, indx) -> \n\t\t\tif count < 1 \n\t\t\t\tthen (if a == \")\" \n\t\t\t\t\tthen count - 1 \n\t\t\t\t\telse if a == \"(\" \n\t\t\t\t\t\tthen count + 1 \n\t\t\t\t\t\telse count, indx - 1)\n\t\t\t\telse (2, indx))\n\t\t(0, length structure - 1) structure) :: Int", "input": "\"hello\"", "status": "success", "output": "Nothing"}
{"code": "{-\nGiacomo - 08/09/17: Homework 1\n\nTry to write small functions\nwhich perform just a single task, and then combine those smaller\npieces to create more complex functions. Don\u2019t repeat yourself: write\none function for each logical task, and reuse functions as necessary.\nBe sure to write functions with exactly the specified name and\ntype signature for each exercise (to help us test your code). You may\ncreate additional helper functions with whatever names and type\nsignatures you wish.\nValidating Credit Card Numbers1\nHave you ever wondered how websites validate your credit card\nnumber when you shop online? They don\u2019t check a massive database\nof numbers, and they don\u2019t use magic. In fact, most credit providers\nrely on a checksum formula for distinguishing valid numbers from\nrandom collections of digits (or typing mistakes).\nIn this section, you will implement the validation algorithm for\ncredit cards. It follows these steps:\n\n\u2022 Double the value of every second digit beginning from the right.\nThat is, the last digit is unchanged; the second-to-last digit is doubled;\nthe third-to-last digit is unchanged; and so on. For example,\n[1,3,8,6] becomes [2,3,16,6].\n\n\u2022 Add the digits of the doubled values and the undoubled digits\nfrom the original number. For example, [2,3,16,6] becomes\n2+3+1+6+6 = 18.\n\n\u2022 Calculate the remainder when the sum is divided by 10. For the\nabove example, the remainder would be 8.\nIf the result equals 0, then the number is valid.\n-}\n\n{-\nExercise 1 We need to first find the digits of a number. Define the\nfunctions\ntoDigits :: Integer -> [Integer]\ntoDigitsRev :: Integer -> [Integer]\ntoDigits should convert positive Integers to a list of digits. (For 0 or\nnegative inputs, toDigits should return the empty list.) toDigitsRev\nshould do the same, but with the digits reversed.\nExample: toDigits 1234 == [1,2,3,4]\nExample: toDigitsRev 1234 == [4,3,2,1]\nExample: toDigits 0 == []\nExample: toDigits (-17) == []\n-}\n\n-- easier to implement this function first and then reverse to get original\n-- sequence\ntoDigitsRev :: Integer -> [Integer]\ntoDigitsRev 0 = []\ntoDigitsRev n\n  | n < 0 = []\ntoDigitsRev n = n `mod` 10 : toDigitsRev (n `div` 10)\n\ntoDigits :: Integer -> [Integer]\ntoDigits n = (reverse . toDigitsRev) n\n\n{-\nExercise 2 Once we have the digits in the proper order, we need to\ndouble every other one. Define a function\ndoubleEveryOther :: [Integer] -> [Integer]\nRemember that doubleEveryOther should double every other number\nbeginning from the right, that is, the second-to-last, fourth-to-last,\n. . . numbers are doubled.\nExample: doubleEveryOther [8,7,6,5] == [16,7,12,5]\nExample: doubleEveryOther [1,2,3] == [1,4,3]\n-}\n\n-- unfortunately, couldn't figure out how to do this from the right\n-- so do it from the left and use reverse\ndoubleEveryOtherLeft :: [Integer] -> [Integer]\ndoubleEveryOtherLeft [] = []\ndoubleEveryOtherLeft [x] = [x]\ndoubleEveryOtherLeft [x,y] = [x, 2*y]\ndoubleEveryOtherLeft (x:y:zs) = x:2*y:doubleEveryOtherLeft(zs)\n\ndoubleEveryOther     :: [Integer] -> [Integer]\ndoubleEveryOther xs = (reverse . doubleEveryOtherLeft . reverse) xs\n\n{-\nExercise 3 The output of doubleEveryOther has a mix of one-digit\nand two-digit numbers. Define the function\nsumDigits :: [Integer] -> Integer\nto calculate the sum of all digits.\nExample: sumDigits [16,7,12,5] = 1 + 6 + 7 + 1 + 2 + 5 = 22\n-}\n\nsumDigits :: [Integer] -> Integer\nsumDigits [] = 0\nsumDigits (x:xs) = (sum . toDigits) x + sumDigits xs\n\n{-\nExercise 4 Define the function\nvalidate :: Integer -> Bool\nthat indicates whether an Integer could be a valid credit card number.\nThis will use all functions defined in the previous exercises.\nExample: validate 4012888888881881 = True\nExample: validate 4012888888881882 = False\n-}\n\nvalidate :: Integer -> Bool\nvalidate x\n  | (sumDigits . doubleEveryOther . toDigits) x `mod` 10 == 0 = True\n  | otherwise = False\n\n{-\nThe Towers of Hanoi2\nExercise 5 The Towers of Hanoi is a classic puzzle with a solution\nthat can be described recursively. Disks of different sizes are stacked\non three pegs; the goal is to get from a starting configuration with\nall disks stacked on the first peg to an ending configuration with all\ndisks stacked on the last peg, as shown in Figure 1.\n\u21d3\nFigure 1: The Towers of Hanoi\nThe only rules are\n\u2022 you may only move one disk at a time, and\n\u2022 a larger disk may never be stacked on top of a smaller one.\nFor example, as the first move all you can do is move the topmost,\nsmallest disk onto a different peg, since only one disk may be moved\nat a time.\nFigure 2: A valid first move. From this point, it is illegal to move to the configuration shown in\nFigure 3, because you are not allowed to put the green disk on top of\nthe smaller blue one.\nFigure 3: An illegal configuration.\nTo move n discs (stacked in increasing size) from peg a to peg b\nusing peg c as temporary storage,\n1. move n \u2212 1 discs from a to c using b as temporary storage\n2. move the top disc from a to b\n3. move n \u2212 1 discs from c to b using a as temporary storage.\nFor this exercise, define a function hanoi with the following type:\ntype Peg = String\ntype Move = (Peg, Peg)\nhanoi :: Integer -> Peg -> Peg -> Peg -> [Move]\nGiven the number of discs and names for the three pegs, hanoi\nshould return a list of moves to be performed to move the stack of\ndiscs from the first peg to the second.\nNote that a type declaration, like type Peg = String above, makes\na type synonym. In this case Peg is declared as a synonym for String,\nand the two names Peg and String can now be used interchangeably.\nGiving more descriptive names to types in this way can be used to\ngive shorter names to complicated types, or (as here) simply to help\nwith documentation.\nExample: hanoi 2 \"a\" \"b\" \"c\" == [(\"a\",\"c\"), (\"a\",\"b\"), (\"c\",\"b\")]\n-}\n\ntype Peg = String\ntype Move = (Peg, Peg)\nhanoi ::  Integer -> Peg -> Peg -> Peg -> [Move]\nhanoi 0 _ _ _ = []\nhanoi 1 a b _ = [(a, b)]\nhanoi n a b c = (hanoi (n-1) a c b) ++ (hanoi 1 a b c) ++ (hanoi (n-1) c b a)\n\n{-\nExercise 6 (Optional) What if there are four pegs instead of three?\nThat is, the goal is still to move a stack of discs from the first peg to\nthe last peg, without ever placing a larger disc on top of a smaller\none, but now there are two extra pegs that can be used as \u201ctemporary\u201d\nstorage instead of only one. Write a function similar to hanoi\nwhich solves this problem in as few moves as possible.\nIt should be possible to do it in far fewer moves than with three\npegs. For example, with three pegs it takes 215 \u2212 1 = 32767 moves\nto transfer 15 discs. With four pegs it can be done in 129 moves. (See\nExercise 1.17 in Graham, Knuth, and Patashnik, Concrete Mathematics,\nsecond ed., Addison-Wesley, 1994.)\n-}\n", "input": "42", "status": "success", "output": "[4,2]"}
{"code": "doubleMe x = x + x\n\ndoubleUs x y = doubleMe x + doubleMe y\n\ndoubleSmallNumber x = if x > 100\n\t\t\t\t\t\tthen x\n\t\t\t\t\t\telse x * 2\n\t\t\t\t\t\t\ndoubleSmallNumber' x = (if x > 100 then x else x * 2) + 1\n\nboomBangs xs = [ if x < 10 then \"BOOM!\" else \"BANG!\" | x <- xs, odd x]\n\nlength' xs = sum [1 | _<-xs]\n\nremoveNonUpperCase :: [Char] -> String\nremoveNonUpperCase st = [c | c <- st, c `elem` ['A'..'Z']]\n\nnestedList xxs = [[x | x <- xs, odd x] | xs <- xxs]\n\nrightTriangle = [(a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2, a + b + c == 24]\n\naddThree :: Int -> Int -> Int -> Int\naddThree x y z = x + y + z\n\nlucky :: (Integral a) => a -> String\nlucky 7 = \"Lucky number seven\"\nlucky x = \"Sorry, yo're out of luck pal\"\n\nfactorial :: (Integral a) => a -> a\nfactorial 0 = 1\nfactorial n = n * factorial (n-1)\n\naddVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)\naddVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)\n\naddVectors' :: (Num a) => (a, a) -> (a, a) -> (a, a)\naddVectors' a b = (fst a + fst b, snd a + snd b)\n\nfirst :: (a, b, c) -> a\nfirst (x, _, _) = x\n\nsecond :: (a, b, c) -> b\nsecond (_, y, _) = y\n\nthird :: (a, b, c) -> c\nthird (_, _, z) = z\n\nhead' :: [a] -> a\nhead' [] = error \"Can't call head on empty list, dummy!\"\nhead' (x:_) = x\n\nhead'' :: [a] -> a\nhead'' xs = case xs of [] -> error \"No head of empty list\"\n                       (x:_) -> x\n\ntell :: (Show a) => [a] -> String\ntell [] = \"The list is empty\"\ntell (x:[]) = \"The list has one element: \" ++ show x\ntell (x:y:[]) = \"The list has two element: \" ++ show x ++ \" and \" ++ show y\ntell (x:y:_) = \"The list is long. The first two elements are: \" ++ show x ++ \" and \" ++ show y\n\nlength'' :: (Num b) => [a] -> b\nlength'' [] = 0\nlength'' (_:xs) = 1 + length'' xs\n\nsum' :: (Num a) => [a] -> a\nsum' [] = 0\nsum' (x:xs) = x + sum' xs\n\ncapital' :: String -> String\ncapital' \"\" = \"Empty String, whoops!\"\ncapital' all@(x:xs) = \"The first letter of \" ++ all ++ \" is \" ++ [x]\n\nbmiTell :: (RealFloat a) => a -> a -> String\nbmiTell weight height\n\t| bmi <= skinny \t= \"You're underweight, you emo, you!\"\n\t| bmi <= normal \t= \"You're supposedly normal. Pfft, I bet you're ugly!\"\n\t| bmi <= fat\t \t= \"You're fat! Lose some weight, fatty!\"\n\t| otherwise\t\t\t= \"You're a whale, congratulation!\"\n\twhere bmi = weight / height ^ 2\n\t      (skinny, normal, fat) = (18.5, 25.0, 30.0)\n\t\t  \ncalBmis :: (RealFloat a) => [(a,a)] -> [a]\ncalBmis xs = [bmi w h | (w,h) <- xs]\n\t where bmi weight height = weight / height ^ 2\n\t\t  \nmax' :: (Ord a) => a -> a -> a\nmax' a b\n\t| a > b \t= a\n\t| otherwise = b\n\t\nmyCompare :: (Ord a) => a -> a -> Ordering\na `myCompare` b\n\t| a > b \t= GT\n\t| a == b \t= EQ\n\t| otherwise = LT\n\t\ninitials :: String -> String -> String\ninitials firstname lastname = [f] ++ \". \" ++ [l] ++ \".\"\n\twhere (f:_) = firstname\n\t      (l:_) = lastname\n\t\t  \ncylinder :: (RealFloat a) => a -> a -> a\ncylinder r h =\n\tlet sideArea = 2 * pi * r * h\n\t    topArea = pi * r ^ 2\n\tin  sideArea + 2 * topArea\n\t\ncalBmis' :: (RealFloat a) => [(a, a)] -> [a]\ncalBmis' xs = [bmi | (w, h) <- xs, let bmi = w / h ^ 2]\n\ndescribeList :: [a] -> String\ndescribeList xs = \"The list is \" ++ case xs of [] -> \"empty.\"\n                                               [x] -> \"a singleton list.\"\n                                               xs -> \"a longer list.\"\n\ndescribeList' :: [a] -> String\ndescribeList' xs = \"The list is \" ++ what xs\n\twhere what [] = \"empty.\"\n\t      what [x] = \"a singleton.\"\n\t      what xs = \"a longer list.\"                                               \n\nmaximum' :: (Ord a) => [a] -> a\nmaximum' [] = error \"maximum of an empty list\"\nmaximum' [x] = x\nmaximum' (x:xs)\n\t| x > maxTail \t= x\n\t| otherwise\t\t= maxTail\n\twhere maxTail = maximum' xs\n\nmaximum'' :: (Ord a) => [a] -> a\nmaximum'' [] = error \"maximum of an empty list\"\nmaximum'' [x] = x\nmaximum'' (x:xs) = max x (maximum'' xs)\n\nreplicate' :: (Num i, Ord i) => i -> a -> [a]\nreplicate' n x\n\t| n <= 0 \t= []\n\t| otherwise = x:replicate' (n-1) x\n\ntake' :: (Num i, Ord i) => i -> [a] -> [a]\ntake' n _\n\t| n <= 0 \t= []\ntake' _ [] \t\t= []\ntake' n (x:xs)\t= x : take' (n-1) xs\n\nreverse' :: [a] -> [a]\nreverse' [] = []\nreverse' (x:xs) = reverse' xs ++ [x]\n\nrepeat' :: a -> [a]\nrepeat' x = x : repeat' x\n\nzip' :: [a] -> [b] -> [(a,b)]\nzip' _ [] = []\nzip' [] _ = []\nzip' (x:xs) (y:ys) = (x,y) : zip' xs ys\n\nelem' :: (Eq a) => a -> [a] -> Bool\nelem' a [] = False\nelem' a (x:xs) \n\t| a == x \t= True\n\t| otherwise\t= a `elem'` xs\n\nquicksort :: (Ord a) => [a] -> [a]\nquicksort [] = []\nquicksort (x:xs) =\n\tlet smallerSorted \t= quicksort [a | a <- xs, a <= x]\n\t    biggerSorted\t= quicksort [a | a <- xs, a > x]\n\tin smallerSorted ++ [x] ++ biggerSorted\n\nmultiThree :: (Num a) => a -> a -> a -> a\nmultiThree x y z = x * y * z\n\ncompareWithHundred :: (Num a, Ord a) =>  a -> Ordering\ncompareWithHundred x = compare 100 x\n\ncompareHundred :: (Num a, Ord a) => a -> Ordering\ncompareHundred = compare 100\n\ndivideByTen :: (Floating a) => a -> a\ndivideByTen = (/10)\n\nisUpperAlphanum :: Char -> Bool\nisUpperAlphanum = (`elem` ['A'..'Z'])\n\napplyTwice :: (a -> a) -> a -> a\napplyTwice f x = f (f x)\n\nzipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]\nzipWith' _ [] _ = []\nzipWith' _ _ [] = []\nzipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys\n\nflip' :: (a -> b -> c) -> (b -> a -> c)\nflip' f = g \n\twhere g x y = f y x\n\nfilter' :: (a -> Bool) -> [a] -> [a]\nfilter' _ [] = []\nfilter' p (x:xs)\n\t| p x \t\t= x : filter' p xs\n\t| otherwise\t= filter' p xs\n\nlargestDivisible :: (Integral a) => a\nlargestDivisible = head (filter p [100000, 99999..])\n\twhere p x = x `mod` 3829 == 0\n\nchain :: (Integral a) => a -> [a]\nchain 1 = [1]\nchain n\n\t| even n \t= n: chain (n `div` 2)\n\t| odd n \t= n: chain (n*3 +1) \n\nnumLongChains :: Int\nnumLongChains = length (filter isLong (map chain [1..100]))\n\twhere isLong xs = length xs > 15\n\nnumLongChains' :: Int\nnumLongChains' = length (filter (\\xs -> length xs > 15) (map chain [1..100]))\n\nsumFold :: (Num a) => [a] -> a\nsumFold xs = foldl (\\acc x -> acc + x) 0 xs\n\nelemFold :: (Eq a) => a -> [a] -> Bool\nelemFold y ys = foldl (\\acc x -> if x == y then True else acc) False ys\n\nelemFold' :: (Eq a) => a -> [a] -> Bool\nelemFold' y ys = foldl (\\acc x -> if x == y then True else acc) False ys\n\nmap' :: (a -> b) -> [a] -> [b]\nmap' f xs = foldr (\\x acc -> f x: acc) [] xs\n\nmapLeftFold :: (a -> b) -> [a] -> [b]\nmapLeftFold f xs = foldl (\\acc x -> acc ++ [f x]) [] xs\n\nmaxFold :: (Ord a) => [a] -> a\nmaxFold = foldl1 (\\acc x -> if x > acc then x else acc) \n\nreverseFold :: [a] -> [a]\nreverseFold = foldl (\\acc x -> x: acc) []\n\nproductFold :: (Num a) => [a] -> a\nproductFold = foldl1 (*)\n\nfilterFold :: (a -> Bool) -> [a] -> [a]\nfilterFold p = foldr (\\x acc -> if p x then x : acc else acc) []\n\nheadFold :: [a] -> a\nheadFold = foldr1 (\\x _ -> x)\n\nlastFold :: [a] -> a\nlastFold = foldl1 (\\_ x -> x)\n\nsqrtSums :: Int\nsqrtSums = length (takeWhile (< 1000) (scanl1 (+) (map sqrt [1..]))) + 1\n ", "input": "['a', 'a']", "status": "success", "output": "\"\""}
{"code": "{- Chapter 12 :: Monads and more -}\n\nimport Data.Char (isDigit, digitToInt)\n\ninc :: [Int] -> [Int]\ninc [] = []\ninc (n:ns) = n+1 : inc ns\n\n{-\n\ninc [20,30,2]\n= [21,31,3]\n\n-}\n\nsqr :: [Int] -> [Int]\nsqr [] = []\nsqr (n:ns) = n^2 : sqr ns\n\n{-\n\nsqr [1,5,10]\n= [1,25,100]\n\n-}\n\nmap' :: (a -> b) -> [a] -> [b]\nmap' f [] = []\nmap' f (x:xs) = f x : map' f xs\n\n{-\n\nmap' (+1) [10,20,30]\n= [11,21,31]\n\n-}\n\ninc' = map (+1)\nsqr' = map (^2)\n\n{-\n\nBuilt into GHC.Base/Prelude:\n\nclass Functor f where\n    fmap :: (a -> b) -> f a -> f b\n\ninstance Functor [] where\n    -- fmap :: (a -> a) -> [a] -> [b]\n    fmap = map\n\ndata Maybe a = Nothing | Just a\n\ninstance Functor Maybe where\n    -- fmap :: (a -> b) -> Maybe a -> Maybe b\n    fmap _ Nothing = Nothing\n    fmap g (Just x) = Just (g x)\n\n-}\n\n\n{-\n\nfmap (+1) Nothing\n= Nothing\n\nfmap (*2) (Just 3)\n= Just 6\n\nfmap not (Just False)\n= Just True\n\n\n-}\n\ndata Tree a = Leaf a | Node (Tree a) (Tree a)\n              deriving Show\n\ninstance Functor Tree where\n    -- fmap :: (a -> b) -> Tree a -> Tree b\n    fmap g (Leaf x) = Leaf (g x)\n    fmap g (Node l r) = Node (fmap g l) (fmap g r)\n\n\n{-\n\n> fmap length (Leaf \"abc\")\nLeaf 3\n\n> fmap even (Node (Leaf 1) (Leaf 2))\nNode (Leaf False) (Leaf True)\n\n-}\n\n{-\n\ninstance Functor IO where\n    -- fmap :: (a -> b) -> IO a -> IO b\n    fmap g mx = do {x <- mx; return (g x)}\n\n-}\n\n{-\n\n> fmap show (return True)\n\"True\"\n\n> fmap show (return False)\n\"False\"\n\nBenefits of using functors:\n\n1. The function fmap can be used to process the elements of any \nstructure tha tis functorial - that is, we can use the same name \nfor fucntions that are essentially the same, rather than having \nto invent a separate name for each instance.\n\n2. We can define generic functions thatcan be used with any functor. \nFor example, the earlier function that increments each integer in a \nlist can be generalized to any functorial type by simply using fmap \nrather than map.\n\n-}\n\ninc'' :: Functor f => f Int -> f Int\ninc'' = fmap (+1)\n\n{-\n\ninc'' (Just 1)\n= Just 2\n\ninc'' [1,2,3,4,5,6]\n= [2,3,4,5,6,7]\n\ninc'' (Node (Leaf 1) (Leaf 2))\n= Node (Leaf 2) (Leaf 3)\n\n\n\n-}\n\ndata Lst a = T [a] -- declare new list type\n                deriving Show\n\n{-\n\nfmap0 :: a -> f a\n\nfmap1 :: (a -> b) -> f a -> f b\n\nfmap2 :: (a -> b -> c) -> f a -> f b -> f c\n\nfmap3 :: (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n\n-------------------------------------------------------\n\npure :: a -> f a\n\n(<*>) :: f (a -> b) -> f a -> f b\n\n> :t pure\npure :: Applicative f => a -> f a\n\n> :t (<*>)\n(<*>) :: Applicative f => f (a -> b) -> f a -> f b\n\n-------------------------------------------------------\n\nfmap0 :: a -> f a\nfmap0 = pure\n\nfmap1 :: (a -> b) -> f a -> f b\nfmap1 g x = pure g <*> x\n\nfmap2 :: (a -> b -> c) -> f a -> f b -> f c\nfmap2 g x y = pure g <*> x <*> y\n\nfmap3 :: (a -> b -> c -> d) -> f a -> f b -> f c -> f d\nfmap3 g x y z = pure g <*> x <*> y <*> z\n\n-}\n\n{-\n\nclass Functor f => Applicative f where\n    pure :: a -> f a\n    (<*>) :: f (a -> b) -> f a -> f b\n\ninstance Applicative Maybe where\n    -- pure :: a -> Maybe a\n    pure = Just\n\n    -- (<*>) :: Maybe (a -> b) -> Maybe a -> Maybe b\n    Nothing <*> _ = Nothing\n    (Just g) <*> mx = fmap g mx\n\n> pure (+1) <*> Just 1\nJust 2\n\n> pure (+) <*> Just 1 <*> Just 2\nJust 3\n\n> pure (+) <*> Nothing <*> Just 2\nNothing\n\n-------------------------------------------------------\n\nApplicatives or \"applicative functors\" are the class of \nfunctors that support pure and <*> functions.\n\nThe standard prelude contains the following instance \ndeclaration:\n\ninstance Applicative [] where\n    -- pure :: a -> [a]\n    pure x = [x]\n\n    -- (<*>) :: [a -> b] -> [a] -> [b]\n    gs <*> xs = [g x | g <- gs, x <- xs]\n\n> pure (+1) <*> [1,2,3]\n[2,3,4]\n\n= [(+1)] <*> [1,2,3]\n= [(+1) 1, (+1) 2, (+1) 3]\n= [2, 3, 4]\n\n> pure (+) <*> [1] <*> [2]\n[3]\n\n= ([(+)] <*> [1]) <*> [2]\n= ([(+) 1]) <*> [2]\n= [((+) 1) 2]\n\n> pure (*) <*> [1,2] <*> [3,4]\n[3,4,6,8]\n\n= [(*)] <*> [1,2] <*> [3,4]\n= [(*) 1, (*) 2] <*> [3,4]\n= [(*) 1 3, (*) 1 4, (*) 2 3, (*) 2 4]\n\nUsing ghci to check: \n> [(*) 1, (*) 2] <*> [3,4]\n[3,4,6,8]\n\n-}\n\nprods :: [Int] -> [Int] -> [Int]\nprods xs ys = [x*y | x <- xs, y <- ys]\n\nprods' :: [Int] -> [Int] -> [Int]\nprods' xs ys = pure (*) <*> xs <*> ys\n\n{-\n\nprods' [1,2] [10,20,30]\n= [10,20,30,20,40,60]\n\ninstance Applicative IO where\n    -- pure :: a -> IO a\n    pure = return\n\n    -- (<*>) :: IO (a -> b) -> IO a -> IO b\n    mg <*> mx = do {g <- mg; x <- mx; return (g x)} \n\n\n\n-}\n\ngetChars :: Int -> IO String\ngetChars 0 = return []\ngetChars n = pure (:) <*> getChar <*> getChars (n-1)\n\n{-\n\n> getChars 3 -- Typing in 'abc' gives:\n\"abc\"\n\n> getChars 2 -- Typing in 'xyz' gives:\n\"xy\"\n\nThe standard library provides the following function:\n\nsequenceA :: Applicative f => [f a] -> f [a]\nsequenceA [] = pure []\nsequenceA (x:xs) = pure (:) <*> x <*> sequenceA xs\n\n-}\n\ngetChars' :: Int -> IO String\ngetChars' n = sequenceA (replicate n getChar)\n\n{-\n\ngetChars' 3 -- Typing in 'abc' gives:\n\"abc\"\n\n> :t replicate 3 getChar\nreplicate 3 getChar :: [IO Char]\n\n\n-------------------------------------------------------\n\nApplicative laws:\n\nApplicative functors are required to satisfy four \nequational laws:\n\npure id <*> x   = x\npure (g x)      = pure g <*> pure x\nx <*> pure y    = pure (\\g -> g y) <*> x\nx <*> (y <*> z) = (pure (.) <*> x <*> y) <*> z\n\n\n-}\n\n{------------------ Monads -------------------------\n\nFrom fubo on Reddit (https://www.reddit.com/r/explainlikeimfive/comments/kzw5j/eli5_monads_programming/c2omloo/):\n\nMonad is not a data type, like a floating-point number, or a list of records. Monad is a set of \nalgebraic properties that a data type can have. Saying that a data type \"is a monad\" (or, more \ntechnically, \"forms a monad\") means saying that a data type follows a certain set of mathematical \nequalities for some operations on that data type.\n\nOkay, what is an \"algebraic property\"? Well, here is an example: commutativity. We say that \nmultiplication of integers is \"commutative\" because for any integers X and Y, X\u00b7Y = Y\u00b7X. No matter \nwhat the integers are, this equality is true. Associativity is another algebraic property, which means \nthat changing the grouping of operations doesn't change their effects: (A+B)+C is the same as A+(B+C).\n\nCommutativity and associativity are algebraic properties. As you can see from these examples, an \nalgebraic property depends on a type (such as integers) and an operation (such as adding or multiplying). \nWe say that the integers \"commute over multiplication\" (and addition, etc.) \u2014 but they do not commute over \nsubtraction: X\u2013Y is not generally the same as Y\u2013X.\n\nSome algebraic properties depend on more than one operation, for instance distributivity, which says that \nA\u00b7(B+C) = A\u00b7B + A\u00b7C. We say that multiplication on the integers distributes over addition.\n\nAlso, when a type has operations with various particular sets of algebraic properties, we sometimes call that \ntype by a special name, such as ring or group. Monad is a different set of algebraic properties. It means there \nare certain operations, called bind and join and return, that work in a particular way. These operations are a \nlittle more abstract than things like addition and multiplication. Monad doesn't say what these operations \nactually do; it just says that they have to relate to each other in a particular fashion. I won't go into exactly \nwhat these are, but basically return is about making new monadic values from non-monadic ones; join is about \ncollapsing nested groupings (kind of like associativity); and bind is about funneling values through functions. \nThere are certain equations that these operations have to meet; and if they do, then we can say that the type \nis (or forms) a monad.\n\nIt happens that a whole bunch of useful things turn out to fit the monad description. One of these is \n\"I/O operations\" \u2014 which is a programmer way of saying, \"those events in a computer program that interact with \nan outside world, like your screen and keyboard, or the Internet\". But there are lots of other monads. Lists \nform a monad. Functions that return a result while reading from a stream of data, are a monad. Functions that \nupdate a shared global state variable are a monad. And so on.\n\n...\n\nFrom functions on monads, it's possible to define imperative-style programming within pure-functional programming. \nThat's what the \"do notation\" in Haskell is.\n\nHowever, more generally, monads work with lazy evaluation to make it possible to fully describe a computation \nseparately from when you actually want it computed. For an example, take a look at Parsec, a monadic parser library, \nwhich makes writing a parser almost as easy as writing down the grammar \u2014 and what you write is not merely a \nspecialized parser description language; it's actual code that can use the full power of Haskell.\n\n\n-}\n\ndata Expr = Val Int | Div Expr Expr -- deriving Show\n\neval :: Expr -> Int\neval (Val n) = n\neval (Div x y) = eval x `div` eval y\n\n{-\n\n> eval (Div (Val 10) (Val 2))\n5\n\n> eval (Div (Val 10) (Val 0))\n*** Exception: divide by zero\n\n-}\n\nsafediv :: Int -> Int -> Maybe Int\nsafediv _ 0 = Nothing\nsafediv n m = Just (n `div` m)\n\n\neval' :: Expr -> Maybe Int\neval' (Val n)   = Just n\neval' (Div x y) = case eval' x of \n                  Nothing -> Nothing\n                  Just n -> case eval' y of\n                     Nothing -> Nothing\n                     Just m -> safediv n m\n\n{-\n\n> eval' (Div (Val 1) (Val 0))\nNothing\n\n> eval' (Div (Div (Val 10) (Val 2)) (Val 5))\nJust 1\n\n> eval' (Div (Div (Val 0) (Val 2)) (Val 5))\nJust 0\n\n> eval' (Div (Div (Val 2) (Val 0)) (Val 5))\nNothing\n\n-}\n\n\n{-\nThe following function is not type correct:\n\neval'' :: Expr -> Maybe Int\neval'' (Val n)   = pure n\neval'' (Div x y) = pure safediv <*> eval'' x <*> eval'' y\n\nghci states: Couldn't match type \u2018Maybe Int\u2019 with \u2018Int\u2019\n\n-------------------------------------------------------\n\n(>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b\nmx >>= f = case mx of\n           Nothing -> Nothing\n           Just x -> f x\n\n\n-}\n\neval'' :: Expr -> Maybe Int\neval'' (Val n)   = Just n\neval'' (Div x y) = eval'' x >>= \\n -> eval'' y >>= \\m -> safediv n m \n-- eval'' (Div x y) = eval'' x >>= (\\n -> eval'' y >>= (\\m -> safediv n m)) \n\n{-\n\n> eval'' (Div (Val 1) (Val 0))\nNothing\n\n> eval'' (Div (Div (Val 10) (Val 2)) (Val 5))\nJust 1\n\n-------------------------------------------------------\n\nm1 >> \\x1 -> \nm2 >> \\x2 -> \n.\n.\n.\nmn >> \\xn -> \nf x1 x2 ... xn\n\nis basically the same as the notation for interactive \nprogramming:\n\ndo x1 <- m1\n   x2 <- m2\n   .\n   .\n   .\n   xn <- mn\n   f x1 x2 ... xn\n\n\n-}\n\neval''' :: Expr -> Maybe Int\neval''' (Val n)   = Just n\neval''' (Div x y) = do n <- eval''' x\n                       m <- eval''' y\n                       safediv n m\n\n{-\n\n> eval''' (Div (Val 1) (Val 0))\nNothing\n\n> eval''' (Div (Div (Val 10) (Val 2)) (Val 5))\nJust 1\n\n-------------------------------------------------------\n\nclass Applicative m => Monad m where\n    return :: a -> m a\n    (>>=) :: m a -> (a -> m b) -> m b\n\n    return = pure\n\nIn the future, return may be removed from the Monad \nclass and become a library function with the following\ndefinition:\n\nreturn :: Applicative f => a -> f a\nreturn = pure\n\n-------------------------------------------------------\n\ninstance Monad Maybe where\n    -- (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b\n    Nothing  >>= _ = Nothing\n    (Just x) >>= f = f x\n\n\ninstance Monad [] where\n    -- (>>=) :: [a] -> (a -> [b]) -> [b]\n    xs >>= f = [y | x <- xs, y <- f x]\n\n-}\n\npairs :: [a] -> [b] -> [(a,b)]\npairs xs ys = do x <- xs\n                 y <- ys\n                 return (x,y)\n\n{-\n\n> pairs [1,2] [3,4]\n[(1,3),(1,4),(2,3),(2,4)]\n\nNote similarity to a definition using the comprehension\nnotation:\n\npairs :: [a] -> [b] -> [(a,b)]\npairs xs ys = [(x,y) | x <- xs, y <- ys]\n\n-------------------------------------------------------\n\ninstance Monad IO where\n    -- return :: a -> IO a\n    return x = ... -- return and >>= are built-into the\n                   -- the language.\n\n    -- (>>=) :: IO a -> (a -> IO b) -> IO b\n    mx >>= f = ...\n\n-}\n\ntype State = Int\n\n-- type ST = State -> State\n\n-- type ST a = State -> (a, State)\n\nnewtype ST a = S (State -> (a,State))\n\napp :: ST a -> State -> (a,State)\napp (S st) x = st x\n\ninstance Functor ST where\n    -- fmap :: (a -> b) -> ST a -> ST b\n    fmap g st = S (\\s -> let (x,s') = app st s in (g x, s'))\n\ninstance Applicative ST where\n    -- pure :: a -> ST a\n    pure x = S (\\s -> (x,s)) \n\n    -- (<*>) :: ST (a -> b) -> ST a -> ST b\n    stf <*> stx = S (\\s -> \n                     let (f,s') = app stf s\n                         (x,s'') = app stx s' in (f x, s''))\n\ninstance Monad ST where\n    -- (>>=) :: ST a -> (a -> ST b) -> ST b\n    st >>= f = S (\\s -> let (x,s') = app st s in app (f x) s')\n\n-- data Tree a = Leaf a | Node (Tree a) (Tree a) deriving Show\n\ntree :: Tree Char\ntree = Node (Node (Leaf 'a') (Leaf 'b')) (Leaf 'c')\n\n\nrlabel :: Tree a -> Int -> (Tree Int, Int)\nrlabel (Leaf _) n = (Leaf n, n+1)\nrlabel (Node l r) n = (Node l' r', n'')\n                      where\n                        (l',n') = rlabel l n\n                        (r',n'') = rlabel r n'\n\n{-\n\n> fst $ rlabel tree 0\nNode (Node (Leaf 0) (Leaf 1)) (Leaf 2)\n\n> rlabel tree 0\n(Node (Node (Leaf 0) (Leaf 1)) (Leaf 2),3)\n\n\n\n\n-}\n\nfresh :: ST Int\nfresh = S (\\n -> (n, n+1))\n\nalabel :: Tree a -> ST (Tree Int)\nalabel (Leaf _) = Leaf <$> fresh\nalabel (Node l r) = Node <$> alabel l <*> alabel r\n\n\n{-\n\n> fst $ app (alabel tree) 0\nNode (Node (Leaf 0) (Leaf 1)) (Leaf 2)\n\n\n-}\n\nmlabel :: Tree a -> ST (Tree Int)\nmlabel (Leaf _) = do n <- fresh\n                     return (Leaf n)\nmlabel (Node l r) = do l' <- mlabel l\n                       r' <- mlabel r\n                       return (Node l' r')\n\n{-\n\n> fst $ app (mlabel tree) 0\nNode (Node (Leaf 0) (Leaf 1)) (Leaf 2)\n\n\n-}\n\n\n{------------------ Generic Functions ---------------\n\nmapM :: Monad m => (a -> m b) -> [a] -> m [b]\nmapM f [] = return []\nmapM f (x:xs) = do y <- f x\n                   ys <- mapM f xs\n                   return (y:ys)\n\n-}\n\n-- convert a digit character to its numeric value\nconv :: Char -> Maybe Int\nconv c | isDigit c = Just (digitToInt c)\n       | otherwise = Nothing\n\n{-\n\n> mapM conv \"1234\"\nJust [1,2,3,4]\n\n> mapM conv \"123a\"\nNothing\n\n> map conv \"1234\"\n[Just 1,Just 2,Just 3,Just 4]\n\n\n> map conv \"123a\"\n[Just 1,Just 2,Just 3,Nothing]\n\n\n> :t mapM conv \"123a\"\nmapM conv \"123a\" :: Maybe [Int]\n\n> :t map conv \"123a\"\nmap conv \"123a\" :: [Maybe Int]\n-}\n\nfilterM :: Monad m => (a -> m Bool) -> [a] -> m [a]\nfilterM p [] = return []\nfilterM p (x:xs) = do b <- p x\n                      ys <- filterM p xs\n                      return (if b then x:ys else ys)\n\n\n{-\n\n-- Obtaining the powerset of a list with filterM:\n> filterM (\\x -> [True, False]) [1,2,3]\n[[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]\n\n-}\n\n-- concat generalised to an arbitrary monad:\n\njoin :: Monad m => m (m a) -> m a\njoin mmx = do mx <- mmx\n              x <- mx\n              return x \n\n\n{-\n\n> join [[1,2],[3,4],[5,6]]\n[1,2,3,4,5,6]\n\n> join [[1,2]]\n[1,2]\n\n> join (Just (Just 1))\nJust 1\n\n> join (Just Nothing)\nNothing\n\n> join Nothing\nNothing\n\n------------------ Monad laws ------------------\n\nreturn x >>= f    = f x\nmx >>= return     = mx\n(mx >>= f) >>= g  = mx >>= (\\x -> (f x >>= g))\n\n\n\n-}\n\n", "input": "[42, 42]", "status": "success", "output": "[43,43]"}
{"code": "doubleMe x = x + x\ndoubleUs x y = doubleMe x + doubleMe y {- x y = x * 2 + y * 2 -}\n\ndoubleSmallNumber x = if x > 100 then x else x*2\ndoubleSmallNumber' x = (if x > 100 then x else x*2) + 2\n\na'B = \"A'B cd\"\n\n\n{- \u30ea\u30b9\u30c8\u5185\u5305\u8868\u8a18 -}\nboomBangs xs = [ if x < 10 then \"BOOM!\" else \"BANG!\" | x <- xs, odd x, x /= 9] {- odd(\u5947\u6570) even(\u5076\u6570)-}\n\nlength' xs = sum [1 | _ <- xs]{- length\u95a2\u6570\u3092\u72ec\u81ea\u306b\u5b9a\u7fa9\u3002\u540c\u3058\u6319\u52d5\u3002\u4f7f\u3044\u6368\u3066\u306e\u95a2\u6570_\u3092\uff11\u306b\u3057\u3066\u5168\u3066\u8db3\u3059\u3002 -}\n\n{- \u95a2\u6570\u306b\u660e\u793a\u7684\u306b\u578b\u5ba3\u8a00\u3092\u4e0e\u3048\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002\u578b\u304c\u308f\u304b\u3089\u306a\u3044\u5834\u5408\u306f:t \u3067\u8abf\u3079\u308c\u308b\u3002 -}\nremoveNonUppercase :: [Char] -> [Char] {- \u4e00\u3064\u306e\u6587\u5b57\u5217\u3092\u5f15\u6570\u3068\u3057\u3066\u53d6\u308a\u3001\u5225\u306e\u6587\u5b57\u5217\u3092\u7d50\u679c\u3068\u3057\u3066\u8fd4\u3059 -}\nremoveNonUppercase st = [c | c <- st, c `elem` ['A'..'Z']]{- \u5927\u6587\u5b57\u3060\u3051\u3092\u6b8b\u3059 -}\n\nremoveNonEven xxs = [[x | x <- xs, even x] | xs <- xxs]{- \uff08\u4f8b\uff09removeNonEven [[1,2,3,4],[10,11,12,13]]\u3067\u5947\u6570\u3092\u9664\u3044\u305f\u30ea\u30b9\u30c8\u306e\u30ea\u30b9\u30c8\u4f5c\u6210\u3002\n  \uff08\u5076\u6570\u3060\u3051\u3092\u53d6\u308a\u51fa\u3057\u305f\uff09 -}\n\n{- [1,2,3] \u30ea\u30b9\u30c8 , (1,'a',\"hello\") \u30bf\u30d7\u30eb -}\n{- [(1,2),(3,4,5),(6,7)] \u30da\u30a2\u3068\u30c8\u30ea\u30d7\u30eb\u3092\u6df7\u5728\u3055\u305b\u308b\u3068\u30a8\u30e9\u30fc\u3068\u306a\u308b\u3002\u6570\u306e\u30ea\u30b9\u30c8\u306e\u5834\u5408[[1,2],[3,4,5],[6,7]]\u306f\u30a8\u30e9\u30fc\u306a\u3057\u3002 -}\n{- \u30da\u30a2\u3092\u64cd\u4f5c\u3059\u308b\u305f\u3081\u306e\u95a2\u6570\u3002fst\uff08\u30da\u30a2\u306e\u4e00\u3064\u76ee\u306e\u8981\u7d20\u3092\u8fd4\u3059\uff09\u3001snd\uff08\u30da\u30a2\u306e\u4e8c\u3064\u76ee\u306e\u8981\u7d20\u3092\u8fd4\u3059\uff09\u3002 -}\n{- zip [1..5] ['a'..'e']\u3000\u30da\u30a2\u306e\u30ea\u30b9\u30c8\u3092\u7c21\u5358\u306b\u4f5c\u308bzip\u95a2\u6570\u3002\u9577\u3055\u304c\u9055\u3046\u578b\u540c\u58eb\u306a\u3089\u4f59\u308a\u306f\u7701\u304b\u308c\u308b\u3002\n  zip [1..] ['a'..'e']\u3000\u7121\u9650\u30ea\u30b9\u30c8\u3068\u6709\u9650\u30ea\u30b9\u30c8\u3092zip\u3059\u308b\u3053\u3068\u3082\u3067\u304d\u308b\u3002 -}\n\n{- \u76f4\u89d2\u4e09\u89d2\u5f62\u3092\u898b\u3064\u3051\u308b\u30d7\u30ed\u30b0\u30e9\u30e0 \uff08c\u304c\u659c\u8fba\u3001\uff13\u8fba\u306f\u5168\u3066\u6574\u6570\u3001\u5404\u8fba\u306f\uff11\uff10\u4ee5\u4e0b\u3001\u5468\u56f2\u306e\u9577\u3055\u306f\uff12\uff14\u306b\u7b49\u3057\u3044\u3002\uff09-}\n{- \u307e\u305a\u5404\u8981\u7d20\u304c\uff11\uff10\u4ee5\u4e0b\u306b\u306a\u308b\u3088\u3046\u306a\u30c8\u30ea\u30d7\u30eb\u3092\u751f\u6210\uff0810^3\u3067\uff11\uff10\uff10\uff10\u901a\u308a\uff09 -> \u6b21\u306b\u30d4\u30bf\u30b4\u30e9\u30b9\u306e\u5b9a\u7406\u304c\u6210\u308a\u7acb\u3064\u304b\u3092\u8abf\u3079\u308b\u8ff0\u8a9e\u3092\u8ffd\u52a0\u3057\u3001\n  \u76f4\u89d2\u4e09\u89d2\u5f62\u3067\u306a\u3044\u3082\u306e\u3092\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\uff08a\u304c\u659c\u8fbac\u3092\u8d85\u3048\u306a\u3044\u3088\u3046\u306b\u3001\u76f4\u89d2\u4e09\u89d2\u5f62\u306f\u5fc5\u305a\u659c\u8fba\u304c\u4e00\u756a\u9577\u3044\u306e\u3067\u3002b\u304ca\u3092\u8d85\u3048\u306a\u3044\u3088\u3046\u306b\u3001b>a,a>b\u672c\u8cea\u7684\u306b\u306f\u540c\u3058\u4e09\u89d2\u5f62\u304c\n  \u542b\u307e\u308c\u3066\u3057\u307e\u3046\u306e\u3067\u3002\uff09 -> \u5468\u56f2\u306e\u9577\u3055\u304c\uff12\uff14\u306e\u3082\u306e\u3060\u3051\u3092\u51fa\u529b -}\ntriangles = [(a,b,c) | c <- [1..10], a <- [1..c], b <- [1..a], a^2 + b^2 == c^2, a+b+c == 24]\n\n\n{- Haskell\u306e\u578b\u306b\u3064\u3044\u3066 -}\nfactorial :: Integer -> Integer {- Integer\uff08\u6709\u754c\u3067\u306f\u306a\u3044 7.2\uff09\u3001Int\uff08\u6709\u754c\u3067\u3042\u308b 7\uff09 -}\nfactorial n = product [1..n] {- product\uff08\u968e\u4e57\u3092\u3059\u308b\u95a2\u6570\uff09 -}\n\ncircumference :: Float -> Float {- Float\uff08\u5358\u7cbe\u5ea6\u6d6e\u52d5\u5c0f\u6570\u70b9\u6570\uff09 -}\ncircumference r = 2 * pi * r {- \u5186\u5468\u3092\u6c42\u3081\u308b\u5f0f -}\n\ncircumference' :: Double -> Double {- Double\uff08\u500d\u7cbe\u5ea6\u6d6e\u52d5\u5c0f\u6570\u70b9\u6570\u3002Float\u306e2\u500d\u3002\uff09 -}\ncircumference' r = 2 * pi * r\n\n\n{- \u578b\u30af\u30e9\u30b9 -}\n{- ghci> :t (==) \u300c\u578b\u3092\u8abf\u3079\u305f\u3044\u5834\u5408\u3001\u4ed6\u306e\u95a2\u6570\u306b\u6e21\u3057\u305f\u3044\u5834\u5408\u3001\u524d\u7f6e\u95a2\u6570\u3068\u3057\u3066\u547c\u3073\u51fa\u3057\u305f\u3044\u5834\u5408\u306f\uff08\uff09\u3067\u56f2\u3080\u300d\n  (==) :: (Eq a) => a -> a -> Bool\u3000\u300c\u7b49\u5024\u6027\u95a2\u6570\u306f\u3001\u540c\u3058\u578b\u306e\u4efb\u610f\u306e\uff12\u3064\u306e\u5f15\u6570\u3092\u53d6\u308a\u3001Bool\u3092\u8fd4\u3059\u3002\u5f15\u6570\u306e\uff12\u3064\u306e\u5024\u306e\u578b\u306f\n  Eq\u30af\u30e9\u30b9\u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3067\u306a\u3051\u308c\u3070\u306a\u3089\u3044\u3002\u3068\u8aad\u3080\u3002\u300d -}\n\n{- Eq\u578b\u30af\u30e9\u30b9 -> \u7b49\u5024\u6027\u3092\u30c6\u30b9\u30c8\u3067\u304d\u308b\u578b\u306b\u4f7f\u308f\u308c\u308b\u3002==, /= -}\n\n{- Ord\u578b\u30af\u30e9\u30b9 -> \u5927\u5c0f\u6bd4\u8f03\u3092\u30c6\u30b9\u30c8\u3059\u308b\u3002>, <, >=, <=, compare(5 `compare` 3 -> GT\u300cGreater Than:\uff15\u306f\uff13\u3088\u308a\u5927\u304d\u3044\u300d, 3 `compare` 5 -> LT\u300cLess Than:\uff13\u306f\uff15\u3088\u308a\u5c0f\u3055\u3044\u300d) -}\n\n{- Show\u578b\u30af\u30e9\u30b9 -> \u6587\u5b57\u5217\u3068\u3057\u3066\u8868\u73fe\u3059\u308b\u3002show :: Show a => a -> String -}\n\n{- Read\u578b\u30af\u30e9\u30b9 -> show\u306e\u5bfe\u3092\u306a\u3059\u578b\u30af\u30e9\u30b9\u3002\u6587\u5b57\u5217\u3092\u53d7\u3051\u53d6\u308a\u3001read\u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u306e\u578b\u306e\u5024\u3092\u8fd4\u3059\u3002Read a => String -> a -}\n{- read \"4\"\u3068\u66f8\u3044\u305f\u306e\u3067\u306f\u578b\u3092\u63a8\u8ad6\u3067\u304d\u306a\u3044\u306e\u3067\u4f55\u3092\u8fd4\u305b\u3070\u3044\u3044\u306e\u304b\u308f\u304b\u3089\u305a\u30a8\u30e9\u30fc\u3068\u306a\u308b\u3002\u554f\u984c\u3092\u89e3\u6c7a\u3059\u308b\u305f\u3081\u306b\u306f\u201d\u578b\u6ce8\u91c8\u201d\u3092\u7528\u3044\u308b\u3002\n  \u5f0f\u306e\u7d42\u308f\u308a\u306b::\u3092\u8ffd\u8a18\u3057\u660e\u793a\u7684\u306b\u578b\u3092\u6559\u3048\u3066\u3042\u3052\u308b\u624b\u6bb5\u3002\u4f8b\uff09read \"5\" :: Int -}\n\n{- Enum\u578b\u30af\u30e9\u30b9 -> \u9806\u756a\u306b\u4e26\u3093\u3060\u578b\u3001\u3064\u307e\u308a\u8981\u7d20\u306e\u5024\u3092\u5217\u6319\u3067\u304d\u308b\u578b\u3002\u4f8b\uff09['a'..'e'], succ 'B'\uff08\u5f8c\u8005\u95a2\u6570\uff09, pred 'C'\uff08\u524d\u8005\u95a2\u6570\uff09 -}\n\n{- Bounded\u578b\u30af\u30e9\u30b9 -> \u4e0a\u9650\u4e0b\u9650\u3092\u6301\u3061\u305d\u308c\u305e\u308cminBound, maxBound\u95a2\u6570\u3067\u8abf\u3079\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002maxBound :: Bounded a => a\u3000\u3068\u3044\u3046\u578b\u3092\u6301\u3063\u3066\u3044\u308b\u3002\u3044\u308f\u3070\u591a\u76f8\u5b9a\u6570\u3002 -}\n{- maxBound :: (Bool, Int, Char) -> (True, 2147483647, '\\1114111')\u3000\u30bf\u30d7\u30eb\u5168\u3066\u306e\u69cb\u6210\u8981\u7d20\u304cBounded\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u306a\u3089\u3070\u30bf\u30d7\u30eb\u81ea\u8eab\u3082Bounded\u306b\u306a\u308b\u3002 -}\n\n{- Num\u578b\u30af\u30e9\u30b9 -> \u6570\u306e\u578b\u30af\u30e9\u30b9\u30021, 2, 3(:t 20 -> 20 :: Num a => a\u3000\u591a\u76f8\u5b9a\u6570\u3068\u3057\u3066\u8868\u73fe\u3055\u308c\u3066\u3044\u3066Num\u578b\u30af\u30e9\u30b9\u306e\u4efb\u610f\u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9[Int, Integer, Float, Double]\u3068\u3057\u3066\n  \u632f\u308b\u821e\u3046\u3053\u3068\u304c\u3067\u304d\u308b\u3002) -}\n{- *(\uff12\u3064\u306e\u6570\u3092\u53d7\u3051\u53d6\u3063\u3066\uff11\u3064\u306e\u6570\u3092\u8fd4\u3059Num\u578b\u30af\u30e9\u30b9\u3001\u3053\u308c\u3089\uff13\u3064\u306e\u6570\u306f\u5168\u3066\u540c\u3058\u578b\u3067\u3042\u308b\u3053\u3068\u3092\u793a\u3059\u3002)\n  \u306a\u306e\u3067\u3001(5 :: Int) * (6 :: Integer)\u306f\u578b\u30a8\u30e9\u30fc\u306b\u306a\u308a\u30015 * (6 :: Integer)\u306f\u6b63\u3057\u304f\u52d5\u304f\u3002\uff15\u306fInteger\u3084Int\u3068\u3057\u3066\u632f\u308b\u821e\u3046\u3053\u3068\u304c\u3067\u304d\u308b\u304c\u540c\u6642\u306b\u4e21\u65b9\u306b\u306f\u306a\u308c\u306a\u3044\u3002 -}\n\n{- Float\u578b\u30af\u30e9\u30b9 -> Float\u3068Double\u304c\u542b\u307e\u308c\u308b\u3002\u6d6e\u52d5\u5c0f\u6570\u70b9\u6570\u306b\u4f7f\u3046\u3002sin\u3001cos\u3001sqrt -}\n\n{- Integral\u578b\u30af\u30e9\u30b9 -> \u6570\u306e\u578b\u30af\u30e9\u30b9\u3002Num\u304c\u5b9f\u6570\u3092\u542b\u3080\u5168\u3066\u306e\u6570\u3092\u542b\u3080\u4e00\u65b9\u3001Integral\u306b\u306f\u6574\u6570\uff08\u5168\u4f53\uff09\u306e\u307f\u304c\u542b\u307e\u308c\u308b\u3002Int\u3001Integer\u3001fromIntegral(fromIntegral :: (Integral a, Num b) => a -> b\n  \u8907\u6570\u306e\u578b\u30af\u30e9\u30b9\u5236\u7d04\u304c\u3042\u308b\u3053\u3068\u306b\u6ce8\u76ee\u3002\u8907\u6570\u306e\u578b\u30af\u30e9\u30b9\u5236\u7d04\u3092\u66f8\u304f\u3068\u304d\u306f\u30ab\u30f3\u30de\uff08,\uff09\u3067\u533a\u5207\u3063\u3066\u62ec\u5f27\u3067\u56f2\u3080\u3002) -}\n{- fromIntegral\u306f\u4f55\u3089\u304b\u306e\u6574\u6570\u3092\u5f15\u6570\u306b\u53d6\u308a\u3001\u3082\u3063\u3068\u4e00\u822c\u7684\u306a\u6570\u3092\u8fd4\u3059\u3002\u6574\u6570\u3068\u6d6e\u52d5\u5c0f\u6570\u70b9\u6570\u3092\u4e00\u7dd2\u306b\u4f7f\u3044\u305f\u3044\u6642\u306b\u3068\u3066\u3082\u5f79\u305f\u3064\u3002\n  \u4f8b\u3048\u3070\u3001length\u95a2\u6570\u306fa -> Int\u306e\u3088\u3046\u306a\u578b\u5ba3\u8a00\u3092\u6301\u3063\u3066\u3044\u307e\u3059\u3002\u305d\u306e\u305f\u3081\u30ea\u30b9\u30c8\u306e\u9577\u3055\u3092\u53d6\u5f97\u3057\u3066\u305d\u308c\u306b3.2\u3092\u52a0\u3048\u308b\u3088\u3046\u306a\u5f0f\u306f\u30a8\u30e9\u30fc\u306b\u306a\u308b\u3002\uff08Int\u3068Float\u3092\u8db3\u3057\u5408\u308f\u305b\u308b\u305f\u3081\u3002\uff09\n  \u305d\u308c\u3092\u89e3\u6c7a\u3059\u308b\u305f\u3081\u306bflomIntegral\u3092\u4f7f\u3063\u3066\u3053\u3046\u3059\u308b\u3002fromIntegral (length [1,2,3,4]) + 3.2 -> 7.2 -}\n\n\n{- \u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1 -> \u30d1\u30bf\u30fc\u30f3\u306f\u4e0a\u304b\u3089\u4e0b\u306e\u9806\u306b\u8a66\u3055\u308c\u308b-}\nlucky :: Int -> String\nlucky 7 = \"LUCKY NUMBER SEVEN!\"\nlucky x = \"Sorry, you're out of luck,pal!\"\n\n{- \u305d\u308c\u305e\u308c\u6570\u5b57\u3092\u6587\u5b57\u3067\u51fa\u529b\u3057\u305d\u308c\u4ee5\u5916\u3092\u5225\u306e\u6587\u7ae0\u3067\u51fa\u529b\u3059\u308b -}\n{- \u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u7248 -}\nsayMe :: Int -> String\nsayMe 1 = \"One!\"\nsayMe 2 = \"Two!\"\nsayMe 3 = \"Three!\"\nsayMe 4 = \"Four!\"\nsayMe 5 = \"Five!\"\nsayMe x = \"Not between 1 and 5\"\n\n{- if/then/else\u7248 -}\nsayMe' :: Int -> String\nsayMe' x = if x == 1 then \"One!\"\n  else if x == 2 then \"Two!\"\n  else if x == 3 then \"Three!\"\n  else if x == 4 then \"Four!\"\n  else if x == 5 then \"Five!\"\n  else \"Not between 1 and 5\"\n{- \u30dd\u30a4\u30f3\u30c8\u306f\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u306e\u65b9\u304c\u5358\u7d14\u306b\u66f8\u3051\u308b\u70b9\u3068\"Not bet...\"\u3092\u5148\u982d\u306b\u6301\u3063\u3066\u3053\u306a\u3044\u3053\u3068\u3002\u5148\u982d\u306b\u6301\u3063\u3066\u304d\u305f\u5834\u5408\u3053\u306e\u95a2\u6570\u306f\u5e38\u306b\"Not bet...\"\u3092\u51fa\u529b\u3059\u308b\u3002 -}\n\n{- \u968e\u4e57 product[1..n]\u3092\u518d\u5e30\u7684\uff08\u305d\u306e\u95a2\u6570\u306e\u5b9a\u7fa9\u306e\u4e2d\u3067\u81ea\u5206\u81ea\u8eab\u3092\u547c\u3073\u51fa\u3059\uff09\u306b\u5b9a\u7fa9\u3059\u308b\u3002\n  \u307e\u305a\u300c\uff10\u306e\u968e\u4e57\u306f\uff11\u300d\u3068\u5b9a\u7fa9\u3002\u6b21\u306b\u300c\u3059\u3079\u3066\u306e\u6b63\u306e\u6574\u6570\u306e\u968e\u4e57\u306f\u3001\u305d\u306e\u6574\u6570\u3068\u305d\u308c\u304b\u3089\uff11\u3092\u5f15\u3044\u305f\u3082\u306e\u306e\u968e\u4e57\u306e\u7a4d\u300d\u3068\u5b9a\u7fa9\u3002 -}\nfactorial' :: Int -> Int\nfactorial' 0 = 1\nfactorial' n = n * factorial' (n - 1)\n\n{- \u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u5931\u6557\u4f8b -}\ncharName :: Char -> String\ncharName 'a' = \"Albert\"\ncharName 'b' = \"Broseph\"\ncharName 'c' = \"Cecil\"\n{- \u3053\u306e\u95a2\u6570\u306f\u4e88\u671f\u3057\u306a\u3044\u5024\u304c\u5165\u529b\u3055\u308c\u308b\u3068\u30a8\u30e9\u30fc\u3068\u306a\u308b\u3002 -}\n{- ghci> charName 'h'\u306a\u3069a,b,c\u4ee5\u5916\u3067\u30a8\u30e9\u30fc\u3002Non-exhaustive patterns\uff08\u30d1\u30bf\u30fc\u30f3\u304c\u7db2\u7f85\u7684\u3067\u306a\u3044\uff09 -}\ncharName x = \"UNKNOWN\"{- \u3053\u308c\u3067\u30a8\u30e9\u30fc\u3092\u56de\u907f\u3067\u304d\u308b\u3002 -}\n\n{- \u30bf\u30d7\u30eb\u306e\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1 -}\n{- \u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u3067\u306a\u3044\u5834\u5408 -}\naddVectors :: (Double, Double) -> (Double, Double) -> (Double, Double)\naddVectors a b = (fst a + fst b, snd a + snd b)\n{- a\u3068\u3044\u3046\u30bf\u30d7\u30eb\u306e\u6700\u521d\u306e\u5024\uff08\uff12\u756a\u76ee\u306e\u5024\uff09\u3068\u3001b\u3068\u3044\u3046\u30bf\u30d7\u30eb\u306e\u6700\u521d\u306e\u5024\uff08\uff12\u756a\u76ee\u306e\u5024\uff09\u3092\u8db3\u3059\u95a2\u6570\u3002\u5f15\u6570\u304ca\u3068\u304bb\u3068\u304b\u3058\u3083\u306a\u3093\u306a\u306e\u304b\u89e3\u3089\u306a\u3044\uff08\u30bf\u30d7\u30eb\u306a\u306e\u306b\uff09\u3002 -}\n{- \u3053\u308c\u3092\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u3092\u4f7f\u3063\u3066\u7f6e\u304d\u63db\u3048\u308b\u3002\u2193 -}\naddVectors' :: (Double, Double) -> (Double, Double) -> (Double, Double)\naddVectors' (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)\n{- \u3053\u3061\u3089\u306e\u65b9\u304c\u5f15\u6570\u304c\u30bf\u30d7\u30eb\u3067\u3042\u308b\u3053\u3068\u304c\u308f\u304b\u308a\u3084\u3059\u304f\u3001\u30bf\u30d7\u30eb\u306e\u8981\u7d20\u306b\u9069\u5207\u306a\u540d\u524d\u304c\u4ed8\u3044\u3066\u3044\u308b\u306e\u3067\u8aad\u307f\u3084\u3059\u3044\u3002\u3053\u308c\u3067\u5168\u3066\u306b\u5408\u81f4\u3059\u308b\u30d1\u30bf\u30fc\u30f3\u306b\u306a\u3063\u3066\u3044\u308b\u3002 -}\n{- Double\u306e\u30da\u30a2\u304c\uff12\u3064\u5f15\u6570\u306b\u6765\u308b\u3053\u3068\u306f\u4fdd\u8a3c\u6e08\u307f\u3002 -}\n{- fst, snd\u3068\u30da\u30a2\u306e\u8981\u7d20\u3092\u5206\u89e3\u3067\u304d\u308b\u304c\u30c8\u30ea\u30d7\u30eb\u306b\u5bfe\u3057\u3066\u306f\uff1f\u30c8\u30ea\u30d7\u30eb\u4ee5\u964d\u306f\u72ec\u81ea\u306b\u5b9a\u7fa9\u3059\u308b\u3002 -}\nfirst :: (a, b, c, d) -> a\nfirst (x, _, _, _) = x\n\nsecond :: (a, b, c, d) -> b\nsecond (_, y, _, _) = y\n\nthird :: (a, b, c, d) -> c\nthird (_, _, z, _) = z\n\nfourth :: (a, b, c, d) -> d\nfourth (_, _, _, s) = s\n{- \u30ea\u30b9\u30c8\u5185\u5305\u8868\u8a18\u306e\u6642\u306b\u3082\u89e6\u308c\u305f\u304c\u3001_\u306f\u4f7f\u3044\u6368\u3066\u306e\u5909\u6570\u3092\u8868\u3059\u305f\u3081\u306b\u7528\u3044\u308b\u3002 -}\n\n{- \u30ea\u30b9\u30c8\u306e\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u3068\u30ea\u30b9\u30c8\u5185\u5305\u8868\u8a18 -}\n{- \u30ea\u30b9\u30c8\u5185\u5305\u8868\u8a18\u3067\u3082\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\n  ghci> let xs = [(1,3),(4,3),(2,4),(5,3),(5,6),(3,1)]\n  ghci> [a+b | (a,b) <- xs]\n  [4,7,6,8,11,4] -}\n{- \u30ea\u30b9\u30c8\u5185\u5305\u8868\u8a18\u306e\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u3067\u306f\u5931\u6557\u3057\u305f\u3089\u5358\u306b\u6b21\u306e\u8981\u7d20\u306b\u9032\u307f\u3001\u5931\u6557\u3057\u305f\u8981\u7d20\u306f\u7d50\u679c\u306e\u30ea\u30b9\u30c8\u306b\u542b\u307e\u308c\u307e\u305b\u3093\u3002\n  ghci> [x*100+3 | (x, 3) <- xs](\u30ea\u30b9\u30c8xs\u306e(x,3)\u306b\u8a72\u5f53\u3059\u308b\u30da\u30a2\u306ex\u306e\u5024\u3092\u5229\u7528\u3059\u308b\u3002\u305d\u308c\u4ee5\u5916\u306e\u30da\u30a2\u306f\u30b9\u30eb\u30fc\u3002)\n  [103,403,503] -}\n{- [1,2,3]\u306f(1:(2:(3:[])))\u306e\u69cb\u6587\u7cd6\u8863 -}\n\n{- \u30ea\u30b9\u30c8\u306b\u5bfe\u3059\u308b\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u3092\u4f7f\u3063\u3066\u72ec\u81ea\u306bhead\u95a2\u6570\u3092\u5b9f\u88c5\u3059\u308b -}\nhead' :: [a] -> a\nhead' [] = error \"Can't call head on an empty list, dummy!\"\nhead' (x:_) = x {- x:xs\u3068\u3044\u3046\u30d1\u30bf\u30fc\u30f3\u3092\u518d\u8d77\u95a2\u6570\u3068\u4e00\u7dd2\u306b\u3088\u304f\u4f7f\u3044\u307e\u3059\u304c\u3001:\u3092\u542b\u3080\u30d1\u30bf\u30fc\u30f3\u306f\u9577\u3055\u304c\uff11\u4ee5\u4e0a\u306e\u30ea\u30b9\u30c8\u306b\u5bfe\u3057\u3066\u3057\u304b\u5408\u81f4\u3057\u306a\u3044\u3002 -}\n{- \u5b9a\u7fa9\u306b\u3042\u308b\u3088\u3046\u306b\u8907\u6570\u306e\u5909\u6570\uff08\u305d\u306e\u3046\u3061\u306e\uff11\u3064\u304c_\u306e\u5834\u5408\u3082\uff09\u306b\u675f\u7e1b\u3057\u305f\u3044\u6642\u306f\u4e38\u62ec\u5f27\u3067\u56f2\u307e\u306a\u3051\u308c\u3070\u30b7\u30f3\u30bf\u30c3\u30af\u30b9\u30a8\u30e9\u30fc\u306b\u306a\u308b\u3002error\u95a2\u6570\u306f\u307f\u3060\u308a\u306b\u4f7f\u308f\u306a\u3044\u307b\u3046\u304c\u3044\u3044\u3002 -}\n\n{- \u30ea\u30b9\u30c8\u306e\u8981\u7d20\u3092\u56de\u308a\u304f\u3069\u304f\u51fa\u529b\u3059\u308b\u95a2\u6570 -}\ntell :: (Show a) => [a] -> String\ntell [] = \"The list is empty\"\ntell (x:[]) = \"The list has one element: \" ++ show x\ntell (x:y:[]) = \"The list has two element: \" ++ show x ++ \" and \" ++ show y\ntell (x:y:_) = \"This list is long. The first two elements are: \" ++ show x ++ \" and \" ++ show y\n{- (x:[])\u3068(x:y:[])\u306f\u305d\u308c\u305e\u308c[x]\u53ca\u3073[x,y]\u3068\u66f8\u304f\u3053\u3068\u3082\u3067\u304d\u308b\u3002\u3057\u304b\u3057(x:y:_)\u3092\u89d2\u62ec\u5f27\u3092\u4f7f\u3063\u3066\u66f8\u304d\u76f4\u3059\u3053\u3068\u306f\u3067\u304d\u306a\u3044\u3002\u3053\u306e\u30d1\u30bf\u30fc\u30f3\u306f\u9577\u3055\u304c\uff12\u4ee5\u4e0a\u306e\u4efb\u610f\u306e\u30ea\u30b9\u30c8\u3068\u5408\u81f4\u3059\u308b\u305f\u3081\u3002 -}\n{- tell\u95a2\u6570\u306f\u3001\u7a7a\u306e\u30ea\u30b9\u30c8\u306b\u3082\u3001\u5358\u4e00\u8981\u7d20\u306e\u30ea\u30b9\u30c8\u306b\u3082\u3001\uff12\u8981\u7d20\u306e\u30ea\u30b9\u30c8\u306b\u3082\u3001\u3042\u308b\u3044\u306f\u3082\u3063\u3068\u591a\u304f\u306e\u8981\u7d20\u306e\u30ea\u30b9\u30c8\u306b\u3082\u5408\u81f4\u3059\u308b\u306e\u3067\u5b89\u5168\u306b\u4f7f\u3048\u308b\u3002 -}\n{- \u4e88\u671f\u3057\u306a\u3044\u30ea\u30b9\u30c8\u304c\u4e0e\u3048\u3089\u308c\u305f\u6642\u4f55\u304c\u8d77\u3053\u308b\u306e\u304b\uff1f\u4f8b\u3048\u3070\uff13\u8981\u7d20\u306e\u30ea\u30b9\u30c8\u3092\u6271\u3046\u65b9\u6cd5\u3057\u304b\u77e5\u3089\u306a\u3044\u95a2\u6570\u3092\u5b9a\u7fa9\u3057\u305f\u5834\u5408\u3069\u3046\u306a\u308b\u304b\u3002 -}\nbadAdd :: (Num a) => [a] -> a\nbadAdd (x:y:z:[]) = x + y + z\n{- \uff13\u8981\u7d20\u4ee5\u5916\u306f\u30a8\u30e9\u30fc\u306b\u306a\u308b\u3002 -}\n{- \u30ea\u30b9\u30c8\u306b\u5bfe\u3059\u308b\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u306e\u6ce8\u610f\u3068\u3057\u3066++\u6f14\u7b97\u5b50\uff08\u4e8c\u3064\u3092\u3064\u306a\u3052\u308b\u6f14\u7b97\u5b50\uff09\u306f\u4f7f\u3048\u306a\u3044\u3068\u3044\u3046\u3053\u3068\u3002\u4f8b\u3048\u3070\u30d1\u30bf\u30fc\u30f3(xs ++ ys)\u306b\u5bfe\u3057\u3066\u5408\u81f4\u3055\u305b\u3088\u3046\u306b\u3082\u3001\n  \u30ea\u30b9\u30c8\u306e\u3069\u306e\u90e8\u5206\u3092xs\u306b\u5408\u81f4\u3055\u305b\u3066\u3001\u3069\u306e\u90e8\u5206\u3092ys\u306b\u5408\u81f4\u3055\u305b\u308c\u3070\u3044\u3044\u304bHaskell\u306b\u4f1d\u3048\u3088\u3046\u304c\u306a\u3044\u304b\u3089\u3002-}\n\n{- as\u30d1\u30bf\u30fc\u30f3 -> \u30d1\u30bf\u30fc\u30f3\u3092\u5206\u89e3\u3057\u3064\u3064\u3001\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u306e\u5bfe\u8c61\u306b\u306a\u3063\u305f\u5024\u81ea\u4f53\u3082\u53c2\u7167\u306b\u3057\u305f\u3044\u6642\u306b\u4f7f\u3046\u3002\u666e\u901a\u306e\u30d1\u30bf\u30fc\u30f3\u306e\u524d\u306b\u540d\u524d\u3068@\u3092\u8ffd\u52a0\u3059\u308b\u3002 -}\n{- xs@(x:y:ys)\u306e\u3088\u3046\u306aas\u30d1\u30bf\u30fc\u30f3\u3092\u4f5c\u308c\u308b\u3002x:y:ys\u306b\u5408\u81f4\u3059\u308b\u3082\u306e\u3068\u5168\u304f\u540c\u3058\u3082\u306e\u306b\u5408\u81f4\u3057\u3064\u3064\u3001x:y:ys\u3068\u30bf\u30a4\u30d7\u3057\u306a\u304f\u3066\u3082\u3001xs\u3067\u5143\u306e\u30ea\u30b9\u30c8\u5168\u4f53\u306b\u30a2\u30af\u30bb\u30b9\u3059\u308b\u3053\u3068\u3082\u3067\u304d\u308b\u3002 -}\nfirstLetter :: String -> String\nfirstLetter \"\" = \"Empty string, whoops!\"\nfirstLetter all@(x:y:xs) = \"The first letter of \" ++ all ++ \" is \" ++ [x]{- x -> 'D', y -> 'r' -}\n{- *Main> firstLetter \"Dracula\"\n  \"The first letter of Dracula is D\" -}\n\n\n{- \u5834\u5408\u5206\u3051\u3057\u3066\u3001\u304d\u3063\u3061\u308a\u30ac\u30fc\u30c9\uff01 -> \u95a2\u6570\u3092\u5b9a\u7fa9\u3059\u308b\u969b\u3001\u5f15\u6570\u306e\u69cb\u9020\u3067\u5834\u5408\u5206\u3051\u3059\u308b\u6642\u306b\u306f\u30d1\u30bf\u30fc\u30f3\u3092\u4f7f\u3046\u3002\u5f15\u6570\u306e\u5024\u304c\u6e80\u305f\u3059\u6027\u8cea\u3067\u5834\u5408\u5206\u3051\u3059\u308b\u6642\u306b\u306f\u3001\u30ac\u30fc\u30c9\u3092\u4f7f\u3046\u3002\u6027\u8cea\u3067\u5834\u5408\u5206\u3051\n\u3000\u3000\u3068\u3046\u3044\u3046\u70b9\u3067if\u3068\u30ac\u30fc\u30c9\u306f\u4f3c\u3066\u3044\u308b\u3002\u305f\u3060\u3057\u3001\u8907\u6570\u306e\u6761\u4ef6\u304c\u3042\u308b\u6642\u306b\u306f\u30ac\u30fc\u30c9\u306e\u65b9\u304cif\u3088\u308a\u53ef\u8aad\u6027\u304c\u9ad8\u304f\u3001\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u3068\u306e\u76f8\u6027\u3082\u629c\u7fa4\u3002 -}\n\n{- BMI\u3092\u8a08\u7b97\u3059\u308b\u95a2\u6570\u3067\u306f\u306a\u304f\u3001\u8a08\u7b97\u6e08\u307f\u306eBMI\u3092\u53d7\u3051\u53d6\u3063\u3066\u5fe0\u544a\u3059\u308b\u3060\u3051\u306e\u95a2\u6570\u3002Double\u3060\u3068\u6570\u304c\u591a\u304f\u3066\u9762\u5012\u306a\u306e\u3067Float\u306b\u5909\u66f4\u3002 -}\nbmiTell :: Float -> String\nbmiTell bmi\n  | bmi <= 18.5 = \"You're underweight, you emo, you!\"\n  | bmi <= 25.0 = \"You're supposedly normal. Pffft, I bet you're ugly!\"\n  | bmi <= 30.0 = \"You're fat! Lose some weight, fatty!\"\n  | otherwise   = \"You're a whale, congratulation!\"\n{- \u30ac\u30fc\u30c9\u306b\u306f\u3001\u30d1\u30a4\u30d7\u6587\u5b57\uff08|\uff09\u3068\u305d\u308c\u306b\u7d9a\u304f\u300e\u771f\u7406\u5024\u5f0f\u300f\u3001\u3055\u3089\u306b\u305d\u306e\u5f0f\u304cTrue\u306b\u8a55\u4fa1\u3055\u308c\u305f\u6642\u306b\u4f7f\u308f\u308c\u308b\u95a2\u6570\u306e\u672c\u4f53\u304c\u7d9a\u304f\u3002\n\u3000\u3000\u5f0f\u304cFalse\u306b\u8a55\u4fa1\u3055\u308c\u305f\u3089\u3001\u305d\u306e\u6b21\u306e\u30ac\u30fc\u30c9\u306e\u8a55\u4fa1\u306b\u79fb\u308b\u3002\u3053\u306e\u7e70\u308a\u8fd4\u3057\u3002\u30a4\u30f3\u30c7\u30f3\u30c8\u3059\u308b\u3002\n\u3000\u3000\u95a2\u6570\u306e\u5b9a\u7fa9\u304b\u3089\u3057\u3066\u3001\u9577\u3044if/else\u306e\u9023\u9396\u306b\u306a\u308b\u3088\u3046\u306a\u66f8\u304d\u65b9\u304c\u907f\u3051\u3089\u308c\u306a\u3044\u5834\u5408\u306a\u3069\u306fif\u3088\u308a\u30ac\u30fc\u30c9\u3092\u4f7f\u3046\u3068\u53ef\u8aad\u6027\u304c\u9ad8\u3044\u3002\n\u3000\u3000\u5927\u62b5\u95a2\u6570\u306e\u6700\u5f8c\u306e\u30ac\u30fc\u30c9\u306f\u5168\u3066\u3092\u30ad\u30e3\u30c3\u30c1\u3059\u308botherwise\u306b\u306a\u3063\u3066\u3044\u308b\u3002\u5168\u3066\u306e\u30ac\u30fc\u30c9\u304cFalse\u306b\u8a55\u4fa1\u3055\u308c\u3066\u6700\u5f8c\u306botherwise\u3082\u306a\u304b\u3063\u305f\u306a\u3089\n\u3000\u3000\u8a55\u4fa1\u306f\u5931\u6557\u3057\u3066\u6b21\u306e\u30d1\u30bf\u30fc\u30f3\u306b\u79fb\u308b\u3002\uff08\u3053\u308c\u304c\u30d1\u30bf\u30fc\u30f3\u3068\u30ac\u30fc\u30c9\u306e\u76f8\u6027\u304c\u60aa\u3044\u7406\u7531\u3002\uff09\u9069\u5207\u306a\u30d1\u30bf\u30fc\u30f3\u304c\u898b\u3064\u304b\u3089\u306a\u3051\u308c\u3070\u30a8\u30e9\u30fc\u304c\u6295\u3052\u3089\u308c\u308b\u3002 -}\n\n{- \u8eab\u9577\u3068\u4f53\u91cd\u3092\u53d7\u3051\u53d6\u3063\u3066BMI\u306e\u8a08\u7b97\u3082\u3059\u308b\u3088\u3046\u306b\u5909\u66f4\u3057\u305f\u95a2\u6570\u3002\u30d7\u30e9\u30b9\u3001show\u95a2\u6570\u3067BMI\u306e\u7d50\u679c\u3082\u8868\u793a\u3059\u308b\u3088\u3046\u306b\u3057\u305f\u3002 -}\nbmiTell' :: Float -> Float -> String\nbmiTell' weight height\n  | weight / height ^ 2 <= 18.5 = show (weight / height ^ 2) ++ \"! You're underweight, you emo, you!\"\n  | weight / height ^ 2 <= 25.0 = show (weight / height ^ 2) ++ \". You're supposedly normal. Pffft , I bet you're ugly!\"\n  | weight / height ^ 2 <= 30.0 = show (weight / height ^ 2) ++ \"? You're fat! Lose some weight, fatty!\"\n  | otherwise                   = show (weight / height ^ 2) ++ \"!? You're whale, congratulation!\"\n\n{- max\u95a2\u6570\uff08\u5927\u5c0f\u6bd4\u8f03Ord\u578b\u30af\u30e9\u30b9\uff09\u3092\u72ec\u81ea\u306b\u5b9a\u7fa9\u3002 -}\nmax' :: (Ord a) => a -> a -> a\nmax' a b\n  | a <= b    = b\n  | otherwise = a\n\n{- compare\u95a2\u6570\uff08\u540c\u3058\u304f\u6bd4\u8f03\uff09\u3092\u72ec\u81ea\u306b\u5b9a\u7fa9\u3002 -}\na `myCompare` b\n  | a == b    = EQ {- a is EQual to b -}\n  | a <= b    = LT {- a is Less Than b -}\n  | otherwise = GT {- a is Greater Than b -}\n\n{- where -}\n{- \u4e0a\u306eBMI\u8a08\u7b97\u95a2\u6570\u3092\u7e70\u308a\u8fd4\u3057\u3092\u907f\u3051\u308b\u305f\u3081\u3001where\u30ad\u30fc\u30ef\u30fc\u30c9\u3092\u4f7f\u3063\u3066\u5909\u6570\u306b\u5024\u3092\u675f\u7e1b\u3057\u3066\u7121\u99c4\u3092\u7701\u304f\u3002 -}\nbmiTell2 :: Float -> Float -> String\nbmiTell2 weight height\n  | bmi <= skinny = show bmi ++ \"! You're underweight, you emo, you!\"\n  | bmi <= normal = show bmi ++ \". You're supposedly normal. Pffft , I bet you're ugly!\"\n  | bmi <= fat    = show bmi ++ \"? You're fat! Lose some weight, fatty!\"\n  | otherwise     = show bmi ++ \"!? You're whale, congratulation!\"\n  where bmi = weight / height ^ 2\n        skinny = 18.5\n        normal = 25.0\n        fat    = 30.0\n{- BMI\u306e\u8a08\u7b97\u65b9\u6cd5\u3092\u5909\u3048\u305f\u304f\u306a\u3063\u3066\u3082\u4e00\u7b87\u6240\u3092\u5909\u3048\u308b\u3060\u3051\u3067\u6e08\u3080\u3002\u305d\u308c\u304b\u3089\u5024\u306b\u540d\u524d\u304c\u3064\u304f\u306e\u3067\u53ef\u8aad\u6027\u3082\u4e0a\u304c\u308a\u3001\u5024\u304c\u4e00\u5ea6\u3057\u304b\u8a08\u7b97\u3055\u308c\u306a\u3044\u306e\u3067\u30d7\u30ed\u30b0\u30e9\u30e0\u304c\u65e9\u304f\u306a\u308b\u3002 -}\n{- where\u30d6\u30ed\u30c3\u30af\u306e\u4e2d\u306e\u5168\u3066\u306e\u5909\u6570\u306e\u30a4\u30f3\u30c7\u30f3\u30c8\u306f\u63c3\u3048\u308b\u3002\u305a\u308c\u308b\u3068Haskell\u304c\u6df7\u4e71\u3057\u3066\u3057\u307e\u3044\u3001\u30d6\u30ed\u30c3\u30af\u306e\u7bc4\u56f2\u3092\u6b63\u3057\u304f\u8a8d\u8b58\u3057\u3066\u304f\u308c\u306a\u3044\u3002 -}\n\n{- where\u306e\u30b9\u30b3\u30fc\u30d7 -> where\u7bc0\u3067\u5b9a\u7fa9\u3057\u305f\u5909\u6570\u306f\u3001\u305d\u306e\u95a2\u6570\u304b\u3089\u3057\u304b\u898b\u3048\u306a\u3044\u306e\u3067\u3001\u4ed6\u306e\u95a2\u6570\u306e\u540d\u524d\u7a7a\u9593\u3092\u6c5a\u67d3\u3059\u308b\u5fc3\u914d\u304c\u306a\u3044\u3002\n  \u8907\u6570\u306e\u7570\u306a\u308b\u95a2\u6570\u304b\u3089\u898b\u3048\u308b\u5fc5\u8981\u306e\u3042\u308b\u5909\u6570\u3092\u5b9a\u7fa9\u3057\u305f\u3044\u5834\u5408\u306f\u3001\u30b0\u30ed\u30fc\u30d0\u30eb\u306b\u5b9a\u7fa9\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u3002\u307e\u305f\u3001where\u306b\u3088\u308b\u675f\u7e1b\u306f\u95a2\u6570\u306e\u9055\u3046\u30d1\u30bf\u30fc\u30f3\u306e\u672c\u4f53\u3067\u306f\u5171\u6709\u3055\u308c\u306a\u3044\u3002 -}\n{- \u540d\u524d\u3092\u5f15\u6570\u306b\u53d6\u308a\u3001\u305d\u306e\u540d\u524d\u3092\u8a8d\u8b58\u3067\u304d\u305f\u5834\u5408\u306b\u306f\u4e0a\u54c1\u306a\u6328\u62f6\u3092\u3001\u305d\u3046\u3067\u306a\u3051\u308c\u3070\u4e0b\u54c1\u306a\u6328\u62f6\u3092\u8fd4\u3059\u95a2\u6570\u3002\n\u3000greet :: String -> String\n  greet \"Juan\" = niceGreeting ++ \" Juan!\"\n  greet \"Fernando\" = niceGreeting ++ \" Fernando!\"\n  greet name = badGreeting ++ \" \" ++ name\n    where niceGreeting = \"Hello! So very nice to see you,\"\n          badGreeting  = \"Oh! Pfft. It's you.\"\n  \u3053\u306e\u95a2\u6570\u306f\u66f8\u3044\u305f\u901a\u308a\u306b\u306f\u52d5\u304b\u306a\u3044\u3002where\u306e\u675f\u7e1b\u306f\u9055\u3046\u30d1\u30bf\u30fc\u30f3\u306e\u95a2\u6570\u672c\u4f53\u3067\u5171\u6709\u3055\u308c\u305a\u3001where\u306e\u675f\u7e1b\u3067\u306e\u540d\u524d\u306f\u6700\u5f8c\u306e\u672c\u4f53\u304b\u3089\u3057\u304b\u898b\u3048\u306a\u3044\u304b\u3089\u3002\n  \u3053\u306e\u95a2\u6570\u3092\u6b63\u3057\u304f\u52d5\u304f\u3088\u3046\u306b\u3059\u308b\u306b\u306f\u3001bad\u3068nice\u306f\u30b0\u30ed\u30fc\u30d0\u30eb\u306b\u5b9a\u7fa9\u3057\u306a\u304f\u3066\u306f\u306a\u3089\u306a\u3044\u3002 -}\nbadGreeting :: String\nbadGreeting = \"Oh! Pfft. It's you.\"\n\nniceGreeting :: String\nniceGreeting = \"Hello! So very nice to see you,\"\n\ngreet :: String -> String\ngreet \"Juan\" = niceGreeting ++ \" Juan!\"\ngreet \"Fernando\" = niceGreeting ++ \" Fernando!\"\ngreet name = badGreeting ++ \" \" ++ name\n\n{- \u8ad6\u7406\u548c(A||B,A\u304cTrue\u306e\u6642\u5e38\u306bTrue\u3001A\u304cFalse\u306e\u6642B\u306b\u7b49\u3057\u3044\u3001A\u304cundefined\u306e\u6642\u5e38\u306bundefined\u3002) -}\nlogicalSum :: Int -> Int -> String\nlogicalSum x y = if x == 1 then \"1\"\n  else if x == 0 then show y\n  else \"Undefined\" {- x == undefined -> undefined -}\n\n{- \u8ad6\u7406\u7a4d(A&&B,A\u304cTrue\u306e\u6642B\u306b\u7b49\u3057\u3044\u3001A\u304cFalse\u306e\u6642\u5e38\u306bFalse\u3001A\u304cundefined\u306e\u6642\u5e38\u306bundefined\u3002) -}\nlogicalProduct :: Int -> Int -> String\nlogicalProduct x y = if x == 1 then show y\n  else if x == 0 then \"0\"\n  else \"Undefined\" {- x == undefined -> undefined -}\n\n{- \u66dc\u65e5\u8a08\u7b97\u95a2\u6570(x\u65e5\u30687\u306e\u5270\u4f59) -}\ndayofFuture :: Int -> String\ndayofFuture x\n  | dayCalc == 0 = \"Sunday\"\n  | dayCalc == 1 = \"Monday\"\n  | dayCalc == 2 = \"Tuesday\"\n  | dayCalc == 3 = \"Wednesday\"\n  | dayCalc == 4 = \"Thursday\"\n  | dayCalc == 5 = \"Friday\"\n  | dayCalc == 6 = \"Saturday\"\n  | otherwise    = \"Woops!\"\n  where dayCalc = x `mod` 7\n\n{- \u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u3068where -}\n{- where\u306e\u675f\u7e1b\u306e\u4e2d\u3067\u3082\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u3092\u4f7f\u3046\u3053\u3068\u304c\u3067\u304d\u308b\u3002\u4e0a\u306eBMI\u95a2\u6570\u306ewhere\u7bc0\u3092\u6b21\u306e\u3088\u3046\u306b\u66f8\u3051\u308b\u3002\n  where bmi = weight / height ^ 2\n        (skinny, normal, fat) = (18.5, 25.0, 30.0) -}\n\n{- \u30d5\u30a1\u30fc\u30b9\u30c8\u30cd\u30fc\u30e0\u3068\u30e9\u30b9\u30c8\u30cd\u30fc\u30e0\u3092\u53d7\u3051\u53d6\u3063\u3066\u30a4\u30cb\u30b7\u30e3\u30eb\u3092\u8fd4\u3059\u95a2\u6570\uff08\u95a2\u6570\u3092\u547c\u3073\u51fa\u3059\u969b\u306b\u540d\u524d\u3092\"\"\u3092\u3064\u3051\u305a\u306b\u5f15\u6570\u3068\u3057\u3066\u66f8\u3044\u3066\u3057\u307e\u3044\u30a8\u30e9\u30fc\u3002\u6587\u5b57\u5217\u306a\u306e\u3067\"Yusuke\" \"Tanabe\"\n\u3000\u3068\u3057\u306a\u3044\u3068\u30c0\u30e1\u3002\uff09\u30a8\u30e9\u30fc\"Not in scope: 'Yusuke' -> \u5909\u6570\u304c\u898b\u5f53\u305f\u3089\u306a\u3044\u3002\" -}\ninitials :: String -> String -> String\ninitials firstname lastname = [f] ++ \". \" ++ [l] ++ \".\"\n  where (f:_) = firstname\n        (l:_) = lastname\n{- \u4e0b\u306e\u4f8b\u306e\u3088\u3046\u306b\u95a2\u6570\u306e\u5f15\u6570\u306e\u3068\u3053\u308d\u3067\u76f4\u63a5\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u3059\u308b\u3053\u3068\u3082\u3067\u304d\u3001\u305d\u306e\u65b9\u304c\u77ed\u304f\u3066\u53ef\u8aad\u6027\u3082\u9ad8\u304f\u306a\u308b\u53ef\u80fd\u6027\u304c\u3042\u308b\u304c\u3001\u3053\u306e\u4e0a\u306e\u4f8b\u306e\u3088\u3046\u306bwhere\u306e\u675f\u7e1b\u3067\u3082\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u304c\u4f7f\u3048\u308b\u3002 -}\ninitials' :: String -> String -> String\ninitials' (f:_) (l:_) = [f] ++ \". \" ++ [l] ++ \".\"\n\n{- where\u30d6\u30ed\u30c3\u30af\u306e\u4e2d\u3067\u306f\u5b9a\u6570\u3060\u3051\u3067\u306f\u306a\u304f\u95a2\u6570\u3082\u5b9a\u7fa9\u3067\u304d\u308b\u3002\u4f53\u91cd\u3068\u8eab\u9577\u306e\u30da\u30a2\u306e\u30ea\u30b9\u30c8[(Double,Double)]\u3092\u53d7\u3051\u53d6\u3063\u3066BMI\u306e\u30ea\u30b9\u30c8[Double]\u3092\u8fd4\u3059\u95a2\u6570\u3002 -}\n{- \u3053\u306e\u4f8b\u3067bmi\u3092\u5b9a\u6570\u3067\u306f\u306a\u304f\u95a2\u6570\u3068\u3057\u3066\u5c0e\u5165\u3057\u305f\u306e\u306f\u3001calcBmis\u95a2\u6570\u306e\u5f15\u6570\u306b\u5bfe\u3057\u3066\uff11\u3064\u306eBMI\u3092\u8a08\u7b97\u3059\u308b\u306e\u3067\u306f\u306a\u304f\u3001\u95a2\u6570\u306b\u6e21\u3055\u308c\u305f\u30ea\u30b9\u30c8\u306e\u8981\u7d20\u305d\u308c\u305e\u308c\u306b\n\u3000\u5bfe\u3057\u3066\u3001\u7570\u306a\u308bBMI\u3092\u8a08\u7b97\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u304b\u3089\u3002 -}\ncalcBmis :: [(Double,Double)] -> [Double]\ncalcBmis xs = [bmi w h | (w, h) <- xs]\n  where bmi weight height = weight / height ^ 2\n{- *Main> calcBmis[(55, 1.74),(95,1.65)]\n  [18.166204254194742,34.894398530762174] -}\n\n{- let It Be -> let\u5f0f\u306fwhere\u7bc0\u306b\u4f3c\u3066\u3044\u308b\u3002where\u306f\u95a2\u6570\u306e\u7d42\u308f\u308a\u3067\u5909\u6570\u3092\u675f\u7e1b\u3057\u3001\u305d\u306e\u5909\u6570\u306f\u30ac\u30fc\u30c9\u3092\u542b\u3080\u95a2\u6570\u5168\u4f53\u304b\u3089\u898b\u3048\u308b\u3002\n\u3000\u305d\u308c\u306b\u5bfe\u3057\u3066let\u5f0f\u306f\u3069\u3053\u3067\u3082\u5909\u6570\u3092\u675f\u7e1b\u3067\u304d\u3001let\u81ea\u8eab\u3082\u5f0f\u306b\u306a\u308b\u3002\u3057\u304b\u3057\u3001let\u5f0f\u304c\u4f5c\u308b\u675f\u7e1b\u306f\u5c40\u6240\u7684\u3067\u3001\u30ac\u30fc\u30c9\u9593\u3067\u5171\u6709\u3055\u308c\u306a\u3044\u3002\n\u3000let\u5f0f\u3067\u3082\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u304c\u4f7f\u3048\u308b\u3002 -}\n{- \u5186\u67f1\u306e\u8868\u9762\u7a4d\u3092\u9ad8\u3055\u3068\u534a\u5f84\u304b\u3089\u6c42\u3081\u308b\u95a2\u6570 -}\ncylinder :: Double -> Double -> Double\ncylinder r h =\n  let sideArea = 2 * pi * r * h\n      topArea = pi * r ^ 2\n  in sideArea + 2 * topArea\n{- let\u5f0f\u306f let bindings in expression\u3068\u3044\u3046\u5f62\u3092\u3068\u308b\u3002let\u3067\u5b9a\u7fa9\u3057\u305f\u5909\u6570\u306f\u305d\u306elet\u5f0f\u5168\u4f53\u304b\u3089\u898b\u3048\u308b\u3002\u3082\u3061\u308d\u3093where\u3067\u3082\u540c\u3058\u3082\u306e\u304c\u5b9a\u7fa9\u3067\u304d\u308b\u3002\n  let\u3068where\u306e\u9055\u3044\u3068\u306f\uff1flet\u5f0f\u306f\u305d\u306e\u540d\u306e\u901a\u308a\u300c\u5f0f\u300d\u3067\u3001where\u7bc0\u306f\u305d\u3046\u3058\u3083\u306a\u3044\u3068\u3044\u3046\u3068\u3053\u308d\u3002\u300c\u5f0f\u3067\u3042\u308b\u300d\u3068\u3044\u3046\u3053\u3068\u306f\u305d\u308c\u304c\u300c\u5024\u3092\u6301\u3064\u300d\u3068\u3044\u3046\u3053\u3068\u3002\n  \u3064\u307e\u308alet\u5f0f\u306f\u30b3\u30fc\u30c9\u4e2d\u306e\u307b\u3068\u3093\u3069\u3069\u3093\u306a\u5834\u6240\u3067\u3082\u4f7f\u3048\u308b\u3068\u3044\u3046\u3053\u3068\u3002\u4f7f\u3044\u65b9\u306e\u4f8b\u3000\u2193 -}\n\n{- let\u306f\u30ed\u30fc\u30ab\u30eb\u30b9\u30b3\u30fc\u30d7\u306b\u95a2\u6570\u3092\u4f5c\u308b\u306e\u306b\u4f7f\u3048\u308b\n  ghci> [let square x = x * x in (square 5, square 3, square 2)]\n  [(25,9,4)] -}\n\n{- let\u3067\u306f\u30bb\u30df\u30b3\u30ed\u30f3(;)\u533a\u5207\u308a\u3092\u4f7f\u3048\u308b\u3002\u30a4\u30f3\u30c7\u30f3\u30c8\u307f\u305f\u3044\u306b\u9593\u5ef6\u3073\u3057\u305f\u69cb\u6587\u3092\u4f7f\u308f\u305a\u306b\u3059\u307f\u3001\u8907\u6570\u306e\u5909\u6570\u3092\u4e00\u884c\u3067\u675f\u7e1b\u3057\u305f\u3044\u6642\u306b\u4fbf\u5229\u3002\n  ghci> (let a = 100; b = 200; c = 300 in a*b*c, let foo = \"Hey \"; bar = \"there!\" in foo ++ bar)\n  (6000000,\"Hey there!\") -}\n\n{- let\u5f0f\u3068\u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\u304c\u3042\u308c\u3070\u3001\u3042\u3063\u3068\u3044\u3046\u9593\u306b\u30bf\u30d7\u30eb\u3092\u8981\u7d20\u306b\u5206\u89e3\u3057\u3066\u305d\u308c\u305e\u308c\u540d\u524d\u306b\u675f\u7e1b\u3067\u304d\u308b\n  ghci> (let (a, b, c) = (1, 2, 3) in a+b+c) * 100\n  600\n  \u3053\u3053\u3067\u306f\u30c8\u30ea\u30d7\u30eb(1,2,3)\u3092\u5206\u89e3\u3059\u308b\u306e\u306blet\u3092\u4f7f\u3063\u305f\u3002\u6700\u521d\u306e\u8981\u7d20\u3092a\u3001\uff12\u3064\u76ee\u306e\u8981\u7d20\u3092b\u3001\uff13\u3064\u76ee\u306e\u8981\u7d20\u3092c\u3068\u8aad\u3093\u3067\u3044\u308b\u3002in a+b+c\u306e\u90e8\u5206\u306f\u3001\n  let\u5f0f\u5168\u4f53\u304c\u5024a+b+c\u3092\u6301\u3064\u3001\u3068\u8a00\u3063\u3066\u3044\u308b\u3002\u6700\u5f8c\u306b\u305d\u306e\u5024\u306b100\u3092\u304b\u3051\u3066\u3044\u308b\u3002 -}\n\n{- \u4f7f\u3044\u52dd\u624b\u304c\u3044\u3044\u3082\u306e\u306e\u3001\u3044\u3064\u3067\u3082let\u5f0f\u3092\u4f7f\u3048\u3070\u3044\u3044\u3068\u306f\u8a00\u3048\u306a\u3044\u3002\u307e\u305alet\u5f0f\u306f\u300c\u5f0f\u300d\u3067\u3042\u308a\u3001\u305d\u306e\u30b9\u30b3\u30fc\u30d7\u306b\u5c40\u6240\u7684\u306a\u306e\u3067\u3001\u30ac\u30fc\u30c9\u3092\u307e\u305f\u3044\u3067\u306f\n  \u4f7f\u3048\u306a\u3044\u3002\u307e\u305f\u3001\u95a2\u6570\u306e\u524d\u3067\u306f\u306a\u304f\u5f8c\u308d\u3067\u90e8\u54c1\u3092\u5b9a\u7fa9\u3059\u308b\u3053\u3068\u3067\u3001\u95a2\u6570\u306e\u672c\u4f53\u304c\u540d\u524d\u3068\u578b\u5ba3\u8a00\u306b\u8fd1\u304f\u306a\u308a\u30b3\u30fc\u30c9\u304c\u8aad\u307f\u3084\u3059\u304f\u306a\u308b\u306e\u3067where\u3092\u4f7f\u3046\u4eba\u3082\u3044\u308b\u3002 -}\n\n{- \u30ea\u30b9\u30c8\u5185\u5305\u8868\u8a18\u3067\u306elet -}\n{- BMI\u8a08\u7b97\u3059\u308b\u4f8b\u3092where\u3067\u95a2\u6570\u3092\u5b9a\u7fa9\u3059\u308b\u306e\u3067\u306f\u306a\u304f\u3001\u30ea\u30b9\u30c8\u5185\u5305\u8868\u8a18\u4e2d\u306elet\u3092\u4f7f\u3063\u3066\u66f8\u304d\u63db\u3048\u3066\u307f\u308b\u3002 -}\ncalcBmis' :: [(Double, Double)] -> [Double]\ncalcBmis' xs = [bmi | (w, h) <- xs, let bmi = w / h ^2]\n{- \u30ea\u30b9\u30c8\u5185\u5305\u8868\u8a18\u304c\u5143\u306e\u30ea\u30b9\u30c8\u304b\u3089\u30bf\u30d7\u30eb\u3092\u53d7\u3051\u53d6\u308a\u3001\u305d\u306e\u8981\u7d20\u3092w\u3068h\u306b\u675f\u7e1b\u3059\u308b\u305f\u3073\u306b\u3001let\u5f0f\u306fw / h ^ 2\u3092\u5909\u6570bmi\u306b\u675f\u7e1b\u3059\u308b\u3002\n  \u305d\u308c\u304b\u3089bmi\u3092\u30ea\u30b9\u30c8\u5185\u5305\u8868\u8a18\u306e\u51fa\u529b\u3068\u3057\u3066\u66f8\u304d\u51fa\u3057\u3066\u3044\u308b\u3060\u3051\u3002 -}\n{- \u30ea\u30b9\u30c8\u5185\u5305\u8868\u8a18\u306e\u4e2d\u306elet\u3092\u8ff0\u8a9e\u306e\u3088\u3046\u306b\u4f7f\u3063\u3066\u3044\u308b\u304c\u3001\u3053\u308c\u306f\u30ea\u30b9\u30c8\u3092\u30d5\u30a3\u30eb\u30bf\u3059\u308b\u308f\u3051\u3067\u306f\u306a\u304f\u3001\u540d\u524d\u3092\u675f\u7e1b\u3057\u3066\u3044\u308b\u3060\u3051\u3002let\u3067\u5b9a\u7fa9\u3055\u308c\u305f\u540d\u524d\u306f\n  \u51fa\u529b\uff08|\u3088\u308a\u524d\u306e\u90e8\u5206\uff09\u3068\u305d\u306elet\u3088\u308a\u5f8c\u308d\u306e\u30ea\u30b9\u30c8\u5185\u5305\u8868\u8a18\u306e\u3059\u3079\u3066\u304b\u3089\u898b\u3048\u308b\u3002\u305f\u3060\u3001\u30b8\u30a7\u30cd\u30ec\u30fc\u30bf\u3068\u547c\u3070\u308c\u308b\u30ea\u30b9\u30c8\u5185\u5305\u8868\u8a18\u306e(w,h) <- xs\u306e\u90e8\u5206\u306f\n  let\u306e\u675f\u7e1b\u3088\u308a\u3082\u524d\u306b\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\u306e\u3067\u3001\u5909\u6570bmi\u306f\u30b8\u30a7\u30cd\u30ec\u30fc\u30bf\u304b\u3089\u306f\u53c2\u7167\u3067\u304d\u306a\u3044\u3002\u3053\u306e\u30c6\u30af\u30cb\u30c3\u30af\u3092\u4f7f\u3063\u3066\u80a5\u6e80\u306a\u4eba\u306eBMI\u306e\u307f\u3092\n  \u8fd4\u3059\u3088\u3046\u306b\u95a2\u6570\u3092\u5909\u3048\u3066\u307f\u308b\u3002\u3000-}\ncalcBmis'' :: [(Double,Double)] -> [Double]\ncalcBmis'' xs = [bmi | (w,h) <- xs, let bmi = w / h ^ 2, bmi > 25.0]\n", "input": "['a', 'a']", "status": "success", "output": "\"\""}
