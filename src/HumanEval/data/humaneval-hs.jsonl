{"task_id": "Haskell/0", "prompt": "-- Check if in given list of numbers, are any two numbers closer to each other than\n-- given threshold.\n-- >>> has_close_elements [1.0, 2.0, 3.0] 0.5\n-- False\n-- >>> has_close_elements [1.0, 2.8, 3.0, 4.0, 5.0, 2.0] 0.3\n-- True\nhas_close_elements :: [Float] -> Float -> Bool", "canonical_solution": "has_close_elements numbers threshold = any (\\(x, y) -> abs (x - y) < threshold) [(x,y) | x <- numbers, y <- numbers, x /= y]", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (has_close_elements [1.0, 2.0, 3.9, 4.0, 5.0, 2.2] 0.3 == True)\n    check (has_close_elements [1.0, 2.0, 3.9, 4.0, 5.0, 2.2] 0.05 == False)\n    check (has_close_elements [1.0, 2.0, 5.9, 4.0, 5.0]       0.95 == True)\n    check (has_close_elements [1.0, 2.0, 5.9, 4.0, 5.0]       0.8  == False)\n    check (has_close_elements [1.0, 2.0, 3.0, 4.0, 5.0, 2.0] 0.1  == True)\n    check (has_close_elements [1.1, 2.2, 3.1, 4.1, 5.1]       1.0  == True)\n    check (has_close_elements [1.1, 2.2, 3.1, 4.1, 5.1]       0.5  == False)\n"}
{"task_id": "Haskell/1", "prompt": "-- Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n-- separate those group into separate strings and return the list of those.\n-- Separate groups are balanced (each open brace is properly closed) and not nested within each other\n-- Ignore any spaces in the input string.\n-- >>> separate_paren_groups \"( ) (( )) (( )( ))\"\n-- [\"()\",\"(())\",\"(()())\"]\nseparate_paren_groups :: String -> [String]", "canonical_solution": "separate_paren_groups paren_string = get_paren_groups paren_string 0 []\n  where\n    get_paren_groups :: String -> Int -> [String] -> [String]\n    get_paren_groups \"\" _ groups = groups\n    get_paren_groups ('(' : cs) 0 groups = get_paren_groups cs 1 (groups ++ [\"(\"])\n    get_paren_groups (c : cs) depth groups\n      | c == '(' || c == ')' = get_paren_groups cs (depth + (get_d c)) ((reverse . tail . reverse $ groups) ++ [(head $ reverse groups) ++ [c]])\n      | otherwise = get_paren_groups cs depth groups\n      where\n        get_d :: Char -> Int\n        get_d '(' = 1\n        get_d ')' = -1\n        get_d _ = 0", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (separate_paren_groups \"(()()) ((())) () ((())()())\" == [\"(()())\",\"((()))\",\"()\",\"((())()())\"])\n    check (separate_paren_groups \"() (()) ((())) (((())))\"      == [\"()\",\"(())\",\"((()))\",\"(((())))\"])\n    check (separate_paren_groups \"(()(())((())))\"             == [\"(()(())((())))\"])\n    check (separate_paren_groups \"( ) (( )) (( )( ))\"           == [\"()\",\"(())\",\"(()())\"])\n"}
{"task_id": "Haskell/2", "prompt": "-- Given a positive floating point number, it can be decomposed into\n-- and integer part (largest integer smaller than given number) and decimals\n-- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n-- >>> truncate_number 3.5\n-- 0.5\ntruncate_number :: Float -> Float", "canonical_solution": "truncate_number number = number - fromIntegral (floor number)", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (truncate_number 3.5 == 0.5)\n    check (abs (truncate_number 1.33   - 0.33 ) < 1e-6)\n    check (abs (truncate_number 123.456 - 0.456) < 1e-6)\n"}
{"task_id": "Haskell/3", "prompt": "-- You're given a list of deposit and withdrawal operations on a bank account that starts with\n-- zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n-- at that point function should return True. Otherwise it should return False.\n-- >>> below_zero [1, 2, 3]\n-- False\n-- >>> below_zero [1, 2, -4, 5]\n-- True\nbelow_zero :: [Int] -> Bool", "canonical_solution": "below_zero operations = any (< 0) $ scanl (+) 0 operations", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (below_zero []                         == False)\n    check (below_zero [1, 2, -3, 1, 2, -3]       == False)\n    check (below_zero [1, 2, -4, 5, 6]           == True)\n    check (below_zero [1, -1, 2, -2, 5, -5, 4, -4] == False)\n    check (below_zero [1, -1, 2, -2, 5, -5, 4, -5] == True)\n    check (below_zero [1, -2, 2, -2, 5, -5, 4, -4] == True)\n"}
{"task_id": "Haskell/4", "prompt": "-- For a given list of input numbers, calculate Mean Absolute Deviation\n-- around the mean of this dataset.\n-- Mean Absolute Deviation is the average absolute difference between each\n-- element and a centerpoint (mean in this case):\n-- MAD = average | x - x_mean |\n-- >>> mean_absolute_deviation [1.0, 2.0, 3.0, 4.0]\n-- 1.0\nmean_absolute_deviation :: [Float] -> Float", "canonical_solution": "mean_absolute_deviation numbers = sum (map abs (map (\\x -> x - mean) numbers)) / fromIntegral (length numbers)\n    where\n        mean = sum numbers / fromIntegral (length numbers)", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (abs (mean_absolute_deviation [1.0,2.0,3.0]       - 2.0/3.0) < 1e-6)\n    check (abs (mean_absolute_deviation [1.0,2.0,3.0,4.0]   - 1.0     ) < 1e-6)\n    check (abs (mean_absolute_deviation [1.0,2.0,3.0,4.0,5.0] - 6.0/5.0) < 1e-6)\n"}
{"task_id": "Haskell/5", "prompt": "-- Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n-- >>> intersperse [] 4\n-- []\n-- >>> intersperse [1, 2, 3] 4\n-- [1,4,2,4,3,4]\nintersperse :: [Int] -> Int -> [Int]", "canonical_solution": "intersperse numbers delimeter = concat [[x, delimeter] | x <- numbers]", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (intersperse []       7 == [])\n    check (intersperse [5,6,3,2] 8 == [5,8,6,8,3,8,2])\n    check (intersperse [2,2,2]   2 == [2,2,2,2,2])\n"}
{"task_id": "Haskell/6", "prompt": "-- Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n-- For each of the group, output the deepest level of nesting of parentheses.\n-- E.g. (()()) has maximum two levels of nesting while ((())) has three.\n-- >>> parse_nested_parens \"(()()) ((())) () ((())()())\"\n-- [2,3,1,3]\nparse_nested_parens :: String -> [Int]", "canonical_solution": "parse_nested_parens paren_string = get_paren_depths paren_string 0 []\n    where\n        get_paren_depths :: String -> Int -> [Int] -> [Int]\n        get_paren_depths \"\" _ max_depths = max_depths\n        get_paren_depths ('(':cs) 0 max_depths = get_paren_depths cs 1 (max_depths ++ [1])\n        get_paren_depths ('(':cs) depth max_depths = get_paren_depths cs (depth + 1) ((reverse . tail . reverse $ max_depths) ++ [max (head $ reverse max_depths) (depth + 1)])\n        get_paren_depths (')':cs) depth max_depths = get_paren_depths cs (depth - 1) max_depths\n        get_paren_depths (_:cs) depth max_depths = get_paren_depths cs depth max_depths", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (parse_nested_parens \"(()()) ((())) () ((())()())\" == [2,3,1,3])\n    check (parse_nested_parens \"() (()) ((())) (((())))\"      == [1,2,3,4])\n    check (parse_nested_parens \"(()(())((())))\"             == [4])\n"}
{"task_id": "Haskell/7", "prompt": "-- Filter an input list of strings only for ones that contain given substring\n-- >>> filter_by_substring [] \"a\"\n-- []\n-- >>> filter_by_substring [\"abc\", \"bacd\", \"cde\", \"array\"] \"a\"\n-- [\"abc\",\"bacd\",\"array\"]\nfilter_by_substring :: [String] -> String -> [String]", "canonical_solution": "filter_by_substring strings substring = [x | x <- strings, substring `isInfixOf` x]", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (filter_by_substring []                          \"john\" == [])\n    check (filter_by_substring [\"xxx\",\"asd\",\"xxy\",\"john doe\",\"xxxAAA\",\"xxx\"] \"xxx\" == [\"xxx\",\"xxxAAA\",\"xxx\"])\n    check (filter_by_substring [\"xxx\",\"asd\",\"aaaxxy\",\"john doe\",\"xxxAAA\",\"xxx\"] \"xx\"  == [\"xxx\",\"aaaxxy\",\"xxxAAA\",\"xxx\"])\n    check (filter_by_substring [\"grunt\",\"trumpet\",\"prune\",\"gruesome\"]    \"run\" == [\"grunt\",\"prune\"])\n"}
{"task_id": "Haskell/8", "prompt": "-- For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n-- Empty sum should be equal to 0 and empty product should be equal to 1.\n-- >>> sum_product []\n-- (0,1)\n-- >>> sum_product [1, 2, 3, 4]\n-- (10,24)\nsum_product :: [Int] -> (Int, Int)", "canonical_solution": "sum_product numbers = (sum numbers, product numbers)", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (sum_product []       == (0,1))\n    check (sum_product [1,1,1]  == (3,1))\n    check (sum_product [100,0]  == (100,0))\n    check (sum_product [3,5,7]  == (15,105))\n    check (sum_product [10]     == (10,10))\n"}
{"task_id": "Haskell/9", "prompt": "-- From a given list of integers, generate a list of rolling maximum element found until given moment\n-- in the sequence.\n-- >>> rolling_max [1, 2, 3, 2, 3, 4, 2]\n-- [1,2,3,3,3,4,4]\nrolling_max :: [Int] -> [Int]", "canonical_solution": "rolling_max numbers = scanl1 max numbers", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (rolling_max []                  == [])\n    check (rolling_max [1,2,3,4]           == [1,2,3,4])\n    check (rolling_max [4,3,2,1]           == [4,4,4,4])\n    check (rolling_max [3,2,3,100,3]       == [3,3,3,100,100])\n"}
{"task_id": "Haskell/10", "prompt": "import Data.List\nis_palindrome :: String -> Bool\nis_palindrome string = string == reverse string\n-- Find the shortest palindrome that begins with a supplied string.\n-- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string that is a palindrome.\n-- - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n-- >>> make_palindrome \"\"\n-- \"\"\n-- >>> make_palindrome \"cat\"\n-- \"catac\"\n-- >>> make_palindrome \"cata\"\n-- \"catac\"\nmake_palindrome :: String -> String", "canonical_solution": "make_palindrome :: String -> String \nmake_palindrome string\n    | null string = \"\"\n    | otherwise = string ++ reverse (take beginning_of_suffix string)\n    where\n        beginning_of_suffix = length $ takeWhile (not . is_palindrome) $ tails string", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (make_palindrome \"\" == \"\")\n    check (make_palindrome \"x\" == \"x\")\n    check (make_palindrome \"xyz\" == \"xyzyx\")\n    check (make_palindrome \"xyx\" == \"xyx\")\n    check (make_palindrome \"jerry\" == \"jerryrrej\")\n"}
{"task_id": "Haskell/11", "prompt": "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform binary XOR on these inputs and return result also as a string.\n-- >>> string_xor \"010\" \"110\"\n-- \"100\"\nstring_xor :: String -> String -> String", "canonical_solution": "string_xor a b = [if x == y then '0' else '1' | (x, y) <- zip a b]", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (string_xor \"111000\" \"101010\" == \"010010\")\n    check (string_xor \"1\" \"1\"         == \"0\")\n    check (string_xor \"0101\" \"0000\"   == \"0101\")\n"}
{"task_id": "Haskell/12", "prompt": "-- Out of list of strings, return the longest one. Return the first one in case of multiple\n-- strings of the same length. Return Nothing in case the input list is empty.\n-- >>> longest []\n-- Nothing\n-- >>> longest [\"a\", \"b\", \"c\"]\n-- Just \"a\"\n-- >>> longest [\"a\", \"bb\", \"ccc\"]\n-- Just \"ccc\"\nlongest :: [String] -> Maybe String", "canonical_solution": "longest strings = case strings of\n    [] -> Nothing\n    _ -> Just $ maximumBy (comparing length) $ reverse strings", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (longest [] == Nothing)\n    check (longest [\"x\",\"y\",\"z\"] == Just \"x\")\n    check (longest [\"x\",\"yyy\",\"zzzz\",\"www\",\"kkkk\",\"abc\"] == Just \"zzzz\")\n"}
{"task_id": "Haskell/13", "prompt": "-- Return a greatest common divisor of two integers a and b\n-- >>> greatest_common_divisor 3 5\n-- 1\n-- >>> greatest_common_divisor 25 15\n-- 5\ngreatest_common_divisor :: Int -> Int -> Int", "canonical_solution": "greatest_common_divisor a b = gcd a b", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (greatest_common_divisor 3 7   == 1)\n    check (greatest_common_divisor 10 15 == 5)\n    check (greatest_common_divisor 49 14 == 7)\n    check (greatest_common_divisor 144 60 == 12)\n"}
{"task_id": "Haskell/14", "prompt": "-- Return list of all prefixes from shortest to longest of the input string\n-- >>> all_prefixes \"abc\"\n-- [\"a\",\"ab\",\"abc\"]\nall_prefixes :: String  -> [String]", "canonical_solution": "all_prefixes string = [take (i+1) string | i <- [0..length string - 1]]", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (all_prefixes \"\"      == [])\n    check (all_prefixes \"asdfgh\" == [\"a\",\"as\",\"asd\",\"asdf\",\"asdfg\",\"asdfgh\"])\n    check (all_prefixes \"WWW\"    == [\"W\",\"WW\",\"WWW\"])\n"}
{"task_id": "Haskell/15", "prompt": "-- Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n-- >>> string_sequence 0\n-- \"0\"\n-- >>> string_sequence 5\n-- \"0 1 2 3 4 5\"\nstring_sequence :: Int -> String", "canonical_solution": "string_sequence n = unwords [show x | x <- [0..n]]", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (string_sequence 0  == \"0\")\n    check (string_sequence 3  == \"0 1 2 3\")\n    check (string_sequence 10 == \"0 1 2 3 4 5 6 7 8 9 10\")\n"}
{"task_id": "Haskell/16", "prompt": "-- Given a string, find out how many distinct characters (regardless of case) does it consist of\n-- >>> count_distinct_characters \"xyzXYZ\"\n-- 3\n-- >>> count_distinct_characters \"Jerry\"\n-- 4\ncount_distinct_characters :: String -> Int", "canonical_solution": "count_distinct_characters string = length $ nub $ map toLower string", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (count_distinct_characters \"\"                  == 0)\n    check (count_distinct_characters \"abcde\"             == 5)\n    check (count_distinct_characters (\"abcde\" ++ \"cade\" ++ \"CADE\") == 5)\n    check (count_distinct_characters \"aaaaAAAAaaaa\"      == 1)\n    check (count_distinct_characters \"Jerry jERRY JeRRRY\" == 5)\n"}
{"task_id": "Haskell/17", "prompt": "-- Input to this function is a string representing musical notes in a special ASCII format.\n-- Your task is to parse this string and return list of integers corresponding to how many beats does each\n-- not last.\n-- Here is a legend:\n-- 'o' - whole note, lasts four beats\n-- 'o|' - half note, lasts two beats\n-- '.|' - quater note, lasts one beat\n-- >>> parse_music \"o o| .| o| o| .| .| .| .| o o\"\n-- [4,2,1,2,2,1,1,1,1,4,4]\nparse_music :: String -> [Int]", "canonical_solution": "parse_music music_string = [note_map x | x <- words music_string]\n    where \n        note_map \"o\" = 4\n        note_map \"o|\" = 2\n        note_map \".|\" = 1", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (parse_music \"\"                       == [])\n    check (parse_music \"o o o o\"                == [4,4,4,4])\n    check (parse_music \".| .| .| .|\"             == [1,1,1,1])\n    check (parse_music \"o| o| .| .| o o o o\"     == [2,2,1,1,4,4,4,4])\n    check (parse_music \"o| .| o| .| o o| o o|\"     == [2,1,2,1,4,2,4,2])\n"}
{"task_id": "Haskell/18", "prompt": "-- Find how many times a given substring can be found in the original string. Count overlaping cases.\n-- >>> how_many_times \"\" \"a\"\n-- 0\n-- >>> how_many_times \"aaa\" \"a\"\n-- 3\n-- >>> how_many_times \"aaaa\" \"aa\"\n-- 3\nhow_many_times :: String -> String -> Int", "canonical_solution": "how_many_times string substring = length $ filter (substring `isPrefixOf`) $ map (take (length substring)) $ tails string", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (how_many_times \"\"          \"x\"    == 0)\n    check (how_many_times \"xyxyxyx\"  \"x\"    == 4)\n    check (how_many_times \"cacacacac\" \"cac\"  == 4)\n    check (how_many_times \"john doe\"  \"john\" == 1)\n"}
{"task_id": "Haskell/19", "prompt": "-- Input is a space-delimited string of numberals from 'zero' to 'nine'.\n-- Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n-- Return the string with numbers sorted from smallest to largest\n-- >>> sort_numbers \"three one five\"\n-- \"one three five\"\nsort_numbers :: String -> String", "canonical_solution": "sort_numbers numbers = unwords $ sortOn (value_map !) $ words numbers\n    where value_map = fromList [(\"zero\", 0), (\"one\", 1), (\"two\", 2), (\"three\", 3), (\"four\", 4), (\"five\", 5), (\"six\", 6), (\"seven\", 7), (\"eight\", 8), (\"nine\", 9)]", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (sort_numbers \"\"                                        == \"\")\n    check (sort_numbers \"three\"                                   == \"three\")\n    check (sort_numbers \"three five nine\"                         == \"three five nine\")\n    check (sort_numbers \"five zero four seven nine eight\"         == \"zero four five seven eight nine\")\n    check (sort_numbers \"six five four three two one zero\"        == \"zero one two three four five six\")\n"}
{"task_id": "Haskell/20", "prompt": "-- From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n-- other and return them in order (smaller number, larger number).\n-- >>> find_closest_elements [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]\n-- (2.0,2.2)\n-- >>> find_closest_elements [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]\n-- (2.0,2.0)\nfind_closest_elements :: [Float] -> (Float, Float)", "canonical_solution": "find_closest_elements numbers = head $ sortOn (\\(x, y) -> abs (x - y)) [(x,y) | (x:ys) <- tails numbers, y <- ys]", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (find_closest_elements [1.0,2.0,3.9,4.0,5.0,2.2] == (3.9,4.0))\n    check (find_closest_elements [1.0,2.0,5.9,4.0,5.0] == (5.0,5.9))\n    check (find_closest_elements [1.0,2.0,3.0,4.0,5.0,2.2] == (2.0,2.2))\n    check (find_closest_elements [1.0,2.0,3.0,4.0,5.0,2.0] == (2.0,2.0))\n    check (find_closest_elements [1.1,2.2,3.1,4.1,5.1] == (2.2,3.1))\n"}
{"task_id": "Haskell/21", "prompt": "-- Given list of numbers (of at least two elements), apply a linear transform to that list,\n-- such that the smallest number will become 0 and the largest will become 1\n-- >>> rescale_to_unit [1.0, 2.0, 3.0, 4.0, 5.0]\n-- [0.0,0.25,0.5,0.75,1.0]\nrescale_to_unit :: [Float] -> [Float]", "canonical_solution": "rescale_to_unit numbers = map (\\x -> (x - min_number) / (max_number - min_number)) numbers\n    where min_number = minimum numbers\n          max_number = maximum numbers", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (rescale_to_unit [2.0,49.9] == [0.0,1.0])\n    check (rescale_to_unit [100.0,49.9] == [1.0,0.0])\n    check (rescale_to_unit [1.0,2.0,3.0,4.0,5.0] == [0.0,0.25,0.5,0.75,1.0])\n    check (rescale_to_unit [2.0,1.0,5.0,3.0,4.0] == [0.25,0.0,1.0,0.5,0.75])\n    check (rescale_to_unit [12.0,11.0,15.0,13.0,14.0] == [0.25,0.0,1.0,0.5,0.75])\n"}
{"task_id": "Haskell/23", "prompt": "-- Return length of given string\nstrlen :: String -> Int", "canonical_solution": "strlen string = length string", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (strlen \"\" == 0)\n    check (strlen \"x\" == 1)\n    check (strlen \"asdasnakj\" == 9)\n"}
{"task_id": "Haskell/24", "prompt": "-- For a given number n, find the largest number that divides n evenly, smaller than n\n-- >>> largest_divisor 15\n-- 5\nlargest_divisor :: Int -> Int", "canonical_solution": "largest_divisor n = maximum [x | x <- [1..n-1], n `mod` x == 0]", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (largest_divisor 3 == 1)\n    check (largest_divisor 7 == 1)\n    check (largest_divisor 10 == 5)\n    check (largest_divisor 100 == 50)\n    check (largest_divisor 49 == 7)\n"}
{"task_id": "Haskell/25", "prompt": "-- Return list of prime factors of given integer in the order from smallest to largest.\n-- Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n-- Input number should be equal to the product of all factors\n-- >>> factorize 8\n-- [2,2,2]\n-- >>> factorize 25\n-- [5,5]\n-- >>> factorize 70\n-- [2,5,7]\nfactorize :: Int -> [Int]", "canonical_solution": "factorize n = factorize' n 2\n    where\n        factorize' :: Int -> Int -> [Int]\n        factorize' n i\n            | i * i > n = [n]\n            | n `mod` i == 0 = i : factorize' (n `div` i) i\n            | otherwise = factorize' n (i + 1)", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (factorize 2 == [2])\n    check (factorize 4 == [2,2])\n    check (factorize 8 == [2,2,2])\n    check (factorize (3*19) == [3,19])\n    check (factorize (3*19*3*19) == [3,3,19,19])\n    check (factorize (3*19*3*19*3*19) == [3,3,3,19,19,19])\n    check (factorize (3*19*19*19) == [3,19,19,19])\n    check (factorize (3*2*3) == [2,3,3])\n"}
{"task_id": "Haskell/26", "prompt": "-- From a list of integers, remove all elements that occur more than once.\n-- Keep order of elements left the same as in the input.\n-- >>> remove_duplicates [1, 2, 3, 2, 4]\n-- [1,3,4]\nremove_duplicates :: [Int] -> [Int]", "canonical_solution": "remove_duplicates numbers = [n | (n, c) <- counts, c <= 1]\n    where counts = [(n, count n numbers) | n <- numbers]\n          count n xs = length [x | x <- xs, x == n]", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (remove_duplicates [] == [])\n    check (remove_duplicates [1,2,3,4] == [1,2,3,4])\n    check (remove_duplicates [1,2,3,2,4,3,5] == [1,4,5])\n"}
{"task_id": "Haskell/27", "prompt": "-- For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n-- >>> flip_case \"Hello\"\n-- \"hELLO\"\nflip_case :: String -> String", "canonical_solution": "flip_case string = map swap_case string\n    where swap_case c = if isUpper c then toLower c else toUpper c", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (flip_case \"\" == \"\")\n    check (flip_case \"Hello!\" == \"hELLO!\")\n    check (flip_case \"These violent delights have violent ends\" == \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\")\n"}
{"task_id": "Haskell/28", "prompt": "-- Concatenate list of strings into a single string\nconcatenate :: [String] -> String", "canonical_solution": "concatenate strings = concat strings", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (concatenate [] == \"\")\n    check (concatenate [\"x\",\"y\",\"z\"] == \"xyz\")\n    check (concatenate [\"x\",\"y\",\"z\",\"w\",\"k\"] == \"xyzwk\")\n"}
{"task_id": "Haskell/29", "prompt": "-- Filter an input list of strings only for ones that start with a given prefix.\n-- >>> filter_by_prefix [] \"a\"\n-- []\n-- >>> filter_by_prefix [\"abc\", \"bcd\", \"cde\", \"array\"] \"a\"\n-- [\"abc\",\"array\"]\nfilter_by_prefix :: [String] -> String -> [String]", "canonical_solution": "filter_by_prefix strings prefix = [x | x <- strings, x `startsWith` prefix]\n    where startsWith :: String -> String -> Bool\n          startsWith string prefix = take (length prefix) string == prefix", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (filter_by_prefix [] \"john\" == [])\n    check (filter_by_prefix [\"xxx\",\"asd\",\"xxy\",\"john doe\",\"xxxAAA\",\"xxx\"] \"xxx\" == [\"xxx\",\"xxxAAA\",\"xxx\"])\n"}
{"task_id": "Haskell/30", "prompt": "-- Return only positive numbers in the list.\nget_positive :: [Int] -> [Int]", "canonical_solution": "get_positive l = [x | x <- l, x > 0]", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (get_positive [-1,-2,4,5,6] == [4,5,6])\n    check (get_positive [5,3,-5,2,3,3,9,0,123,1,-10] == [5,3,2,3,3,9,123,1])\n    check (get_positive [-1,-2] == [])\n    check (get_positive [] == [])\n"}
{"task_id": "Haskell/31", "prompt": "-- Return true if a given number is prime, and false otherwise.\n-- >>> is_prime 6\n-- False\n-- >>> is_prime 101\n-- True\n-- >>> is_prime 11\n-- True\n-- >>> is_prime 13441\n-- True\n-- >>> is_prime 61\n-- True\n-- >>> is_prime 4\n-- False\n-- >>> is_prime 1\n-- False\nis_prime :: Int -> Bool", "canonical_solution": "is_prime n = n > 1 && all (\\k -> n `mod` k /= 0) [2..n-1]", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (is_prime 6 == False)\n    check (is_prime 101 == True)\n    check (is_prime 11 == True)\n    check (is_prime 13441 == True)\n    check (is_prime 61 == True)\n    check (is_prime 4 == False)\n    check (is_prime 1 == False)\n    check (is_prime 5 == True)\n    check (is_prime 17 == True)\n    check (is_prime (5*17) == False)\n    check (is_prime (11*7) == False)\n    check (is_prime (13441*19) == False)\n"}
{"task_id": "Haskell/32", "prompt": "roundTo :: Double -> Int -> Double\nroundTo x n = (fromInteger $ round $ x * (10^n)) / (10.0^^n)\n-- Evaluates polynomial with coefficients xs at point x.\n-- return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\npoly :: [Double] -> Double -> Double\npoly coeffs x = sum [coeff * x ** fromIntegral i | (i, coeff) <- zip [0..] coeffs]\n-- xs are coefficients of a polynomial.\n-- find_zero find x such that poly(x) = 0.\n-- find_zero returns only only zero point, even if there are many.\n-- Moreover, find_zero only takes list xs having even number of coefficients\n-- and largest non zero coefficient as it guarantees\n-- a solution.\n-- >>> roundTo (find_zero [1,2]) 2 -- f(x) = 1 + 2x\n-- -0.5\n-- >>> roundTo (find_zero [-6,11,-6,1]) 2 -- (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n-- 1.0", "canonical_solution": "find_zero :: [Double] -> Double\nfind_zero coeffs = go (-1.0) 1.0\n    where\n        go :: Double -> Double -> Double\n        go begin end\n            | abs (end - begin) < 1e-10 = begin\n            | otherwise =\n                let center = (begin + end) / 2.0 in\n                    if poly coeffs center * poly coeffs begin > 0\n                        then go center end\n                        else go begin center", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (roundTo (find_zero [1,2]) 2 == -0.5)\n    check (roundTo (find_zero [-6,11,-6,1]) 2 == 1.0)\n"}
{"task_id": "Haskell/33", "prompt": "-- This function takes a list l and returns a list l' such that\n-- l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n-- to the values of the corresponding indicies of l, but sorted.\n-- >>> sort_third [1,2,3]\n-- [1,2,3]\n-- >>> sort_third [5,6,3,4,8,9,2]\n-- [2,6,3,4,8,9,5]\nsort_third :: [Int] -> [Int]", "canonical_solution": "sort_third xs = replaceEveryThird xs (sort $ everyThird xs)\n  where\n    everyThird :: [Int] -> [Int]\n    everyThird [] = []\n    everyThird (x:xs) = x : everyThird (drop 2 xs)\n    replaceEveryThird :: [Int] -> [Int] -> [Int]\n    replaceEveryThird [] _ = []\n    replaceEveryThird xs [] = xs\n    replaceEveryThird (x:xs) (y:ys) = y : (take 2 xs ++ replaceEveryThird (drop 2 xs) ys)", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (sort_third [1,2,3] == [1,2,3])\n    check (sort_third [5,6,3,4,8,9,2] == [2,6,3,4,8,9,5])\n    check (sort_third [5,8,-12,4,23,2,3,11,12,-10] == [ -12,8,3,4,23,2,3,11,12,-10])\n"}
{"task_id": "Haskell/34", "prompt": "-- Return sorted unique elements in a list\n-- >>> unique [5,3,5,2,3,3,9,0,123]\n-- [0,2,3,5,9,123]\nunique :: [Int] -> [Int]", "canonical_solution": "unique = sort . nub", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (unique [5,3,5,2,3,3,9,0,123] == [0,2,3,5,9,123])\n"}
{"task_id": "Haskell/35", "prompt": "-- Return maximum element in the list.\n-- >>> max_element [1,2,3]\n-- 3\n-- >>> max_element [5,3,-5,2,-3,3,9,0,123,1,-10]\n-- 123\nmax_element :: [Int] -> Int", "canonical_solution": "max_element = maximum", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (max_element [1,2,3] == 3)\n    check (max_element [5,3,-5,2,-3,3,9,0,124,1,-10] == 124)\n"}
{"task_id": "Haskell/36", "prompt": "-- Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n-- >>> fizz_buzz 50\n-- 0\n-- >>> fizz_buzz 78\n-- 2\n-- >>> fizz_buzz 79\n-- 3\nfizz_buzz :: Int -> Int", "canonical_solution": "fizz_buzz = length . filter (== '7') . concatMap show . filter (\\x -> x `mod` 11 == 0 || x `mod` 13 == 0) . enumFromTo 0 . pred", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (fizz_buzz 50  == 0)\n    check (fizz_buzz 78  == 2)\n    check (fizz_buzz 79  == 3)\n    check (fizz_buzz 100 == 3)\n"}
{"task_id": "Haskell/37", "prompt": "-- This function takes a list l and returns a list l' such that\n-- l' is identical to l in the odd indicies, while its values at the even indicies are equal\n-- to the values of the even indicies of l, but sorted.\n-- >>> sort_even [1,2,3]\n-- [1,2,3]\n-- >>> sort_even [5,6,3,4]\n-- [3,6,5,4]\nsort_even :: [Int] -> [Int]", "canonical_solution": "sort_even xs = replaceEverySecond xs (sort $ everySecond xs)\n  where\n    everySecond :: [Int] -> [Int]\n    everySecond [] = []\n    everySecond (x:xs) = x : everySecond (drop 1 xs)\n    replaceEverySecond :: [Int] -> [Int] -> [Int]\n    replaceEverySecond [] _ = []\n    replaceEverySecond xs [] = xs\n    replaceEverySecond (x:xs) (y:ys) = y : (take 1 xs ++ replaceEverySecond (drop 1 xs) ys)", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (sort_even [1,2,3] == [1,2,3])\n    check (sort_even [5,3,-5,2,-3,3,9,0,123,1,-10] == [-10,3,-5,2,-3,3,5,0,9,1,123])\n    check (sort_even [5,8,-12,4,23,2,3,11,12,-10] == [-12,8,3,4,5,2,12,11,23,-10])\n"}
{"task_id": "Haskell/38", "prompt": "-- returns encoded string by cycling groups of three characters.\nencode_cyclic :: String -> String", "canonical_solution": "encode_cyclic = concatMap (\\x -> if length x == 3 then tail x ++ [head x] else x) . chunksOf 3\n  where\n    chunksOf :: Int -> [a] -> [[a]]\n    chunksOf _ [] = []\n    chunksOf n xs = take n xs : chunksOf n (drop n xs)", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (encode_cyclic \"\"    == \"\")\n    check (encode_cyclic \"abc\" == \"bca\")\n    check (encode_cyclic \"abcd\" == \"bcad\")\n    check (encode_cyclic \"abcdef\" == \"bcaefd\")\n"}
{"task_id": "Haskell/39", "prompt": "-- prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n-- >>> prime_fib 1\n-- 2\n-- >>> prime_fib 2\n-- 3\n-- >>> prime_fib 3\n-- 5\n-- >>> prime_fib 4\n-- 13\n-- >>> prime_fib 5\n-- 89\nprime_fib :: Int -> Int", "canonical_solution": "prime_fib n = head $ drop (n - 1) $ filter isPrime $ map fib [1..]\n  where\n    fib :: Int -> Int\n    fib 1 = 2\n    fib 2 = 3\n    fib n = fib (n - 1) + fib (n - 2)\n    isPrime :: Int -> Bool\n    isPrime p = p > 1 && all (\\k -> p `mod` k /= 0) [2..(p - 1)]", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (prime_fib 1 == 2)\n    check (prime_fib 2 == 3)\n    check (prime_fib 3 == 5)\n    check (prime_fib 4 == 13)\n    check (prime_fib 5 == 89)\n    check (prime_fib 6 == 233)\n    check (prime_fib 7 == 1597)\n"}
{"task_id": "Haskell/40", "prompt": "-- triples_sum_to_zero takes a list of integers as an input.\n-- it returns True if there are three distinct elements in the list that\n-- sum to zero, and False otherwise.\n-- >>> triples_sum_to_zero [1,3,5,0]\n-- False\n-- >>> triples_sum_to_zero [1,3,-2,1]\n-- True\n-- >>> triples_sum_to_zero [1,2,3,7]\n-- False\n-- >>> triples_sum_to_zero [2,4,-5,3,9,7]\n-- True\n-- >>> triples_sum_to_zero [1]\n-- False\ntriples_sum_to_zero :: [Int] -> Bool", "canonical_solution": "triples_sum_to_zero xs = any (\\(a, b, c) -> a + b + c == 0) $ triples xs\n  where\n    triples :: [Int] -> [(Int, Int, Int)]\n    triples [] = []\n    triples (x:xs) = [(x, y, z) | y <- xs, z <- tail xs, y /= z] ++ triples xs", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (triples_sum_to_zero [1,3,5,0] == False)\n    check (triples_sum_to_zero [1,3,5,-1] == False)\n    check (triples_sum_to_zero [1,3,-2,1] == True)\n    check (triples_sum_to_zero [1,2,3,7] == False)\n    check (triples_sum_to_zero [1,2,5,7] == False)\n    check (triples_sum_to_zero [2,4,-5,3,9,7] == True)\n    check (triples_sum_to_zero [1] == False)\n    check (triples_sum_to_zero [1,3,5,-100] == False)\n    check (triples_sum_to_zero [100,3,5,-100] == False)"}
{"task_id": "Haskell/41", "prompt": "-- Imagine a road that's a perfectly straight infinitely long line.\n-- n cars are driving left to right;  simultaneously, a different set of n cars\n-- are driving right to left.   The two sets of cars start out being very far from\n-- each other.  All cars move in the same speed.  Two cars are said to collide\n-- when a car that's moving left to right hits a car that's moving right to left.\n-- However, the cars are infinitely sturdy and strong; as a result, they continue moving\n-- in their trajectory as if they did not collide.\n-- This function outputs the number of such collisions.\ncar_race_collision :: Int -> Int", "canonical_solution": "car_race_collision n = n^\u2b502", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (car_race_collision 2 == 4)\n    check (car_race_collision 3 == 9)\n    check (car_race_collision 4 == 16)\n    check (car_race_collision 8 == 64)\n    check (car_race_collision 10 == 100)"}
{"task_id": "Haskell/42", "prompt": "-- Return list with elements incremented by 1.\n-- >>> incr_list [1,2,3]\n-- [2,3,4]\n-- >>> incr_list [5,3,5,2,3,3,9,0,123]\n-- [6,4,6,3,4,4,10,1,124]\nincr_list :: [Int] -> [Int]", "canonical_solution": "incr_list = map (+1)", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (incr_list [] == [])\n    check (incr_list [3,2,1] == [4,3,2])\n    check (incr_list [5,2,5,2,3,3,9,0,123] == [6,3,6,3,4,4,10,1,124])"}
{"task_id": "Haskell/43", "prompt": "-- pairs_sum_to_zero takes a list of integers as an input.\n-- it returns True if there are two distinct elements in the list that\n-- sum to zero, and False otherwise.\n-- >>> pairs_sum_to_zero [1,3,5,0]\n-- False\n-- >>> pairs_sum_to_zero [1,3,-2,1]\n-- False\n-- >>> pairs_sum_to_zero [1,2,3,7]\n-- False\n-- >>> pairs_sum_to_zero [2,4,-5,3,5,7]\n-- True\n-- >>> pairs_sum_to_zero [1]\n-- False\npairs_sum_to_zero :: [Int] -> Bool", "canonical_solution": "pairs_sum_to_zero xs = any (\\(a, b) -> a + b == 0) $ pairs xs\n  where\n    pairs [] = []\n    pairs (x:xs) = [(x, y) | y <- xs] ++ pairs xs", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (pairs_sum_to_zero [1,3,5,0] == False)\n    check (pairs_sum_to_zero [1,3,-2,1] == False)\n    check (pairs_sum_to_zero [1,2,3,7] == False)\n    check (pairs_sum_to_zero [2,4,-5,3,5,7] == True)\n    check (pairs_sum_to_zero [1] == False)\n    check (pairs_sum_to_zero [-3,9,-1,3,2,30] == True)\n    check (pairs_sum_to_zero [-3,9,-1,3,2,31] == True)\n    check (pairs_sum_to_zero [-3,9,-1,4,2,30] == False)\n    check (pairs_sum_to_zero [-3,9,-1,4,2,31] == False)"}
{"task_id": "Haskell/44", "prompt": "-- Change numerical base of input number x to base.\n-- return string representation after the conversion.\n-- base numbers are less than 10.\n-- >>> change_base 8 3\n-- \"22\"\n-- >>> change_base 8 2\n-- \"1000\"\n-- >>> change_base 7 2\n-- \"111\"\nchange_base :: Int -> Int -> String", "canonical_solution": "change_base x base = reverse $ change_base' x\n  where\n    change_base' :: Int -> String \n    change_base' 0 = \"\"\n    change_base' x = show (x `mod` base) ++ change_base' (x `div` base)", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (change_base 8 3 == \"22\")\n    check (change_base 9 3 == \"100\")\n    check (change_base 234 2 == \"11101010\")\n    check (change_base 16 2 == \"10000\")\n    check (change_base 8 2 == \"1000\")\n    check (change_base 7 2 == \"111\")"}
{"task_id": "Haskell/45", "prompt": "-- Given length of a side and high return area for a triangle.\n-- >>> triangle_area 5 3\n-- 7.5\ntriangle_area :: Double -> Double -> Double", "canonical_solution": "triangle_area a h = a * h / 2.0", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (triangle_area 5 3 == 7.5)\n    check (triangle_area 2 2 == 2.0)\n    check (triangle_area 10 8 == 40.0)"}
{"task_id": "Haskell/46", "prompt": "-- The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n-- fib4(0) -> 0\n-- fib4(1) -> 0\n-- fib4(2) -> 2\n-- fib4(3) -> 0\n-- fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n-- Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n-- >>> fib4 5\n-- 4\n-- >>> fib4 6\n-- 8\n-- >>> fib4 7\n-- 14\nfib4 :: Int -> Int", "canonical_solution": "fib4 n = fib4' n 0 0 2 0\n  where\n    fib4' :: Int -> Int -> Int -> Int -> Int -> Int\n    fib4' 0 a b c d = a\n    fib4' 1 a b c d = b\n    fib4' 2 a b c d = c\n    fib4' 3 a b c d = d\n    fib4' n a b c d = fib4' (n - 1) b c d (a + b + c + d)", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (fib4 5 == 4)\n    check (fib4 8 == 28)\n    check (fib4 10 == 104)\n    check (fib4 12 == 386)"}
{"task_id": "Haskell/47", "prompt": "-- Return median of elements in the list l.\n-- >>> median [3,1,2,4,5]\n-- 3.0\n-- >>> median [-10,4,6,1000,10,20]\n-- 8.0\nmedian :: [Int] -> Double", "canonical_solution": "median xs = if odd len then fromIntegral (sorted !! (len `div` 2)) else (fromIntegral (sorted !! (len `div` 2 - 1)) + fromIntegral (sorted !! (len `div` 2))) / 2\n  where\n    sorted :: [Int]\n    sorted = sort xs\n    len = length sorted", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (median [3,1,2,4,5] == 3.0)\n    check (median [-10,4,6,1000,10,20] == 8.0)\n    check (median [5] == 5.0)\n    check (median [6,5] == 5.5)\n    check (median [8,1,3,9,9,2,7] == 7.0)"}
{"task_id": "Haskell/48", "prompt": "-- Checks if given string is a palindrome\n-- >>> is_palindrome \"\"\n-- True\n-- >>> is_palindrome \"aba\"\n-- True\n-- >>> is_palindrome \"aaaaa\"\n-- True\n-- >>> is_palindrome \"zbcd\"\n-- False\nis_palindrome :: String -> Bool", "canonical_solution": "is_palindrome = (==) <*> reverse", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (is_palindrome \"\" == True)\n    check (is_palindrome \"aba\" == True)\n    check (is_palindrome \"aaaaa\" == True)\n    check (is_palindrome \"zbcd\" == False)\n    check (is_palindrome \"xywyx\" == True)\n    check (is_palindrome \"xywyz\" == False)\n    check (is_palindrome \"xywzx\" == False)"}
{"task_id": "Haskell/49", "prompt": "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp 3 5\n-- 3\n-- >>> modp 1101 101\n-- 2\n-- >>> modp 0 101\n-- 1\n-- >>> modp 3 11\n-- 8\n-- >>> modp 100 101\n-- 1\nmodp :: Int -> Int -> Int", "canonical_solution": "modp n p = modp' n p 1\n  where\n    modp' :: Int -> Int -> Int -> Int\n    modp' 0 p ret = ret\n    modp' n p ret = modp' (n - 1) p (mod (2 * ret) p)", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (modp 3 5 == 3)\n    check (modp 1101 101 == 2)\n    check (modp 0 101 == 1)\n    check (modp 3 11 == 8)\n    check (modp 100 101 == 1)\n    check (modp 30 5 == 4)\n    check (modp 31 5 == 3)"}
{"task_id": "Haskell/50", "prompt": "-- returns encoded string by shifting every character by 5 in the alphabet.\nencode_shift :: String -> String", "canonical_solution": "encode_shift = map (\\c -> chr (((ord c + 5 - ord 'a') `mod` 26) + ord 'a'))", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (encode_shift \"\" == \"\")\n    check (encode_shift \"abcxyz\" == \"fgh cde\" {- wraparound: 'x'->'c','y'->'d','z'->'e' -})\n    check (encode_shift \"hello\" == \"mjqqt\")"}
{"task_id": "Haskell/51", "prompt": "-- remove_vowels is a function that takes string and returns string without vowels.\n-- >>> remove_vowels \"\"\n-- \"\"\n-- >>> remove_vowels \"abcdef\\nghijklm\"\n-- \"bcdf\\nghjklm\"\n-- >>> remove_vowels \"abcdef\"\n-- \"bcdf\"\n-- >>> remove_vowels \"aaaaa\"\n-- \"\"\n-- >>> remove_vowels \"aaBAA\"\n-- \"B\"\n-- >>> remove_vowels \"zbcd\"\n-- \"zbcd\"\nremove_vowels :: String -> String", "canonical_solution": "remove_vowels = filter (`notElem` \"aeiouAEIOU\")", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (remove_vowels \"\" == \"\")\n    check (remove_vowels \"abcdef\\nghijklm\" == \"bcdf\\nghjklm\")\n    check (remove_vowels \"abcdef\" == \"bcdf\")\n    check (remove_vowels \"aaaaa\" == \"\")\n    check (remove_vowels \"aaBAA\" == \"B\")\n    check (remove_vowels \"zbcd\" == \"zbcd\")"}
{"task_id": "Haskell/52", "prompt": "-- Return True if all numbers in the list l are below threshold t.\n-- >>> below_threshold [1,2,4,10] 100\n-- True\n-- >>> below_threshold [1,20,4,10] 5\n-- False\nbelow_threshold :: [Int] -> Int -> Bool", "canonical_solution": "below_threshold numbers threshold = all (< threshold) numbers", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (below_threshold [1,2,4,10] 100)\n    check (not $ below_threshold [1,20,4,10] 5)\n    check (below_threshold [1,20,4,10] 21)\n    check (below_threshold [1,8,4,10] 11)\n    check (not $ below_threshold [1,8,4,10] 10)"}
{"task_id": "Haskell/53", "prompt": "-- Add two numbers x and y\n-- >>> add 2 3\n-- 5\n-- >>> add 5 7\n-- 12\nadd :: Int -> Int -> Int", "canonical_solution": "add = (+)", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (add 0 1 == 1)\n    check (add 2 3 == 5)\n    check (add 5 7 == 12)\n    check (add 100 200 == 300)"}
{"task_id": "Haskell/54", "prompt": "-- Check if two words have the same characters.\n-- >>> same_chars \"eabcdzzzz\" \"dddzzzzzzzddeddabc\"\n-- True\n-- >>> same_chars \"abcd\" \"dddddddabc\"\n-- True\n-- >>> same_chars \"dddddddabc\" \"abcd\"\n-- True\n-- >>> same_chars \"eabcd\" \"dddddddabc\"\n-- False\n-- >>> same_chars \"abcd\" \"dddddddabce\"\n-- False\n-- >>> same_chars \"eabcdzzzz\" \"dddzzzzzzzddddabc\"\n-- False\nsame_chars :: String -> String -> Bool", "canonical_solution": "same_chars s0 s1 = sort (nub s0) == sort (nub s1)", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (same_chars \"eabcdzzzz\" \"dddzzzzzzzddeddabc\")\n    check (same_chars \"abcd\" \"dddddddabc\")\n    check (not $ same_chars \"eabcd\" \"dddddddabc\")\n    check (not $ same_chars \"abcd\" \"dddddddabcf\")"}
{"task_id": "Haskell/55", "prompt": "-- Return n-th Fibonacci number.\n-- >>> fib 10\n-- 55\n-- >>> fib 1\n-- 1\n-- >>> fib 8\n-- 21\nfib :: Int -> Int", "canonical_solution": "fib n = fib' n 0 1\n  where\n    fib' :: Int -> Int -> Int -> Int\n    fib' 0 a b = a\n    fib' n a b = fib' (n - 1) b (a + b)", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (fib 0 == 0)\n    check (fib 1 == 1)\n    check (fib 2 == 1)\n    check (fib 10 == 55)\n    check (fib 12 == 144)"}
{"task_id": "Haskell/56", "prompt": "-- brackets is a string of \"<\" and \">\".\n-- return True if every opening bracket has a corresponding closing bracket.\n-- >>> correct_bracketing \"<\"\n-- False\n-- >>> correct_bracketing \"<>\"\n-- True\n-- >>> correct_bracketing \"<<><>>\"\n-- True\n-- >>> correct_bracketing \"><<>\"\n-- False\ncorrect_bracketing :: String -> Bool", "canonical_solution": "correct_bracketing brackets =\n    let\n        process (depth, flag) b\n            | depth < 0 = (-1, False)\n            | b == '<'  = (depth + 1, True)\n            | otherwise = (depth - 1, True)\n    in\n        case foldl process (0, True) brackets of {}\n            (0, True) -> True\n            _         -> False", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (not $ correct_bracketing \"<\")\n    check (correct_bracketing \"<>\")\n    check (correct_bracketing \"<<><>>\")\n    check (not $ correct_bracketing \"><<>\")\n    check (not $ correct_bracketing \"<<<>\")"}
{"task_id": "Haskell/57", "prompt": "-- Return True is list elements are monotonically increasing or decreasing.\n-- >>> monotonic [1,2,4,20]\n-- True\n-- >>> monotonic [1,20,4,10]\n-- False\n-- >>> monotonic [4,1,0,-10]\n-- True\nmonotonic :: [Int] -> Bool", "canonical_solution": "monotonic l = l == sort l || l == reverse (sort l)", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (monotonic [1,2,4,20])\n    check (not $ monotonic [1,20,4,10])\n    check (monotonic [4,1,0,-10])\n    check (monotonic [9,9,9])"}
{"task_id": "Haskell/58", "prompt": "-- Return sorted unique common elements for two lists.\n-- >>> common [1,4,3,34,653,2,5] [5,7,1,5,9,653,121]\n-- [1,5,653]\n-- >>> common [5,3,2,8] [3,2]\n-- [2,3]\ncommon :: [Int] -> [Int] -> [Int]", "canonical_solution": "common l1 l2 = sort $ nub $ l1 `intersect` l2", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (common [1,4,3,34,653,2,5] [5,7,1,5,9,653,121] == [1,5,653])\n    check (common [5,3,2,8] [3,2] == [2,3])\n    check (common [4,3,2,8] [] == [])"}
{"task_id": "Haskell/59", "prompt": "-- Return the largest prime factor of n. Assume n > 1 and is not a prime.\n-- >>> largest_prime_factor 13195\n-- 29\n-- >>> largest_prime_factor 2048\n-- 2\nlargest_prime_factor :: Int -> Int", "canonical_solution": "largest_prime_factor n = maximum $ filter (\\x -> n `mod` x == 0) $ filter is_prime [2..n]\n  where \n    is_prime :: Int -> Bool\n    is_prime k = null [x | x <- [2..k-1], k `mod` x == 0]", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (largest_prime_factor 15 == 5)\n    check (largest_prime_factor 27 == 3)\n    check (largest_prime_factor 63 == 7)\n    check (largest_prime_factor 330 == 11)\n    check (largest_prime_factor 13195 == 29)\n    check (largest_prime_factor 2048 == 2)"}
{"task_id": "Haskell/60", "prompt": "-- sum_to_n is a function that sums numbers from 1 to n.\n-- >>> sum_to_n 30\n-- 465\n-- >>> sum_to_n 100\n-- 5050\n-- >>> sum_to_n 5\n-- 15\n-- >>> sum_to_n 10\n-- 55\n-- >>> sum_to_n 1\n-- 1\nsum_to_n :: Int -> Int", "canonical_solution": "sum_to_n n = sum [1..n]", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (sum_to_n 1 == 1)\n    check (sum_to_n 6 == 21)\n    check (sum_to_n 11 == 66)\n    check (sum_to_n 30 == 465)\n    check (sum_to_n 100 == 5050)"}
{"task_id": "Haskell/61", "prompt": "-- brackets is a string of \"(\" and \")\".\n-- return True if every opening bracket has a corresponding closing bracket.\n-- >>> correct_bracketing \"(\"\n-- False\n-- >>> correct_bracketing \"()\"\n-- True\n-- >>> correct_bracketing \"(()())\"\n-- True\n-- >>> correct_bracketing \")(()\"\n-- False\ncorrect_bracketing :: String -> Bool", "canonical_solution": "correct_bracketing brackets =\n    let\n        process (depth, flag) b\n            | depth < 0 = (-1, False)\n            | b == '('  = (depth + 1, True)\n            | otherwise = (depth - 1, True)\n    in\n        case foldl process (0, True) brackets of {}\n            (0, True) -> True\n            _         -> False", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (correct_bracketing \"()\" == True)\n    check (correct_bracketing \"(()())\" == True)\n    check (correct_bracketing \"()()(()())()\" == True)\n    check (correct_bracketing \"()()((()()())())(()()(()))\" == True)\n    check (correct_bracketing \"((()())))\" == False)\n    check (correct_bracketing \")(()\" == False)\n    check (correct_bracketing \"(\" == False)"}
{"task_id": "Haskell/62", "prompt": "-- xs represent coefficients of a polynomial.\n-- xs[0] + xs[1] * x + xs[2] * x^2 + ....\n-- Return derivative of this polynomial in the same form.\n-- >>> derivative [3,1,2,4,5]\n-- [1,4,12,20]\n-- >>> derivative [1,2,3]\n-- [2,6]\nderivative :: [Int] -> [Int]", "canonical_solution": "derivative xs = [i * x | (i, x) <- zip [1..] (tail xs)]", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (derivative [3,1,2,4,5] == [1,4,12,20])\n    check (derivative [1,2,3] == [2,6])\n    check (derivative [3,2,1] == [2,2])\n    check (derivative [3,2,1,0,4] == [2,2,0,16])\n    check (derivative [1] == [])"}
{"task_id": "Haskell/63", "prompt": "-- The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n-- fibfib(0) == 0\n-- fibfib(1) == 0\n-- fibfib(2) == 1\n-- fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n-- Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n-- >>> fibfib 1\n-- 0\n-- >>> fibfib 5\n-- 4\n-- >>> fibfib 8\n-- 24\nfibfib :: Int -> Int", "canonical_solution": "fibfib n\n  | n == 0 = 0\n  | n == 1 = 0\n  | n == 2 = 1\n  | otherwise = fibfib (n - 1) + fibfib (n - 2) + fibfib (n - 3)", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (fibfib 1 == 0)\n    check (fibfib 2 == 1)\n    check (fibfib 5 == 4)\n    check (fibfib 8 == 24)\n    check (fibfib 10 == 81)\n    check (fibfib 12 == 274)\n    check (fibfib 14 == 927)"}
{"task_id": "Haskell/64", "prompt": "-- Write a function vowels_count which takes a string representing\n-- a word as input and returns the number of vowels in the string.\n-- Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n-- vowel, but only when it is at the end of the given word.\n-- Example:\n-- >>> vowels_count \"abcde\"\n-- 2\n-- >>> vowels_count \"ACEDY\"\n-- 3\nvowels_count :: String -> Int", "canonical_solution": "vowels_count s = (length $ filter (`elem` \"aeiouAEIOU\") s) + if last s `elem` \"yY\" then 1 else 0", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (vowels_count \"\" == 0)\n    check (vowels_count \"abcde\" == 2)\n    check (vowels_count \"ACEDY\" == 3)\n    check (vowels_count \"Alone\" == 3)\n    check (vowels_count \"key\" == 2)"}
{"task_id": "Haskell/65", "prompt": "-- Circular shift the digits of the integer x, shift the digits right by shift\n-- and return the result as a string.\n-- If shift > number of digits, return digits reversed.\n-- >>> circular_shift 12 1\n-- \"21\"\n-- >>> circular_shift 12 2\n-- \"12\"\ncircular_shift :: Int -> Int -> String", "canonical_solution": "circular_shift x shift\n  | shift > length s = reverse s\n  | otherwise = drop (length s - shift) s ++ take (length s - shift) s\n  where \n    s :: String\n    s = show x", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (circular_shift 100 2 == \"001\")\n    check (circular_shift 12 2 == \"12\")\n    check (circular_shift 97 8 == \"79\")\n    check (circular_shift 12 1 == \"21\")"}
{"task_id": "Haskell/66", "prompt": "-- Task\n-- Write a function that takes a string as input and returns the sum of the upper characters only'\n-- ASCII codes.\n-- Examples:\n--     digitSum \"\" => 0\n--     digitSum \"abAB\" => 131\n--     digitSum \"abcCd\" => 67\n--     digitSum \"helloE\" => 69\n--     digitSum \"woArBld\" => 131\n--     digitSum \"aAaaaXa\" => 153\ndigitSum :: String -> Int", "canonical_solution": "digitSum s = sum [ord c | c <- s, isUpper c]", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (digitSum \"\" == 0)\n    check (digitSum \"abAB\" == 131)\n    check (digitSum \"abcCd\" == 67)\n    check (digitSum \"helloE\" == 69)\n    check (digitSum \"woArBld\" == 131)"}
{"task_id": "Haskell/67", "prompt": "-- In this task, you will be given a string that represents a number of apples and oranges\n-- that are distributed in a basket of fruit this basket contains\n-- apples, oranges, and mango fruits. Given the string that represents the total number of\n-- the oranges and apples and an integer that represent the total number of the fruits\n-- in the basket return the number of the mango fruits in the basket.\n-- for examble:\n-- fruit_distribution \"5 apples and 6 oranges\" 19 ->19 - 5 - 6 = 8\n-- fruit_distribution \"0 apples and 1 oranges\" 3 -> 3 - 0 - 1 = 2\n-- fruit_distribution \"2 apples and 3 oranges\" 100 -> 100 - 2 - 3 = 95\n-- fruit_distribution \"100 apples and 1 oranges\" 120 -> 120 - 100 - 1 = 19\nfruit_distribution :: String -> Int -> Int", "canonical_solution": "fruit_distribution s n = n - sum (map read (words (filter (\\x -> isDigit x || isSpace x) s)) :: [Int])", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (fruit_distribution \"5 apples and 6 oranges\" 19 == 8)\n    check (fruit_distribution \"5 apples and 6 oranges\" 21 == 10)\n    check (fruit_distribution \"0 apples and 1 oranges\" 3 == 2)\n    check (fruit_distribution \"2 apples and 3 oranges\" 100 == 95)\n    check (fruit_distribution \"2 apples and 3 oranges\" 5 == 0)\n    check (fruit_distribution \"1 apples and 100 oranges\" 120 == 19)"}
{"task_id": "Haskell/68", "prompt": "-- Given an array representing a branch of a tree that has non-negative integer nodes\n-- your task is to pluck one of the nodes and return it.\n-- The plucked node should be the node with the smallest even value.\n-- If multiple nodes with the same smallest even value are found return the node that has smallest index.\n-- The plucked node should be returned in a list, [ smalest_value, its index ],\n-- If there are no even values or the given array is empty, return [].\n-- Example 1:\n--     Input: [4,2,3]\n--     Output: [2, 1]\n--     Explanation: 2 has the smallest even value, and 2 has the smallest index.\n-- Example 2:\n--     Input: [1,2,3]\n--     Output: [2, 1]\n--     Explanation: 2 has the smallest even value, and 2 has the smallest index.\n-- Example 3:\n--     Input: []\n--     Output: []\n-- Example 4:\n--     Input: [5, 0, 3, 0, 4, 2]\n--     Output: [0, 1]\n--     Explanation: 0 is the smallest value, but  there are two zeros,\n--                  so we will choose the first zero, which has the smallest index.\n-- Constraints:\n--     * 1 <= nodes.length <= 10000\n--     * 0 <= node.value\npluck :: [Int] -> [Int]", "canonical_solution": "pluck arr = if length arr == 0 then [] else [minimum evens, head (elemIndices (minimum evens) arr)]\n    where \n        evens :: [Int]\n        evens = filter even arr", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (pluck [4,2,3] == [2,1])\n    check (pluck [1,2,3] == [2,1])\n    check (pluck [] == [])\n    check (pluck [5,0,3,0,4,2] == [0,1])\n    check (pluck [7,6,7,1] == [6,1])\n    check (pluck [7,9,7,1] == [])"}
{"task_id": "Haskell/69", "prompt": "-- You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n-- zero, and has a frequency greater than or equal to the value of the integer itself.\n-- The frequency of an integer is the number of times it appears in the list.\n-- If no such a value exist, return -1.\n-- Examples:\n--     search [4, 1, 2, 2, 3, 1] == 2\n--     search [1, 2, 2, 3, 3, 3, 4, 4, 4] == 3\n--     search [5, 5, 4, 4, 4] == -1\nsearch :: [Int] -> Int", "canonical_solution": "search lst = let frq = map (\\x -> length (filter (== x) lst)) [0..(maximum lst)]\n             in if null [i | i <- [1..(length frq - 1)], frq !! i >= i] then -1 else maximum [i | i <- [1..(length frq - 1)], frq !! i >= i]", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (search [4,1,2,2,3,1] == 2)\n    check (search [1,2,2,3,3,3,4,4,4] == 3)\n    check (search [5,5,4,4,4] == -1)\n    check (search [5,5,5,5,1] == 1)\n    check (search [4,1,4,1,4,4] == 4)\n    check (search [3,3] == -1)\n    check (search [2,3,3,2,2] == 2)"}
{"task_id": "Haskell/70", "prompt": "-- Given list of integers, return list in strange order.\n-- Strange sorting, is when you start with the minimum value,\n-- then maximum of the remaining integers, then minimum and so on.\n-- Examples:\n-- strange_sort_list [1, 2, 3, 4] == [1, 4, 2, 3]\n-- strange_sort_list [5, 5, 5, 5] == [5, 5, 5, 5]\n-- strange_sort_list [] == []\nstrange_sort_list :: [Int] -> [Int]", "canonical_solution": "strange_sort_list lst = let helper [] _ = []\n                            helper lst True = minimum lst : helper (delete (minimum lst) lst) False\n                            helper lst False = maximum lst : helper (delete (maximum lst) lst) True\n                        in helper lst True", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (strange_sort_list [1, 2, 3, 4] == [1, 4, 2, 3])\n    check (strange_sort_list [5, 6, 7, 8, 9] == [5, 9, 6, 8, 7])\n    check (strange_sort_list [1, 2, 3, 4, 5] == [1, 5, 2, 4, 3])\n    check (strange_sort_list [5, 6, 7, 8, 9, 1] == [1, 9, 5, 8, 6, 7])\n    check (strange_sort_list [5, 5, 5, 5] == [5, 5, 5, 5])\n    check (strange_sort_list [] == [])\n    check (strange_sort_list [1, 2, 3, 4, 5, 6, 7, 8] == [1, 8, 2, 7, 3, 6, 4, 5])\n    check (strange_sort_list [0, 2, 2, 2, 5, 5, -5, -5] == [-5, 5, -5, 5, 0, 2, 2, 2])\n    check (strange_sort_list [111111] == [111111])\n"}
{"task_id": "Haskell/71", "prompt": "-- Given the lengths of the three sides of a triangle. Return the area of\n-- the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n-- Otherwise return -1\n-- Three sides make a valid triangle when the sum of any two sides is greater\n-- than the third side.\n-- Example:\n-- triangle_area 3 4 5 == 6.00\n-- triangle_area 1 2 10 == -1\ntriangle_area :: Double -> Double -> Double -> Double", "canonical_solution": "triangle_area a b c = if a + b <= c || a + c <= b || b + c <= a then -1 else round' (sqrt (s * (s - a) * (s - b) * (s - c))) 2\n                      where \n                        s :: Double\n                        s = (a + b + c) / 2\n                        round' x n = (fromInteger $ round $ x * (10^n)) / (10.0^^n)", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (triangle_area 3 4 5 == 6.0)\n    check (triangle_area 1 2 10 == -1)\n    check (triangle_area 4 8 5 == 8.18)\n    check (triangle_area 2 2 2 == 1.73)\n    check (triangle_area 1 2 3 == -1)\n    check (triangle_area 10 5 7 == 16.25)\n    check (triangle_area 2 6 3 == -1)\n    check (triangle_area 1 1 1 == 0.43)\n    check (triangle_area 2 2 10 == -1)\n"}
{"task_id": "Haskell/72", "prompt": "-- Write a function that returns True if the object q will fly, and False otherwise.\n-- The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n-- Example:\n-- will_it_fly [1, 2] 5 == False\n-- 1+2 is less than the maximum possible weight, but it's unbalanced.\n-- will_it_fly [3, 2, 3] 1 == False\n-- it's balanced, but 3+2+3 is more than the maximum possible weight.\n-- will_it_fly [3, 2, 3] 9 == True\n-- 3+2+3 is less than the maximum possible weight, and it's balanced.\n-- will_it_fly [3] 5 == True\n-- 3 is less than the maximum possible weight, and it's balanced.\nwill_it_fly :: [Int] -> Int -> Bool", "canonical_solution": "will_it_fly q w = sum q <= w && q == reverse q", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (will_it_fly [3, 2, 3] 9 == True)\n    check (will_it_fly [1, 2] 5 == False)\n    check (will_it_fly [3] 5 == True)\n    check (will_it_fly [3, 2, 3] 1 == False)\n    check (will_it_fly [1, 2, 3] 6 == False)\n    check (will_it_fly [5] 5 == True)\n"}
{"task_id": "Haskell/73", "prompt": "-- Given an array arr of integers, find the minimum number of elements that\n-- need to be changed to make the array palindromic. A palindromic array is an array that\n-- is read the same backwards and forwards. In one change, you can change one element to any other element.\n-- For example:\n-- smallest_change [1,2,3,5,4,7,9,6] == 4\n-- smallest_change [1, 2, 3, 4, 3, 2, 2] == 1\n-- smallest_change [1, 2, 3, 2, 1] == 0\nsmallest_change :: [Int] -> Int", "canonical_solution": "smallest_change arr = length [i | i <- [0..(length arr `div` 2 - 1)], arr !! i /= arr !! (length arr - i - 1)]", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (smallest_change [1, 2, 3, 5, 4, 7, 9, 6] == 4)\n    check (smallest_change [1, 2, 3, 4, 3, 2, 2] == 1)\n    check (smallest_change [1, 4, 2] == 1)\n    check (smallest_change [1, 4, 4, 2] == 1)\n    check (smallest_change [1, 2, 3, 2, 1] == 0)\n    check (smallest_change [3, 1, 1, 3] == 0)\n    check (smallest_change [1] == 0)\n    check (smallest_change [0, 1] == 1)\n"}
{"task_id": "Haskell/74", "prompt": "-- Write a function that accepts two lists of strings and returns the list that has\n-- total number of chars in the all strings of the list less than the other list.\n-- if the two lists have the same number of chars, return the first list.\n-- Examples\n-- total_match [] [] == []\n-- total_match [\"hi\", \"admin\"] [\"hI\", \"Hi\"] == [\"hI\", \"Hi\"]\n-- total_match [\"hi\", \"admin\"] [\"hi\", \"hi\", \"admin\", \"project\"] == [\"hi\", \"admin\"]\n-- total_match [\"hi\", \"admin\"] [\"hI\", \"hi\", \"hi\"] == [\"hI\", \"hi\", \"hi\"]\n-- total_match [\"4\"] [\"1\", \"2\", \"3\", \"4\", \"5\"] == [\"4\"]\ntotal_match :: [String] -> [String] -> [String]", "canonical_solution": "total_match lst1 lst2 = if sum (map length lst1) <= sum (map length lst2) then lst1 else lst2", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (total_match [] [] == [])\n    check (total_match [\"hi\", \"admin\"] [\"hi\", \"hi\"] == [\"hi\", \"hi\"])\n    check (total_match [\"hi\", \"admin\"] [\"hi\", \"hi\", \"admin\", \"project\"] == [\"hi\", \"admin\"])\n    check (total_match [\"4\"] [\"1\", \"2\", \"3\", \"4\", \"5\"] == [\"4\"])\n    check (total_match [\"hi\", \"admin\"] [\"hI\", \"Hi\"] == [\"hI\", \"Hi\"])\n    check (total_match [\"hi\", \"admin\"] [\"hI\", \"hi\", \"hi\"] == [\"hI\", \"hi\", \"hi\"])\n    check (total_match [\"hi\", \"admin\"] [\"hI\", \"hi\", \"hii\"] == [\"hi\", \"admin\"])\n    check (total_match [] [\"this\"] == [])\n    check (total_match [\"this\"] [] == [])\n"}
{"task_id": "Haskell/75", "prompt": "-- Write a function that returns true if the given number is the multiplication of 3 prime numbers\n-- and false otherwise.\n-- Knowing that (a) is less then 100.\n-- Example:\n-- is_multiply_prime 30 == True\n-- 30 = 2 * 3 * 5\nis_multiply_prime :: Int -> Bool", "canonical_solution": "is_multiply_prime a = let is_prime n = null [i | i <- [2..(n-1)], n `mod` i == 0]\n                      in or [is_prime i && is_prime j && is_prime k && i * j * k == a | i <- [2..100], j <- [2..100], k <- [2..100]]", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (is_multiply_prime 5 == False)\n    check (is_multiply_prime 30 == True)\n    check (is_multiply_prime 8 == True)\n    check (is_multiply_prime 10 == False)\n    check (is_multiply_prime 125 == True)\n    check (is_multiply_prime (3 * 5 * 7) == True)\n    check (is_multiply_prime (3 * 6 * 7) == False)\n    check (is_multiply_prime (9 * 9 * 9) == False)\n    check (is_multiply_prime (11 * 9 * 9) == False)\n    check (is_multiply_prime (11 * 13 * 7) == True)\n"}
{"task_id": "Haskell/76", "prompt": "-- Your task is to write a function that returns true if a number x is a simple\n-- power of n and false in other cases.\n-- x is a simple power of n if n**int=x\n-- For example:\n-- is_simple_power 1 4 => true\n-- is_simple_power 2 2 => true\n-- is_simple_power 8 2 => true\n-- is_simple_power 3 2 => false\n-- is_simple_power 3 1 => false\n-- is_simple_power 5 3 => false\nis_simple_power :: Int -> Int -> Bool", "canonical_solution": "is_simple_power x n = or [n ^ i == x | i <- [0..x]]", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (is_simple_power 1 4 == True)\n    check (is_simple_power 2 2 == True)\n    check (is_simple_power 8 2 == True)\n    check (is_simple_power 3 2 == False)\n    check (is_simple_power 3 1 == False)\n    check (is_simple_power 5 3 == False)\n    check (is_simple_power 16 2 == True)\n    check (is_simple_power 143214 16 == False)\n    check (is_simple_power 4 2 == True)\n    check (is_simple_power 9 3 == True)\n    check (is_simple_power 16 4 == True)\n    check (is_simple_power 24 2 == False)\n    check (is_simple_power 128 4 == False)\n    check (is_simple_power 12 6 == False)\n    check (is_simple_power 1 1 == True)\n    check (is_simple_power 1 12 == True)\n"}
{"task_id": "Haskell/77", "prompt": "-- Write a function that takes an integer a and returns True\n-- if this ingeger is a cube of some integer number.\n-- Note: you may assume the input is always valid.\n-- Examples:\n-- iscube 1 ==> True\n-- iscube 2 ==> False\n-- iscube (-1) ==> True\n-- iscube 64 ==> True\n-- iscube 0 ==> True\n-- iscube 180 ==> False\niscube :: Int -> Bool", "canonical_solution": "iscube a = let b = abs a\n           in round (fromIntegral b ** (1.0 / 3.0)) ^ 3 == b", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (iscube 1 == True)\n    check (iscube 2 == False)\n    check (iscube (-1) == True)\n    check (iscube 64 == True)\n    check (iscube 180 == False)\n    check (iscube 1000 == True)\n    check (iscube 0 == True)\n    check (iscube 1729 == False)\n"}
{"task_id": "Haskell/78", "prompt": "-- You have been tasked to write a function that receives\n-- a hexadecimal number as a string and counts the number of hexadecimal\n-- digits that are primes (prime number, or a prime, is a natural number\n-- greater than 1 that is not a product of two smaller natural numbers).\n-- Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n-- Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n-- So you have to determine a number of the following digits: 2, 3, 5, 7,\n-- B (=decimal 11), D (=decimal 13).\n-- Note: you may assume the input is always correct or empty string,\n-- and symbols A,B,C,D,E,F are always uppercase.\n-- Examples:\n-- For num = \"AB\" the output should be 1.\n-- For num = \"1077E\" the output should be 2.\n-- For num = \"ABED1A33\" the output should be 4.\n-- For num = \"123456789ABCDEF0\" the output should be 6.\n-- For num = \"2020\" the output should be 2.\nhex_key :: String -> Int", "canonical_solution": "hex_key num = length [i | i <- num, i `elem` \"2357BD\"]", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (hex_key \"AB\" == 1)\n    check (hex_key \"1077E\" == 2)\n    check (hex_key \"ABED1A33\" == 4)\n    check (hex_key \"2020\" == 2)\n    check (hex_key \"123456789ABCDEF0\" == 6)\n    check (hex_key \"112233445566778899AABBCCDDEEFF00\" == 12)\n    check (hex_key \"\" == 0)\n"}
{"task_id": "Haskell/79", "prompt": "-- You will be given a number in decimal form and your task is to convert it to\n-- binary format. The function should return a string, with each character representing a binary\n-- number. Each character in the string will be '0' or '1'.\n-- There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n-- The extra characters are there to help with the format.\n-- Examples:\n-- decimal_to_binary 15   # returns \"db1111db\"\n-- decimal_to_binary 32   # returns \"db100000db\"\ndecimal_to_binary :: Int -> String", "canonical_solution": "decimal_to_binary decimal = \"db\" ++ showIntAtBase 2 intToDigit decimal \"db\"", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (decimal_to_binary 0 == \"db0db\")\n    check (decimal_to_binary 32 == \"db100000db\")\n    check (decimal_to_binary 103 == \"db1100111db\")\n    check (decimal_to_binary 15 == \"db1111db\")\n"}
{"task_id": "Haskell/80", "prompt": "-- You are given a string s.\n-- Your task is to check if the string is happy or not.\n-- A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n-- For example:\n-- is_happy \"a\" => False\n-- is_happy \"aa\" => False\n-- is_happy \"abcd\" => True\n-- is_happy \"aabb\" => False\n-- is_happy \"adb\" => True\n-- is_happy \"xyy\" => False\nis_happy :: String -> Bool", "canonical_solution": "is_happy s = length s >= 3 && and [s !! i /= s !! (i+1) && s !! (i+1) /= s !! (i+2) && s !! i /= s !! (i+2) | i <- [0..(length s - 3)]]", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (is_happy \"a\" == False)\n    check (is_happy \"aa\" == False)\n    check (is_happy \"abcd\" == True)\n    check (is_happy \"aabb\" == False)\n    check (is_happy \"adb\" == True)\n    check (is_happy \"xyy\" == False)\n    check (is_happy \"iopaxpoi\" == True)\n    check (is_happy \"iopaxioi\" == False)\n"}
{"task_id": "Haskell/81", "prompt": "-- It is the last week of the semester and the teacher has to give the grades\n-- to students. The teacher has been making her own algorithm for grading.\n-- The only problem is, she has lost the code she used for grading.\n-- She has given you a list of GPAs for some students and you have to write\n-- a function that can output a list of letter grades using the following table:\n--          GPA       |    Letter grade\n--           4.0                A+\n--         > 3.7                A\n--         > 3.3                A-\n--         > 3.0                B+\n--         > 2.7                B\n--         > 2.3                B-\n--         > 2.0                C+\n--         > 1.7                C\n--         > 1.3                C-\n--         > 1.0                D+\n--         > 0.7                D\n--         > 0.0                D-\n--           0.0                E\n-- Example:\n-- numerical_letter_grade [4.0, 3, 1.7, 2, 3.5] == [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\nnumerical_letter_grade :: [Double] -> [String]", "canonical_solution": "numerical_letter_grade grades = map grade grades\n    where\n        grade :: Double -> String\n        grade gpa\n            | gpa == 4.0 = \"A+\"\n            | gpa > 3.7 = \"A\"\n            | gpa > 3.3 = \"A-\"\n            | gpa > 3.0 = \"B+\"\n            | gpa > 2.7 = \"B\"\n            | gpa > 2.3 = \"B-\"\n            | gpa > 2.0 = \"C+\"\n            | gpa > 1.7 = \"C\"\n            | gpa > 1.3 = \"C-\"\n            | gpa > 1.0 = \"D+\"\n            | gpa > 0.7 = \"D\"\n            | gpa > 0.0 = \"D-\"\n            | otherwise = \"E\"", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (numerical_letter_grade [4.0,3,1.7,2,3.5] == [\"A+\",\"B\",\"C-\",\"C\",\"A-\"])\n    check (numerical_letter_grade [1.2]       == [\"D+\"])\n    check (numerical_letter_grade [0.5]       == [\"D-\"])\n    check (numerical_letter_grade [0.0]       == [\"E\"])\n    check (numerical_letter_grade [1,0.3,1.5,2.8,3.3] == [\"D\",\"D-\",\"C-\",\"B\",\"B+\"])\n    check (numerical_letter_grade [0,0.7]     == [\"E\",\"D-\"])\n"}
{"task_id": "Haskell/82", "prompt": "-- Write a function that takes a string and returns True if the string\n-- length is a prime number or False otherwise\n-- Examples\n-- prime_length \"Hello\" == True\n-- prime_length \"abcdcba\" == True\n-- prime_length \"kittens\" == True\n-- prime_length \"orange\" == False\nprime_length :: String -> Bool", "canonical_solution": "prime_length string = let l = length string\n                      in l /= 0 && l /= 1 && null [i | i <- [2..(l-1)], l `mod` i == 0]", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (prime_length \"Hello\"    == True)\n    check (prime_length \"abcdcba\"  == True)\n    check (prime_length \"kittens\"  == True)\n    check (prime_length \"orange\"   == False)\n    check (prime_length \"wow\"      == True)\n    check (prime_length \"world\"    == True)\n    check (prime_length \"MadaM\"    == True)\n    check (prime_length \"Wow\"      == True)\n    check (prime_length \"\"         == False)\n    check (prime_length \"HI\"       == True)\n    check (prime_length \"go\"       == True)\n    check (prime_length \"gogo\"     == False)\n    check (prime_length \"aaaaaaaaaaaaaaa\" == False)\n    check (prime_length \"Madam\"    == True)\n    check (prime_length \"M\"        == False)\n    check (prime_length \"0\"        == False)\n"}
{"task_id": "Haskell/83", "prompt": "-- Given a positive integer n, return the count of the numbers of n-digit\n-- positive integers that start or end with 1.\nstarts_one_ends :: Int -> Int", "canonical_solution": "starts_one_ends n = if n == 1 then 1 else 18 * (10 ^ (n - 2))", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (starts_one_ends 1 == 1)\n    check (starts_one_ends 2 == 18)\n    check (starts_one_ends 3 == 180)\n    check (starts_one_ends 4 == 1800)\n    check (starts_one_ends 5 == 18000)\n"}
{"task_id": "Haskell/84", "prompt": "-- Given a positive integer N, return the total sum of its digits in binary.\n-- Example\n--     For N = 1000, the sum of digits will be 1 the output should be \"1\".\n--     For N = 150, the sum of digits will be 6 the output should be \"110\".\n--     For N = 147, the sum of digits will be 12 the output should be \"1100\".\n-- Variables:\n--     @N integer\n--          Constraints: 0 \u2264 N \u2264 10000.\n-- Output:\n--      a string of binary number\nsolve :: Int -> String", "canonical_solution": "solve n = showIntAtBase 2 intToDigit (sum (map digitToInt (show n))) \"\"", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (solve 1000 == \"1\")\n    check (solve 150  == \"110\")\n    check (solve 147  == \"1100\")\n    check (solve 333  == \"1001\")\n    check (solve 963  == \"10010\")\n"}
{"task_id": "Haskell/85", "prompt": "-- Given a non-empty list of integers lst. add the even elements that are at odd indices..\n-- Examples:\n--     add [4, 2, 6, 7] ==> 2\nadd :: [Int] -> Int", "canonical_solution": "add lst =\n  sum\n    [ lst !! i\n      | i <- [1, 3 .. (length lst - 1)],\n        even (lst !! i)\n    ]", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (add [4,88]        == 88)\n    check (add [4,5,6,7,2,122]== 122)\n    check (add [4,0,6,7]     == 0)\n    check (add [4,4,6,8]     == 12)\n"}
{"task_id": "Haskell/86", "prompt": "-- Write a function that takes a string and returns an ordered version of it.\n-- Ordered version of string, is a string where all words (separated by space)\n-- are replaced by a new word where all the characters arranged in\n-- ascending order based on ascii value.\n-- Note: You should keep the order of words and blank spaces in the sentence.\n-- For example:\n-- anti_shuffle \"Hi\" returns \"Hi\"\n-- anti_shuffle \"hello\" returns \"ehllo\"\n-- anti_shuffle \"Hello World!!!\" returns \"Hello !!!Wdlor\"\nanti_shuffle :: String -> String", "canonical_solution": "anti_shuffle s = unwords [sort i | i <- words s]", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (anti_shuffle \"Hi\"                                   == \"Hi\")\n    check (anti_shuffle \"hello\"                                == \"ehllo\")\n    check (anti_shuffle \"number\"                               == \"bemnru\")\n    check (anti_shuffle \"abcd\"                                 == \"abcd\")\n    check (anti_shuffle \"Hello World!!!\"                      == \"Hello !!!Wdlor\")\n    check (anti_shuffle \"\"                                     == \"\")\n    check (anti_shuffle \"Hi. My name is Mister Robot. How are you?\" == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")\n"}
{"task_id": "Haskell/87", "prompt": "-- You are given a 2 dimensional data, as a nested lists,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the list,\n-- and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n-- each tuple is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row [[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1\n-- [(0,0),(1,4),(1,0),(2,5),(2,0)]\n-- >>> get_row [] 1\n-- []\n-- >>> get_row [[], [1], [1, 2, 3]] 3\n-- [(2,2)]\nget_row :: [[Int]] -> Int -> [(Int, Int)]", "canonical_solution": "get_row lst x =\n  let coords =\n        [ (i, j)\n          | i <- [0 .. (length lst - 1)],\n            j <- [0 .. (length (lst !! i) - 1)],\n            (lst !! i) !! j == x\n        ]\n   in sortBy\n        (\\x y -> compare (fst x) (fst y))\n        ( sortBy\n            (\\x y -> compare (snd y) (snd x))\n            coords\n        )", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (get_row [[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1 == [(0,0),(1,4),(1,0),(2,5),(2,0)])\n    check (get_row (replicate 6 [1,2,3,4,5,6]) 2           == [(0,1),(1,1),(2,1),(3,1),(4,1),(5,1)])\n    check (get_row [[1,2,3,4,5,6],[1,2,3,4,5,6],[1,1,3,4,5,6],[1,2,1,4,5,6],[1,2,3,1,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1 == [(0,0),(1,0),(2,1),(2,0),(3,2),(3,0),(4,3),(4,0),(5,4),(5,0),(6,5),(6,0)])\n    check (get_row [] 1                                        == [])\n    check (get_row [[1]] 2                                    == [])\n    check (get_row [[],[1],[1,2,3]] 3                         == [(2,2)])\n"}
{"task_id": "Haskell/88", "prompt": "-- Given an array of non-negative integers, return a copy of the given array after sorting,\n-- you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n-- or sort it in descending order if the sum( first index value, last index value) is even.\n-- Note:\n-- * don't change the given array.\n-- Examples:\n-- >>> sort_array []\n-- []\n-- >>> sort_array [5]\n-- [5]\n-- >>> sort_array [2, 4, 3, 0, 1, 5]\n-- [0,1,2,3,4,5]\n-- >>> sort_array [2, 4, 3, 0, 1, 5, 6]\n-- [6,5,4,3,2,1,0]\nsort_array :: [Int] -> [Int]", "canonical_solution": "sort_array array =\n  if length array == 0\n    then []\n    else\n      sortBy\n        ( \\x y ->\n            if (array !! 0 + array !! (length array - 1)) `mod` 2 == 0\n              then compare y x\n              else compare x y\n        )\n        array", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (sort_array []               == [])\n    check (sort_array [5]              == [5])\n    check (sort_array [2,4,3,0,1,5]    == [0,1,2,3,4,5])\n    check (sort_array [2,4,3,0,1,5,6]  == [6,5,4,3,2,1,0])\n    check (sort_array [2,1]            == [1,2])\n    check (sort_array [15,42,87,32,11,0] == [0,11,15,32,42,87])\n    check (sort_array [21,14,23,11]    == [23,21,14,11])\n"}
{"task_id": "Haskell/89", "prompt": "-- Create a function encrypt that takes a string as an argument and\n-- returns a string encrypted with the alphabet being rotated.\n-- The alphabet should be rotated in a manner such that the letters\n-- shift down by two multiplied to two places.\n-- For example:\n-- >>> encrypt \"hi\"\n-- \"lm\"\n-- >>> encrypt \"asdfghjkl\"\n-- \"ewhjklnop\"\n-- >>> encrypt \"gf\"\n-- \"kj\"\n-- >>> encrypt \"et\"\n-- \"ix\"\nencrypt :: String -> String", "canonical_solution": "encrypt s =\n  let d = ['a' .. 'z']\n   in [ d !! ((fromEnum c - fromEnum 'a' + 2 * 2) `mod` 26)\n        | c <- s\n      ]", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (encrypt \"hi\"                                            == \"lm\")\n    check (encrypt \"asdfghjkl\"                                     == \"ewhjklnop\")\n    check (encrypt \"gf\"                                            == \"kj\")\n    check (encrypt \"et\"                                            == \"ix\")\n    check (encrypt \"faewfawefaewg\"                                == \"jeiajeaijeiak\")\n    check (encrypt \"hellomyfriend\"                                == \"lippsqcjvmirh\")\n    check (encrypt \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\" == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\n    check (encrypt \"a\"                                             == \"e\")\n"}
{"task_id": "Haskell/90", "prompt": "-- You are given a list of integers.\n-- Write a function next_smallest() that returns the 2nd smallest element of the list.\n-- Return None if there is no such element.\n-- next_smallest [1, 2, 3, 4, 5] == 2\n-- next_smallest [5, 1, 4, 3, 2] == 2\n-- next_smallest [] == None\n-- next_smallest [1, 1] == None\nnext_smallest :: [Int] -> Maybe Int", "canonical_solution": "next_smallest lst =\n  if length (sort (nub lst)) < 2\n    then Nothing\n    else Just (sort (nub lst) !! 1)", "test": "-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (next_smallest [1,2,3,4,5] == Just 2)\n    check (next_smallest [5,1,4,3,2] == Just 2)\n    check (next_smallest [] == Nothing)\n    check (next_smallest [1,1] == Nothing)\n    check (next_smallest [1,1,1,1,0] == Just 1)\n    check (next_smallest [-35,34,12,-45] == Just (-35))\n"}
{"task_id": "Haskell/91", "prompt": "-- You'll be given a string of words, and your task is to count the number\n-- of boredoms. A boredom is a sentence that starts with the word \"I\".\n-- Sentences are delimited by '.', '?' or '!'.\n-- For example:\n-- >>> is_bored \"Hello world\"\n-- 0\n-- >>> is_bored \"The sky is blue. The sun is shining. I love this weather\"\n-- 1\nis_bored :: String -> Int", "canonical_solution": "is_bored s =\n  sum\n    [ 1\n      | sentence <- splitOnDelimiters s,\n        take 2 sentence == \"I \"\n    ]", "test": "-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (is_bored \"Hello world\" == 0)\n    check (is_bored \"Is the sky blue?\" == 0)\n    check (is_bored \"I love It !\" == 1)\n    check (is_bored \"bIt\" == 0)\n    check (is_bored \"I feel good today. I will be productive. will kill It\" == 2)\n    check (is_bored \"You and I are going for a walk\" == 0)\n"}
{"task_id": "Haskell/92", "prompt": "-- Create a function that takes 3 numbers.\n-- Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n-- Returns false in any other cases.\n-- Examples\n-- any_int 5 2 7 => True\n-- any_int 3 2 2 => False\n-- any_int 3 (-2) 1 => True\n-- any_int 3.6 (-2.2) 2 => False\nany_int :: Float -> Float -> Float -> Bool", "canonical_solution": "any_int x y z =\n  isInt x\n    && isInt y\n    && isInt z\n    && (x + y == z || x + z == y || y + z == x)\n  where\n    isInt a = a == fromInteger (round a)", "test": "-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (any_int 2 3 1 == True)\n    check (any_int 2.5 2 3 == False)\n    check (any_int 1.5 5 3.5 == False)\n    check (any_int 2 6 2 == False)\n    check (any_int 4 2 2 == True)\n    check (any_int 2.2 2.2 2.2 == False)\n    check (any_int (-4) 6 2 == True)\n    check (any_int 2 1 1 == True)\n    check (any_int 3 4 7 == True)\n    check (any_int 3.0 4 7 == False)\n"}
{"task_id": "Haskell/93", "prompt": "-- Write a function that takes a message, and encodes in such a\n-- way that it swaps case of all letters, replaces all vowels in\n-- the message with the letter that appears 2 places ahead of that\n-- vowel in the english alphabet.\n-- Assume only letters.\n-- Examples:\n-- >>> encode \"test\"\n-- \"TGST\"\n-- >>> encode \"This is a message\"\n-- \"tHKS KS C MGSSCGG\"\nencode :: String -> String", "canonical_solution": "encode message =\n  let vowels = \"aeiouAEIOU\"\n      vowels_replace =\n        zip\n          vowels\n          ( map\n              (\\x -> chr (ord x + 2))\n              vowels\n          )\n      message' =\n        map\n          ( \\x ->\n              if isUpper x\n                then toLower x\n                else toUpper x\n          )\n          message\n   in map\n        ( \\x ->\n            if x `elem` vowels\n              then (fromJust (lookup x vowels_replace))\n              else x\n        )\n        message'", "test": "-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (encode \"test\" == \"TGST\")\n    check (encode \"Mudasir\" == \"mWDCSKR\")\n    check (encode \"YES\" == \"ygs\")\n    check (encode \"This is a message\" == \"tHKS KS C MGSSCGG\")\n    check (encode \"I DoNt KnOw WhAt tO WrItE\" == \"k dQnT kNqW wHcT Tq wRkTg\")\n"}
{"task_id": "Haskell/94", "prompt": "-- You are given a list of integers.\n-- You need to find the largest prime value and return the sum of its digits.\n-- Examples:\n-- For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n-- For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n-- For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n-- For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n-- For lst = [0,81,12,3,1,21] the output should be 3\n-- For lst = [0,8,1,2,1,7] the output should be 7\nskjkasdkd :: [Int] -> Int", "canonical_solution": "skjkasdkd lst =\n  let isPrime n =\n        null\n          [ i\n            | i <- [2 .. (floor (sqrt (fromIntegral n)))],\n              n `mod` i == 0\n          ]\n      maxx =\n        maximum\n          [ i | i <- lst, isPrime i\n          ]\n   in sum [read [i] | i <- show maxx]", "test": "-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (skjkasdkd [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] == 10)\n    check (skjkasdkd [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] == 25)\n    check (skjkasdkd [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] == 13)\n    check (skjkasdkd [0,724,32,71,99,32,6,0,5,91,83,0,5,6] == 11)\n    check (skjkasdkd [0,81,12,3,1,21] == 3)\n    check (skjkasdkd [0,8,1,2,1,7] == 7)\n    check (skjkasdkd [8191] == 19)\n    check (skjkasdkd [8191,123456,127,7] == 19)\n    check (skjkasdkd [127,97,8192] == 10)\n"}
{"task_id": "Haskell/95", "prompt": "-- Given a dictionary, return True if all keys are strings in lower\n-- case or all keys are strings in upper case, else return False.\n-- The function should return False is the given dictionary is empty.\n-- Examples:\n-- check_dict_case [(\"a\",\"apple\"), (\"b\",\"banana\")] should return True.\n-- check_dict_case [(\"a\",\"apple\"), (\"A\",\"banana\"), (\"B\",\"banana\")] should return False.\n-- check_dict_case [(\"a\",\"apple\"), (\"8\",\"banana\"), (\"a\",\"apple\")] should return False.\n-- check_dict_case [(\"Name\",\"John\"), (\"Age\",\"36\"), (\"City\",\"Houston\")] should return False.\n-- check_dict_case [(\"STATE\",\"NC\"), (\"ZIP\",\"12345\")] should return True.\ncheck_dict_case :: [(String, String)] -> Bool", "canonical_solution": "check_dict_case dict =\n  length dict > 0\n    && all (\\x -> all isUpper x) keys\n    || all\n      (\\x -> all isLower x)\n      keys\n  where\n    keys = map fst dict", "test": "-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (check_dict_case [(\"p\",\"pineapple\"),(\"b\",\"banana\")] == True)\n    check (check_dict_case [(\"p\",\"pineapple\"),(\"A\",\"banana\"),(\"B\",\"banana\")] == False)\n    check (check_dict_case [(\"p\",\"pineapple\"),(\"8\",\"banana\"),(\"a\",\"apple\")] == False)\n    check (check_dict_case [(\"Name\",\"John\"),(\"Age\",\"36\"),(\"City\",\"Houston\")] == False)\n    check (check_dict_case [(\"STATE\",\"NC\"),(\"ZIP\",\"12345\")] == True)\n    check (check_dict_case [] == False)\n"}
{"task_id": "Haskell/96", "prompt": "-- Implement a function that takes an non-negative integer and returns an array of the first n\n-- integers that are prime numbers and less than n.\n-- for example:\n-- count_up_to 5 => [2,3]\n-- count_up_to 11 => [2,3,5,7]\n-- count_up_to 0 => []\n-- count_up_to 20 => [2,3,5,7,11,13,17,19]\n-- count_up_to 1 => []\n-- count_up_to 18 => [2,3,5,7,11,13,17]\ncount_up_to :: Int -> [Int]", "canonical_solution": "count_up_to n =\n  [ i\n    | i <- [2 .. (n - 1)],\n      is_prime i\n  ]\n  where\n    is_prime n =\n      null\n        [ i\n          | i <- [2 .. (n - 1)],\n            n `mod` i == 0\n        ]", "test": "-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (count_up_to 5 == [2,3])\n    check (count_up_to 6 == [2,3,5])\n    check (count_up_to 7 == [2,3,5])\n    check (count_up_to 10 == [2,3,5,7])\n    check (count_up_to 0 == [])\n    check (count_up_to 22 == [2,3,5,7,11,13,17,19])\n    check (count_up_to 1 == [])\n    check (count_up_to 18 == [2,3,5,7,11,13,17])\n    check (count_up_to 47 == [2,3,5,7,11,13,17,19,23,29,31,37,41,43])\n    check (count_up_to 101 == [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97])\n"}
{"task_id": "Haskell/97", "prompt": "-- Complete the function that takes two integers and returns\n-- the product of their unit digits.\n-- Assume the input is always valid.\n-- Examples:\n-- multiply 148 412 should return 16.\n-- multiply 19 28 should return 72.\n-- multiply 2020 1851 should return 0.\n-- multiply 14 (-15) should return 20.\nmultiply :: Int -> Int -> Int", "canonical_solution": "multiply a b =\n  abs (a `mod` 10)\n    * abs (b `mod` 10)", "test": "-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (multiply 148 412 == 16)\n    check (multiply 19 28 == 72)\n    check (multiply 2020 1851 == 0)\n    check (multiply 14 (-15) == 20)\n    check (multiply 76 67 == 42)\n    check (multiply 17 27 == 49)\n    check (multiply 0 1 == 0)\n    check (multiply 0 0 == 0)\n"}
{"task_id": "Haskell/98", "prompt": "-- Given a string s, count the number of uppercase vowels in even indices.\n-- For example:\n-- count_upper \"aBCdEf\" returns 1\n-- count_upper \"abcdefg\" returns 0\n-- count_upper \"dBBE\" returns 0\ncount_upper :: String -> Int", "canonical_solution": "count_upper s =\n  length\n    [ i\n      | i <- [0, 2 .. (length s - 1)],\n        s !! i `elem` \"AEIOU\"\n    ]", "test": "-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (count_upper \"aBCdEf\" == 1)\n    check (count_upper \"abcdefg\" == 0)\n    check (count_upper \"dBBE\" == 0)\n    check (count_upper \"B\" == 0)\n    check (count_upper \"U\" == 1)\n    check (count_upper \"\" == 0)\n    check (count_upper \"EEEE\" == 2)\n"}
{"task_id": "Haskell/99", "prompt": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer \"10\"\n-- 10\n-- >>> closest_integer \"15.3\"\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nclosest_integer :: String -> Integer", "canonical_solution": "closest_integer s = let n = read s :: Double\n    in round n", "test": "-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (closest_integer \"10\" == 10)\n    check (closest_integer \"14.5\" == 15)\n    check (closest_integer \"-15.5\" == -16)\n    check (closest_integer \"15.3\" == 15)\n    check (closest_integer \"0\" == 0)\n"}
{"task_id": "Haskell/100", "prompt": "-- Given a positive integer n, you have to make a pile of n levels of stones.\n-- The first level has n stones.\n-- The number of stones in the next level is:\n--     - the next odd number if n is odd.\n--     - the next even number if n is even.\n-- Return the number of stones in each level in a list, where element at index\n-- i represents the number of stones in the level (i+1).\n-- Examples:\n-- >>> make_a_pile 3\n-- [3,5,7]\nmake_a_pile :: Int -> [Int]", "canonical_solution": "make_a_pile n =\n  [ n + 2 * i\n    | i <- [0 .. n - 1]\n  ]", "test": "-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (make_a_pile 3 == [3,5,7])\n    check (make_a_pile 4 == [4,6,8,10])\n    check (make_a_pile 5 == [5,7,9,11,13])\n    check (make_a_pile 6 == [6,8,10,12,14,16])\n    check (make_a_pile 8 == [8,10,12,14,16,18,20,22])\n"}
{"task_id": "Haskell/101", "prompt": "-- You will be given a string of words separated by commas or spaces. Your task is\n-- to split the string into words and return an array of the words.\n-- For example:\n-- >>> words_string \"Hi, my name is John\"\n-- [\"Hi\",\"my\",\"name\",\"is\",\"John\"]\n-- >>> words_string \"One, two, three, four, five, six\"\n-- [\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"]\nwords_string :: String -> [String]", "canonical_solution": "words_string s = words $\n        map\n        ( \\c ->\n            if c == ','\n                then ' '\n                else c\n        )\n        s", "test": "-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (words_string \"Hi, my name is John\" == [\"Hi\",\"my\",\"name\",\"is\",\"John\"])\n    check (words_string \"One, two, three, four, five, six\" == [\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"])\n    check (words_string \"\" == [])\n    check (words_string \"ahmed     , gamal\" == [\"ahmed\",\"gamal\"])"}
{"task_id": "Haskell/102", "prompt": "-- This function takes two positive numbers x and y and returns the\n-- biggest even integer number that is in the range [x, y] inclusive. If\n-- there's no such number, then the function should return -1.\n-- For example:\n-- choose_num 12 15 = 14\n-- choose_num 13 12 = -1\nchoose_num :: Int -> Int -> Int", "canonical_solution": "choose_num x y\n  | x > y = -1\n  | y `mod` 2 == 0 = y\n  | x == y = -1\n  | otherwise = y - 1", "test": "-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (choose_num 12 15 == 14)\n    check (choose_num 13 12 == -1)\n    check (choose_num 33 12354 == 12354)\n    check (choose_num 5234 5233 == -1)\n    check (choose_num 6 29 == 28)\n    check (choose_num 27 10 == -1)\n    check (choose_num 7 7 == -1)\n    check (choose_num 546 546 == 546)"}
{"task_id": "Haskell/103", "prompt": "-- You are given two positive integers n and m, and your task is to compute the\n-- average of the integers from n through m (including n and m).\n-- Round the answer to the nearest integer and convert that to binary.\n-- If n is greater than m, return -1.\n-- Example:\n-- rounded_avg 1 5 => \"0b11\"\n-- rounded_avg 7 5 => -1\n-- rounded_avg 10 20 => \"0b1111\"\n-- rounded_avg 20 33 => \"0b11010\"\nrounded_avg :: Int -> Int -> Either Int String", "canonical_solution": "rounded_avg n m\n  | m < n = Left (-1)\n  | otherwise =\n      let avg = round $ fromIntegral (n + m) / 2\n       in Right $ \"0b\" ++ Numeric.showIntAtBase 2 Data.Char.intToDigit avg \"\"", "test": "-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    case rounded_avg 1 5 of\n      Right s -> check (s == \"0b11\")\n      _       -> error \"Failed\"\n    case rounded_avg 7 5 of\n      Left (-1) -> return ()\n      _         -> error \"Failed\"\n    case rounded_avg 10 20 of\n      Right s -> check (s == \"0b1111\")\n      _       -> error \"Failed\"\n    case rounded_avg 20 33 of\n      Right s -> check (s == \"0b11010\")\n      _       -> error \"Failed\""}
{"task_id": "Haskell/104", "prompt": "-- Given a list of positive integers x. return a sorted list of all\n-- elements that hasn't any even digit.\n-- Note: Returned list should be sorted in increasing order.\n-- For example:\n-- >>> unique_digits [15, 33, 1422, 1]\n-- [1,15,33]\n-- >>> unique_digits [152, 323, 1422, 10]\n-- []\nunique_digits :: [Int] -> [Int]", "canonical_solution": "unique_digits x = sort $ filter\n      (all odd . map digitToInt . show)\n      x", "test": "-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (unique_digits [15,33,1422,1] == [1,15,33])\n    check (unique_digits [152,323,1422,10] == [])\n    check (unique_digits [12345,2033,111,151] == [111,151])\n    check (unique_digits [135,103,31] == [31,135])"}
{"task_id": "Haskell/105", "prompt": "-- Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n-- reverse the resulting array, and then replace each digit by its corresponding name from\n-- \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n-- For example:\n--   arr = [2, 1, 1, 4, 5, 8, 2, 3]\n--         -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8]\n--         -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n--   return [\"Eight\",\"Five\",\"Four\",\"Three\",\"Two\",\"Two\",\"One\",\"One\"]\n--   If the array is empty, return an empty array:\n--   arr = []\n--   return []\n--   If the array has any strange number ignore it:\n--   arr = [1, -1 , 55]\n--         -> sort arr -> [-1, 1, 55]\n--         -> reverse arr -> [55, 1, -1]\n--   return = ['One']\nby_length :: [Int] -> [String]", "canonical_solution": "by_length xs = map toWord $ filter isDigit $ reverse $ sort xs\n  where\n    isDigit x = x >= 1 && x <= 9\n    toWord x = case x of\n      1 -> \"One\"\n      2 -> \"Two\"\n      3 -> \"Three\"\n      4 -> \"Four\"\n      5 -> \"Five\"\n      6 -> \"Six\"\n      7 -> \"Seven\"\n      8 -> \"Eight\"\n      9 -> \"Nine\"", "test": "-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (by_length [2,1,1,4,5,8,2,3] == [\"Eight\",\"Five\",\"Four\",\"Three\",\"Two\",\"Two\",\"One\",\"One\"])\n    check (by_length [] == [])\n    check (by_length [1,-1,55] == [\"One\"])\n    check (by_length [1,-1,3,2] == [\"Three\",\"Two\",\"One\"])\n    check (by_length [9,4,8] == [\"Nine\",\"Eight\",\"Four\"])"}
{"task_id": "Haskell/106", "prompt": "-- Implement the function f that takes n as a parameter,\n-- and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n-- or the sum of numbers from 1 to i otherwise.\n-- i starts from 1.\n-- the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n-- Example:\n-- f 5 == [1,2,6,24,15]\nf :: Int -> [Int]", "canonical_solution": "f n =\n  [ if even i\n      then product [1 .. i]\n      else sum [1 .. i]\n    | i <- [1 .. n]\n  ]", "test": "-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (f 5 == [1,2,6,24,15])\n    check (f 7 == [1,2,6,24,15,720,28])\n    check (f 1 == [1])\n    check (f 3 == [1,2,6])"}
{"task_id": "Haskell/107", "prompt": "-- Given a positive integer n, return a tuple that has the number of even and odd\n-- integer palindromes that fall within the range(1, n), inclusive.\n-- Example 1:\n--     Input: 3\n--     Output: (1,2)\n--     Explanation:\n--     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n-- Example 2:\n--     Input: 12\n--     Output: (4,6)\n--     Explanation:\n--     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n-- Note:\n--     1. 1 <= n <= 10^3\n--     2. returned tuple has the number of even and odd integer palindromes respectively.\neven_odd_palindrome :: Int -> (Int, Int)", "canonical_solution": "even_odd_palindrome n = (evenCount, oddCount)\n  where\n    isPalindrome x = show x == reverse (show x)\n    evenCount = length [x | x <- [1..n], isPalindrome x, even x]\n    oddCount = length [x | x <- [1..n], isPalindrome x, odd x]", "test": "-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (even_odd_palindrome 123 == (8,13))\n    check (even_odd_palindrome 12 == (4,6))\n    check (even_odd_palindrome 3 == (1,2))\n    check (even_odd_palindrome 63 == (6,8))\n    check (even_odd_palindrome 25 == (5,6))\n    check (even_odd_palindrome 19 == (4,6))\n    check (even_odd_palindrome 9 == (4,5))\n    check (even_odd_palindrome 1 == (0,1))"}
{"task_id": "Haskell/108", "prompt": "-- Write a function count_nums which takes an array of integers and returns\n-- the number of elements which has a sum of digits > 0.\n-- If a number is negative, then its first signed digit will be negative:\n-- e.g. -123 has signed digits -1, 2, and 3.\n-- >>> count_nums [] == 0\n-- >>> count_nums [-1, 11, -11] == 1\n-- >>> count_nums [1, 1, 2] == 3\ncount_nums :: [Int] -> Int", "canonical_solution": "count_nums arr = length $ filter (> 0) $ map digitsSum arr\n  where\n    digitsSum n =\n      if n < 0\n        then negate $ sum $ map digitToInt $ tail $ show n\n        else sum $ map digitToInt $ show n", "test": "-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (count_nums [] == 0)\n    check (count_nums [-1,11,-11] == 1)\n    check (count_nums [1,1,2] == 3)\n    check (count_nums [1,1,2,-2,3,4,5] == 6)\n    check (count_nums [1,6,9,-6,0,1,5] == 5)\n    check (count_nums [1,100,98,-7,1,-1] == 4)\n    check (count_nums [12,23,34,-45,-56,0] == 5)\n    check (count_nums [-0,1] == 1)\n    check (count_nums [1] == 1)"}
{"task_id": "Haskell/109", "prompt": "-- We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n-- numbers in the array will be randomly ordered. Your task is to determine if\n-- it is possible to get an array sorted in non-decreasing order by performing\n-- the following operation on the given array:\n--     You are allowed to perform right shift operation any number of times.\n-- One right shift operation means shifting all elements of the array by one\n-- position in the right direction. The last element of the array will be moved to\n-- the starting position in the array i.e. 0th index.\n-- If it is possible to obtain the sorted array by performing the above operation\n-- then return True else return False.\n-- If the given array is empty then return True.\n-- Note: The given list is guaranteed to have unique elements.\n-- For Example:\n-- move_one_ball [3, 4, 5, 1, 2] ==>True\n-- Explanation: By performin 2 right shift operations, non-decreasing order can\n--              be achieved for the given array.\n-- move_one_ball [3, 5, 4, 1, 2] ==>False\n-- Explanation:It is not possible to get non-decreasing order for the given\n--             array by performing any number of right shift operations.\nmove_one_ball :: (Ord a) => [a] -> Bool", "canonical_solution": "move_one_ball [] = True\nmove_one_ball arr = any (\\i -> rotate i arr == sort arr) [0 .. length arr - 1]\n  where\n    rotate n xs = drop n xs ++ take n xs", "test": "-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (move_one_ball [3,4,5,1,2] == True)\n    check (move_one_ball [3,5,10,1,2] == True)\n    check (move_one_ball [4,3,1,2] == False)\n    check (move_one_ball [3,5,4,1,2] == False)\n    check (move_one_ball [] == True)"}
{"task_id": "Haskell/110", "prompt": "-- In this problem, you will implement a function that takes two lists of numbers,\n-- and determines whether it is possible to perform an exchange of elements\n-- between them to make lst1 a list of only even numbers.\n-- There is no limit on the number of exchanged elements between lst1 and lst2.\n-- If it is possible to exchange elements between the lst1 and lst2 to make\n-- all the elements of lst1 to be even, return \"YES\".\n-- Otherwise, return \"NO\".\n-- For example:\n-- exchange [1, 2, 3, 4] [1, 2, 3, 4] => \"YES\"\n-- exchange [1, 2, 3, 4] [1, 5, 3, 4] => \"NO\"\n-- It is assumed that the input lists will be non-empty.\nexchange :: [Int] -> [Int] -> String", "canonical_solution": "exchange lst1 lst2\n  | evenCount >= oddCount = \"YES\"\n  | otherwise = \"NO\"\n  where\n    evenCount = length $ filter even lst2\n    oddCount = length $ filter odd lst1", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (exchange [1,2,3,4] [1,2,3,4] == \"YES\")\n    check (exchange [1,2,3,4] [1,5,3,4] == \"NO\")\n    check (exchange [1,2,3,4] [2,1,4,3] == \"YES\")\n    check (exchange [5,7,3]   [2,6,4]   == \"YES\")\n    check (exchange [5,7,3]   [2,6,3]   == \"NO\")\n    check (exchange [3,2,6,1,8,9] [3,5,5,1,1,1] == \"NO\")\n    check (exchange [100,200] [200,200] == \"YES\")\n"}
{"task_id": "Haskell/111", "prompt": "-- Given a string representing a space separated lowercase letters, return a dictionary\n-- of the letter with the most repetition and containing the corresponding count.\n-- If several letters have the same occurrence, return all of them.\n-- Example:\n-- histogram \"a b c\" == [('a',1),('b',1),('c',1)]\n-- histogram \"a b b a\" == [('a',2),('b',2)]\n-- histogram \"a b c a b\" == [('a',2),('b',2)]\n-- histogram \"b b b b a\" == [('b',4)]\n-- histogram(\"\") == []\nhistogram :: String -> [(Char, Int)]", "canonical_solution": "histogram str =\n  [ (c, n)\n    | (n, c) <- freqs,\n      n == maxFreq\n  ]\n  where\n    freqs =\n      [ (length g, head g)\n        | g <- group $ sort str,\n          head g /= ' '\n      ]\n    maxFreq = maximum $ map fst freqs", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (histogram \"a b b a\"     == [('a',2),('b',2)])\n    check (histogram \"a b c a b\"   == [('a',2),('b',2)])\n    check (histogram \"a b c d g\"   == [('a',1),('b',1),('c',1),('d',1),('g',1)])\n    check (histogram \"r t g\"       == [('r',1),('t',1),('g',1)])\n    check (histogram \"b b b b a\"   == [('b',4)])\n    check (histogram \"\"            == [])\n    check (histogram \"a\"           == [('a',1)])\n"}
{"task_id": "Haskell/112", "prompt": "-- Task\n-- We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n-- then check if the result string is palindrome.\n-- A string is called palindrome if it reads the same backward as forward.\n-- You should return a tuple containing the result string and True/False for the check.\n-- Example\n-- For s = \"abcde\", c = \"ae\", the result should be (\"bcd\",False)\n-- For s = \"abcdef\", c = \"b\"  the result should be (\"acdef\",False)\n-- For s = \"abcdedcba\", c = \"ab\", the result should be (\"cdedc\",True)\nreverse_delete :: String -> String -> (String, Bool)", "canonical_solution": "reverse_delete s c = (s', s' == reverse s')\n  where\n    s' =v filter (`notElem` c) s", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (reverse_delete \"abcde\"      \"ae\" == (\"bcd\",False))\n    check (reverse_delete \"abcdef\"     \"b\"  == (\"acdef\",False))\n    check (reverse_delete \"abcdedcba\"  \"ab\" == (\"cdedc\",True))\n    check (reverse_delete \"dwik\"       \"w\"  == (\"dik\",False))\n    check (reverse_delete \"a\"          \"a\"  == (\"\",True))\n    check (reverse_delete \"abcdedcba\"  \"\"   == (\"abcdedcba\",True))\n    check (reverse_delete \"abcdedcba\"  \"v\"  == (\"abcdedcba\",True))\n    check (reverse_delete \"vabba\"      \"v\"  == (\"abba\",True))\n    check (reverse_delete \"mamma\"      \"mia\"== (\"\",True))\n"}
{"task_id": "Haskell/113", "prompt": "-- Given a list of strings, where each string consists of only digits, return a list.\n-- Each element i of the output should be \"the number of odd elements in the\n-- string i of the input.\" where all the i's should be replaced by the number\n-- of odd digits in the i'th string of the input.\n-- >>> odd_count [\"1234567\"]\n-- [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n-- >>> odd_count [\"3\",\"11111111\"]\n-- [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n--  \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\nodd_count :: [String] -> [String]", "canonical_solution": "odd_count lst = map countOdd lst\n  where\n    countOdd s = \"the number of odd elements \" ++ show n ++ \"n the str\" ++ show n ++ \"ng \" ++ show n ++ \" of the \" ++ show n ++ \"nput.\"\n      where\n        n =\n          length $\n            filter odd $\n              map read $\n                map (: []) s", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (odd_count [\"1234567\"]               == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"])\n    check (odd_count [\"3\",\"11111111\"]        == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\"the number of odd elements 8n the str8ng 8 of the 8nput.\"])\n    check (odd_count [\"271\",\"137\",\"314\"]    == [\"the number of odd elements 2n the str2ng 2 of the 2nput.\",\"the number of odd elements 3n the str3ng 3 of the 3nput.\",\"the number of odd elements 2n the str2ng 2 of the 2nput.\"])\n    check (odd_count []                         == [])\n"}
{"task_id": "Haskell/114", "prompt": "-- Given an array of integers nums, find the minimum sum of any non-empty sub-array\n-- of nums.\n-- Example\n-- minSubArraySum [2, 3, 4, 1, 2, 4] == 1\n-- minSubArraySum [-1, -2, -3] == -6\nminSubArraySum :: [Int] -> Int", "canonical_solution": "minSubArraySum [x] = x\nminSubArraySum (x:xs) = minimum [n, n + x, x]\n  where n = minSubArraySum xs", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (minSubArraySum [2,3,4,1,2,4]           == 1)\n    check (minSubArraySum [-1,-2,-3]              == -6)\n    check (minSubArraySum [-1,-2,-3,2,-10]       == -14)\n    check (minSubArraySum [-9999999999999999]     == -9999999999999999)\n    check (minSubArraySum [0,10,20,1000000]       == 0)\n    check (minSubArraySum [-1,-2,-3,10,-5]       == -6)\n    check (minSubArraySum [100,-1,-2,-3,10,-5]    == -6)\n    check (minSubArraySum [10,11,13,8,3,4]        == 3)\n    check (minSubArraySum [100,-33,32,-1,0,-2]    == -33)\n    check (minSubArraySum [-10]                   == -10)\n    check (minSubArraySum [7]                     == 7)\n    check (minSubArraySum [1,-1]                  == -1)\n"}
{"task_id": "Haskell/115", "prompt": "-- You are given a rectangular grid of wells. Each row represents a single well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well has a corresponding bucket that can be used to extract water from it,\n-- and all buckets have the same capacity.\n-- Your task is to use the buckets to empty the wells.\n-- Output the number of times you need to lower the buckets.\n-- Example 1:\n--     Input:\n--         grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n--         bucket_capacity : 1\n--     Output: 6\n-- Example 2:\n--     Input:\n--         grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n--         bucket_capacity : 2\n--     Output: 5\n-- Example 3:\n--     Input:\n--         grid : [[0,0,0], [0,0,0]]\n--         bucket_capacity : 5\n--     Output: 0\n-- constraints:\n--     * all wells have the same length\n--     * 1 <= grid.length <= 10^2\n--     * 1 <= grid[:,1].length <= 10^2\n--     * grid[i][j] -> 0 | 1\n--     * 1 <= capacity <= 10\nmax_fill :: [[Int]] -> Int -> Int", "canonical_solution": "max_fill grid capacity = sum $ map (ceiling . (/ fromIntegral capacity) . fromIntegral . sum) $ grid", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (max_fill [[0,0,1,0],[0,1,0,0],[1,1,1,1]]    1 == 6)\n    check (max_fill [[0,0,1,1],[0,0,0,0],[1,1,1,1],[0,1,1,1]] 2 == 5)\n    check (max_fill [[0,0,0],[0,0,0]]                 5 == 0)\n    check (max_fill [[1,1,1,1],[1,1,1,1]]              2 == 4)\n    check (max_fill [[1,1,1,1],[1,1,1,1]]              9 == 2)\n"}
{"task_id": "Haskell/116", "prompt": "-- In this Kata, you have to sort an array of non-negative integers according to\n-- number of ones in their binary representation in ascending order.\n-- For similar number of ones, sort based on decimal value.\n-- It must be implemented like this:\n-- >>> sort_array [1, 5, 2, 3, 4] == [1, 2, 3, 4, 5]\n-- >>> sort_array [-2, -3, -4, -5, -6] == [-6, -5, -4, -3, -2]\n-- >>> sort_array [1, 0, 2, 3, 4] [0, 1, 2, 3, 4]\nsort_array :: [Int] -> [Int]", "canonical_solution": "sort_array arr = sortBy g arr\n  where\n    f x y = compare (countOnes $ abs x) (countOnes $ abs y)\n    g x y =\n      if (f x y) /= EQ\n        then (f x y)\n        else (compare x y)\n    countOnes x =\n      length $\n        filter (== '1') $\n          showIntAtBase 2 intToDigit x \"\"", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (sort_array [1,5,2,3,4]               == [1,2,4,3,5])\n    check (sort_array [-2,-3,-4,-5,-6]          == [-4,-2,-6,-5,-3])\n    check (sort_array [1,0,2,3,4]               == [0,1,2,4,3])\n    check (sort_array []                        == [])\n    check (sort_array [2,5,77,4,5,3,5,7,2,3,4]  == [2,2,4,4,3,3,5,5,5,7,77])\n    check (sort_array [3,6,44,12,32,5]          == [32,3,5,6,12,44])\n    check (sort_array [2,4,8,16,32]             == [2,4,8,16,32])\n"}
{"task_id": "Haskell/117", "prompt": "-- Given a string s and a natural number n, you have been tasked to implement\n-- a function that returns a list of all words from string s that contain exactly\n-- n consonants, in order these words appear in the string s.\n-- If the string s is empty then the function should return an empty list.\n-- Note: you may assume the input string contains only letters and spaces.\n-- Examples:\n-- select_words \"Mary had a little lamb\" 4 ==> [\"little\"]\n-- select_words \"Mary had a little lamb\" 3 ==> [\"Mary\", \"lamb\"]\n-- select_words \"simple white space\" 2 ==> []\n-- select_words \"Hello world\" 4 ==> [\"world\"]\n-- select_words \"Uncle sam\" 3 ==> [\"Uncle\"]\nselect_words :: String -> Int -> [String]", "canonical_solution": "select_words s n = filter (\\word -> countConsonants word == n) $ words s\n  where\n    countConsonants word = length $ filter (\\c -> isConsonant c && isLetter c) word\n    isConsonant c = toLower c `notElem` \"aeiou\"\n    isLetter c = c `elem` ['a'..'z'] ++ ['A'..'Z']", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (select_words \"Mary had a little lamb\" 4 == [\"little\"] )\n    check (select_words \"Mary had a little lamb\" 3 == [\"Mary\",\"lamb\"])                \n    check (select_words \"simple white space\"    2 == [] )\n    check (select_words \"Hello world\"           4 == [\"world\"])                      \n    check (select_words \"Uncle sam\"             3 == [\"Uncle\"])                      \n    check (select_words \"\"                      4 == [] )\n    check (select_words \"a b c d e f\"           1 == [\"b\",\"c\",\"d\",\"f\"])        \n"}
{"task_id": "Haskell/118", "prompt": "-- You are given a word. Your task is to find the closest vowel that stands between\n-- two consonants from the right side of the word (case sensitive).\n-- Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n-- find any vowel met the above condition.\n-- You may assume that the given string contains English letter only.\n-- Example:\n-- get_closest_vowel \"yogurt\" ==> \"u\"\n-- get_closest_vowel \"FULL\" ==> \"U\"\n-- get_closest_vowel \"quick\" ==> \"\"\n-- get_closest_vowel \"ab\" ==> \"\"\nget_closest_vowel :: String -> String", "canonical_solution": "get_closest_vowel word = f (reverse word)\n  where\n    f (x : y : z : xs) =\n      if vowel y && consonant x && consonant z\n        then [y]\n        else f (y : z : xs)\n    f _ = \"\"\n    vowel x = x `elem` \"aeiouAEIOU\"\n    consonant = not . vowel", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (get_closest_vowel \"yogurt\" == \"u\")\n    check (get_closest_vowel \"full\"   == \"u\")\n    check (get_closest_vowel \"easy\"   == \"\")\n    check (get_closest_vowel \"eAsy\"   == \"\")\n    check (get_closest_vowel \"ali\"    == \"\")\n    check (get_closest_vowel \"bad\"    == \"a\")\n    check (get_closest_vowel \"most\"   == \"o\")\n    check (get_closest_vowel \"ab\"     == \"\")\n    check (get_closest_vowel \"ba\"     == \"\")\n    check (get_closest_vowel \"quick\"  == \"\")\n    check (get_closest_vowel \"anime\"  == \"i\")\n    check (get_closest_vowel \"Asia\"   == \"\")\n    check (get_closest_vowel \"Above\"  == \"o\")\n"}
{"task_id": "Haskell/119", "prompt": "-- You are given a list of two strings, both strings consist of open\n-- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if it is possible to concatenate the two strings in\n-- some order, that the resulting string will be good.\n-- A string S is considered to be good if and only if all parentheses in S\n-- are balanced. For example: the string '(())()' is good, while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens [\"()(\", \")\"] == \"Yes\"\n-- match_parens [\")\", \")\"] == \"No\"\nmatch_parens :: [String] -> String", "canonical_solution": "match_parens [s1, s2] = if check (s1 ++ s2) || check (s2 ++ s1) then \"Yes\" else \"No\"\n  where\n    check :: String -> Bool\n    check s = go s 0\n    go :: String -> Int -> Bool\n    go [] n = n == 0\n    go ('(':xs) n = go xs (n+1)\n    go (')':xs) n = n > 0 && go xs (n-1)\n    go (_:xs) n = go xs n\nmatchParens _ = \"No\"", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (match_parens [\"()(\",\")\"]        == \"Yes\")\n    check (match_parens [\")\",\")\"]          == \"No\")\n    check (match_parens [\"(()(())\",\"())())\"] == \"No\")\n    check (match_parens [\")())\",\"(()()(\"]  == \"Yes\")\n    check (match_parens [\"(())))\",\"(()())((\"] == \"Yes\")\n    check (match_parens [\"()\",\"())\"]       == \"No\")\n    check (match_parens [\"(()(\",\"()))()\"] == \"Yes\")\n    check (match_parens [\"(((()\",\"((())\"]   == \"No\")\n    check (match_parens [\")(()\",\"(()(\"]   == \"No\")\n    check (match_parens [\")(\",\")(\"]       == \"No\")\n    check (match_parens [\"(\",\")\"]          == \"Yes\")\n    check (match_parens [\")\",\"(\"]          == \"Yes\")\n"}
{"task_id": "Haskell/120", "prompt": "-- Given an array arr of integers and a positive integer k, return a sorted list\n-- of length k with the maximum k numbers in arr.\n-- Example 1:\n--     Input: arr = [-3, -4, 5], k = 3\n--     Output: [-4, -3, 5]\n-- Example 2:\n--     Input: arr = [4, -4, 4], k = 2\n--     Output: [4, 4]\n-- Example 3:\n--     Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n--     Output: [2]\n-- Note:\n--     1. The length of the array will be in the range of [1, 1000].\n--     2. The elements in the array will be in the range of [-1000, 1000].\n--     3. 0 <= k <= len(arr)\nmaximumK :: [Int] -> Int -> [Int]", "canonical_solution": "maximumK arr k = reverse $ take k $ reverse $ sort arr", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (maximumK [-3,-4,5] 3 == [-4,-3,5])\n    check (maximumK [4,-4,4] 2 == [4,4])\n    check (maximumK [-3,2,1,2,-1,-2,1] 1 == [2])\n    check (maximumK [123,-123,20,0,1,2,-3] 3 == [2,20,123])\n    check (maximumK [-123,20,0,1,2,-3] 4 == [0,1,2,20])\n    check (maximumK [5,15,0,3,-13,-8,0] 7 == [-13,-8,0,0,3,5,15])\n    check (maximumK [-1,0,2,5,3,-10] 2 == [3,5])\n    check (maximumK [1,0,5,-7] 1 == [5])\n    check (maximumK [4,-4] 2 == [-4,4])\n    check (maximumK [-10,10] 2 == [-10,10])\n    check (maximumK [1,2,3,-23,243,-400,0] 0 == [])\n"}
{"task_id": "Haskell/121", "prompt": "-- Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n-- Examples\n-- solution [5, 8, 7, 1] ==> 12\n-- solution [3, 3, 3, 3, 3] ==> 9\n-- solution [30, 13, 24, 321] ==> 0\nsolution :: [Int] -> Int", "canonical_solution": "solution lst =\n  sum\n    [ x\n      | (idx, x) <- zip [0 ..] lst,\n        even idx,\n        odd x\n    ]", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (solution [5,8,7,1] == 12)\n    check (solution [3,3,3,3,3] == 9)\n    check (solution [30,13,24,321] == 0)\n    check (solution [5,9] == 5)\n    check (solution [2,4,8] == 0)\n    check (solution [30,13,23,32] == 23)\n    check (solution [3,13,2,9] == 3)\n"}
{"task_id": "Haskell/122", "prompt": "-- Given a non-empty array of integers arr and an integer k, return\n-- the sum of the elements with at most two digits from the first k elements of arr.\n-- Example:\n--     Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n--     Output: 24 # sum of 21 + 3\n-- Constraints:\n--     1. 1 <= len(arr) <= 100\n--     2. 1 <= k <= len(arr)\nadd_elements :: [Int] -> Int -> Int", "canonical_solution": "add_elements arr k = sum [x | x <- take k arr, length (show x) <= 2]", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (add_elements [1,-2,-3,41,57,76,87,88,99] 3 == -4)\n    check (add_elements [111,121,3,4000,5,6] 2 == 0)\n    check (add_elements [11,21,3,90,5,6,7,8,9] 4 == 125)\n    check (add_elements [111,21,3,4000,5,6,7,8,9] 4 == 24)\n    check (add_elements [1] 1 == 1)\n"}
{"task_id": "Haskell/123", "prompt": "-- Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n-- The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n-- as follows: start with any positive integer n. Then each term is obtained from the\n-- previous term as follows: if the previous term is even, the next term is one half of\n-- the previous term. If the previous term is odd, the next term is 3 times the previous\n-- term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n-- Note:\n--     1. Collatz(1) is [1].\n--     2. returned list sorted in increasing order.\n-- For example:\n-- get_odd_collatz 5 returns [1,5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\nget_odd_collatz :: Int -> [Int]", "canonical_solution": "get_odd_collatz n = sort $ filter odd $ collatz n\n  where\n    collatz :: Int -> [Int]\n    collatz 1 = [1]\n    collatz x\n      | even x = x : collatz (x `div` 2)\n      | otherwise = x : collatz (x * 3 + 1)", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (get_odd_collatz 14 == [1,5,7,11,13,17])\n    check (get_odd_collatz 5 == [1,5])\n    check (get_odd_collatz 12 == [1,3,5])\n    check (get_odd_collatz 1 == [1])\n"}
{"task_id": "Haskell/124", "prompt": "-- You have to write a function which validates a given date string and\n-- returns True if the date is valid otherwise False.\n-- The date is valid if all of the following rules are satisfied:\n-- 1. The date string is not empty.\n-- 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n-- 3. The months should not be less than 1 or higher than 12.\n-- 4. The date should be in the format: mm-dd-yyyy\n-- for example:\n-- >>> valid_date \"03-11-2000\"\n-- True\n-- >>> valid_date \"15-01-2012\"\n-- False\n-- >>> valid_date \"04-0-2040\"\n-- False\n-- >>> valid_date \"06-04-2020\"\n-- True\n-- >>> valid_date \"06/04/2020\"\n-- False\nvalid_date :: String -> Bool", "canonical_solution": "valid_date date = case splitDate date of\n  Just (m, d, y) -> isValidDate m d y\n  _ -> False\n  where\n    splitDate :: String -> Maybe (Int, Int, Int)\n    splitDate (m1 : m2 : '-' : d1 : d2 : '-' : y1 : y2 : y3 : y4 : []) =\n      Just\n        ( digitToInt m1 * 10 + digitToInt m2,\n          digitToInt d1 * 10 + digitToInt d2,\n          digitToInt y1 * 1000 + digitToInt y2 * 100 + digitToInt y3 * 10 + digitToInt y4\n        )\n    splitDate _ = Nothing\n    isValidDate m d y =\n      m >= 1\n        && m <= 12\n        && ( m `elem` [1, 3, 5, 7, 8, 10, 12] && d >= 1 && d <= 31\n               || m `elem` [4, 6, 9, 11] && d >= 1 && d <= 30\n               || m == 2 && d >= 1 && d <= 29 && (y `mod` 4 /= 0 || y `mod` 100 == 0 && y `mod` 400 /= 0)\n           )", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (valid_date \"03-11-2000\" == True)\n    check (valid_date \"15-01-2012\" == False)\n    check (valid_date \"04-0-2040\" == False)\n    check (valid_date \"06-04-2020\" == True)\n    check (valid_date \"01-01-2007\" == True)\n    check (valid_date \"03-32-2011\" == False)\n    check (valid_date \"\" == False)\n    check (valid_date \"04-31-3000\" == False)\n    check (valid_date \"06-06-2005\" == True)\n    check (valid_date \"21-31-2000\" == False)\n    check (valid_date \"04-12-2003\" == True)\n    check (valid_date \"04122003\" == False)\n    check (valid_date \"20030412\" == False)\n    check (valid_date \"2003-04\" == False)\n    check (valid_date \"2003-04-12\" == False)\n    check (valid_date \"04-2003\" == False)\n"}
{"task_id": "Haskell/125", "prompt": "-- Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n-- should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n-- alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n-- Examples\n-- split_words \"Hello world!\" \u279e [\"Hello\",\"world!\"]\n-- split_words \"Hello,world!\" \u279e [\"Hello\",\"world!\"]\n-- split_words \"abcdef\" == 3\nsplit_words :: String -> Either Int [String]", "canonical_solution": "split_words txt\n  | ' ' `elem` txt = Right $ words txt\n  | ',' `elem` txt = Right $ words $ map (\\c -> if c == ',' then ' ' else c) txt\n  | otherwise = Left $ length $ filter (\\c -> isLower c && even (ord c)) txt", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (split_words \"Hello world!\" == Right [\"Hello\",\"world!\"])\n    check (split_words \"Hello,world!\" == Right [\"Hello\",\"world!\"])\n    check (split_words \"Hello world,!\" == Right [\"Hello\",\"world,!\"])\n    check (split_words \"Hello,Hello,world !\" == Right [\"Hello,Hello,world\",\"!\"])\n    check (split_words \"abcdef\" == Left 3)\n    check (split_words \"aaabb\" == Left 2)\n    check (split_words \"aaaBb\" == Left 1)\n    check (split_words \"\" == Left 0)\n"}
{"task_id": "Haskell/126", "prompt": "-- Given a list of numbers, return whether or not they are sorted\n-- in ascending order. If list has more than 1 duplicate of the same\n-- number, return False. Assume no negative numbers and only integers.\n-- Examples\n-- is_sorted [5] \u279e True\n-- is_sorted [1, 2, 3, 4, 5] \u279e True\n-- is_sorted [1, 3, 2, 4, 5] \u279e False\n-- is_sorted [1, 2, 3, 4, 5, 6] \u279e True\n-- is_sorted [1, 2, 3, 4, 5, 6, 7] \u279e True\n-- is_sorted [1, 3, 2, 4, 5, 6, 7] \u279e False\n-- is_sorted [1, 2, 2, 3, 3, 4] \u279e True\n-- is_sorted [1, 2, 2, 2, 3, 4] \u279e False\nis_sorted :: [Int] -> Bool", "canonical_solution": "is_sorted lst = length (nub lst) == length lst && all (uncurry (<=)) (zip lst (tail lst))", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (is_sorted [] == True)\n    check (is_sorted [5] == True)\n    check (is_sorted [1,2,3,4,5] == True)\n    check (is_sorted [1,3,2,4,5] == False)\n    check (is_sorted [1,2,3,4,5,6] == True)\n    check (is_sorted [1,2,3,4,5,6,7] == True)\n    check (is_sorted [1,3,2,4,5,6,7] == False)\n    check (is_sorted [1,2,2,3,3,4] == True)\n    check (is_sorted [1,2,2,2,3,4] == False)\n    check (is_sorted [1,2,3,3,3,4] == False)\n    check (is_sorted [3,2,1] == False)\n    check (is_sorted [1,2,3,4] == True)\n"}
{"task_id": "Haskell/127", "prompt": "-- You are given two intervals,\n-- where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n-- The given intervals are closed which means that the interval (start, end)\n-- includes both start and end.\n-- For each given interval, it is assumed that its start is less or equal its end.\n-- Your task is to determine whether the length of intersection of these two\n-- intervals is a prime number.\n-- Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n-- which its length is 1, which not a prime number.\n-- If the length of the intersection is a prime number, return \"YES\",\n-- otherwise, return \"NO\".\n-- If the two intervals don't intersect, return \"NO\".\n-- [input/output] samples:\n-- intersection (1, 2) (2, 3) ==> \"NO\"\n-- intersection (-1, 1) (0, 4) ==> \"NO\"\n-- intersection (-3, -1) (-5, 5) ==> \"YES\"\nintersection :: (Int, Int) -> (Int, Int) -> String", "canonical_solution": "intersection (a, b) (c, d)\n  | b < c || d < a = \"NO\"\n  | otherwise = if isPrime (abs (min b d - max a c)) then \"YES\" else \"NO\"\n  where\n    isPrime :: Int -> Bool\n    isPrime n = n > 1 && all (\\k -> n `mod` k /= 0) [2..floor (sqrt (fromIntegral n))]", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (intersection (1,2) (2,3) == \"NO\")\n    check (intersection (-1,1) (0,4) == \"NO\")\n    check (intersection (-3,-1) (-5,5) == \"YES\")\n    check (intersection (-2,2) (-4,0) == \"YES\")\n    check (intersection (-11,2) (-1,-1) == \"NO\")\n    check (intersection (1,2) (3,5) == \"NO\")\n    check (intersection (1,2) (1,2) == \"NO\")\n    check (intersection (-2,-2) (-3,-2) == \"NO\")\n"}
{"task_id": "Haskell/128", "prompt": "-- You are given an array arr of integers and you need to return\n-- sum of magnitudes of integers multiplied by product of all signs\n-- of each number in the array, represented by 1, -1 or 0.\n-- Note: return None for empty arr.\n-- Example:\n-- >>> prod_signs [1, 2, 2, -4] == Just (-9)\n-- >>> prod_signs [0, 1] == Just 0\n-- >>> prod_signs [] == Nothing\nprod_signs :: [Int] -> Maybe Int", "canonical_solution": "prod_signs arr\n  | null arr = Nothing\n  | otherwise = Just $ prod * sum (map abs arr)\n  where\n    prod :: Int\n    prod = if 0 `elem` arr then 0 else (-1) ^ length (filter (< 0) arr)", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (prod_signs [1,2,2,-4] == Just (-9))\n    check (prod_signs [0,1] == Just 0)\n    check (prod_signs [1,1,1,2,3,-1,1] == Just (-10))\n    check (prod_signs [] == Nothing)\n    check (prod_signs [2,4,1,2,-1,-1,9] == Just 20)\n    check (prod_signs [-1,1,-1,1] == Just 4)\n    check (prod_signs [-1,1,1,1] == Just (-4))\n    check (prod_signs [-1,1,1,0] == Just 0)\n"}
{"task_id": "Haskell/129", "prompt": "-- Given a grid with N rows and N columns (N >= 2) and a positive integer k,\n-- each cell of the grid contains a value. Every integer in the range [1, N * N]\n-- inclusive appears exactly once on the cells of the grid.\n-- You have to find the minimum path of length k in the grid. You can start\n-- from any cell, and in each step you can move to any of the neighbor cells,\n-- in other words, you can go to cells which share an edge with you current\n-- cell.\n-- Please note that a path of length k means visiting exactly k cells (not\n-- necessarily distinct).\n-- You CANNOT go off the grid.\n-- A path A (of length k) is considered less than a path B (of length k) if\n-- after making the ordered lists of the values on the cells that A and B go\n-- through (let's call them lst_A and lst_B), lst_A is lexicographically less\n-- than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n-- such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n-- lst_A[j] = lst_B[j].\n-- It is guaranteed that the answer is unique.\n-- Return an ordered list of the values on the cells that the minimum path go through.\n-- Examples:\n--     Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n--     Output: [1, 2, 1]\n--     Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n--     Output: [1]\nminPath :: [[Int]] -> Int -> [Int]", "canonical_solution": "minPath grid k = seq [1, smallest_neighbor $ one_pos grid] k\n    where\n        one_pos :: [[Int]] -> (Int, Int)\n        one_pos [] = (-1, -1)\n        one_pos (x:xs) = case elemIndex 1 x of\n            Just i -> (i, 0)\n            Nothing -> case one_pos xs of\n                (-1, -1) -> (-1, -1)\n                (i, j) -> (i, j + 1)", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (minPath [[1,2,3],[4,5,6],[7,8,9]] 3 == [1,2,1])\n    check (minPath [[5,9,3],[4,1,6],[7,8,2]] 1 == [1])\n    check (minPath [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]] 4 == [1,2,1,2])\n    check (minPath [[6,4,13,10],[5,7,12,1],[3,16,11,15],[8,14,9,2]] 7 == [1,10,1,10,1,10,1])\n    check (minPath [[8,14,9,2],[6,4,13,15],[5,7,1,12],[3,10,11,16]] 5 == [1,7,1,7,1])\n    check (minPath [[11,8,7,2],[5,16,14,4],[9,3,15,6],[12,13,10,1]] 9 == [1,6,1,6,1,6,1,6,1])\n    check (minPath [[12,13,10,1],[9,3,15,6],[5,16,14,4],[11,8,7,2]] 12 == [1,6,1,6,1,6,1,6,1,6,1,6])\n    check (minPath [[2,7,4],[3,1,5],[6,8,9]] 8 == [1,3,1,3,1,3,1,3])\n    check (minPath [[6,1,5],[3,8,9],[2,7,4]] 8 == [1,5,1,5,1,5,1,5])\n    check (minPath [[1,2],[3,4]] 10 == [1,2,1,2,1,2,1,2,1,2])\n    check (minPath [[1,3],[3,2]] 10 == [1,3,1,3,1,3,1,3,1,3])\n"}
{"task_id": "Haskell/130", "prompt": "-- Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in\n-- the last couple centuries. However, what people don't know is Tribonacci sequence.\n-- Tribonacci sequence is defined by the recurrence:\n-- tri 1 = 3\n-- tri n = 1 + n / 2, if n is even.\n-- tri n =  tri (n - 1) + tri (n - 2) + tri (n + 1), if n is odd.\n-- For example:\n-- tri 2 = 1 + (2 / 2) = 2\n-- tri 4 = 3\n-- tri 3 = tri 2 + tri 1 + tri 4\n--       = 2 + 3 + 3 = 8\n-- You are given a non-negative integer number n, you have to a return a list of the\n-- first n + 1 numbers of the Tribonacci sequence.\n-- Examples:\n-- tri 3 = [1, 3, 2, 8]\ntri :: Int -> [Int]", "canonical_solution": "tri n = map tri' [0..n]\n    where\n        tri' :: Int -> Int\n        tri' 0 = 1\n        tri' 1 = 3\n        tri' n\n            | even n = 1 + n `div` 2\n            | otherwise = tri' (n - 1) + tri' (n - 2) + tri' (n + 1)", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (tri 3 == [1,3,2,8])\n    check (tri 4 == [1,3,2,8,3])\n    check (tri 5 == [1,3,2,8,3,15])\n    check (tri 6 == [1,3,2,8,3,15,4])\n    check (tri 7 == [1,3,2,8,3,15,4,24])\n    check (tri 8 == [1,3,2,8,3,15,4,24,5])\n    check (tri 9 == [1,3,2,8,3,15,4,24,5,35])\n    check (tri 20 == [1,3,2,8,3,15,4,24,5,35,6,48,7,63,8,80,9,99,10,120,11])\n    check (tri 0 == [1])\n    check (tri 1 == [1,3])\n"}
{"task_id": "Haskell/131", "prompt": "-- Given a positive integer n, return the product of the odd digits.\n-- Return 0 if all digits are even.\n-- For example:\n-- digits 1  == 1\n-- digits 4  == 0\n-- digits 235 == 15\ndigits :: Int -> Int", "canonical_solution": "digits n = if odd_count == 0 then 0 else product\n  where\n    f :: Char -> (Int, Int) -> (Int, Int)\n    (product, odd_count) = foldr f (1, 0) (show n)\n    f digit (acc, count)\n      | even int_digit = (acc, count)\n      | otherwise = (acc * int_digit, count + 1)\n      where\n        int_digit :: Int\n        int_digit = read [digit] :: Int", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (digits 5 == 5)\n    check (digits 54 == 5)\n    check (digits 120 == 1)\n    check (digits 5014 == 5)\n    check (digits 98765 == 315)\n    check (digits 5576543 == 2625)\n    check (digits 2468 == 0)\n"}
{"task_id": "Haskell/132", "prompt": "-- Create a function that takes a string as input which contains only square brackets.\n-- The function should return True if and only if there is a valid subsequence of brackets\n-- where at least one bracket in the subsequence is nested.\n-- >>> is_nested \"[[]]\"\n-- True\n-- >>> is_nested \"[]]]]]]][[[[[]\"\n-- False\n-- >>> is_nested \"[][]\"\n-- False\n-- >>> is_nested \"[]\"\n-- False\n-- >>> is_nested \"[[][]]\"\n-- True\n-- >>> is_nested \"[[]][[\"\n-- True\nis_nested :: String -> Bool", "canonical_solution": "is_nested string = is_nested' string 0 [] []\n  where\n    is_nested' :: String -> Int -> [Int] -> [Int] -> Bool\n    is_nested' ('[' : cs) index opening_bracket_index closing_bracket_index = is_nested' cs (index + 1) (opening_bracket_index ++ [index]) closing_bracket_index\n    is_nested' (']' : cs) index opening_bracket_index closing_bracket_index = is_nested' cs (index + 1) opening_bracket_index ([index] ++ closing_bracket_index)\n    is_nested' \"\" index opening_bracket_index closing_bracket_index\n      | index < 3 = False\n      | otherwise = is_nested'' opening_bracket_index closing_bracket_index 0 (length closing_bracket_index)\n      where\n        is_nested'' :: [Int] -> [Int] -> Int -> Int -> Bool\n        is_nested'' _ [] cnt l = cnt >= 2\n        is_nested'' [] _ cnt l = cnt >= 2\n        is_nested'' (o : os) (c : cs) cnt l\n          | o < c && cnt < l = is_nested'' os cs (cnt + 1) l\n          | otherwise = is_nested'' os (c : cs) cnt l", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (is_nested \"[[]]\" == True)\n    check (is_nested \"[]]]]]]][[[[[]\" == False)\n    check (is_nested \"[][]\" == False)\n    check (is_nested \"[]\" == False)\n    check (is_nested \"[[][]]\" == True)\n    check (is_nested \"[[]][[\" == True)\n    check (is_nested \"\" == False)\n    check (is_nested \"[[[[]]]]\" == True)\n    check (is_nested \"[][][[]]\" == True)\n    check (is_nested \"[]]\" == False)\n"}
{"task_id": "Haskell/133", "prompt": "sum_squares :: [Double] -> Int\nsum_squares lst = sum_squares' lst 0\n  where\n    sum_squares' [] acc = acc\n    sum_squares' (x : xs) acc = sum_squares' xs (acc + ceiling x ^ 2)\n-- Since Python has no type declarations and only floats, the Haskell implementation cannot be as general as the Python implementation due to strict typing.\n-- Therefore, the Haskell implementation only accepts lists of Doubles, not mixed with Ints. For completeness, here is the implementation for Ints (no need for ceiling):", "canonical_solution": "sum_squares_int :: [Int] -> Int\nsum_squares_int lst = sum_squares' lst 0\n  where\n    sum_squares' [] acc = acc\n    sum_squares' (x : xs) acc = sum_squares' xs (acc + x ^ 2)", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (sum_squares [1.0,2.0,3.0] == 14)\n    check (sum_squares [1.0,3.0,5.0,7.0] == 84)\n    check (sum_squares [1.4,4.2,0.0] == 29)\n    check (sum_squares [-2.4,1.0,1.0] == 6)\n    check (sum_squares [100.0,1.0,15.0,2.0] == 10230)\n    check (sum_squares [10000.0,10000.0] == 200000000)\n    check (sum_squares [-1.4,4.6,6.3] == 75)\n    check (sum_squares [-1.4,17.9,18.9,19.9] == 1086)\n    check (sum_squares [0.0] == 0)\n    check (sum_squares [-1.0] == 1)\n    check (sum_squares [-1.0,1.0,0.0] == 2)\n"}
{"task_id": "Haskell/134", "prompt": "import Data.Char (isLetter) \ncheck_if_last_char_is_a_letter :: String -> Bool", "canonical_solution": "check_if_last_char_is_a_letter [] = False\ncheck_if_last_char_is_a_letter txt = isLetter $ last txt", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (check_if_last_char_is_a_letter \"\" == False)\n    check (check_if_last_char_is_a_letter \"apple\" == False)\n    check (check_if_last_char_is_a_letter \"apple pi e\" == True)\n    check (check_if_last_char_is_a_letter \"apple pi e \" == False)\n    check (check_if_last_char_is_a_letter \"A\" == True)\n    check (check_if_last_char_is_a_letter \"Pumpkin pie \" == False)\n    check (check_if_last_char_is_a_letter \"Pumpkin pie 1\" == False)\n"}
{"task_id": "Haskell/135", "prompt": "-- Create a function which returns the largest index of an element which\n-- is not greater than or equal to the element immediately preceding it. If\n-- no such element exists then return -1. The given array will not contain\n-- uplicate values.\n-- >>> can_arrange [1,2,4,3,5]\n-- 3\n-- >>> can_arrange [1,2,3]\n-- -1\ncan_arrange :: [Int] -> Int", "canonical_solution": "can_arrange arr = can_arrange' arr 1 (-1)\n  where\n    can_arrange' :: [Int] -> Int -> Int -> Int\n    can_arrange' [] index res = res\n    can_arrange' (a : []) index res = res\n    can_arrange' (a : b : xs) index res\n      | a >= b = can_arrange' (b : xs) (index + 1) index\n      | otherwise = can_arrange' (b : xs) (index + 1) res", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (can_arrange [1,2,4,3,5] == 3)\n    check (can_arrange [1,2,4,5] == -1)\n    check (can_arrange [1,4,2,5,6,7,8,9,10] == 2)\n    check (can_arrange [4,8,5,7,3] == 4)\n    check (can_arrange [] == -1)\n"}
{"task_id": "Haskell/136", "prompt": "-- Create a function that returns a tuple (a, b), where 'a' is\n-- the largest of negative integers, and 'b' is the smallest\n-- of positive integers in a list.\n-- If there is no negative or positive integers, return them as None.\n-- Examples:\n-- >>> largest_smallest_integers [2, 4, 1, 3, 5, 7]\n-- (Nothing,Just 1)\n-- >>> largest_smallest_integers []\n-- (Nothing,Nothing)\n-- >>> largest_smallest_integers [0]\n-- (Nothing,Nothing)\nlargest_smallest_integers :: [Int] -> (Maybe Int, Maybe Int)", "canonical_solution": "largest_smallest_integers [] = (Nothing, Nothing)\nlargest_smallest_integers arr = largest_smallest_integers' arr Nothing Nothing\n  where\n    largest_smallest_integers' :: [Int] -> Maybe Int -> Maybe Int -> (Maybe Int, Maybe Int)\n    largest_smallest_integers' [] largest smallest = (largest, smallest)\n    largest_smallest_integers' (x : xs) largest smallest\n      | x < 0 && isNothing largest = largest_smallest_integers' xs (Just x) smallest\n      | x < 0 = largest_smallest_integers' xs (Just (max (fromJust largest) x)) smallest\n      | x > 0 && isNothing smallest = largest_smallest_integers' xs largest (Just x)\n      | x > 0 = largest_smallest_integers' xs largest (Just (min (fromJust smallest) x))\n      | otherwise = largest_smallest_integers' xs largest smallest", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (largest_smallest_integers [2,4,1,3,5,7]   == (Nothing,Just 1))\n    check (largest_smallest_integers [2,4,1,3,5,7,0] == (Nothing,Just 1))\n    check (largest_smallest_integers [1,3,2,4,5,6,-2] == (Just (-2),Just 1))\n    check (largest_smallest_integers [4,5,3,6,2,7,-7] == (Just (-7),Just 2))\n    check (largest_smallest_integers [7,3,8,4,9,2,5,-9] == (Just (-9),Just 2))\n    check (largest_smallest_integers []               == (Nothing,Nothing))\n    check (largest_smallest_integers [0]              == (Nothing,Nothing))\n    check (largest_smallest_integers [-1,-3,-5,-6]    == (Just (-1),Nothing))\n    check (largest_smallest_integers [-1,-3,-5,-6,0]  == (Just (-1),Nothing))\n    check (largest_smallest_integers [-6,-4,-4,-3,1]  == (Just (-3),Just 1))\n    check (largest_smallest_integers [-6,-4,-4,-3,-100,1] == (Just (-3),Just 1))\n"}
{"task_id": "Haskell/137", "prompt": "-- Create a function that takes integers, floats, or strings representing\n-- real numbers, and returns the larger variable in its given variable type.\n-- Return Nothing if the values are equal.\n-- Note: If a real number is represented as a string, the floating point might be . or ,\n-- >>> compare_one (IntNumber 1) (FloatNumber 2.5)\n-- Just (FloatNumber 2.5)\n-- >>> compare_one (IntNumber 1) (StringNumber \"2,3\")\n-- Just (StringNumber \"2,3\")\n-- >>> compare_one (StringNumber \"5,1\") (StringNumber \"6\")\n-- Just (StringNumber \"6\")\n-- >>> compare_one (StringNumber \"1\") (IntNumber 1)\n-- Nothing\ncompare_one :: Either3 Int Float String -> Either3 Int Float String -> Maybe (Either3 Int Float String)", "canonical_solution": "compare_one x y = if xf == yf then Nothing else Just (if xf > yf then x else y)\n  where\n    to_float :: Either3 Int Float String -> Float\n    to_float (IntNumber x) = fromIntegral x\n    to_float (FloatNumber x) = x\n    to_float (StringNumber x) = read (map (\\c -> if c == ',' then '.' else c) x) :: Float\n    xf :: Float\n    xf = to_float x\n    yf :: Float\n    yf = to_float y", "test": "\n\n-- Test suite (requires Either3 and constructors IntNumber, FloatNumber, StringNumber)\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (compare_one (IntNumber 1) (IntNumber 2)         == Just (IntNumber 2))\n    check (compare_one (IntNumber 1) (FloatNumber 2.5)     == Just (FloatNumber 2.5))\n    check (compare_one (IntNumber 1) (StringNumber \"2,3\") == Just (StringNumber \"2,3\"))\n    check (compare_one (StringNumber \"5,1\") (StringNumber \"6\") == Just (StringNumber \"6\"))\n    check (compare_one (StringNumber \"1\") (IntNumber 1)   == Nothing)\n"}
{"task_id": "Haskell/138", "prompt": "-- Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n-- Example\n-- >>> is_equal_to_sum_even 4\n-- False\n-- >>> is_equal_to_sum_even 6\n-- False\n-- >>> is_equal_to_sum_even 8\n-- True\nis_equal_to_sum_even :: Int -> Bool", "canonical_solution": "is_equal_to_sum_even n = n `mod` 2 == 0 && n >= 8", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (is_equal_to_sum_even 4  == False)\n    check (is_equal_to_sum_even 6  == False)\n    check (is_equal_to_sum_even 8  == True)\n    check (is_equal_to_sum_even 10 == True)\n    check (is_equal_to_sum_even 11 == False)\n    check (is_equal_to_sum_even 12 == True)\n    check (is_equal_to_sum_even 13 == False)\n    check (is_equal_to_sum_even 16 == True)\n"}
{"task_id": "Haskell/139", "prompt": "-- The Brazilian factorial is defined as:\n-- brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n-- where n > 0\n-- For example:\n-- >>> special_factorial 4\n-- 288\n-- The function will receive an integer as input and should return the special\n-- factorial of this integer.\nspecial_factorial :: Int -> Int", "canonical_solution": "special_factorial n = product [product [1 .. i] | i <- [1 .. n]]", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (special_factorial 4 == 288)\n    check (special_factorial 5 == 34560)\n    check (special_factorial 7 == 125411328000)\n    check (special_factorial 1 == 1)\n"}
{"task_id": "Haskell/150", "prompt": "-- A simple program which should return the value of x if n is\n-- a prime number and should return the value of y otherwise.\n-- Examples:\n-- >>> x_or_y 7 34 12\n-- 34\n-- >>> x_or_y 15 8 5\n-- 5\nx_or_y :: Int -> Int -> Int -> Int", "canonical_solution": "x_or_y n x y = if n == 1 then y else if length [i | i <- [2 .. n - 1], n `mod` i == 0] > 0 then y else x", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (x_or_y 7 34 12 == 34)\n    check (x_or_y 15 8 5 == 5)\n    check (x_or_y 3 33 5212 == 33)\n    check (x_or_y 1259 3 52 == 3)\n    check (x_or_y 7919 (-1) 12 == -1)\n    check (x_or_y 3609 1245 583 == 583)\n    check (x_or_y 91 56 129 == 129)\n    check (x_or_y 6 34 1234 == 1234)\n    check (x_or_y 1 2 0 == 0)\n    check (x_or_y 2 2 0 == 2)\n"}
{"task_id": "Haskell/151", "prompt": "-- Given a list of numbers, return the sum of squares of the numbers\n-- in the list that are odd. Ignore numbers that are negative or not integers.\n-- >>> double_the_difference [1, 3, 2, 0]\n-- 10 (1 + 9 + 0 + 0)\n-- >>> double_the_difference [-1, -2, 0]\n-- 0\n-- >>> double_the_difference [9, -2]\n-- 81\n-- >>> double_the_difference [0]\n-- 0\n-- If the input list is empty, return 0.\ndouble_the_difference :: [Int] -> Int", "canonical_solution": "double_the_difference lst = sum [i ^ 2 | i <- lst, i > 0, odd i]", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (double_the_difference [] == 0)\n    check (double_the_difference [5,4] == 25)\n    check (double_the_difference [-10,-20,-30] == 0)\n    check (double_the_difference [-1,-2,8] == 0)\n    check (double_the_difference [3,5] == 34)\n    check (double_the_difference [-99,-97..99] == 166650)\n"}
{"task_id": "Haskell/152", "prompt": "-- I think we all remember that feeling when the result of some long-awaited\n-- event is finally known. The feelings and thoughts you have at that moment are\n-- definitely worth noting down and comparing.\n-- Your task is to determine if a person correctly guessed the results of a number of matches.\n-- You are given two arrays of scores and guesses of equal length, where each index shows a match.\n-- Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n-- the value is 0, and if not, the value is the absolute difference between the guess and the score.\n-- example:\n-- >>> compare' [1,2,3,4,5,1] [1,2,3,4,2,-2]\n-- [0,0,0,0,3,3]\n-- >>> compare' [0,5,0,0,0,4] [4,1,1,0,0,-2]\n-- [4,4,1,0,0,6]\ncompare' :: [Int] -> [Int] -> [Int]", "canonical_solution": "compare' game guess = [abs (x - y) | (x, y) <- zip game guess]", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (compare' [1,2,3,4,5,1] [1,2,3,4,2,-2] == [0,0,0,0,3,3])\n    check (compare' [0,5,0,0,0,4] [4,1,1,0,0,-2] == [4,4,1,0,0,6])\n    check (compare' [0,0,0,0,0,0] [0,0,0,0,0,0] == [0,0,0,0,0,0])\n    check (compare' [1,2,3] [-1,-2,-3] == [2,4,6])\n    check (compare' [1,2,3,5] [-1,2,3,4] == [2,0,0,1])\n"}
{"task_id": "Haskell/153", "prompt": "-- You will be given the name of a class (a string) and a list of extensions.\n-- The extensions are to be used to load additional classes to the class. The\n-- strength of the extension is as follows: Let CAP be the number of the uppercase\n-- letters in the extension's name, and let SM be the number of lowercase letters\n-- in the extension's name, the strength is given by the fraction CAP - SM.\n-- You should find the strongest extension and return a string in this\n-- format: ClassName.StrongestExtensionName.\n-- If there are two or more extensions with the same strength, you should\n-- choose the one that comes first in the list.\n-- For example, if you are given \"Slices\" as the class and a list of the\n-- extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n-- return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n-- (its strength is -1).\n-- Example:\n-- >>> strongest_extension \"my_class\" [\"AA\", \"Be\", \"CC\"]\n-- \"my_class.AA\"\nstrongest_extension :: String -> [String] -> String", "canonical_solution": "strongest_extension class_name extensions = class_name ++ \".\" ++ strongest\n  where\n    strongest :: String\n    strongest = head $ filter (\\x -> strength x == maximum (map strength extensions)) extensions\n    strength x = length [x | x <- x, isAlpha x, isUpper x] - length [x | x <- x, isAlpha x, isLower x]", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (strongest_extension \"Watashi\" [\"tEN\",\"niNE\",\"eIGHt8OKe\"] == \"Watashi.eIGHt8OKe\")\n    check (strongest_extension \"Boku123\" [\"nani\",\"NazeDa\",\"YEs.WeCaNe\",\"32145tggg\"] == \"Boku123.YEs.WeCaNe\")\n    check (strongest_extension \"__YESIMHERE\" [\"t\",\"eMptY\",\"nothing\",\"zeR00\",\"NuLl__\",\"123NoooneB321\"] == \"__YESIMHERE.NuLl__\")\n    check (strongest_extension \"K\" [\"Ta\",\"TAR\",\"t234An\",\"cosSo\"] == \"K.TAR\")\n    check (strongest_extension \"__HAHA\" [\"Tab\",\"123\",\"781345\",\"-_-\"] == \"__HAHA.123\")\n    check (strongest_extension \"YameRore\" [\"HhAas\",\"okIWILL123\",\"WorkOut\",\"Fails\",\"-_-\"] == \"YameRore.okIWILL123\")\n    check (strongest_extension \"finNNalLLly\" [\"Die\",\"NowW\",\"Wow\",\"WoW\"] == \"finNNalLLly.WoW\")\n    check (strongest_extension \"_\" [\"Bb\",\"91245\"] == \"_.Bb\")\n    check (strongest_extension \"Sp\" [\"671235\",\"Bb\"] == \"Sp.671235\")\n"}
{"task_id": "Haskell/154", "prompt": "-- You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word\n-- >>> cycpattern_check \"abcd\" \"abd\"\n-- False\n-- >>> cycpattern_check \"hello\" \"ell\"\n-- True\n-- >>> cycpattern_check \"whassup\" \"psus\"\n-- False\n-- >>> cycpattern_check \"abab\" \"baa\"\n-- True\n-- >>> cycpattern_check \"efef\" \"eeff\"\n-- False\n-- >>> cycpattern_check \"himenss\" \"simen\"\n-- True\ncycpattern_check :: String -> String -> Bool", "canonical_solution": "cycpattern_check a b = any (`isInfixOf` a) (createRotations b)\n  where\n    createRotations :: String -> [String]\n    createRotations str = [drop i str ++ take i str | i <- [0 .. length str - 1]]", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (cycpattern_check \"xyzw\" \"xyw\" == False)\n    check (cycpattern_check \"yello\" \"ell\" == True)\n    check (cycpattern_check \"whattup\" \"ptut\" == False)\n    check (cycpattern_check \"efef\" \"fee\" == True)\n    check (cycpattern_check \"abab\" \"aabb\" == False)\n    check (cycpattern_check \"winemtt\" \"tinem\" == True)\n"}
{"task_id": "Haskell/155", "prompt": "-- Given an integer. return a tuple that has the number of even and odd digits respectively.\n-- Example:\n-- >>> even_odd_count (-12)\n-- (1, 1)\n-- >>> even_odd_count 123\n-- (1, 2)\neven_odd_count :: Int -> (Int, Int)", "canonical_solution": "even_odd_count num = (length [i | i <- show (abs num), even (read [i] :: Int)], length [i | i <- show (abs num), odd (read [i] :: Int)])", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (even_odd_count 7 == (0,1))\n    check (even_odd_count (-78) == (1,1))\n    check (even_odd_count 3452 == (2,2))\n    check (even_odd_count 346211 == (3,3))\n    check (even_odd_count (-345821) == (3,3))\n    check (even_odd_count (-2) == (1,0))\n    check (even_odd_count (-45347) == (2,3))\n    check (even_odd_count 0 == (1,0))\n"}
{"task_id": "Haskell/156", "prompt": "-- Given a positive integer, obtain its roman numeral equivalent as a string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n-- Examples:\n-- >>> int_to_mini_roman 19\n-- \"xix\"\n-- >>> int_to_mini_roman 152\n-- \"clii\"\n-- >>> int_to_mini_roman 426\n-- \"cdxxvi\"\nint_to_mini_roman :: Int -> String", "canonical_solution": "int_to_mini_roman number = map toLower $ int_to_mini_roman' number num sym (length num - 1) \"\"\n  where\n    num :: [Int]\n    sym :: [String]\n    num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"]\n    int_to_mini_roman' :: Int -> [Int] -> [String] -> Int -> String -> String\n    int_to_mini_roman' number num sym index res\n      | index < 0 = res\n      | number == 0 = res\n      | num !! index <= number = int_to_mini_roman' (number - num !! index) num sym index (res ++ sym !! index)\n      | otherwise = int_to_mini_roman' number num sym (index - 1) res", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (int_to_mini_roman 19 == \"xix\")\n    check (int_to_mini_roman 152 == \"clii\")\n    check (int_to_mini_roman 251 == \"ccli\")\n    check (int_to_mini_roman 426 == \"cdxxvi\")\n    check (int_to_mini_roman 500 == \"d\")\n    check (int_to_mini_roman 1 == \"i\")\n    check (int_to_mini_roman 4 == \"iv\")\n    check (int_to_mini_roman 43 == \"xliii\")\n    check (int_to_mini_roman 90 == \"xc\")\n    check (int_to_mini_roman 94 == \"xciv\")\n    check (int_to_mini_roman 532 == \"dxxxii\")\n    check (int_to_mini_roman 900 == \"cm\")\n    check (int_to_mini_roman 994 == \"cmxciv\")\n    check (int_to_mini_roman 1000 == \"m\")\n"}
{"task_id": "Haskell/157", "prompt": "-- Given the lengths of the three sides of a triangle. Return True if the three\n-- sides form a right-angled triangle, False otherwise.\n-- A right-angled triangle is a triangle in which one angle is right angle or\n-- 90 degree.\n-- Example:\n-- >>> right_angle_triangle 3 4 5\n-- True\n-- >>> right_angle_triangle 1 2 3\n-- False\nright_angle_triangle :: Int -> Int -> Int -> Bool", "canonical_solution": "right_angle_triangle a b c = a * a == b * b + c * c || b * b == a * a + c * c || c * c == a * a + b * b", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (right_angle_triangle 3 4 5 == True)\n    check (right_angle_triangle 1 2 3 == False)\n    check (right_angle_triangle 10 6 8 == True)\n    check (right_angle_triangle 2 2 2 == False)\n    check (right_angle_triangle 7 24 25 == True)\n    check (right_angle_triangle 10 5 7 == False)\n    check (right_angle_triangle 5 12 13 == True)\n    check (right_angle_triangle 15 8 17 == True)\n    check (right_angle_triangle 48 55 73 == True)\n    check (right_angle_triangle 1 1 1 == False)\n    check (right_angle_triangle 2 2 10 == False)\n"}
{"task_id": "Haskell/158", "prompt": "-- Write a function that accepts a list of strings.\n-- The list contains different words. Return the word with maximum number\n-- of unique characters. If multiple strings have maximum number of unique\n-- characters, return the one which comes first in lexicographical order.\n-- >>> find_max [\"name\", \"of\", \"string\"]\n-- \"string\"\n-- >>> find_max [\"name\", \"enam\", \"game\"]\n-- \"enam\"\n-- >>> find_max [\"aaaaaaa\", \"bb\" ,\"cc\"]\n-- \"aaaaaaa\"\nfind_max :: [String] -> String", "canonical_solution": "find_max words\n  | words == [] = \"\"\n  | otherwise = head $ filter (\\x -> (length . nub) x == maximum (map (length . nub) words)) $ sort words", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (find_max [\"name\",\"of\",\"string\"] == \"string\")\n    check (find_max [\"name\",\"enam\",\"game\"] == \"enam\")\n    check (find_max [\"aaaaaaa\",\"bb\",\"cc\"] == \"aaaaaaa\")\n    check (find_max [\"abc\",\"cba\"] == \"abc\")\n    check (find_max [\"play\",\"this\",\"game\",\"of\",\"footbott\"] == \"footbott\")\n    check (find_max [\"we\",\"are\",\"gonna\",\"rock\"] == \"gonna\")\n    check (find_max [\"we\",\"are\",\"a\",\"mad\",\"nation\"] == \"nation\")\n    check (find_max [\"this\",\"is\",\"a\",\"prrk\"] == \"this\")\n    check (find_max [\"b\"] == \"b\")\n    check (find_max [\"play\",\"play\",\"play\"] == \"play\")\n"}
{"task_id": "Haskell/159", "prompt": "-- You're a hungry rabbit, and you already have eaten a certain number of carrots,\n-- but now you need to eat more carrots to complete the day's meals.\n-- you should return an array of [ total number of eaten carrots after your meals,\n--                                 the number of carrots left after your meals ]\n-- if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n-- Example:\n-- >>> eat 5 6 10\n-- [11, 4]\n-- >>> eat 4 8 9\n-- [12, 1]\n-- >>> eat 1 10 10\n-- [11, 0]\n-- >>> eat 2 11 5\n-- [7, 0]\n-- Variables:\n-- @number : integer\n--     the number of carrots that you have eaten.\n-- @need : integer\n--     the number of carrots that you need to eat.\n-- @remaining : integer\n--     the number of remaining carrots thet exist in stock\n-- Constraints:\n-- * 0 <= number <= 1000\n-- * 0 <= need <= 1000\n-- * 0 <= remaining <= 1000\n-- Have fun :)\neat :: Int -> Int -> Int -> [Int]", "canonical_solution": "eat number need remaining = if need <= remaining then [number + need, remaining - need] else [number + remaining, 0]", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (eat 5 6 10 == [11,4])\n    check (eat 4 8 9 == [12,1])\n    check (eat 1 10 10 == [11,0])\n    check (eat 2 11 5 == [7,0])\n    check (eat 4 5 7 == [9,2])\n    check (eat 4 5 1 == [5,0])\n"}
{"task_id": "Haskell/160", "prompt": "-- Given two lists operator, and operand. The first list has basic algebra operations, and\n-- the second list is a list of integers. Use the two given lists to build the algebric\n-- expression and return the evaluation of this expression.\n-- The basic algebra operations:\n-- Addition ( + )\n-- Subtraction ( - )\n-- Multiplication ( * )\n-- Floor division ( // )\n-- Exponentiation ( ** )\n-- Example:\n-- >>> do_algebra [\"+\", \"*\", \"-\"] [2, 3, 4, 5]\n-- 9\n-- Note:\n--     The length of operator list is equal to the length of operand list minus one.\n--     Operand is a list of of non-negative integers.\n--     Operator list has at least one operator, and operand list has at least two operands.\ndo_algebra :: [String] -> [Int] -> Int", "canonical_solution": "do_algebra operators operands = head (snd (foldl (\\(operators, operands) operator -> applyOperator operator operators operands 0 (length operators)) (operators, operands) operator_order))\n  where\n    operator_order :: [String]\n    operator_order = [\"**\", \"//\", \"*\", \"+\", \"-\"]\n    applyOperator operator operators operands index length\n      | index >= length = (operators, operands)\n      | operator /= operators !! index = applyOperator operator operators operands (index + 1) length\n      | otherwise = applyOperator operator (newOperators) (newOperands) (index + 1) (length - 1)\n      where\n        newOperands :: [Int]\n        newOperands = take index operands ++ [newOperand] ++ (drop (index + 2) operands)\n        newOperand = case operator of\n          \"*\" -> operands !! index * operands !! (index + 1)\n          \"//\" -> operands !! index `div` operands !! (index + 1)\n          \"+\" -> operands !! index + operands !! (index + 1)\n          \"-\" -> operands !! index - operands !! (index + 1)\n          _ -> operands !! index ^ operands !! (index + 1)\n        newOperators = take index operators ++ (drop (index + 1) operators)", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (do_algebra [\"**\",\"*\",\"+\"] [2,3,4,5] == 37)\n    check (do_algebra [\"+\",\"*\",\"-\"] [2,3,4,5] == 9)\n    check (do_algebra [\"//\",\"*\"] [7,3,4] == 8)\n"}
{"task_id": "Haskell/161", "prompt": "-- You are given a string s.\n-- if s[i] is a letter, reverse its case from lower to upper or vise versa,\n-- otherwise keep it as it is.\n-- If the string contains no letters, reverse the string.\n-- The function should return the resulted string.\n-- Examples\n-- >>> solve \"1234\"\n-- \"4321\"\n-- >>> solve \"ab\"\n-- \"AB\"\n-- >>> solve \"#a@C\"\n-- \"#A@c\"\nsolve :: String -> String", "canonical_solution": "solve s = if flg == 0 then reverse s else reverseUpperLower s\n  where\n    flg :: Int\n    flg = length [i | i <- s, i `elem` ['a' .. 'z']] + length [i | i <- s, i `elem` ['A' .. 'Z']]\n    reverseUpperLower s = [if i `elem` ['a' .. 'z'] then toUpper i else toLower i | i <- s]", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (solve \"AsDf\" == \"aSdF\")\n    check (solve \"1234\" == \"4321\")\n    check (solve \"ab\" == \"AB\")\n    check (solve \"#a@C\" == \"#A@c\")\n    check (solve \"#AsdfW^45\" == \"#aSDFw^45\")\n    check (solve \"#6@2\" == \"2@6#\")\n    check (solve \"#$a^D\" == \"#$A^d\")\n    check (solve \"#ccc\" == \"#CCC\")\n"}
{"task_id": "Haskell/162", "prompt": "-- Given a string 'text', return its md5 hash equivalent string.\n-- If 'text' is an empty string, return Nothing.\n-- >>> string_to_md5 \"Hello world\"\n-- Just \"3e25960a79dbc69b674cd4ec67a72c62\"\n-- Build depends on: base >= 4.7 && < 5, base16-bytestring, bytestring, cryptohash-md5\nstring_to_md5 :: String -> Maybe String", "canonical_solution": "string_to_md5 text = if text == \"\" then Nothing else Just $ unpack $ encode $ MD5.hash $ pack text", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (string_to_md5 \"Hello world\" == Just \"3e25960a79dbc69b674cd4ec67a72c62\")\n    check (string_to_md5 \"\" == Nothing)\n    check (string_to_md5 \"A B C\" == Just \"0ef78513b0cb8cef12743f5aeb35f888\")\n    check (string_to_md5 \"password\" == Just \"5f4dcc3b5aa765d61d8327deb882cf99\")\n"}
{"task_id": "Haskell/163", "prompt": "-- Given two positive integers a and b, return the even digits between a\n-- and b, in ascending order.\n-- For example:\n-- >>> generate_integers 2 8\n-- [2, 4, 6, 8]\n-- >>> generate_integers 8 2\n-- [2, 4, 6, 8]\n-- >>> generate_integers 10 14\n-- []\ngenerate_integers :: Int -> Int -> [Int]", "canonical_solution": "generate_integers a b = [i | i <- [max 2 (min a b) .. min 8 (max a b)], even i]", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (generate_integers 2 10 == [2,4,6,8])\n    check (generate_integers 10 2 == [2,4,6,8])\n    check (generate_integers 132 2 == [2,4,6,8])\n    check (generate_integers 17 89 == [])\n"}
{"task_id": "Haskell/140", "prompt": "-- Given a string text, replace all spaces in it with underscores,\n-- and if a string has more than 2 consecutive spaces,\n-- then replace all consecutive spaces with -\n-- >>> fix_spaces \"Example\"\n-- \"Example\"\n-- >>> fix_spaces \" Example 2\"\n-- \"_Example_2\"\n-- >>> fix_spaces \" Example 2\"\n-- \"_Example_2\"\n-- >>> fix_spaces \" Example   3\"\n-- \"_Example-3\"\nfix_spaces :: String -> String", "canonical_solution": "fix_spaces [] = []\nfix_spaces string = fix_spaces' string 0 \"\"\n  where\n    fix_spaces' :: String -> Int -> String -> String\n    fix_spaces' (x : xs) count res\n      | xs == [] && count == 0 && x == ' ' = res ++ \"_\"\n      | xs == [] && count > 0 && x == ' ' = res ++ \"-\"\n      | xs == [] && count == 0 && x /= ' ' = res ++ [x]\n      | xs == [] && count == 1 && x /= ' ' = res ++ \"_\" ++ [x]\n      | xs == [] && count > 1 && x /= ' ' = res ++ \"-\" ++ [x]\n      | x == ' ' = fix_spaces' xs (count + 1) res\n      | x /= ' ' && count > 1 = fix_spaces' xs 0 (res ++ \"-\" ++ [x])\n      | x /= ' ' && count == 1 = fix_spaces' xs 0 (res ++ \"_\" ++ [x])\n      | otherwise = fix_spaces' xs 0 (res ++ [x])", "test": "\n-- Test suite for fix_spaces\nimport Test.HUnit\n\ntests = TestList [\n  \"no spaces\" ~: fix_spaces \"Example\" ~?= \"Example\",\n  \"single trailing space\" ~: fix_spaces \"Mudasir Hanif \" ~?= \"Mudasir_Hanif_\",\n  \"double spaces between words\" ~: fix_spaces \"Yellow Yellow  Dirty  Fellow\" ~?= \"Yellow_Yellow__Dirty__Fellow\",\n  \"three spaces in middle\" ~: fix_spaces \"Exa   mple\" ~?= \"Exa-mple\",\n  \"leading and mixed spaces\" ~: fix_spaces \"   Exa 1 2 2 mple\" ~?= \"-Exa_1_2_2_mple\"\n]\n\nmain = runTestTT tests >>= print\n"}
{"task_id": "Haskell/141", "prompt": "-- Create a function which takes a string representing a file's name, and returns\n-- 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n-- A file's name is considered to be valid if and only if all the following conditions are met:\n-- - There should not be more than three digits ('0'-'9') in the file's name.\n-- - The file's name contains exactly one dot '.'\n-- - The substring before the dot should not be empty, and it starts with a letter from the latin alphapet ('a'-'z' and 'A'-'Z').\n-- - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n-- Examples:\n-- >>> file_name_check \"example.txt\"\n-- \"Yes\"\n-- >>> file_name_check \"1example.dll\"\n-- \"No\" (the name should start with a latin alphapet letter\nfile_name_check :: String -> String", "canonical_solution": "file_name_check filename\n  | (length filename) < 5 = \"No\"\n  | otherwise = if containsOneDot filename && containsNoMoreThanThreeDigits filename && endsOnTxtExeOrDll filename && doesNotStartWithDot filename && startWithLetterFromLatinAlphabet filename then \"Yes\" else \"No\"\n  where\n    containsOneDot :: String -> Bool\n    containsOneDot filename = length (filter (== '.') filename) == 1\n    containsNoMoreThanThreeDigits filename = length (filter (\\x -> x `elem` ['0' .. '9']) filename) <= 3\n    endsOnTxtExeOrDll filename = (drop (length filename - 4) filename) `elem` [\".txt\", \".exe\", \".dll\"]\n    doesNotStartWithDot filename = head filename /= '.'\n    startWithLetterFromLatinAlphabet filename = head filename `elem` ['a' .. 'z'] || head filename `elem` ['A' .. 'Z']", "test": "\n-- Test suite for file_name_check\nimport Test.HUnit\n\ntests = TestList [\n  \"valid txt\"        ~: file_name_check \"example.txt\"  ~?= \"Yes\",\n  \"starts with digit\"~: file_name_check \"1example.dll\" ~?= \"No\",\n  \"unknown ext\"      ~: file_name_check \"s1sdf3.asd\"    ~?= \"No\",\n  \"single letter\"    ~: file_name_check \"K.dll\"        ~?= \"Yes\",\n  \"three digits\"     ~: file_name_check \"MY16FILE3.exe\"~?= \"Yes\",\n  \"four digits\"      ~: file_name_check \"His12FILE94.exe\"~?= \"No\",\n  \"starts underscore\"~: file_name_check \"_Y.txt\"       ~?= \"No\",\n  \"multiple dots\"    ~: file_name_check \"final..txt\"   ~?= \"No\",\n  \"no dot\"           ~: file_name_check \"final132\"     ~?= \"No\",\n  \"empty name\"       ~: file_name_check \".txt\"          ~?= \"No\"\n]\n\nmain = runTestTT tests >>= print\n"}
{"task_id": "Haskell/142", "prompt": "-- This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a\n-- multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not\n-- change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\n-- Examples:\n-- >>> sum_squares [1,2,3]\n-- 6\n-- >>> sum_squares []\n-- 0\n-- >>> sum_squares [-1,-5,2,-1,-5]\n-- -126\nsum_squares :: [Int] -> Int", "canonical_solution": "sum_squares lst = sum_squares' lst 0 0\n  where\n    sum_squares' :: [Int] -> Int -> Int -> Int\n    sum_squares' [] sum _ = sum\n    sum_squares' (x : xs) sum index\n      | index `mod` 3 == 0 = sum_squares' xs (sum + x ^ 2) (index + 1)\n      | index `mod` 4 == 0 = sum_squares' xs (sum + x ^ 3) (index + 1)\n      | otherwise = sum_squares' xs (sum + x) (index + 1)", "test": "\n-- Test suite for sum_squares\nimport Test.HUnit\n\ntests = TestList [\n  \"simple list\"      ~: sum_squares [1,2,3]              ~?= 6,\n  \"all ones\"         ~: sum_squares [1,1,1,1,1,1,1,1,1]  ~?= 9,\n  \"negative mix\"     ~: sum_squares [-1,-5,2,-1,-5]      ~?= (-126),\n  \"single zero\"      ~: sum_squares [0]                   ~?= 0,\n  \"mixed large\"      ~: sum_squares [-56,-99,1,0,-2]      ~?= 3030\n]\n\nmain = runTestTT tests >>= print\n"}
{"task_id": "Haskell/143", "prompt": "-- You are given a string representing a sentence,\n-- the sentence contains some words separated by a space,\n-- and you have to return a string that contains the words from the original sentence,\n-- whose lengths are prime numbers,\n-- the order of the words in the new string should be the same as the original one.\n-- Example 1:\n-- >>> words_in_sentence \"This is a test\"\n-- \"is\"\n-- Example 2:\n-- >>> words_in_sentence \"lets go for swimming\"\n-- \"go for\"\n-- Constraints:\n-- * 1 <= len(sentence) <= 100\n-- * sentence contains only letters\nwords_in_sentence :: String -> String", "canonical_solution": "words_in_sentence sentence = unwords $ filter (\\x -> isPrime (length x)) (words sentence)\n  where\n    isPrime :: Int -> Bool\n    isPrime n = n > 1 && all (\\x -> n `mod` x /= 0) [2 .. n - 1]", "test": "\n-- Test suite for words_in_sentence\nimport Test.HUnit\n\ntests = TestList [\n  \"example 1\"        ~: words_in_sentence \"This is a test\"                   ~?= \"is\",\n  \"example 2\"        ~: words_in_sentence \"lets go for swimming\"           ~?= \"go for\",\n  \"multiple words\"   ~: words_in_sentence \"there is no place available here\" ~?= \"there is no place\",\n  \"mixed case\"       ~: words_in_sentence \"Hi I am Hussein\"               ~?= \"Hi am Hussein\",\n  \"all primes\"       ~: words_in_sentence \"go for it\"                      ~?= \"go for it\",\n  \"none prime\"       ~: words_in_sentence \"here\"                          ~?= \"\",\n  \"one prime\"        ~: words_in_sentence \"here is\"                       ~?= \"is\"\n]\n\nmain = runTestTT tests >>= print\n"}
{"task_id": "Haskell/144", "prompt": "-- Your task is to implement a function that will simplify the expression\n-- x * n. The function returns True if x * n evaluates to a whole number and False\n-- otherwise. Both x and n, are string representation of a fraction, and have the following format,\n-- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n-- You can assume that x, and n are valid fractions, and do not have zero as denominator.\n-- >>> simplify \"1/5\" \"5/1\"\n-- True\n-- >>> simplify \"1/6\" \"2/1\"\n-- False\n-- >>> simplify \"7/10\" \"10/2\"\n-- False\nsimplify :: String -> String -> Bool", "canonical_solution": "simplify x n = numerator / denominator == fromIntegral (round (numerator / denominator))\n  where\n    a, b, c, d :: Double\n    a = read (take (fromJust (elemIndex '/' x)) x)\n    b = read (drop (fromJust (elemIndex '/' x) + 1) x)\n    c = read (take (fromJust (elemIndex '/' n)) n)\n    d = read (drop (fromJust (elemIndex '/' n) + 1) n)\n    numerator, denominator :: Double\n    numerator = a * c\n    denominator = b * d", "test": "\n-- Test suite for simplify\nimport Test.HUnit\n\ntests = TestList [\n  \"true case\"        ~: simplify \"1/5\" \"5/1\"    ~?= True,\n  \"false case\"       ~: simplify \"1/6\" \"2/1\"    ~?= False,\n  \"true case 2\"      ~: simplify \"5/1\" \"3/1\"    ~?= True,\n  \"false case 2\"     ~: simplify \"7/10\" \"10/2\" ~?= False,\n  \"mixed lengths\"    ~: simplify \"2/10\" \"50/10\"~?= True,\n  \"equal fractions\"  ~: simplify \"1/5\" \"1/5\"    ~?= False\n]\n\nmain = runTestTT tests >>= print\n"}
{"task_id": "Haskell/145", "prompt": "-- Write a function which sorts the given list of integers\n-- in ascending order according to the sum of their digits.\n-- Note: if there are several items with similar sum of their digits,\n-- order them based on their index in original list.\n-- For example:\n-- >>> order_by_points [1, 11, -1, -11, -12]\n-- [-1, -11, 1, -12, 11]\n-- >>> order_by_points []\n-- []\n-- Remember that if the number is negative, you need to not parse the first '-' and multiply the first number of the sum by -1\norder_by_points :: [Int] -> [Int]", "canonical_solution": "order_by_points nums = sortBy (\\x y -> compare (digits_sum x) (digits_sum y)) nums", "test": "\n-- Test suite for order_by_points\nimport Test.HUnit\n\ntests = TestList [\n  \"basic mix\"        ~: order_by_points [1,11,-1,-11,-12]                     ~?= [-1,-11,1,-12,11],\n  \"empty\"            ~: order_by_points []                                      ~?= [],\n  \"long list\"        ~: order_by_points [1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46] ~?=\n                                                    [0,2,3,6,53,423,423,423,1234,145,37,46,56,463,3457],\n  \"negatives\"        ~: order_by_points [1,-11,-32,43,54,-98,2,-3]               ~?= [-3,-32,-98,-11,1,2,43,54]\n]\n\nmain = runTestTT tests >>= print\n"}
{"task_id": "Haskell/146", "prompt": "-- Write a function that takes an array of numbers as input and returns\n-- the number of elements in the array that are greater than 10 and both\n-- first and last digits of a number are odd (1, 3, 5, 7, 9).\n-- For example:\n-- >>> specialFilter [15, -73, 14, -15]\n-- 1\n-- >>> specialFilter [33, -2, -3, 45, 21, 109]\n-- 2\nspecialFilter :: [Int] -> Int", "canonical_solution": "specialFilter nums = length $ filter greaterThanTenAndOddBorders nums\n  where\n    greaterThanTenAndOddBorders :: Int -> Bool\n    greaterThanTenAndOddBorders n = n > 10 && odd (read [head (show n)] :: Int) && odd (read [show n !! (length (show n) - 1)] :: Int)", "test": "\n-- Test suite for specialFilter\nimport Test.HUnit\n\ntests = TestList [\n  \"none qualify\"     ~: specialFilter [5,-2,1,-5]           ~?= 0,\n  \"one qualify\"      ~: specialFilter [15,-73,14,-15]       ~?= 1,\n  \"two qualify\"      ~: specialFilter [33,-2,-3,45,21,109]   ~?= 2,\n  \"four qualify\"     ~: specialFilter [43,-12,93,125,121,109]~?= 4,\n  \"edge single\"      ~: specialFilter [1]                    ~?= 0,\n  \"empty\"            ~: specialFilter []                     ~?= 0\n]\n\nmain = runTestTT tests >>= print\n"}
{"task_id": "Haskell/147", "prompt": "-- You are given a positive integer n. You have to create an integer array a of length n.\n--     For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n--     Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,\n-- and a[i] + a[j] + a[k] is a multiple of 3.\n-- Example :\n-- >>> get_max_triples 5\n-- 1\n-- Explanation:\n-- a = [1, 3, 7, 13, 21]\n-- The only valid triple is (1, 7, 13).\nget_max_triples :: Int -> Int", "canonical_solution": "get_max_triples n = length $ filter (\\(x, y, z) -> (x + y + z) `mod` 3 == 0) [(a !! i, a !! j, a !! k) | i <- [0 .. n - 1], j <- [i + 1 .. n - 1], k <- [j + 1 .. n - 1]]\n  where\n    a :: [Int]\n    a = [i * i - i + 1 | i <- [1 .. n]]", "test": "\n-- Test suite for get_max_triples\nimport Test.HUnit\n\ntests = TestList [\n  \"n=5\"              ~: get_max_triples 5   ~?= 1,\n  \"n=6\"              ~: get_max_triples 6   ~?= 4,\n  \"n=10\"             ~: get_max_triples 10  ~?= 36,\n  \"n=100\"            ~: get_max_triples 100 ~?= 53361\n]\n\nmain = runTestTT tests >>= print\n"}
{"task_id": "Haskell/148", "prompt": "-- There are eight planets in our solar system: the closest to the Sun\n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n-- Uranus, Neptune.\n-- Write a function that takes two planet names as strings planet1 and planet2.\n-- The function should return a tuple containing all planets whose orbits are\n-- located between the orbit of planet1 and the orbit of planet2, sorted by\n-- the proximity to the sun.\n-- The function should return an empty tuple if planet1 or planet2\n-- are not correct planet names.\n-- Examples\n-- >>> bf \"Jupiter\" \"Neptune\"\n-- [\"Saturn\", \"Uranus\"]\n-- >>> bf \"Earth\" \"Mercury\"\n-- [\"Venus\"]\n-- >>> bf \"Mercury\" \"Uranus\"\n-- [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"]\nbf :: String -> String -> [String]", "canonical_solution": "bf planet1 planet2 =\n  if planet1 `elem` planet_names && planet2 `elem` planet_names && planet1 /= planet2\n    then\n      if planet1_index < planet2_index\n        then take (planet2_index - planet1_index - 1) (drop (planet1_index + 1) planet_names)\n        else take (planet1_index - planet2_index - 1) (drop (planet2_index + 1) planet_names)\n    else []\n  where\n    planet_names :: [String]\n    planet_names = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    planet1_index :: Int\n    planet1_index = head [i | (i, x) <- zip [0 ..] planet_names, x == planet1]\n    planet2_index :: Int\n    planet2_index = head [i | (i, x) <- zip [0 ..] planet_names, x == planet2]", "test": "\n-- Test suite for bf\nimport Test.HUnit\n\ntests = TestList [\n  \"gw Jupiter->Neptune\" ~: bf \"Jupiter\" \"Neptune\" ~?= [\"Saturn\",\"Uranus\"],\n  \"ew Earth->Mercury\"   ~: bf \"Earth\" \"Mercury\"   ~?= [\"Venus\"],\n  \"range Mercury->Uranus\" ~: bf \"Mercury\" \"Uranus\" ~?=\n                              [\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\"],\n  \"reverse Neptune->Venus\" ~: bf \"Neptune\" \"Venus\" ~?=\n                              [\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\"],\n  \"same planet\"         ~: bf \"Earth\" \"Earth\"       ~?= [],\n  \"invalid name\"        ~: bf \"Jupiter\" \"Pluto\"    ~?= []\n]\n\nmain = runTestTT tests >>= print\n"}
{"task_id": "Haskell/149", "prompt": "-- Write a function that accepts a list of strings as a parameter,\n-- deletes the strings that have odd lengths from it,\n-- and returns the resulted list with a sorted order,\n-- The list is always a list of strings and never an array of numbers,\n-- and it may contain duplicates.\n-- The order of the list should be ascending by length of each word, and you\n-- should return the list sorted by that rule.\n-- If two words have the same length, sort the list alphabetically.\n-- The function should return a list of strings in sorted order.\n-- You may assume that all words will have the same length.\n-- For example:\n-- >>> sorted_list_sum [\"aa\", \"a\", \"aaa\"]\n-- [\"aa\"]\n-- >>> sorted_list_sum [\"ab\", \"a\", \"aaa\", \"cd\"]\n-- [\"ab\", \"cd\"]\nsorted_list_sum :: [String] -> [String]", "canonical_solution": "sorted_list_sum lst = sort $ filter (\\x -> length x `mod` 2 == 0) lst", "test": "\n-- Test suite for sorted_list_sum\nimport Test.HUnit\n\ntests = TestList [\n  \"single even lengths\"  ~: sorted_list_sum [\"aa\",\"a\",\"aaa\"]           ~?= [\"aa\"],\n  \"mixed list\"           ~: sorted_list_sum [\"school\",\"AI\",\"asdf\",\"b\"] ~?=\n                               [\"AI\",\"asdf\",\"school\"],\n  \"all odd lengths\"      ~: sorted_list_sum [\"d\",\"b\",\"c\",\"a\"]         ~?= [],\n  \"duplicates and mix\"   ~: sorted_list_sum [\"aaaa\",\"bbbb\",\"dd\",\"cc\"] ~?=\n                               [\"cc\",\"dd\",\"aaaa\",\"bbbb\"]\n]\n\nmain = runTestTT tests >>= print\n"}
