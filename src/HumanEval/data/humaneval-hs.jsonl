{"task_id": "Haskell/0", "prompt": "-- Check if in given list of numbers, are any two numbers closer to each other than\n-- given threshold.\n-- >>> has_close_elements [1.0, 2.0, 3.0] 0.5\n-- False\n-- >>> has_close_elements [1.0, 2.8, 3.0, 4.0, 5.0, 2.0] 0.3\n-- True\nhas_close_elements :: [Float] -> Float -> Bool", "canonical_solution": "has_close_elements numbers threshold = \u2b50 any (\\(x, y) -> \u2b50 abs (x - y) < threshold) \u2b50 [(x,y) | x <- numbers, y <- numbers, \u2b50 x /= y]", "test": ""}
{"task_id": "Haskell/1", "prompt": "-- Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n-- separate those group into separate strings and return the list of those.\n-- Separate groups are balanced (each open brace is properly closed) and not nested within each other\n-- Ignore any spaces in the input string.\n-- >>> separate_paren_groups \"( ) (( )) (( )( ))\"\n-- [\"()\",\"(())\",\"(()())\"]\nseparate_paren_groups :: String -> [String]", "canonical_solution": "separate_paren_groups paren_string = \u2b50 get_paren_groups paren_string 0 []\n  where\n    get_paren_groups :: String -> Int -> [String] -> [String]\n    get_paren_groups \"\" _ groups = \u2b50 groups\n    get_paren_groups ('(' : cs) 0 groups = \u2b50 get_paren_groups cs 1 (groups ++ [\"(\"])\n    get_paren_groups (c : cs) depth groups\n      | c == '(' || c == ')' = get_paren_groups cs (depth + (get_d c)) \u2b50 ((reverse . tail . reverse $ groups) ++ \u2b50 [(head $ reverse groups) ++ [c]])\n      | otherwise = \u2b50 get_paren_groups cs depth groups\n      where\n        get_d :: Char -> Int\n        get_d '(' = \u2b50 1\n        get_d ')' = \u2b50 -1\n        get_d _ = \u2b50 0", "test": ""}
{"task_id": "Haskell/2", "prompt": "-- Given a positive floating point number, it can be decomposed into\n-- and integer part (largest integer smaller than given number) and decimals\n-- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n-- >>> truncate_number 3.5\n-- 0.5\ntruncate_number :: Float -> Float", "canonical_solution": "truncate_number number = \u2b50 number - fromIntegral \u2b50 (floor number)", "test": ""}
{"task_id": "Haskell/3", "prompt": "-- You're given a list of deposit and withdrawal operations on a bank account that starts with\n-- zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n-- at that point function should return True. Otherwise it should return False.\n-- >>> below_zero [1, 2, 3]\n-- False\n-- >>> below_zero [1, 2, -4, 5]\n-- True\nbelow_zero :: [Int] -> Bool", "canonical_solution": "below_zero operations = \u2b50 any (< 0) $ \u2b50 scanl (+) 0 operations", "test": ""}
{"task_id": "Haskell/4", "prompt": "-- For a given list of input numbers, calculate Mean Absolute Deviation\n-- around the mean of this dataset.\n-- Mean Absolute Deviation is the average absolute difference between each\n-- element and a centerpoint (mean in this case):\n-- MAD = average | x - x_mean |\n-- >>> mean_absolute_deviation [1.0, 2.0, 3.0, 4.0]\n-- 1.0\nmean_absolute_deviation :: [Float] -> Float", "canonical_solution": "mean_absolute_deviation numbers = sum \u2b50 (map abs (map (\\x -> \u2b50 x - mean) numbers)) / \u2b50 fromIntegral (length numbers)\n    where\n        mean = \u2b50 sum numbers / \u2b50 fromIntegral (length numbers)", "test": ""}
{"task_id": "Haskell/5", "prompt": "-- Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n-- >>> intersperse [] 4\n-- []\n-- >>> intersperse [1, 2, 3] 4\n-- [1,4,2,4,3,4]\nintersperse :: [Int] -> Int -> [Int]", "canonical_solution": "intersperse numbers delimeter = \u2b50 concat [[x, delimeter] | \u2b50 x <- numbers]", "test": ""}
{"task_id": "Haskell/6", "prompt": "-- Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n-- For each of the group, output the deepest level of nesting of parentheses.\n-- E.g. (()()) has maximum two levels of nesting while ((())) has three.\n-- >>> parse_nested_parens \"(()()) ((())) () ((())()())\"\n-- [2,3,1,3]\nparse_nested_parens :: String -> [Int]", "canonical_solution": "parse_nested_parens paren_string = get_paren_depths paren_string \u2b50 0 []\n    where\n        get_paren_depths :: String -> Int -> [Int] -> [Int]\n        get_paren_depths \"\" _ max_depths = \u2b50 max_depths\n        get_paren_depths ('(':cs) 0 max_depths = \u2b50 get_paren_depths cs 1 \u2b50 (max_depths ++ [1])\n        get_paren_depths ('(':cs) depth max_depths = \u2b50 get_paren_depths cs (depth + 1) ((reverse . tail . reverse $ max_depths) ++ \u2b50 [max (head $ reverse max_depths) (depth + 1)])\n        get_paren_depths (')':cs) depth max_depths = \u2b50 get_paren_depths cs (depth - 1) max_depths\n        get_paren_depths (_:cs) depth max_depths = \u2b50 get_paren_depths cs depth max_depths", "test": ""}
{"task_id": "Haskell/7", "prompt": "-- Filter an input list of strings only for ones that contain given substring\n-- >>> filter_by_substring [] \"a\"\n-- []\n-- >>> filter_by_substring [\"abc\", \"bacd\", \"cde\", \"array\"] \"a\"\n-- [\"abc\",\"bacd\",\"array\"]\nfilter_by_substring :: [String] -> String -> [String]", "canonical_solution": "filter_by_substring strings substring = \u2b50 [x | x <- strings, \u2b50 substring `isInfixOf` x]", "test": ""}
{"task_id": "Haskell/8", "prompt": "-- For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n-- Empty sum should be equal to 0 and empty product should be equal to 1.\n-- >>> sum_product []\n-- (0,1)\n-- >>> sum_product [1, 2, 3, 4]\n-- (10,24)\nsum_product :: [Int] -> (Int, Int)", "canonical_solution": "sum_product numbers = \u2b50 (sum numbers, product numbers)", "test": ""}
{"task_id": "Haskell/9", "prompt": "-- From a given list of integers, generate a list of rolling maximum element found until given moment\n-- in the sequence.\n-- >>> rolling_max [1, 2, 3, 2, 3, 4, 2]\n-- [1,2,3,3,3,4,4]\nrolling_max :: [Int] -> [Int]", "canonical_solution": "rolling_max numbers = \u2b50 scanl1 \u2b50 max numbers", "test": ""}
{"task_id": "Haskell/10", "prompt": "is_palindrome :: String -> Bool", "canonical_solution": "is_palindrome string = \u2b50 string == \u2b50 reverse string", "test": ""}
{"task_id": "Haskell/11", "prompt": "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform binary XOR on these inputs and return result also as a string.\n-- >>> string_xor \"010\" \"110\"\n-- \"100\"\nstring_xor :: String -> String -> String", "canonical_solution": "string_xor a b = \u2b50 [if x == y \u2b50 then '0' else '1' | \u2b50 (x, y) <- \u2b50 zip a b]", "test": ""}
{"task_id": "Haskell/12", "prompt": "-- Out of list of strings, return the longest one. Return the first one in case of multiple\n-- strings of the same length. Return Nothing in case the input list is empty.\n-- >>> longest []\n-- Nothing\n-- >>> longest [\"a\", \"b\", \"c\"]\n-- Just \"a\"\n-- >>> longest [\"a\", \"bb\", \"ccc\"]\n-- Just \"ccc\"\nlongest :: [String] -> Maybe String", "canonical_solution": "longest strings = case \u2b50 strings of\n    [] -> \u2b50 Nothing\n    _ -> \u2b50 Just $ maximumBy \u2b50 (comparing length) $ \u2b50 reverse strings", "test": ""}
{"task_id": "Haskell/13", "prompt": "-- Return a greatest common divisor of two integers a and b\n-- >>> greatest_common_divisor 3 5\n-- 1\n-- >>> greatest_common_divisor 25 15\n-- 5\ngreatest_common_divisor :: Int -> Int -> Int", "canonical_solution": "greatest_common_divisor a b = \u2b50 gcd \u2b50 a b", "test": ""}
{"task_id": "Haskell/14", "prompt": "-- Return list of all prefixes from shortest to longest of the input string\n-- >>> all_prefixes \"abc\"\n-- [\"a\",\"ab\",\"abc\"]\nall_prefixes :: String  -> [String]", "canonical_solution": "all_prefixes string = \u2b50 [take (i+1) string | \u2b50 i <- \u2b50 [0..length string - 1]]", "test": ""}
{"task_id": "Haskell/15", "prompt": "-- Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n-- >>> string_sequence 0\n-- \"0\"\n-- >>> string_sequence 5\n-- \"0 1 2 3 4 5\"\nstring_sequence :: Int -> String", "canonical_solution": "string_sequence n = \u2b50 unwords \u2b50 [show x | x <- \u2b50 [0..n]]", "test": ""}
{"task_id": "Haskell/16", "prompt": "-- Given a string, find out how many distinct characters (regardless of case) does it consist of\n-- >>> count_distinct_characters \"xyzXYZ\"\n-- 3\n-- >>> count_distinct_characters \"Jerry\"\n-- 4\ncount_distinct_characters :: String -> Int", "canonical_solution": "count_distinct_characters string = \u2b50 length $ \u2b50 nub $ \u2b50 map toLower string", "test": ""}
{"task_id": "Haskell/17", "prompt": "-- Input to this function is a string representing musical notes in a special ASCII format.\n-- Your task is to parse this string and return list of integers corresponding to how many beats does each\n-- not last.\n-- Here is a legend:\n-- 'o' - whole note, lasts four beats\n-- 'o|' - half note, lasts two beats\n-- '.|' - quater note, lasts one beat\n-- >>> parse_music \"o o| .| o| o| .| .| .| .| o o\"\n-- [4,2,1,2,2,1,1,1,1,4,4]\nparse_music :: String -> [Int]", "canonical_solution": "parse_music music_string = \u2b50 [note_map x | x <- \u2b50 words music_string]\n    where \n        note_map \"o\" = \u2b50 4\n        note_map \"o|\" = \u2b50 2\n        note_map \".|\" = \u2b50 1", "test": ""}
{"task_id": "Haskell/18", "prompt": "-- Find how many times a given substring can be found in the original string. Count overlaping cases.\n-- >>> how_many_times \"\" \"a\"\n-- 0\n-- >>> how_many_times \"aaa\" \"a\"\n-- 3\n-- >>> how_many_times \"aaaa\" \"aa\"\n-- 3\nhow_many_times :: String -> String -> Int", "canonical_solution": "how_many_times string substring = \u2b50 length $ filter \u2b50 (substring `isPrefixOf`) $ map \u2b50 (take \u2b50 (length substring)) $ \u2b50 tails string", "test": ""}
{"task_id": "Haskell/19", "prompt": "-- Input is a space-delimited string of numberals from 'zero' to 'nine'.\n-- Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n-- Return the string with numbers sorted from smallest to largest\n-- >>> sort_numbers \"three one five\"\n-- \"one three five\"\nsort_numbers :: String -> String", "canonical_solution": "sort_numbers numbers = \u2b50 unwords $ sortOn \u2b50 (value_map !) $ \u2b50 words numbers\n    where value_map = fromList \u2b50 [(\"zero\", 0), (\"one\", 1), (\"two\", 2), (\"three\", 3), (\"four\", 4), (\"five\", 5), \u2b50 (\"six\", 6), (\"seven\", 7), (\"eight\", 8), (\"nine\", 9)]", "test": ""}
{"task_id": "Haskell/20", "prompt": "-- From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n-- other and return them in order (smaller number, larger number).\n-- >>> find_closest_elements [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]\n-- (2.0,2.2)\n-- >>> find_closest_elements [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]\n-- (2.0,2.0)\nfind_closest_elements :: [Float] -> (Float, Float)", "canonical_solution": "find_closest_elements numbers = \u2b50 head $ sortOn \u2b50 (\\(x, y) -> \u2b50 abs (x - y)) \u2b50 [(x,y) | (x:ys) <- \u2b50 tails numbers, y <- ys]", "test": ""}
{"task_id": "Haskell/21", "prompt": "-- Given list of numbers (of at least two elements), apply a linear transform to that list,\n-- such that the smallest number will become 0 and the largest will become 1\n-- >>> rescale_to_unit [1.0, 2.0, 3.0, 4.0, 5.0]\n-- [0.0,0.25,0.5,0.75,1.0]\nrescale_to_unit :: [Float] -> [Float]", "canonical_solution": "rescale_to_unit numbers = map \u2b50 (\\x -> \u2b50 (x - min_number) / \u2b50 (max_number - min_number)) \u2b50 numbers\n    where min_number = \u2b50 minimum numbers\n          max_number = \u2b50 maximum numbers", "test": ""}
{"task_id": "Haskell/23", "prompt": "-- Return length of given string\nstrlen :: String -> Int", "canonical_solution": "strlen string = \u2b50 length \u2b50 string", "test": ""}
{"task_id": "Haskell/24", "prompt": "-- For a given number n, find the largest number that divides n evenly, smaller than n\n-- >>> largest_divisor 15\n-- 5\nlargest_divisor :: Int -> Int", "canonical_solution": "largest_divisor n = \u2b50 maximum \u2b50 [x | x <- \u2b50 [1..n-1], \u2b50 n `mod` x == \u2b50 0]", "test": ""}
{"task_id": "Haskell/25", "prompt": "-- Return list of prime factors of given integer in the order from smallest to largest.\n-- Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n-- Input number should be equal to the product of all factors\n-- >>> factorize 8\n-- [2,2,2]\n-- >>> factorize 25\n-- [5,5]\n-- >>> factorize 70\n-- [2,5,7]\nfactorize :: Int -> [Int]", "canonical_solution": "factorize n = factorize' n 2\n    where\n        factorize' :: Int -> Int -> [Int]\n        factorize' n i\n            | i * i > n = \u2b50 [n]\n            | n `mod` i == 0 = \u2b50 i : \u2b50 factorize' (n `div` i) i\n            | otherwise = \u2b50 factorize' n \u2b50 (i + 1)", "test": ""}
{"task_id": "Haskell/26", "prompt": "-- From a list of integers, remove all elements that occur more than once.\n-- Keep order of elements left the same as in the input.\n-- >>> remove_duplicates [1, 2, 3, 2, 4]\n-- [1,3,4]\nremove_duplicates :: [Int] -> [Int]", "canonical_solution": "remove_duplicates numbers = [n | \u2b50 (n, c) <- counts, \u2b50 c <= 1]\n    where counts = \u2b50 [(n, count n numbers) | n <- \u2b50 numbers]\n          count n xs = length \u2b50 [x | x <- xs, \u2b50 x == n]", "test": ""}
{"task_id": "Haskell/27", "prompt": "-- For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n-- >>> flip_case \"Hello\"\n-- \"hELLO\"\nflip_case :: String -> String", "canonical_solution": "flip_case string = \u2b50 map swap_case string\n    where swap_case c = \u2b50 if isUpper c then \u2b50 toLower c else \u2b50 toUpper c", "test": ""}
{"task_id": "Haskell/28", "prompt": "-- Concatenate list of strings into a single string\nconcatenate :: [String] -> String", "canonical_solution": "concatenate strings = \u2b50 concat strings", "test": ""}
{"task_id": "Haskell/29", "prompt": "-- Filter an input list of strings only for ones that start with a given prefix.\n-- >>> filter_by_prefix [] \"a\"\n-- []\n-- >>> filter_by_prefix [\"abc\", \"bcd\", \"cde\", \"array\"] \"a\"\n-- [\"abc\",\"array\"]\nfilter_by_prefix :: [String] -> String -> [String]", "canonical_solution": "filter_by_prefix strings prefix = \u2b50 [x | x <- \u2b50 strings, \u2b50 x `startsWith` prefix]\n    where startsWith :: String -> String -> Bool\n          startsWith string prefix = \u2b50 take (length prefix) \u2b50 string == prefix", "test": ""}
{"task_id": "Haskell/30", "prompt": "-- Return only positive numbers in the list.\nget_positive :: [Int] -> [Int]", "canonical_solution": "get_positive l = \u2b50 [x | x <- l, \u2b50 x > 0]", "test": ""}
{"task_id": "Haskell/31", "prompt": "-- Return true if a given number is prime, and false otherwise.\n-- >>> is_prime 6\n-- False\n-- >>> is_prime 101\n-- True\n-- >>> is_prime 11\n-- True\n-- >>> is_prime 13441\n-- True\n-- >>> is_prime 61\n-- True\n-- >>> is_prime 4\n-- False\n-- >>> is_prime 1\n-- False\nis_prime :: Int -> Bool", "canonical_solution": "is_prime n = \u2b50 n > 1 && \u2b50 all (\\k -> \u2b50 n `mod` k /= 0) \u2b50 [2..n-1]", "test": ""}
{"task_id": "Haskell/32", "prompt": "roundTo :: Double -> Int -> Double", "canonical_solution": "roundTo x n = \u2b50 (fromInteger $ round $ \u2b50 x * (10^n)) / \u2b50 (10.0^^n)", "test": ""}
{"task_id": "Haskell/33", "prompt": "-- This function takes a list l and returns a list l' such that\n-- l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n-- to the values of the corresponding indicies of l, but sorted.\n-- >>> sort_third [1,2,3]\n-- [1,2,3]\n-- >>> sort_third [5,6,3,4,8,9,2]\n-- [2,6,3,4,8,9,5]\nsort_third :: [Int] -> [Int]", "canonical_solution": "sort_third xs = replaceEveryThird xs (sort $ everyThird xs)\n  where\n    everyThird :: [Int] -> [Int]\n    everyThird [] = \u2b50 []\n    everyThird (x:xs) = \u2b50 x : everyThird \u2b50 (drop 2 xs)\n    replaceEveryThird :: [Int] -> [Int] -> [Int]\n    replaceEveryThird [] _ = \u2b50 []\n    replaceEveryThird xs [] = \u2b50 xs\n    replaceEveryThird (x:xs) (y:ys) = \u2b50 y : (take 2 xs ++ \u2b50 replaceEveryThird (drop 2 xs) ys)", "test": ""}
{"task_id": "Haskell/34", "prompt": "-- Return sorted unique elements in a list\n-- >>> unique [5,3,5,2,3,3,9,0,123]\n-- [0,2,3,5,9,123]\nunique :: [Int] -> [Int]", "canonical_solution": "unique = \u2b50 sort . \u2b50 nub", "test": ""}
{"task_id": "Haskell/35", "prompt": "-- Return maximum element in the list.\n-- >>> max_element [1,2,3]\n-- 3\n-- >>> max_element [5,3,-5,2,-3,3,9,0,123,1,-10]\n-- 123\nmax_element :: [Int] -> Int", "canonical_solution": "max_element = \u2b50 maximum", "test": ""}
{"task_id": "Haskell/36", "prompt": "-- Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n-- >>> fizz_buzz 50\n-- 0\n-- >>> fizz_buzz 78\n-- 2\n-- >>> fizz_buzz 79\n-- 3\nfizz_buzz :: Int -> Int", "canonical_solution": "fizz_buzz = \u2b50 length . filter \u2b50 (== '7') . concatMap show . filter (\\x -> \u2b50 x `mod` 11 == 0 || \u2b50 x `mod` 13 == 0) . \u2b50 enumFromTo 0 . pred", "test": ""}
{"task_id": "Haskell/37", "prompt": "-- This function takes a list l and returns a list l' such that\n-- l' is identical to l in the odd indicies, while its values at the even indicies are equal\n-- to the values of the even indicies of l, but sorted.\n-- >>> sort_even [1,2,3]\n-- [1,2,3]\n-- >>> sort_even [5,6,3,4]\n-- [3,6,5,4]\nsort_even :: [Int] -> [Int]", "canonical_solution": "sort_even xs = replaceEverySecond xs (sort $ everySecond xs)\n  where\n    everySecond :: [Int] -> [Int]\n    everySecond [] = \u2b50 []\n    everySecond (x:xs) = \u2b50 x : everySecond \u2b50 (drop 1 xs)\n    replaceEverySecond :: [Int] -> [Int] -> [Int]\n    replaceEverySecond [] _ = \u2b50 []\n    replaceEverySecond xs [] = \u2b50 xs\n    replaceEverySecond (x:xs) (y:ys) = \u2b50 y : (take 1 xs ++ \u2b50 replaceEverySecond \u2b50 (drop 1 xs) ys)", "test": ""}
{"task_id": "Haskell/38", "prompt": "-- returns encoded string by cycling groups of three characters.\nencode_cyclic :: String -> String", "canonical_solution": "encode_cyclic = concatMap (\\x -> \u2b50 if length x == 3 then \u2b50 tail x ++ [head x] else \u2b50 x) . chunksOf \u2b50 3\n  where\n    chunksOf :: Int -> [a] -> [[a]]\n    chunksOf _ [] = \u2b50 []\n    chunksOf n xs = \u2b50 take n xs : \u2b50 chunksOf n \u2b50 (drop n xs)", "test": ""}
{"task_id": "Haskell/39", "prompt": "-- prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n-- >>> prime_fib 1\n-- 2\n-- >>> prime_fib 2\n-- 3\n-- >>> prime_fib 3\n-- 5\n-- >>> prime_fib 4\n-- 13\n-- >>> prime_fib 5\n-- 89\nprime_fib :: Int -> Int", "canonical_solution": "prime_fib n = head $ drop (n - 1) $ filter isPrime $ map fib [1..]\n  where\n    fib :: Int -> Int\n    fib 1 = \u2b50 2\n    fib 2 = \u2b50 3\n    fib n = \u2b50 fib (n - 1) + \u2b50 fib (n - 2)\n    isPrime :: Int -> Bool\n    isPrime p = \u2b50 p > 1 && \u2b50 all (\\k -> p `mod` \u2b50 k /= 0) \u2b50 [2..(p - 1)]", "test": ""}
{"task_id": "Haskell/40", "prompt": "-- triples_sum_to_zero takes a list of integers as an input.\n-- it returns True if there are three distinct elements in the list that\n-- sum to zero, and False otherwise.\n-- >>> triples_sum_to_zero [1,3,5,0]\n-- False\n-- >>> triples_sum_to_zero [1,3,-2,1]\n-- True\n-- >>> triples_sum_to_zero [1,2,3,7]\n-- False\n-- >>> triples_sum_to_zero [2,4,-5,3,9,7]\n-- True\n-- >>> triples_sum_to_zero [1]\n-- False\ntriples_sum_to_zero :: [Int] -> Bool", "canonical_solution": "triples_sum_to_zero xs = \u2b50 any (\\(a, b, c) -> \u2b50 a + b + c == 0) $ triples xs\n  where\n    triples :: [Int] -> [(Int, Int, Int)]\n    triples [] = \u2b50 []\n    triples (x:xs) = \u2b50 [(x, y, z) | y <- xs, z <- \u2b50 tail xs, \u2b50 y /= z] ++ \u2b50 triples xs", "test": ""}
{"task_id": "Haskell/41", "prompt": "-- Imagine a road that's a perfectly straight infinitely long line.\n-- n cars are driving left to right;  simultaneously, a different set of n cars\n-- are driving right to left.   The two sets of cars start out being very far from\n-- each other.  All cars move in the same speed.  Two cars are said to collide\n-- when a car that's moving left to right hits a car that's moving right to left.\n-- However, the cars are infinitely sturdy and strong; as a result, they continue moving\n-- in their trajectory as if they did not collide.\n-- This function outputs the number of such collisions.\ncar_race_collision :: Int -> Int", "canonical_solution": "car_race_collision n = \u2b50 n^\u2b502", "test": ""}
{"task_id": "Haskell/42", "prompt": "-- Return list with elements incremented by 1.\n-- >>> incr_list [1,2,3]\n-- [2,3,4]\n-- >>> incr_list [5,3,5,2,3,3,9,0,123]\n-- [6,4,6,3,4,4,10,1,124]\nincr_list :: [Int] -> [Int]", "canonical_solution": "incr_list = \u2b50 map (+1)", "test": ""}
{"task_id": "Haskell/43", "prompt": "-- pairs_sum_to_zero takes a list of integers as an input.\n-- it returns True if there are two distinct elements in the list that\n-- sum to zero, and False otherwise.\n-- >>> pairs_sum_to_zero [1,3,5,0]\n-- False\n-- >>> pairs_sum_to_zero [1,3,-2,1]\n-- False\n-- >>> pairs_sum_to_zero [1,2,3,7]\n-- False\n-- >>> pairs_sum_to_zero [2,4,-5,3,5,7]\n-- True\n-- >>> pairs_sum_to_zero [1]\n-- False\npairs_sum_to_zero :: [Int] -> Bool", "canonical_solution": "pairs_sum_to_zero xs = \u2b50 any (\\(a, b) -> \u2b50 a + b == 0) $ \u2b50 pairs xs\n  where\n    pairs [] = \u2b50 []\n    pairs (x:xs) = \u2b50 [(x, y) | y <- xs] ++ pairs xs", "test": ""}
{"task_id": "Haskell/44", "prompt": "-- Change numerical base of input number x to base.\n-- return string representation after the conversion.\n-- base numbers are less than 10.\n-- >>> change_base 8 3\n-- \"22\"\n-- >>> change_base 8 2\n-- \"1000\"\n-- >>> change_base 7 2\n-- \"111\"\nchange_base :: Int -> Int -> String", "canonical_solution": "change_base x base = \u2b50 reverse $ change_base' x\n  where\n    change_base' :: Int -> String \n    change_base' 0 = \u2b50 \"\"\n    change_base' x = \u2b50 show (x `mod` base) ++ \u2b50 change_base' (x `div` base)", "test": ""}
{"task_id": "Haskell/45", "prompt": "-- Given length of a side and high return area for a triangle.\n-- >>> triangle_area 5 3\n-- 7.5\ntriangle_area :: Double -> Double -> Double", "canonical_solution": "triangle_area a h = \u2b50 a * h / \u2b50 2.0", "test": ""}
{"task_id": "Haskell/46", "prompt": "-- The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n-- fib4(0) -> 0\n-- fib4(1) -> 0\n-- fib4(2) -> 2\n-- fib4(3) -> 0\n-- fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n-- Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n-- >>> fib4 5\n-- 4\n-- >>> fib4 6\n-- 8\n-- >>> fib4 7\n-- 14\nfib4 :: Int -> Int", "canonical_solution": "fib4 n = \u2b50 fib4' n 0 0 2 0\n  where\n    fib4' :: Int -> Int -> Int -> Int -> Int -> Int\n    fib4' 0 a b c d = \u2b50 a\n    fib4' 1 a b c d = \u2b50 b\n    fib4' 2 a b c d = \u2b50 c\n    fib4' 3 a b c d = \u2b50 d\n    fib4' n a b c d = \u2b50 fib4' (n - 1) b c d \u2b50 (a + b + c + d)", "test": ""}
{"task_id": "Haskell/47", "prompt": "-- Return median of elements in the list l.\n-- >>> median [3,1,2,4,5]\n-- 3.0\n-- >>> median [-10,4,6,1000,10,20]\n-- 8.0\nmedian :: [Int] -> Double", "canonical_solution": "median xs = \u2b50 if odd len then fromIntegral (sorted !! (len `div` 2)) else \u2b50 (fromIntegral (sorted !! (len `div` 2 - 1)) + fromIntegral (sorted !! (len `div` 2))) / 2\n  where\n    sorted :: [Int]\n    sorted = \u2b50 sort xs\n    len = \u2b50 length sorted", "test": ""}
{"task_id": "Haskell/48", "prompt": "-- Checks if given string is a palindrome\n-- >>> is_palindrome \"\"\n-- True\n-- >>> is_palindrome \"aba\"\n-- True\n-- >>> is_palindrome \"aaaaa\"\n-- True\n-- >>> is_palindrome \"zbcd\"\n-- False\nis_palindrome :: String -> Bool", "canonical_solution": "is_palindrome = \u2b50 (==) <*> reverse", "test": ""}
{"task_id": "Haskell/49", "prompt": "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp 3 5\n-- 3\n-- >>> modp 1101 101\n-- 2\n-- >>> modp 0 101\n-- 1\n-- >>> modp 3 11\n-- 8\n-- >>> modp 100 101\n-- 1\nmodp :: Int -> Int -> Int", "canonical_solution": "modp n p = \u2b50 modp' n p 1\n  where\n    modp' :: Int -> Int -> Int -> Int\n    modp' 0 p ret = \u2b50 ret\n    modp' n p ret = \u2b50 modp' (n - 1) p \u2b50 (mod (2 * ret) p)", "test": ""}
{"task_id": "Haskell/50", "prompt": "-- returns encoded string by shifting every character by 5 in the alphabet.\nencode_shift :: String -> String", "canonical_solution": "encode_shift = \u2b50 map (\\c -> \u2b50 chr (((ord c + 5 - ord 'a') `mod` 26) + \u2b50 ord 'a'))", "test": ""}
{"task_id": "Haskell/51", "prompt": "-- remove_vowels is a function that takes string and returns string without vowels.\n-- >>> remove_vowels \"\"\n-- \"\"\n-- >>> remove_vowels \"abcdef\\nghijklm\"\n-- \"bcdf\\nghjklm\"\n-- >>> remove_vowels \"abcdef\"\n-- \"bcdf\"\n-- >>> remove_vowels \"aaaaa\"\n-- \"\"\n-- >>> remove_vowels \"aaBAA\"\n-- \"B\"\n-- >>> remove_vowels \"zbcd\"\n-- \"zbcd\"\nremove_vowels :: String -> String", "canonical_solution": "remove_vowels = \u2b50 filter (`notElem` \"aeiouAEIOU\")", "test": ""}
{"task_id": "Haskell/52", "prompt": "-- Return True if all numbers in the list l are below threshold t.\n-- >>> below_threshold [1,2,4,10] 100\n-- True\n-- >>> below_threshold [1,20,4,10] 5\n-- False\nbelow_threshold :: [Int] -> Int -> Bool", "canonical_solution": "below_threshold numbers threshold = \u2b50 all (< threshold) numbers", "test": ""}
{"task_id": "Haskell/53", "prompt": "-- Add two numbers x and y\n-- >>> add 2 3\n-- 5\n-- >>> add 5 7\n-- 12\nadd :: Int -> Int -> Int", "canonical_solution": "add = \u2b50 (+)", "test": ""}
{"task_id": "Haskell/54", "prompt": "-- Check if two words have the same characters.\n-- >>> same_chars \"eabcdzzzz\" \"dddzzzzzzzddeddabc\"\n-- True\n-- >>> same_chars \"abcd\" \"dddddddabc\"\n-- True\n-- >>> same_chars \"dddddddabc\" \"abcd\"\n-- True\n-- >>> same_chars \"eabcd\" \"dddddddabc\"\n-- False\n-- >>> same_chars \"abcd\" \"dddddddabce\"\n-- False\n-- >>> same_chars \"eabcdzzzz\" \"dddzzzzzzzddddabc\"\n-- False\nsame_chars :: String -> String -> Bool", "canonical_solution": "same_chars s0 s1 = \u2b50 sort (nub s0) == \u2b50 sort (nub s1)", "test": ""}
{"task_id": "Haskell/55", "prompt": "-- Return n-th Fibonacci number.\n-- >>> fib 10\n-- 55\n-- >>> fib 1\n-- 1\n-- >>> fib 8\n-- 21\nfib :: Int -> Int", "canonical_solution": "fib n = \u2b50 fib' n 0 1\n  where\n    fib' :: Int -> Int -> Int -> Int\n    fib' 0 a b = \u2b50 a\n    fib' n a b = \u2b50 fib' (n - 1) b \u2b50 (a + b)", "test": ""}
{"task_id": "Haskell/56", "prompt": "-- brackets is a string of \"<\" and \">\".\n-- return True if every opening bracket has a corresponding closing bracket.\n-- >>> correct_bracketing \"<\"\n-- False\n-- >>> correct_bracketing \"<>\"\n-- True\n-- >>> correct_bracketing \"<<><>>\"\n-- True\n-- >>> correct_bracketing \"><<>\"\n-- False\ncorrect_bracketing :: String -> Bool", "canonical_solution": "correct_bracketing brackets =\n    let\n        process (depth, flag) b\n            | depth < 0 = \u2b50 (-1, False)\n            | b == '<'  = \u2b50 (depth + 1, True)\n            | otherwise = \u2b50 (depth - 1, True)\n    in\n        case foldl process \u2b50 (0, True) brackets of {}\n            (0, True) -> \u2b50 True\n            _         -> \u2b50 False", "test": ""}
{"task_id": "Haskell/57", "prompt": "-- Return True is list elements are monotonically increasing or decreasing.\n-- >>> monotonic [1,2,4,20]\n-- True\n-- >>> monotonic [1,20,4,10]\n-- False\n-- >>> monotonic [4,1,0,-10]\n-- True\nmonotonic :: [Int] -> Bool", "canonical_solution": "monotonic l = \u2b50 l == sort l || l == \u2b50 reverse (sort l)", "test": ""}
{"task_id": "Haskell/58", "prompt": "-- Return sorted unique common elements for two lists.\n-- >>> common [1,4,3,34,653,2,5] [5,7,1,5,9,653,121]\n-- [1,5,653]\n-- >>> common [5,3,2,8] [3,2]\n-- [2,3]\ncommon :: [Int] -> [Int] -> [Int]", "canonical_solution": "common l1 l2 = \u2b50 sort $ nub $ l1 `intersect` l2", "test": ""}
{"task_id": "Haskell/59", "prompt": "-- Return the largest prime factor of n. Assume n > 1 and is not a prime.\n-- >>> largest_prime_factor 13195\n-- 29\n-- >>> largest_prime_factor 2048\n-- 2\nlargest_prime_factor :: Int -> Int", "canonical_solution": "largest_prime_factor n = \u2b50 maximum $ filter (\\x -> n `mod` x == 0) $ \u2b50 filter is_prime [2..n]\n  where \n    is_prime :: Int -> Bool\n    is_prime k = \u2b50 null [x | x <- \u2b50 [2..k-1], k `mod` x == 0]", "test": ""}
{"task_id": "Haskell/60", "prompt": "-- sum_to_n is a function that sums numbers from 1 to n.\n-- >>> sum_to_n 30\n-- 465\n-- >>> sum_to_n 100\n-- 5050\n-- >>> sum_to_n 5\n-- 15\n-- >>> sum_to_n 10\n-- 55\n-- >>> sum_to_n 1\n-- 1\nsum_to_n :: Int -> Int", "canonical_solution": "sum_to_n n = \u2b50 sum [1..n]", "test": ""}
{"task_id": "Haskell/61", "prompt": "-- brackets is a string of \"(\" and \")\".\n-- return True if every opening bracket has a corresponding closing bracket.\n-- >>> correct_bracketing \"(\"\n-- False\n-- >>> correct_bracketing \"()\"\n-- True\n-- >>> correct_bracketing \"(()())\"\n-- True\n-- >>> correct_bracketing \")(()\"\n-- False\ncorrect_bracketing :: String -> Bool", "canonical_solution": "correct_bracketing brackets =\n    let\n        process (depth, flag) b\n            | depth < 0 = \u2b50 (-1, False)\n            | b == '('  = \u2b50 (depth + 1, True)\n            | otherwise = \u2b50 (depth - 1, True)\n    in\n        case foldl process \u2b50 (0, True) brackets of {}\n            (0, True) -> \u2b50 True\n            _         -> \u2b50 False", "test": ""}
{"task_id": "Haskell/62", "prompt": "-- xs represent coefficients of a polynomial.\n-- xs[0] + xs[1] * x + xs[2] * x^2 + ....\n-- Return derivative of this polynomial in the same form.\n-- >>> derivative [3,1,2,4,5]\n-- [1,4,12,20]\n-- >>> derivative [1,2,3]\n-- [2,6]\nderivative :: [Int] -> [Int]", "canonical_solution": "derivative xs = \u2b50 [i * x | (i, x) <- \u2b50 zip [1..] (tail xs)]", "test": ""}
{"task_id": "Haskell/63", "prompt": "-- The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n-- fibfib(0) == 0\n-- fibfib(1) == 0\n-- fibfib(2) == 1\n-- fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n-- Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n-- >>> fibfib 1\n-- 0\n-- >>> fibfib 5\n-- 4\n-- >>> fibfib 8\n-- 24\nfibfib :: Int -> Int", "canonical_solution": "fibfib n\n  | n == 0 = \u2b50 0\n  | n == 1 = \u2b50 0\n  | n == 2 = \u2b50 1\n  | otherwise = \u2b50 fibfib (n - 1) + fibfib (n - 2) + \u2b50 fibfib (n - 3)", "test": ""}
{"task_id": "Haskell/64", "prompt": "-- Write a function vowels_count which takes a string representing\n-- a word as input and returns the number of vowels in the string.\n-- Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n-- vowel, but only when it is at the end of the given word.\n-- Example:\n-- >>> vowels_count \"abcde\"\n-- 2\n-- >>> vowels_count \"ACEDY\"\n-- 3\nvowels_count :: String -> Int", "canonical_solution": "vowels_count s = \u2b50 (length $ filter (`elem` \"aeiouAEIOU\") s) + if last s `elem` \"yY\" then \u2b50 1 else 0", "test": ""}
{"task_id": "Haskell/65", "prompt": "-- Circular shift the digits of the integer x, shift the digits right by shift\n-- and return the result as a string.\n-- If shift > number of digits, return digits reversed.\n-- >>> circular_shift 12 1\n-- \"21\"\n-- >>> circular_shift 12 2\n-- \"12\"\ncircular_shift :: Int -> Int -> String", "canonical_solution": "circular_shift x shift\n  | shift > length s = \u2b50 reverse s\n  | otherwise = \u2b50 drop (length s - shift) s ++ \u2b50 take (length s - shift) s\n  where \n    s :: String\n    s = \u2b50 show x", "test": ""}
{"task_id": "Haskell/66", "prompt": "-- Task\n-- Write a function that takes a string as input and returns the sum of the upper characters only'\n-- ASCII codes.\n-- Examples:\n--     digitSum \"\" => 0\n--     digitSum \"abAB\" => 131\n--     digitSum \"abcCd\" => 67\n--     digitSum \"helloE\" => 69\n--     digitSum \"woArBld\" => 131\n--     digitSum \"aAaaaXa\" => 153\ndigitSum :: String -> Int", "canonical_solution": "digitSum s = \u2b50 sum [ord c | c <- s, \u2b50 isUpper c]", "test": ""}
{"task_id": "Haskell/67", "prompt": "-- In this task, you will be given a string that represents a number of apples and oranges\n-- that are distributed in a basket of fruit this basket contains\n-- apples, oranges, and mango fruits. Given the string that represents the total number of\n-- the oranges and apples and an integer that represent the total number of the fruits\n-- in the basket return the number of the mango fruits in the basket.\n-- for examble:\n-- fruit_distribution \"5 apples and 6 oranges\" 19 ->19 - 5 - 6 = 8\n-- fruit_distribution \"0 apples and 1 oranges\" 3 -> 3 - 0 - 1 = 2\n-- fruit_distribution \"2 apples and 3 oranges\" 100 -> 100 - 2 - 3 = 95\n-- fruit_distribution \"100 apples and 1 oranges\" 120 -> 120 - 100 - 1 = 19\nfruit_distribution :: String -> Int -> Int", "canonical_solution": "fruit_distribution s n = \u2b50 n - sum (map read (words (filter (\\x -> \u2b50 isDigit x || isSpace x) s)) :: [Int])", "test": ""}
{"task_id": "Haskell/68", "prompt": "-- Given an array representing a branch of a tree that has non-negative integer nodes\n-- your task is to pluck one of the nodes and return it.\n-- The plucked node should be the node with the smallest even value.\n-- If multiple nodes with the same smallest even value are found return the node that has smallest index.\n-- The plucked node should be returned in a list, [ smalest_value, its index ],\n-- If there are no even values or the given array is empty, return [].\n-- Example 1:\n--     Input: [4,2,3]\n--     Output: [2, 1]\n--     Explanation: 2 has the smallest even value, and 2 has the smallest index.\n-- Example 2:\n--     Input: [1,2,3]\n--     Output: [2, 1]\n--     Explanation: 2 has the smallest even value, and 2 has the smallest index.\n-- Example 3:\n--     Input: []\n--     Output: []\n-- Example 4:\n--     Input: [5, 0, 3, 0, 4, 2]\n--     Output: [0, 1]\n--     Explanation: 0 is the smallest value, but  there are two zeros,\n--                  so we will choose the first zero, which has the smallest index.\n-- Constraints:\n--     * 1 <= nodes.length <= 10000\n--     * 0 <= node.value\npluck :: [Int] -> [Int]", "canonical_solution": "pluck arr = \u2b50 if length arr == 0 then [] \u2b50 else [minimum evens, head (elemIndices (minimum evens) arr)]\n    where \n        evens :: [Int]\n        evens = \u2b50 filter even arr", "test": ""}
{"task_id": "Haskell/69", "prompt": "-- You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n-- zero, and has a frequency greater than or equal to the value of the integer itself.\n-- The frequency of an integer is the number of times it appears in the list.\n-- If no such a value exist, return -1.\n-- Examples:\n--     search [4, 1, 2, 2, 3, 1] == 2\n--     search [1, 2, 2, 3, 3, 3, 4, 4, 4] == 3\n--     search [5, 5, 4, 4, 4] == -1\nsearch :: [Int] -> Int", "canonical_solution": "search lst = \u2b50 let frq = map (\\x -> \u2b50 length (filter (== x) lst)) [0..(maximum lst)]\n             in if null [i | i <- [1..(length frq - 1)], frq !! i >= i] \u2b50 then -1 else maximum [i | i <- [1..(length frq - 1)], \u2b50 frq !! i >= i]", "test": ""}
{"task_id": "Haskell/70", "prompt": "-- Given list of integers, return list in strange order.\n-- Strange sorting, is when you start with the minimum value,\n-- then maximum of the remaining integers, then minimum and so on.\n-- Examples:\n-- strange_sort_list [1, 2, 3, 4] == [1, 4, 2, 3]\n-- strange_sort_list [5, 5, 5, 5] == [5, 5, 5, 5]\n-- strange_sort_list [] == []\nstrange_sort_list :: [Int] -> [Int]", "canonical_solution": "strange_sort_list lst = \u2b50 let helper [] _ = []\n                            helper lst True = \u2b50 minimum lst : helper (delete (minimum lst) lst) False\n                            helper lst False = \u2b50 maximum lst : helper (delete (maximum lst) lst) True\n                        in \u2b50 helper lst True", "test": ""}
{"task_id": "Haskell/71", "prompt": "-- Given the lengths of the three sides of a triangle. Return the area of\n-- the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n-- Otherwise return -1\n-- Three sides make a valid triangle when the sum of any two sides is greater\n-- than the third side.\n-- Example:\n-- triangle_area 3 4 5 == 6.00\n-- triangle_area 1 2 10 == -1\ntriangle_area :: Double -> Double -> Double -> Double", "canonical_solution": "triangle_area a b c = \u2b50 if a + b <= c || a + c <= b || b + c <= a then -1 else \u2b50 round' (sqrt (s * (s - a) * (s - b) * (s - c))) 2\n                      where \n                        s :: Double\n                        s = \u2b50 (a + b + c) / 2\n                        round' x n = \u2b50 (fromInteger $ round $ x * (10^n)) / (10.0^^n)", "test": ""}
{"task_id": "Haskell/72", "prompt": "-- Write a function that returns True if the object q will fly, and False otherwise.\n-- The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n-- Example:\n-- will_it_fly [1, 2] 5 == False\n-- 1+2 is less than the maximum possible weight, but it's unbalanced.\n-- will_it_fly [3, 2, 3] 1 == False\n-- it's balanced, but 3+2+3 is more than the maximum possible weight.\n-- will_it_fly [3, 2, 3] 9 == True\n-- 3+2+3 is less than the maximum possible weight, and it's balanced.\n-- will_it_fly [3] 5 == True\n-- 3 is less than the maximum possible weight, and it's balanced.\nwill_it_fly :: [Int] -> Int -> Bool", "canonical_solution": "will_it_fly q w = \u2b50 sum q <= w && q == \u2b50 reverse q", "test": ""}
{"task_id": "Haskell/73", "prompt": "-- Given an array arr of integers, find the minimum number of elements that\n-- need to be changed to make the array palindromic. A palindromic array is an array that\n-- is read the same backwards and forwards. In one change, you can change one element to any other element.\n-- For example:\n-- smallest_change [1,2,3,5,4,7,9,6] == 4\n-- smallest_change [1, 2, 3, 4, 3, 2, 2] == 1\n-- smallest_change [1, 2, 3, 2, 1] == 0\nsmallest_change :: [Int] -> Int", "canonical_solution": "smallest_change arr = \u2b50 length [i | i <- [0..(length arr `div` 2 - 1)], arr !! i /= arr !! \u2b50 (length arr - i - 1)]", "test": ""}
{"task_id": "Haskell/74", "prompt": "-- Write a function that accepts two lists of strings and returns the list that has\n-- total number of chars in the all strings of the list less than the other list.\n-- if the two lists have the same number of chars, return the first list.\n-- Examples\n-- total_match [] [] == []\n-- total_match [\"hi\", \"admin\"] [\"hI\", \"Hi\"] == [\"hI\", \"Hi\"]\n-- total_match [\"hi\", \"admin\"] [\"hi\", \"hi\", \"admin\", \"project\"] == [\"hi\", \"admin\"]\n-- total_match [\"hi\", \"admin\"] [\"hI\", \"hi\", \"hi\"] == [\"hI\", \"hi\", \"hi\"]\n-- total_match [\"4\"] [\"1\", \"2\", \"3\", \"4\", \"5\"] == [\"4\"]\ntotal_match :: [String] -> [String] -> [String]", "canonical_solution": "total_match lst1 lst2 = \u2b50 if sum (map length lst1) <= \u2b50 sum (map length lst2) then \u2b50 lst1 else lst2", "test": ""}
{"task_id": "Haskell/75", "prompt": "-- Write a function that returns true if the given number is the multiplication of 3 prime numbers\n-- and false otherwise.\n-- Knowing that (a) is less then 100.\n-- Example:\n-- is_multiply_prime 30 == True\n-- 30 = 2 * 3 * 5\nis_multiply_prime :: Int -> Bool", "canonical_solution": "is_multiply_prime a = \u2b50 let is_prime n = \u2b50 null [i | i <- [2..(n-1)], n `mod` i == 0]\n                      in or [is_prime i && is_prime j && is_prime k && i * j * k == a | i <- [2..100], j <- \u2b50 [2..100], k <- [2..100]]", "test": ""}
{"task_id": "Haskell/76", "prompt": "-- Your task is to write a function that returns true if a number x is a simple\n-- power of n and false in other cases.\n-- x is a simple power of n if n**int=x\n-- For example:\n-- is_simple_power 1 4 => true\n-- is_simple_power 2 2 => true\n-- is_simple_power 8 2 => true\n-- is_simple_power 3 2 => false\n-- is_simple_power 3 1 => false\n-- is_simple_power 5 3 => false\nis_simple_power :: Int -> Int -> Bool", "canonical_solution": "is_simple_power x n = \u2b50 or [n ^ i == x | \u2b50 i <- [0..x]]", "test": ""}
{"task_id": "Haskell/77", "prompt": "-- Write a function that takes an integer a and returns True\n-- if this ingeger is a cube of some integer number.\n-- Note: you may assume the input is always valid.\n-- Examples:\n-- iscube 1 ==> True\n-- iscube 2 ==> False\n-- iscube (-1) ==> True\n-- iscube 64 ==> True\n-- iscube 0 ==> True\n-- iscube 180 ==> False\niscube :: Int -> Bool", "canonical_solution": "iscube a = let b = \u2b50 abs a\n           in round \u2b50 (fromIntegral b ** (1.0 / 3.0)) ^ 3 == b", "test": ""}
{"task_id": "Haskell/78", "prompt": "-- You have been tasked to write a function that receives\n-- a hexadecimal number as a string and counts the number of hexadecimal\n-- digits that are primes (prime number, or a prime, is a natural number\n-- greater than 1 that is not a product of two smaller natural numbers).\n-- Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n-- Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n-- So you have to determine a number of the following digits: 2, 3, 5, 7,\n-- B (=decimal 11), D (=decimal 13).\n-- Note: you may assume the input is always correct or empty string,\n-- and symbols A,B,C,D,E,F are always uppercase.\n-- Examples:\n-- For num = \"AB\" the output should be 1.\n-- For num = \"1077E\" the output should be 2.\n-- For num = \"ABED1A33\" the output should be 4.\n-- For num = \"123456789ABCDEF0\" the output should be 6.\n-- For num = \"2020\" the output should be 2.\nhex_key :: String -> Int", "canonical_solution": "hex_key num = \u2b50 length [i | i <- \u2b50 num, i `elem` \"2357BD\"]", "test": ""}
{"task_id": "Haskell/79", "prompt": "-- You will be given a number in decimal form and your task is to convert it to\n-- binary format. The function should return a string, with each character representing a binary\n-- number. Each character in the string will be '0' or '1'.\n-- There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n-- The extra characters are there to help with the format.\n-- Examples:\n-- decimal_to_binary 15   # returns \"db1111db\"\n-- decimal_to_binary 32   # returns \"db100000db\"\ndecimal_to_binary :: Int -> String", "canonical_solution": "decimal_to_binary decimal = \u2b50 \"db\" ++ showIntAtBase 2 intToDigit decimal \"db\"", "test": ""}
{"task_id": "Haskell/80", "prompt": "-- You are given a string s.\n-- Your task is to check if the string is happy or not.\n-- A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n-- For example:\n-- is_happy \"a\" => False\n-- is_happy \"aa\" => False\n-- is_happy \"abcd\" => True\n-- is_happy \"aabb\" => False\n-- is_happy \"adb\" => True\n-- is_happy \"xyy\" => False\nis_happy :: String -> Bool", "canonical_solution": "is_happy s = \u2b50 length s >= 3 && and \u2b50 [s !! i /= s !! (i+1) && s !! (i+1) /= s !! (i+2) && s !! i /= s !! (i+2) | i <- \u2b50 [0..(length s - 3)]]", "test": ""}
{"task_id": "Haskell/81", "prompt": "-- It is the last week of the semester and the teacher has to give the grades\n-- to students. The teacher has been making her own algorithm for grading.\n-- The only problem is, she has lost the code she used for grading.\n-- She has given you a list of GPAs for some students and you have to write\n-- a function that can output a list of letter grades using the following table:\n--          GPA       |    Letter grade\n--           4.0                A+\n--         > 3.7                A\n--         > 3.3                A-\n--         > 3.0                B+\n--         > 2.7                B\n--         > 2.3                B-\n--         > 2.0                C+\n--         > 1.7                C\n--         > 1.3                C-\n--         > 1.0                D+\n--         > 0.7                D\n--         > 0.0                D-\n--           0.0                E\n-- Example:\n-- numerical_letter_grade [4.0, 3, 1.7, 2, 3.5] == [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\nnumerical_letter_grade :: [Double] -> [String]", "canonical_solution": "numerical_letter_grade grades = \u2b50 map grade grades\n    where\n        grade :: Double -> String\n        grade gpa\n            | gpa == 4.0 = \u2b50 \"A+\"\n            | gpa > 3.7 = \u2b50 \"A\"\n            | gpa > 3.3 = \u2b50 \"A-\"\n            | gpa > 3.0 = \u2b50 \"B+\"\n            | gpa > 2.7 = \u2b50 \"B\"\n            | gpa > 2.3 = \u2b50 \"B-\"\n            | gpa > 2.0 = \u2b50 \"C+\"\n            | gpa > 1.7 = \u2b50 \"C\"\n            | gpa > 1.3 = \u2b50 \"C-\"\n            | gpa > 1.0 = \u2b50 \"D+\"\n            | gpa > 0.7 = \u2b50 \"D\"\n            | gpa > 0.0 = \u2b50 \"D-\"\n            | otherwise = \u2b50 \"E\"", "test": ""}
{"task_id": "Haskell/82", "prompt": "-- Write a function that takes a string and returns True if the string\n-- length is a prime number or False otherwise\n-- Examples\n-- prime_length \"Hello\" == True\n-- prime_length \"abcdcba\" == True\n-- prime_length \"kittens\" == True\n-- prime_length \"orange\" == False\nprime_length :: String -> Bool", "canonical_solution": "prime_length string = let l = \u2b50 length string\n                      in l /= 0 && l /= 1 && null [i | i <- \u2b50 [2..(l-1)], l `mod` i == 0]", "test": ""}
{"task_id": "Haskell/83", "prompt": "-- Given a positive integer n, return the count of the numbers of n-digit\n-- positive integers that start or end with 1.\nstarts_one_ends :: Int -> Int", "canonical_solution": "starts_one_ends n = \u2b50 if n == 1 \u2b50 then 1 \u2b50 else 18 * (10 ^ (n - 2))", "test": ""}
{"task_id": "Haskell/84", "prompt": "-- Given a positive integer N, return the total sum of its digits in binary.\n-- Example\n--     For N = 1000, the sum of digits will be 1 the output should be \"1\".\n--     For N = 150, the sum of digits will be 6 the output should be \"110\".\n--     For N = 147, the sum of digits will be 12 the output should be \"1100\".\n-- Variables:\n--     @N integer\n--          Constraints: 0 \u2264 N \u2264 10000.\n-- Output:\n--      a string of binary number\nsolve :: Int -> String", "canonical_solution": "solve n = \u2b50 showIntAtBase 2 intToDigit \u2b50 (sum (map digitToInt \u2b50 (show n))) \"\"", "test": ""}
{"task_id": "Haskell/85", "prompt": "-- Given a non-empty list of integers lst. add the even elements that are at odd indices..\n-- Examples:\n--     add [4, 2, 6, 7] ==> 2\nadd :: [Int] -> Int", "canonical_solution": "add lst =\n  sum\n    [ lst !! i\n      | i <- \u2b50 [1, 3 .. \u2b50 (length lst - 1)],\n        even \u2b50 (lst !! i)\n    ]", "test": ""}
{"task_id": "Haskell/86", "prompt": "-- Write a function that takes a string and returns an ordered version of it.\n-- Ordered version of string, is a string where all words (separated by space)\n-- are replaced by a new word where all the characters arranged in\n-- ascending order based on ascii value.\n-- Note: You should keep the order of words and blank spaces in the sentence.\n-- For example:\n-- anti_shuffle \"Hi\" returns \"Hi\"\n-- anti_shuffle \"hello\" returns \"ehllo\"\n-- anti_shuffle \"Hello World!!!\" returns \"Hello !!!Wdlor\"\nanti_shuffle :: String -> String", "canonical_solution": "anti_shuffle s = \u2b50 unwords \u2b50 [sort i | i <- \u2b50 words s]", "test": ""}
{"task_id": "Haskell/87", "prompt": "-- You are given a 2 dimensional data, as a nested lists,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the list,\n-- and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n-- each tuple is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row [[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1\n-- [(0,0),(1,4),(1,0),(2,5),(2,0)]\n-- >>> get_row [] 1\n-- []\n-- >>> get_row [[], [1], [1, 2, 3]] 3\n-- [(2,2)]\nget_row :: [[Int]] -> Int -> [(Int, Int)]", "canonical_solution": "get_row lst x =\n  let coords =\n        [ (i, j)\n          | i <- \u2b50 [0 .. (length lst - 1)],\n            j <- \u2b50 [0 .. (length (lst !! i) - 1)],\n            (lst !! i) !! j \u2b50 == x\n        ]\n   in sortBy\n        (\\x y -> \u2b50 compare (fst x) (fst y))\n        ( sortBy\n            (\\x y -> \u2b50 compare (snd y) (snd x))\n            coords\n        )", "test": ""}
{"task_id": "Haskell/88", "prompt": "-- Given an array of non-negative integers, return a copy of the given array after sorting,\n-- you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n-- or sort it in descending order if the sum( first index value, last index value) is even.\n-- Note:\n-- * don't change the given array.\n-- Examples:\n-- >>> sort_array []\n-- []\n-- >>> sort_array [5]\n-- [5]\n-- >>> sort_array [2, 4, 3, 0, 1, 5]\n-- [0,1,2,3,4,5]\n-- >>> sort_array [2, 4, 3, 0, 1, 5, 6]\n-- [6,5,4,3,2,1,0]\nsort_array :: [Int] -> [Int]", "canonical_solution": "sort_array array =\n  if length array == 0\n    then \u2b50 []\n    else\n      sortBy\n        ( \\x y ->\n            if (array !! 0 + array !! \u2b50 (length array - 1)) `mod` 2 == \u2b50 0\n              then \u2b50 compare y x\n              else \u2b50 compare x y\n        )\n        array", "test": ""}
{"task_id": "Haskell/89", "prompt": "-- Create a function encrypt that takes a string as an argument and\n-- returns a string encrypted with the alphabet being rotated.\n-- The alphabet should be rotated in a manner such that the letters\n-- shift down by two multiplied to two places.\n-- For example:\n-- >>> encrypt \"hi\"\n-- \"lm\"\n-- >>> encrypt \"asdfghjkl\"\n-- \"ewhjklnop\"\n-- >>> encrypt \"gf\"\n-- \"kj\"\n-- >>> encrypt \"et\"\n-- \"ix\"\nencrypt :: String -> String", "canonical_solution": "encrypt s =\n  let d = \u2b50 ['a' .. 'z']\n   in [ d !! \u2b50 ((fromEnum c - fromEnum 'a' + \u2b50 2 * 2) `mod` \u2b50 26)\n        | c <- \u2b50 s\n      ]", "test": ""}
{"task_id": "Haskell/90", "prompt": "-- You are given a list of integers.\n-- Write a function next_smallest() that returns the 2nd smallest element of the list.\n-- Return None if there is no such element.\n-- next_smallest [1, 2, 3, 4, 5] == 2\n-- next_smallest [5, 1, 4, 3, 2] == 2\n-- next_smallest [] == None\n-- next_smallest [1, 1] == None\nnext_smallest :: [Int] -> Maybe Int", "canonical_solution": "next_smallest lst =\n  if length \u2b50 (sort (nub lst)) < \u2b50 2\n    then \u2b50 Nothing\n    else \u2b50 Just (sort (nub lst) !! 1)", "test": ""}
{"task_id": "Haskell/91", "prompt": "-- You'll be given a string of words, and your task is to count the number\n-- of boredoms. A boredom is a sentence that starts with the word \"I\".\n-- Sentences are delimited by '.', '?' or '!'.\n-- For example:\n-- >>> is_bored \"Hello world\"\n-- 0\n-- >>> is_bored \"The sky is blue. The sun is shining. I love this weather\"\n-- 1\nis_bored :: String -> Int", "canonical_solution": "is_bored s =\n  sum\n    [ 1\n      | sentence <- \u2b50 splitOnDelimiters s,\n        take 2 sentence == \u2b50 \"I \"\n    ]", "test": ""}
{"task_id": "Haskell/92", "prompt": "-- Create a function that takes 3 numbers.\n-- Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n-- Returns false in any other cases.\n-- Examples\n-- any_int 5 2 7 => True\n-- any_int 3 2 2 => False\n-- any_int 3 (-2) 1 => True\n-- any_int 3.6 (-2.2) 2 => False\nany_int :: Float -> Float -> Float -> Bool", "canonical_solution": "any_int x y z =\n  isInt x\n    && isInt y\n    && isInt \u2b50 z\n    && (x + y == z || \u2b50 x + z == y || \u2b50 y + z == x)\n  where\n    isInt a = a == \u2b50 fromInteger (round a)", "test": ""}
{"task_id": "Haskell/93", "prompt": "-- Write a function that takes a message, and encodes in such a\n-- way that it swaps case of all letters, replaces all vowels in\n-- the message with the letter that appears 2 places ahead of that\n-- vowel in the english alphabet.\n-- Assume only letters.\n-- Examples:\n-- >>> encode \"test\"\n-- \"TGST\"\n-- >>> encode \"This is a message\"\n-- \"tHKS KS C MGSSCGG\"\nencode :: String -> String", "canonical_solution": "encode message =\n  let vowels = \u2b50 \"aeiouAEIOU\"\n      vowels_replace =\n        zip\n          vowels\n          ( map\n              (\\x -> \u2b50 chr (ord x + 2))\n              vowels\n          )\n      message' =\n        map\n          ( \\x ->\n              if isUpper x\n                then \u2b50 toLower x\n                else \u2b50 toUpper x\n          )\n          message\n   in map\n        ( \\x ->\n            if x `elem` vowels\n              then \u2b50 (fromJust (lookup x vowels_replace))\n              else \u2b50 x\n        )\n        message'", "test": ""}
{"task_id": "Haskell/94", "prompt": "-- You are given a list of integers.\n-- You need to find the largest prime value and return the sum of its digits.\n-- Examples:\n-- For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n-- For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n-- For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n-- For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n-- For lst = [0,81,12,3,1,21] the output should be 3\n-- For lst = [0,8,1,2,1,7] the output should be 7\nskjkasdkd :: [Int] -> Int", "canonical_solution": "skjkasdkd lst =\n  let isPrime n =\n        null\n          [ i\n            | i <- \u2b50 [2 .. (floor (sqrt \u2b50 (fromIntegral n)))],\n              n `mod` \u2b50 i == 0\n          ]\n      maxx =\n        maximum\n          [ i | i <- \u2b50 lst, isPrime i\n          ]\n   in sum [read [i] | i <- \u2b50 show maxx]", "test": ""}
{"task_id": "Haskell/95", "prompt": "-- Given a dictionary, return True if all keys are strings in lower\n-- case or all keys are strings in upper case, else return False.\n-- The function should return False is the given dictionary is empty.\n-- Examples:\n-- check_dict_case [(\"a\",\"apple\"), (\"b\",\"banana\")] should return True.\n-- check_dict_case [(\"a\",\"apple\"), (\"A\",\"banana\"), (\"B\",\"banana\")] should return False.\n-- check_dict_case [(\"a\",\"apple\"), (\"8\",\"banana\"), (\"a\",\"apple\")] should return False.\n-- check_dict_case [(\"Name\",\"John\"), (\"Age\",\"36\"), (\"City\",\"Houston\")] should return False.\n-- check_dict_case [(\"STATE\",\"NC\"), (\"ZIP\",\"12345\")] should return True.\ncheck_dict_case :: [(String, String)] -> Bool", "canonical_solution": "check_dict_case dict =\n  length dict > \u2b50 0\n    && all (\\x -> \u2b50 all isUpper x) keys\n    || all\n      (\\x -> \u2b50 all isLower x)\n      keys\n  where\n    keys = map \u2b50 fst dict", "test": ""}
{"task_id": "Haskell/96", "prompt": "-- Implement a function that takes an non-negative integer and returns an array of the first n\n-- integers that are prime numbers and less than n.\n-- for example:\n-- count_up_to 5 => [2,3]\n-- count_up_to 11 => [2,3,5,7]\n-- count_up_to 0 => []\n-- count_up_to 20 => [2,3,5,7,11,13,17,19]\n-- count_up_to 1 => []\n-- count_up_to 18 => [2,3,5,7,11,13,17]\ncount_up_to :: Int -> [Int]", "canonical_solution": "count_up_to n =\n  [ i\n    | i <- \u2b50 [2 .. (n - 1)],\n      is_prime \u2b50 i\n  ]\n  where\n    is_prime n =\n      null\n        [ i\n          | i <- \u2b50 [2 .. \u2b50 (n - 1)],\n            n `mod` \u2b50 i == 0\n        ]", "test": ""}
{"task_id": "Haskell/97", "prompt": "-- Complete the function that takes two integers and returns\n-- the product of their unit digits.\n-- Assume the input is always valid.\n-- Examples:\n-- multiply 148 412 should return 16.\n-- multiply 19 28 should return 72.\n-- multiply 2020 1851 should return 0.\n-- multiply 14 (-15) should return 20.\nmultiply :: Int -> Int -> Int", "canonical_solution": "multiply a b =\n  abs \u2b50 (a `mod` 10)\n    * abs \u2b50 (b `mod` 10)", "test": ""}
{"task_id": "Haskell/98", "prompt": "-- Given a string s, count the number of uppercase vowels in even indices.\n-- For example:\n-- count_upper \"aBCdEf\" returns 1\n-- count_upper \"abcdefg\" returns 0\n-- count_upper \"dBBE\" returns 0\ncount_upper :: String -> Int", "canonical_solution": "count_upper s =\n  length\n    [ i\n      | i <- \u2b50 [0, 2 .. \u2b50 (length s - 1)],\n        s !! i `elem` \u2b50 \"AEIOU\"\n    ]", "test": ""}
{"task_id": "Haskell/99", "prompt": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer \"10\"\n-- 10\n-- >>> closest_integer \"15.3\"\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nclosest_integer :: String -> Integer", "canonical_solution": "closest_integer s = let n = \u2b50 read s \u2b50 :: Double\n    in round \u2b50 n", "test": ""}
{"task_id": "Haskell/100", "prompt": "-- Given a positive integer n, you have to make a pile of n levels of stones.\n-- The first level has n stones.\n-- The number of stones in the next level is:\n--     - the next odd number if n is odd.\n--     - the next even number if n is even.\n-- Return the number of stones in each level in a list, where element at index\n-- i represents the number of stones in the level (i+1).\n-- Examples:\n-- >>> make_a_pile 3\n-- [3,5,7]\nmake_a_pile :: Int -> [Int]", "canonical_solution": "make_a_pile n =\n  [ n + \u2b50 2 * i\n    | i <- \u2b50 [0 .. \u2b50 n - 1]\n  ]", "test": ""}
{"task_id": "Haskell/101", "prompt": "-- You will be given a string of words separated by commas or spaces. Your task is\n-- to split the string into words and return an array of the words.\n-- For example:\n-- >>> words_string \"Hi, my name is John\"\n-- [\"Hi\",\"my\",\"name\",\"is\",\"John\"]\n-- >>> words_string \"One, two, three, four, five, six\"\n-- [\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"]\nwords_string :: String -> [String]", "canonical_solution": "words_string s = \u2b50 words $\n        map\n        ( \\c ->\n            if c == \u2b50 ','\n                then \u2b50 ' '\n                else \u2b50 c\n        )\n        s", "test": ""}
{"task_id": "Haskell/102", "prompt": "-- This function takes two positive numbers x and y and returns the\n-- biggest even integer number that is in the range [x, y] inclusive. If\n-- there's no such number, then the function should return -1.\n-- For example:\n-- choose_num 12 15 = 14\n-- choose_num 13 12 = -1\nchoose_num :: Int -> Int -> Int", "canonical_solution": "choose_num x y\n  | x > \u2b50 y = \u2b50 -1\n  | y `mod` \u2b50 2 == 0 = \u2b50 y\n  | x == \u2b50 y = \u2b50 -1\n  | otherwise = \u2b50 y - 1", "test": ""}
{"task_id": "Haskell/103", "prompt": "-- You are given two positive integers n and m, and your task is to compute the\n-- average of the integers from n through m (including n and m).\n-- Round the answer to the nearest integer and convert that to binary.\n-- If n is greater than m, return -1.\n-- Example:\n-- rounded_avg 1 5 => \"0b11\"\n-- rounded_avg 7 5 => -1\n-- rounded_avg 10 20 => \"0b1111\"\n-- rounded_avg 20 33 => \"0b11010\"\nrounded_avg :: Int -> Int -> Either Int String", "canonical_solution": "rounded_avg n m\n  | m < \u2b50 n = \u2b50 Left (-1)\n  | otherwise =\n      let avg = round $ fromIntegral \u2b50 (n + m) / 2\n       in Right $ \"0b\" ++ \u2b50 Numeric.showIntAtBase 2 Data.Char.intToDigit \u2b50 avg \"\"", "test": ""}
{"task_id": "Haskell/104", "prompt": "-- Given a list of positive integers x. return a sorted list of all\n-- elements that hasn't any even digit.\n-- Note: Returned list should be sorted in increasing order.\n-- For example:\n-- >>> unique_digits [15, 33, 1422, 1]\n-- [1,15,33]\n-- >>> unique_digits [152, 323, 1422, 10]\n-- []\nunique_digits :: [Int] -> [Int]", "canonical_solution": "unique_digits x = \u2b50 sort $ filter\n      (all odd . \u2b50 map digitToInt . \u2b50 show)\n      x", "test": ""}
{"task_id": "Haskell/105", "prompt": "-- Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n-- reverse the resulting array, and then replace each digit by its corresponding name from\n-- \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n-- For example:\n--   arr = [2, 1, 1, 4, 5, 8, 2, 3]\n--         -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8]\n--         -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n--   return [\"Eight\",\"Five\",\"Four\",\"Three\",\"Two\",\"Two\",\"One\",\"One\"]\n--   If the array is empty, return an empty array:\n--   arr = []\n--   return []\n--   If the array has any strange number ignore it:\n--   arr = [1, -1 , 55]\n--         -> sort arr -> [-1, 1, 55]\n--         -> reverse arr -> [55, 1, -1]\n--   return = ['One']\nby_length :: [Int] -> [String]", "canonical_solution": "by_length xs = map toWord $ \u2b50 filter isDigit $ \u2b50 reverse $ \u2b50 sort xs\n  where\n    isDigit x = \u2b50 x >= 1 && \u2b50 x <= 9\n    toWord x = case \u2b50 x of\n      1 -> \u2b50 \"One\"\n      2 -> \u2b50 \"Two\"\n      3 -> \u2b50 \"Three\"\n      4 -> \u2b50 \"Four\"\n      5 -> \u2b50 \"Five\"\n      6 -> \u2b50 \"Six\"\n      7 -> \u2b50 \"Seven\"\n      8 -> \u2b50 \"Eight\"\n      9 -> \u2b50 \"Nine\"", "test": ""}
{"task_id": "Haskell/106", "prompt": "-- Implement the function f that takes n as a parameter,\n-- and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n-- or the sum of numbers from 1 to i otherwise.\n-- i starts from 1.\n-- the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n-- Example:\n-- f 5 == [1,2,6,24,15]\nf :: Int -> [Int]", "canonical_solution": "f n =\n  [ if \u2b50 even i\n      then \u2b50 product [1 .. i]\n      else \u2b50 sum [1 .. i]\n    | i <- \u2b50 [1 .. n]\n  ]", "test": ""}
{"task_id": "Haskell/107", "prompt": "-- Given a positive integer n, return a tuple that has the number of even and odd\n-- integer palindromes that fall within the range(1, n), inclusive.\n-- Example 1:\n--     Input: 3\n--     Output: (1,2)\n--     Explanation:\n--     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n-- Example 2:\n--     Input: 12\n--     Output: (4,6)\n--     Explanation:\n--     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n-- Note:\n--     1. 1 <= n <= 10^3\n--     2. returned tuple has the number of even and odd integer palindromes respectively.\neven_odd_palindrome :: Int -> (Int, Int)", "canonical_solution": "even_odd_palindrome n = (evenCount, oddCount)\n  where\n    isPalindrome x = \u2b50 show x == reverse \u2b50 (show x)\n    evenCount = length [x | x <- \u2b50 [1..n], isPalindrome x, \u2b50 even x]\n    oddCount = length [x | x <- \u2b50 [1..n], isPalindrome x, \u2b50 odd x]", "test": ""}
{"task_id": "Haskell/108", "prompt": "-- Write a function count_nums which takes an array of integers and returns\n-- the number of elements which has a sum of digits > 0.\n-- If a number is negative, then its first signed digit will be negative:\n-- e.g. -123 has signed digits -1, 2, and 3.\n-- >>> count_nums [] == 0\n-- >>> count_nums [-1, 11, -11] == 1\n-- >>> count_nums [1, 1, 2] == 3\ncount_nums :: [Int] -> Int", "canonical_solution": "count_nums arr = length $ filter \u2b50 (> 0) $ map digitsSum arr\n  where\n    digitsSum n =\n      if \u2b50 n < 0\n        then \u2b50 negate $ sum $ map digitToInt \u2b50 $ tail $ show n\n        else \u2b50 sum $ map digitToInt \u2b50 $ show n", "test": ""}
{"task_id": "Haskell/109", "prompt": "-- We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n-- numbers in the array will be randomly ordered. Your task is to determine if\n-- it is possible to get an array sorted in non-decreasing order by performing\n-- the following operation on the given array:\n--     You are allowed to perform right shift operation any number of times.\n-- One right shift operation means shifting all elements of the array by one\n-- position in the right direction. The last element of the array will be moved to\n-- the starting position in the array i.e. 0th index.\n-- If it is possible to obtain the sorted array by performing the above operation\n-- then return True else return False.\n-- If the given array is empty then return True.\n-- Note: The given list is guaranteed to have unique elements.\n-- For Example:\n-- move_one_ball [3, 4, 5, 1, 2] ==>True\n-- Explanation: By performin 2 right shift operations, non-decreasing order can\n--              be achieved for the given array.\n-- move_one_ball [3, 5, 4, 1, 2] ==>False\n-- Explanation:It is not possible to get non-decreasing order for the given\n--             array by performing any number of right shift operations.\nmove_one_ball :: (Ord a) => [a] -> Bool", "canonical_solution": "move_one_ball [] = True\nmove_one_ball arr = any (\\i -> \u2b50 rotate i arr == \u2b50 sort arr) [0 .. \u2b50 length arr - 1]\n  where\n    rotate n xs = \u2b50 drop n xs ++ \u2b50 take n xs", "test": ""}
{"task_id": "Haskell/110", "prompt": "-- In this problem, you will implement a function that takes two lists of numbers,\n-- and determines whether it is possible to perform an exchange of elements\n-- between them to make lst1 a list of only even numbers.\n-- There is no limit on the number of exchanged elements between lst1 and lst2.\n-- If it is possible to exchange elements between the lst1 and lst2 to make\n-- all the elements of lst1 to be even, return \"YES\".\n-- Otherwise, return \"NO\".\n-- For example:\n-- exchange [1, 2, 3, 4] [1, 2, 3, 4] => \"YES\"\n-- exchange [1, 2, 3, 4] [1, 5, 3, 4] => \"NO\"\n-- It is assumed that the input lists will be non-empty.\nexchange :: [Int] -> [Int] -> String", "canonical_solution": "exchange lst1 lst2\n  | evenCount \u2b50 >= oddCount = \u2b50 \"YES\"\n  | otherwise = \u2b50 \"NO\"\n  where\n    evenCount = \u2b50 length $ \u2b50 filter even \u2b50 lst2\n    oddCount = \u2b50 length $ \u2b50 filter odd \u2b50 lst1", "test": ""}
{"task_id": "Haskell/111", "prompt": "-- Given a string representing a space separated lowercase letters, return a dictionary\n-- of the letter with the most repetition and containing the corresponding count.\n-- If several letters have the same occurrence, return all of them.\n-- Example:\n-- histogram \"a b c\" == [('a',1),('b',1),('c',1)]\n-- histogram \"a b b a\" == [('a',2),('b',2)]\n-- histogram \"a b c a b\" == [('a',2),('b',2)]\n-- histogram \"b b b b a\" == [('b',4)]\n-- histogram(\"\") == []\nhistogram :: String -> [(Char, Int)]", "canonical_solution": "histogram str =\n  [ (c, n)\n    | (n, c) <- \u2b50 freqs,\n      n == \u2b50 maxFreq\n  ]\n  where\n    freqs =\n      [ (length g, head g)\n        | g <- \u2b50 group $ sort str,\n          head g \u2b50 /= ' '\n      ]\n    maxFreq = \u2b50 maximum $ \u2b50 map fst freqs", "test": ""}
{"task_id": "Haskell/112", "prompt": "-- Task\n-- We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n-- then check if the result string is palindrome.\n-- A string is called palindrome if it reads the same backward as forward.\n-- You should return a tuple containing the result string and True/False for the check.\n-- Example\n-- For s = \"abcde\", c = \"ae\", the result should be (\"bcd\",False)\n-- For s = \"abcdef\", c = \"b\"  the result should be (\"acdef\",False)\n-- For s = \"abcdedcba\", c = \"ab\", the result should be (\"cdedc\",True)\nreverse_delete :: String -> String -> (String, Bool)", "canonical_solution": "reverse_delete s c = \u2b50 (s', s' == \u2b50 reverse s')\n  where\n    s' =v filter (`notElem` \u2b50 c) s", "test": ""}
{"task_id": "Haskell/113", "prompt": "-- Given a list of strings, where each string consists of only digits, return a list.\n-- Each element i of the output should be \"the number of odd elements in the\n-- string i of the input.\" where all the i's should be replaced by the number\n-- of odd digits in the i'th string of the input.\n-- >>> odd_count [\"1234567\"]\n-- [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n-- >>> odd_count [\"3\",\"11111111\"]\n-- [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n--  \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\nodd_count :: [String] -> [String]", "canonical_solution": "odd_count lst = map countOdd lst\n  where\n    countOdd s = \"the number of odd elements \" ++ show n ++ \"n the str\" ++ \u2b50 show n ++ \"ng \" ++ show n ++ \" of the \" ++ \u2b50 show n ++ \"nput.\"\n      where\n        n =\n          length $\n            filter \u2b50 odd $\n              map \u2b50 read $\n                map \u2b50 (: []) s", "test": ""}
{"task_id": "Haskell/114", "prompt": "-- Given an array of integers nums, find the minimum sum of any non-empty sub-array\n-- of nums.\n-- Example\n-- minSubArraySum [2, 3, 4, 1, 2, 4] == 1\n-- minSubArraySum [-1, -2, -3] == -6\nminSubArraySum :: [Int] -> Int", "canonical_solution": "minSubArraySum [x] = \u2b50 x\nminSubArraySum (x:xs) = \u2b50 minimum \u2b50 [n, n + \u2b50 x, x]\n  where n = \u2b50 minSubArraySum \u2b50 xs", "test": ""}
{"task_id": "Haskell/115", "prompt": "-- You are given a rectangular grid of wells. Each row represents a single well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well has a corresponding bucket that can be used to extract water from it,\n-- and all buckets have the same capacity.\n-- Your task is to use the buckets to empty the wells.\n-- Output the number of times you need to lower the buckets.\n-- Example 1:\n--     Input:\n--         grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n--         bucket_capacity : 1\n--     Output: 6\n-- Example 2:\n--     Input:\n--         grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n--         bucket_capacity : 2\n--     Output: 5\n-- Example 3:\n--     Input:\n--         grid : [[0,0,0], [0,0,0]]\n--         bucket_capacity : 5\n--     Output: 0\n-- constraints:\n--     * all wells have the same length\n--     * 1 <= grid.length <= 10^2\n--     * 1 <= grid[:,1].length <= 10^2\n--     * grid[i][j] -> 0 | 1\n--     * 1 <= capacity <= 10\nmax_fill :: [[Int]] -> Int -> Int", "canonical_solution": "max_fill grid capacity = sum $ map \u2b50 (ceiling . (/ fromIntegral \u2b50 capacity) . \u2b50 fromIntegral . sum) $ \u2b50 grid", "test": ""}
{"task_id": "Haskell/116", "prompt": "-- In this Kata, you have to sort an array of non-negative integers according to\n-- number of ones in their binary representation in ascending order.\n-- For similar number of ones, sort based on decimal value.\n-- It must be implemented like this:\n-- >>> sort_array [1, 5, 2, 3, 4] == [1, 2, 3, 4, 5]\n-- >>> sort_array [-2, -3, -4, -5, -6] == [-6, -5, -4, -3, -2]\n-- >>> sort_array [1, 0, 2, 3, 4] [0, 1, 2, 3, 4]\nsort_array :: [Int] -> [Int]", "canonical_solution": "sort_array arr = sortBy g arr\n  where\n    f x y = compare \u2b50 (countOnes $ abs x) \u2b50 (countOnes $ abs y)\n    g x y =\n      if (f x y) \u2b50 /= EQ\n        then \u2b50 (f x y)\n        else \u2b50 (compare x y)\n    countOnes x =\n      length $\n        filter \u2b50 (== '1') $\n          showIntAtBase 2 \u2b50 intToDigit x \"\"", "test": ""}
{"task_id": "Haskell/117", "prompt": "-- Given a string s and a natural number n, you have been tasked to implement\n-- a function that returns a list of all words from string s that contain exactly\n-- n consonants, in order these words appear in the string s.\n-- If the string s is empty then the function should return an empty list.\n-- Note: you may assume the input string contains only letters and spaces.\n-- Examples:\n-- select_words \"Mary had a little lamb\" 4 ==> [\"little\"]\n-- select_words \"Mary had a little lamb\" 3 ==> [\"Mary\", \"lamb\"]\n-- select_words \"simple white space\" 2 ==> []\n-- select_words \"Hello world\" 4 ==> [\"world\"]\n-- select_words \"Uncle sam\" 3 ==> [\"Uncle\"]\nselect_words :: String -> Int -> [String]", "canonical_solution": "select_words s n = filter \u2b50 (\\word -> \u2b50 countConsonants word == n) $ \u2b50 words s\n  where\n    countConsonants word = length $ filter \u2b50 (\\c -> isConsonant c && isLetter c) word\n    isConsonant c = \u2b50 toLower c `notElem` \u2b50 \"aeiou\"\n    isLetter c = \u2b50 c `elem` ['a'..'z'] ++ \u2b50 ['A'..'Z']", "test": ""}
{"task_id": "Haskell/118", "prompt": "-- You are given a word. Your task is to find the closest vowel that stands between\n-- two consonants from the right side of the word (case sensitive).\n-- Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n-- find any vowel met the above condition.\n-- You may assume that the given string contains English letter only.\n-- Example:\n-- get_closest_vowel \"yogurt\" ==> \"u\"\n-- get_closest_vowel \"FULL\" ==> \"U\"\n-- get_closest_vowel \"quick\" ==> \"\"\n-- get_closest_vowel \"ab\" ==> \"\"\nget_closest_vowel :: String -> String", "canonical_solution": "get_closest_vowel word = f (reverse \u2b50 word)\n  where\n    f (x : y : z : xs) =\n      if vowel y && consonant x && \u2b50 consonant z\n        then \u2b50 [y]\n        else \u2b50 f (y : z : xs)\n    f _ = \u2b50 \"\"\n    vowel x = \u2b50 x `elem` \"aeiouAEIOU\"\n    consonant = \u2b50 not . vowel", "test": ""}
{"task_id": "Haskell/119", "prompt": "-- You are given a list of two strings, both strings consist of open\n-- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if it is possible to concatenate the two strings in\n-- some order, that the resulting string will be good.\n-- A string S is considered to be good if and only if all parentheses in S\n-- are balanced. For example: the string '(())()' is good, while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens [\"()(\", \")\"] == \"Yes\"\n-- match_parens [\")\", \")\"] == \"No\"\nmatch_parens :: [String] -> String", "canonical_solution": "match_parens [s1, s2] = if \u2b50 check (s1 ++ s2) || \u2b50 check (s2 ++ s1) \u2b50 then \"Yes\" \u2b50 else \"No\"\n  where\n    check :: String -> Bool\n    check s = go s 0\n    go :: String -> Int -> Bool\n    go [] n = \u2b50 n == 0\n    go ('(':xs) n = \u2b50 go xs (n+1)\n    go (')':xs) n = \u2b50 n > 0 && \u2b50 go xs (n-1)\n    go (_:xs) n = \u2b50 go xs n\nmatchParens _ = \u2b50 \"No\"", "test": ""}
{"task_id": "Haskell/120", "prompt": "-- Given an array arr of integers and a positive integer k, return a sorted list\n-- of length k with the maximum k numbers in arr.\n-- Example 1:\n--     Input: arr = [-3, -4, 5], k = 3\n--     Output: [-4, -3, 5]\n-- Example 2:\n--     Input: arr = [4, -4, 4], k = 2\n--     Output: [4, 4]\n-- Example 3:\n--     Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n--     Output: [2]\n-- Note:\n--     1. The length of the array will be in the range of [1, 1000].\n--     2. The elements in the array will be in the range of [-1000, 1000].\n--     3. 0 <= k <= len(arr)\nmaximumK :: [Int] -> Int -> [Int]", "canonical_solution": "maximumK arr k = \u2b50 reverse $ \u2b50 take k $ \u2b50 reverse $ \u2b50 sort arr", "test": ""}
{"task_id": "Haskell/121", "prompt": "-- Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n-- Examples\n-- solution [5, 8, 7, 1] ==> 12\n-- solution [3, 3, 3, 3, 3] ==> 9\n-- solution [30, 13, 24, 321] ==> 0\nsolution :: [Int] -> Int", "canonical_solution": "solution lst =\n  sum\n    [ x\n      | (idx, x) <- \u2b50 zip [0 ..] lst,\n        even \u2b50 idx,\n        odd \u2b50 x\n    ]", "test": ""}
{"task_id": "Haskell/122", "prompt": "-- Given a non-empty array of integers arr and an integer k, return\n-- the sum of the elements with at most two digits from the first k elements of arr.\n-- Example:\n--     Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n--     Output: 24 # sum of 21 + 3\n-- Constraints:\n--     1. 1 <= len(arr) <= 100\n--     2. 1 <= k <= len(arr)\nadd_elements :: [Int] -> Int -> Int", "canonical_solution": "add_elements arr k = \u2b50 sum \u2b50 [x | x <- \u2b50 take k arr, \u2b50 length (show x) <= 2]", "test": ""}
{"task_id": "Haskell/123", "prompt": "-- Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n-- The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n-- as follows: start with any positive integer n. Then each term is obtained from the\n-- previous term as follows: if the previous term is even, the next term is one half of\n-- the previous term. If the previous term is odd, the next term is 3 times the previous\n-- term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n-- Note:\n--     1. Collatz(1) is [1].\n--     2. returned list sorted in increasing order.\n-- For example:\n-- get_odd_collatz 5 returns [1,5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\nget_odd_collatz :: Int -> [Int]", "canonical_solution": "get_odd_collatz n = sort $ filter odd $ collatz n\n  where\n    collatz :: Int -> [Int]\n    collatz 1 = \u2b50 [1]\n    collatz x\n      | even x = \u2b50 x : collatz \u2b50 (x `div` 2)\n      | otherwise = \u2b50 x : collatz \u2b50 (x * 3 + \u2b50 1)", "test": ""}
{"task_id": "Haskell/124", "prompt": "-- You have to write a function which validates a given date string and\n-- returns True if the date is valid otherwise False.\n-- The date is valid if all of the following rules are satisfied:\n-- 1. The date string is not empty.\n-- 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n-- 3. The months should not be less than 1 or higher than 12.\n-- 4. The date should be in the format: mm-dd-yyyy\n-- for example:\n-- >>> valid_date \"03-11-2000\"\n-- True\n-- >>> valid_date \"15-01-2012\"\n-- False\n-- >>> valid_date \"04-0-2040\"\n-- False\n-- >>> valid_date \"06-04-2020\"\n-- True\n-- >>> valid_date \"06/04/2020\"\n-- False\nvalid_date :: String -> Bool", "canonical_solution": "valid_date date = case splitDate date of\n  Just (m, d, y) -> isValidDate m d y\n  _ -> \u2b50 False\n  where\n    splitDate :: String -> Maybe (Int, Int, Int)\n    splitDate (m1 : m2 : '-' : \u2b50 d1 : d2 : '-' : \u2b50 y1 : y2 : y3 : y4 : []) =\n      Just\n        ( digitToInt m1 * 10 + \u2b50 digitToInt m2,\n          digitToInt d1 * 10 + \u2b50 digitToInt d2,\n          digitToInt y1 * \u2b50 1000 + digitToInt y2 * 100 + \u2b50 digitToInt y3 * 10 + digitToInt y4\n        )\n    splitDate _ = Nothing\n    isValidDate m d y =\n      m >= \u2b50 1\n        && m <= \u2b50 12\n        && ( m `elem` \u2b50 [1, 3, 5, 7, 8, 10, 12] && d \u2b50 >= 1 && d <= 31\n               || m `elem` \u2b50 [4, 6, 9, 11] && d \u2b50 >= 1 && d <= 30\n               || m == 2 && d \u2b50 >= 1 && d <= 29 && (y `mod` 4 /= \u2b50 0 || y `mod` 100 == \u2b50 0 && y `mod` \u2b50 400 /= 0)\n           )", "test": ""}
{"task_id": "Haskell/125", "prompt": "-- Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n-- should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n-- alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n-- Examples\n-- split_words \"Hello world!\" \u279e [\"Hello\",\"world!\"]\n-- split_words \"Hello,world!\" \u279e [\"Hello\",\"world!\"]\n-- split_words \"abcdef\" == 3\nsplit_words :: String -> Either Int [String]", "canonical_solution": "split_words txt\n  | ' ' `elem` txt = \u2b50 Right $ words txt\n  | ',' `elem` txt = \u2b50 Right $ words $ \u2b50 map (\\c -> if c == ',' then ' ' else c) txt\n  | otherwise = \u2b50 Left $ length $ filter \u2b50 (\\c -> isLower c && even (ord c)) txt", "test": ""}
{"task_id": "Haskell/126", "prompt": "-- Given a list of numbers, return whether or not they are sorted\n-- in ascending order. If list has more than 1 duplicate of the same\n-- number, return False. Assume no negative numbers and only integers.\n-- Examples\n-- is_sorted [5] \u279e True\n-- is_sorted [1, 2, 3, 4, 5] \u279e True\n-- is_sorted [1, 3, 2, 4, 5] \u279e False\n-- is_sorted [1, 2, 3, 4, 5, 6] \u279e True\n-- is_sorted [1, 2, 3, 4, 5, 6, 7] \u279e True\n-- is_sorted [1, 3, 2, 4, 5, 6, 7] \u279e False\n-- is_sorted [1, 2, 2, 3, 3, 4] \u279e True\n-- is_sorted [1, 2, 2, 2, 3, 4] \u279e False\nis_sorted :: [Int] -> Bool", "canonical_solution": "is_sorted lst = \u2b50 length (nub lst) == length lst && \u2b50 all (uncurry (<=)) (zip lst (tail lst))", "test": ""}
{"task_id": "Haskell/127", "prompt": "-- You are given two intervals,\n-- where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n-- The given intervals are closed which means that the interval (start, end)\n-- includes both start and end.\n-- For each given interval, it is assumed that its start is less or equal its end.\n-- Your task is to determine whether the length of intersection of these two\n-- intervals is a prime number.\n-- Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n-- which its length is 1, which not a prime number.\n-- If the length of the intersection is a prime number, return \"YES\",\n-- otherwise, return \"NO\".\n-- If the two intervals don't intersect, return \"NO\".\n-- [input/output] samples:\n-- intersection (1, 2) (2, 3) ==> \"NO\"\n-- intersection (-1, 1) (0, 4) ==> \"NO\"\n-- intersection (-3, -1) (-5, 5) ==> \"YES\"\nintersection :: (Int, Int) -> (Int, Int) -> String", "canonical_solution": "intersection (a, b) (c, d)\n  | b < c || d < a = \"NO\"\n  | otherwise = \u2b50 if isPrime (abs (min b d - max a c)) then \u2b50 \"YES\" else \"NO\"\n  where\n    isPrime :: Int -> Bool\n    isPrime n = \u2b50 n > 1 && all (\\k -> n `mod` k /= 0) [2..floor (sqrt (fromIntegral n))]", "test": ""}
{"task_id": "Haskell/128", "prompt": "-- You are given an array arr of integers and you need to return\n-- sum of magnitudes of integers multiplied by product of all signs\n-- of each number in the array, represented by 1, -1 or 0.\n-- Note: return None for empty arr.\n-- Example:\n-- >>> prod_signs [1, 2, 2, -4] == Just (-9)\n-- >>> prod_signs [0, 1] == Just 0\n-- >>> prod_signs [] == Nothing\nprod_signs :: [Int] -> Maybe Int", "canonical_solution": "prod_signs arr\n  | null arr = \u2b50 Nothing\n  | otherwise = \u2b50 Just $ prod * sum (map abs arr)\n  where\n    prod :: Int\n    prod = \u2b50 if 0 `elem` arr then 0 else \u2b50 (-1) ^ length (filter (< 0) arr)", "test": ""}
{"task_id": "Haskell/129", "prompt": "-- Given a grid with N rows and N columns (N >= 2) and a positive integer k,\n-- each cell of the grid contains a value. Every integer in the range [1, N * N]\n-- inclusive appears exactly once on the cells of the grid.\n-- You have to find the minimum path of length k in the grid. You can start\n-- from any cell, and in each step you can move to any of the neighbor cells,\n-- in other words, you can go to cells which share an edge with you current\n-- cell.\n-- Please note that a path of length k means visiting exactly k cells (not\n-- necessarily distinct).\n-- You CANNOT go off the grid.\n-- A path A (of length k) is considered less than a path B (of length k) if\n-- after making the ordered lists of the values on the cells that A and B go\n-- through (let's call them lst_A and lst_B), lst_A is lexicographically less\n-- than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n-- such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n-- lst_A[j] = lst_B[j].\n-- It is guaranteed that the answer is unique.\n-- Return an ordered list of the values on the cells that the minimum path go through.\n-- Examples:\n--     Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n--     Output: [1, 2, 1]\n--     Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n--     Output: [1]\nminPath :: [[Int]] -> Int -> [Int]", "canonical_solution": "minPath grid k = \u2b50 seq [1, smallest_neighbor $ one_pos grid] k\n    where\n        one_pos :: [[Int]] -> (Int, Int)\n        one_pos [] = \u2b50 (-1, -1)\n        one_pos (x:xs) = \u2b50 case elemIndex 1 x of\n            Just i -> (i, 0)\n            Nothing -> case one_pos xs of\n                (-1, -1) -> (-1, -1)\n                (i, j) -> (i, j + 1)", "test": ""}
{"task_id": "Haskell/130", "prompt": "-- Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in\n-- the last couple centuries. However, what people don't know is Tribonacci sequence.\n-- Tribonacci sequence is defined by the recurrence:\n-- tri 1 = 3\n-- tri n = 1 + n / 2, if n is even.\n-- tri n =  tri (n - 1) + tri (n - 2) + tri (n + 1), if n is odd.\n-- For example:\n-- tri 2 = 1 + (2 / 2) = 2\n-- tri 4 = 3\n-- tri 3 = tri 2 + tri 1 + tri 4\n--       = 2 + 3 + 3 = 8\n-- You are given a non-negative integer number n, you have to a return a list of the\n-- first n + 1 numbers of the Tribonacci sequence.\n-- Examples:\n-- tri 3 = [1, 3, 2, 8]\ntri :: Int -> [Int]", "canonical_solution": "tri n = \u2b50 map tri' [0..n]\n    where\n        tri' :: Int -> Int\n        tri' 0 = \u2b50 1\n        tri' 1 = \u2b50 3\n        tri' n\n            | even n = \u2b50 1 + n `div` 2\n            | otherwise = \u2b50 tri' (n - 1) + \u2b50 tri' (n - 2) + \u2b50 tri' (n + 1)", "test": ""}
{"task_id": "Haskell/131", "prompt": "-- Given a positive integer n, return the product of the odd digits.\n-- Return 0 if all digits are even.\n-- For example:\n-- digits 1  == 1\n-- digits 4  == 0\n-- digits 235 == 15\ndigits :: Int -> Int", "canonical_solution": "digits n = \u2b50 if odd_count == 0 then \u2b50 0 else product\n  where\n    f :: Char -> (Int, Int) -> (Int, Int)\n    (product, odd_count) = \u2b50 foldr f (1, 0) (show n)\n    f digit (acc, count)\n      | even int_digit = \u2b50 (acc, count)\n      | otherwise = \u2b50 (acc * int_digit, count + 1)\n      where\n        int_digit :: Int\n        int_digit = \u2b50 read [digit] :: Int", "test": ""}
{"task_id": "Haskell/132", "prompt": "-- Create a function that takes a string as input which contains only square brackets.\n-- The function should return True if and only if there is a valid subsequence of brackets\n-- where at least one bracket in the subsequence is nested.\n-- >>> is_nested \"[[]]\"\n-- True\n-- >>> is_nested \"[]]]]]]][[[[[]\"\n-- False\n-- >>> is_nested \"[][]\"\n-- False\n-- >>> is_nested \"[]\"\n-- False\n-- >>> is_nested \"[[][]]\"\n-- True\n-- >>> is_nested \"[[]][[\"\n-- True\nis_nested :: String -> Bool", "canonical_solution": "is_nested string = is_nested' string 0 [] []\n  where\n    is_nested' :: String -> Int -> [Int] -> [Int] -> Bool\n    is_nested' ('[' : cs) index opening_bracket_index closing_bracket_index = \u2b50 is_nested' cs (index + 1) (opening_bracket_index \u2b50 ++ [index]) closing_bracket_index\n    is_nested' (']' : cs) index opening_bracket_index closing_bracket_index = \u2b50 is_nested' cs (index + 1) opening_bracket_index ([index] \u2b50 ++ closing_bracket_index)\n    is_nested' \"\" index opening_bracket_index closing_bracket_index\n      | index < 3 = \u2b50 False\n      | otherwise = \u2b50 is_nested'' opening_bracket_index closing_bracket_index 0 (length closing_bracket_index)\n      where\n        is_nested'' :: [Int] -> [Int] -> Int -> Int -> Bool\n        is_nested'' _ [] cnt l = \u2b50 cnt >= 2\n        is_nested'' [] _ cnt l = \u2b50 cnt >= 2\n        is_nested'' (o : os) (c : cs) cnt l\n          | o < c && cnt < l = \u2b50 is_nested'' os cs (cnt + 1) l\n          | otherwise = \u2b50 is_nested'' os (c : cs) cnt l", "test": ""}
{"task_id": "Haskell/133", "prompt": "sum_squares :: [Double] -> Int", "canonical_solution": "sum_squares lst = \u2b50 sum_squares' lst 0\n  where\n    sum_squares' [] acc = \u2b50 acc\n    sum_squares' (x : xs) acc = \u2b50 sum_squares' xs (acc + ceiling x ^ 2)", "test": ""}
{"task_id": "Haskell/134", "prompt": "check_if_last_char_is_a_letter :: String -> Bool", "canonical_solution": "check_if_last_char_is_a_letter [] = \u2b50 False\ncheck_if_last_char_is_a_letter txt = \u2b50 isLetter $ last txt", "test": ""}
{"task_id": "Haskell/135", "prompt": "-- Create a function which returns the largest index of an element which\n-- is not greater than or equal to the element immediately preceding it. If\n-- no such element exists then return -1. The given array will not contain\n-- uplicate values.\n-- >>> can_arrange [1,2,4,3,5]\n-- 3\n-- >>> can_arrange [1,2,3]\n-- -1\ncan_arrange :: [Int] -> Int", "canonical_solution": "can_arrange arr = \u2b50 can_arrange' arr 1 (-1)\n  where\n    can_arrange' :: [Int] -> Int -> Int -> Int\n    can_arrange' [] index res = \u2b50 res\n    can_arrange' (a : []) index res = \u2b50 res\n    can_arrange' (a : b : xs) index res\n      | a >= b = \u2b50 can_arrange' (b : xs) (index + 1) index\n      | otherwise = \u2b50 can_arrange' (b : xs) (index + 1) res", "test": ""}
{"task_id": "Haskell/136", "prompt": "-- Create a function that returns a tuple (a, b), where 'a' is\n-- the largest of negative integers, and 'b' is the smallest\n-- of positive integers in a list.\n-- If there is no negative or positive integers, return them as None.\n-- Examples:\n-- >>> largest_smallest_integers [2, 4, 1, 3, 5, 7]\n-- (Nothing,Just 1)\n-- >>> largest_smallest_integers []\n-- (Nothing,Nothing)\n-- >>> largest_smallest_integers [0]\n-- (Nothing,Nothing)\nlargest_smallest_integers :: [Int] -> (Maybe Int, Maybe Int)", "canonical_solution": "largest_smallest_integers [] = \u2b50 (Nothing, Nothing)\nlargest_smallest_integers arr = \u2b50 largest_smallest_integers' arr Nothing Nothing\n  where\n    largest_smallest_integers' :: [Int] -> Maybe Int -> Maybe Int -> (Maybe Int, Maybe Int)\n    largest_smallest_integers' [] largest smallest = (largest, smallest)\n    largest_smallest_integers' (x : xs) largest smallest\n      | x < 0 && isNothing largest = \u2b50 largest_smallest_integers' xs (Just x) smallest\n      | x < 0 = \u2b50 largest_smallest_integers' xs (Just \u2b50 (max (fromJust largest) x)) smallest\n      | x > 0 && isNothing smallest = \u2b50 largest_smallest_integers' xs largest (Just x)\n      | x > 0 = \u2b50 largest_smallest_integers' xs largest (Just \u2b50 (min (fromJust smallest) x))\n      | otherwise = \u2b50 largest_smallest_integers' xs largest smallest", "test": ""}
{"task_id": "Haskell/137", "prompt": "-- Create a function that takes integers, floats, or strings representing\n-- real numbers, and returns the larger variable in its given variable type.\n-- Return Nothing if the values are equal.\n-- Note: If a real number is represented as a string, the floating point might be . or ,\n-- >>> compare_one (IntNumber 1) (FloatNumber 2.5)\n-- Just (FloatNumber 2.5)\n-- >>> compare_one (IntNumber 1) (StringNumber \"2,3\")\n-- Just (StringNumber \"2,3\")\n-- >>> compare_one (StringNumber \"5,1\") (StringNumber \"6\")\n-- Just (StringNumber \"6\")\n-- >>> compare_one (StringNumber \"1\") (IntNumber 1)\n-- Nothing\ncompare_one :: Either3 Int Float String -> Either3 Int Float String -> Maybe (Either3 Int Float String)", "canonical_solution": "compare_one x y = \u2b50 if xf == yf then \u2b50 Nothing else Just \u2b50 (if xf > yf then x else y)\n  where\n    to_float :: Either3 Int Float String -> Float\n    to_float (IntNumber x) = \u2b50 fromIntegral x\n    to_float (FloatNumber x) = \u2b50 x\n    to_float (StringNumber x) = \u2b50 read (map (\\c -> if c == ',' then \u2b50 '.' else c) x) :: Float\n    xf :: Float\n    xf = \u2b50 to_float x\n    yf :: Float\n    yf = \u2b50 to_float y", "test": ""}
{"task_id": "Haskell/138", "prompt": "-- Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n-- Example\n-- >>> is_equal_to_sum_even 4\n-- False\n-- >>> is_equal_to_sum_even 6\n-- False\n-- >>> is_equal_to_sum_even 8\n-- True\nis_equal_to_sum_even :: Int -> Bool", "canonical_solution": "is_equal_to_sum_even n = \u2b50 n `mod` 2 == 0 && \u2b50 n >= 8", "test": ""}
{"task_id": "Haskell/139", "prompt": "-- The Brazilian factorial is defined as:\n-- brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n-- where n > 0\n-- For example:\n-- >>> special_factorial 4\n-- 288\n-- The function will receive an integer as input and should return the special\n-- factorial of this integer.\nspecial_factorial :: Int -> Int", "canonical_solution": "special_factorial n = \u2b50 product [product [1 .. i] | i <- \u2b50 [1 .. n]]", "test": ""}
{"task_id": "Haskell/140", "prompt": "-- Given a string text, replace all spaces in it with underscores,\n-- and if a string has more than 2 consecutive spaces,\n-- then replace all consecutive spaces with -\n-- >>> fix_spaces \"Example\"\n-- \"Example\"\n-- >>> fix_spaces \" Example 2\"\n-- \"_Example_2\"\n-- >>> fix_spaces \" Example 2\"\n-- \"_Example_2\"\n-- >>> fix_spaces \" Example   3\"\n-- \"_Example-3\"\nfix_spaces :: String -> String", "canonical_solution": "fix_spaces [] = \u2b50 []\nfix_spaces string = fix_spaces' string 0 \"\"\n  where\n    fix_spaces' :: String -> Int -> String -> String\n    fix_spaces' (x : xs) count res\n      | xs == [] && count == 0 && x == ' ' = \u2b50 res ++ \"_\"\n      | xs == [] && count > 0 && x == ' ' = \u2b50 res ++ \"-\"\n      | xs == [] && count == 0 && x /= ' ' = \u2b50 res ++ [x]\n      | xs == [] && count == 1 && x /= ' ' = \u2b50 res ++ \"_\" ++ [x]\n      | xs == [] && count > 1 && x /= ' ' = \u2b50 res ++ \"-\" ++ [x]\n      | x == ' ' = \u2b50 fix_spaces' xs (count + 1) res\n      | x /= ' ' && count > 1 = \u2b50 fix_spaces' xs 0 (res ++ \"-\" ++ [x])\n      | x /= ' ' && count == 1 = \u2b50 fix_spaces' xs 0 (res ++ \"_\" ++ [x])\n      | otherwise = \u2b50 fix_spaces' xs 0 (res ++ [x])", "test": ""}
{"task_id": "Haskell/141", "prompt": "-- Create a function which takes a string representing a file's name, and returns\n-- 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n-- A file's name is considered to be valid if and only if all the following conditions are met:\n-- - There should not be more than three digits ('0'-'9') in the file's name.\n-- - The file's name contains exactly one dot '.'\n-- - The substring before the dot should not be empty, and it starts with a letter from the latin alphapet ('a'-'z' and 'A'-'Z').\n-- - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n-- Examples:\n-- >>> file_name_check \"example.txt\"\n-- \"Yes\"\n-- >>> file_name_check \"1example.dll\"\n-- \"No\" (the name should start with a latin alphapet letter\nfile_name_check :: String -> String", "canonical_solution": "file_name_check filename\n  | (length filename) < 5 = \"No\"\n  | otherwise = \u2b50 if containsOneDot filename && containsNoMoreThanThreeDigits filename && endsOnTxtExeOrDll filename && doesNotStartWithDot filename && startWithLetterFromLatinAlphabet filename then \u2b50 \"Yes\" else \"No\"\n  where\n    containsOneDot :: String -> Bool\n    containsOneDot filename = \u2b50 length (filter (== '.') filename) == 1\n    containsNoMoreThanThreeDigits filename = \u2b50 length (filter (\\x -> x `elem` ['0' .. '9']) filename) <= 3\n    endsOnTxtExeOrDll filename = \u2b50 (drop (length filename - 4) filename) `elem` [\".txt\", \".exe\", \".dll\"]\n    doesNotStartWithDot filename = \u2b50 head filename /= '.'\n    startWithLetterFromLatinAlphabet filename = \u2b50 head filename `elem` ['a' .. 'z'] || \u2b50 head filename `elem` ['A' .. 'Z']", "test": ""}
{"task_id": "Haskell/142", "prompt": "-- This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a\n-- multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not\n-- change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\n-- Examples:\n-- >>> sum_squares [1,2,3]\n-- 6\n-- >>> sum_squares []\n-- 0\n-- >>> sum_squares [-1,-5,2,-1,-5]\n-- -126\nsum_squares :: [Int] -> Int", "canonical_solution": "sum_squares lst = \u2b50 sum_squares' lst 0 0\n  where\n    sum_squares' :: [Int] -> Int -> Int -> Int\n    sum_squares' [] sum _ = \u2b50 sum\n    sum_squares' (x : xs) sum index\n      | index `mod` 3 == 0 = \u2b50 sum_squares' xs (sum + x ^ 2) (index + 1)\n      | index `mod` 4 == 0 = \u2b50 sum_squares' xs (sum + x ^ 3) (index + 1)\n      | otherwise = \u2b50 sum_squares' xs (sum + x) (index + 1)", "test": ""}
{"task_id": "Haskell/143", "prompt": "-- You are given a string representing a sentence,\n-- the sentence contains some words separated by a space,\n-- and you have to return a string that contains the words from the original sentence,\n-- whose lengths are prime numbers,\n-- the order of the words in the new string should be the same as the original one.\n-- Example 1:\n-- >>> words_in_sentence \"This is a test\"\n-- \"is\"\n-- Example 2:\n-- >>> words_in_sentence \"lets go for swimming\"\n-- \"go for\"\n-- Constraints:\n-- * 1 <= len(sentence) <= 100\n-- * sentence contains only letters\nwords_in_sentence :: String -> String", "canonical_solution": "words_in_sentence sentence = \u2b50 unwords $ \u2b50 filter (\\x -> \u2b50 isPrime (length x)) (words sentence)\n  where\n    isPrime :: Int -> Bool\n    isPrime n = \u2b50 n > 1 && \u2b50 all (\\x -> n `mod` x /= 0) [2 .. n - 1]", "test": ""}
{"task_id": "Haskell/144", "prompt": "-- Your task is to implement a function that will simplify the expression\n-- x * n. The function returns True if x * n evaluates to a whole number and False\n-- otherwise. Both x and n, are string representation of a fraction, and have the following format,\n-- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n-- You can assume that x, and n are valid fractions, and do not have zero as denominator.\n-- >>> simplify \"1/5\" \"5/1\"\n-- True\n-- >>> simplify \"1/6\" \"2/1\"\n-- False\n-- >>> simplify \"7/10\" \"10/2\"\n-- False\nsimplify :: String -> String -> Bool", "canonical_solution": "simplify x n = \u2b50 numerator / denominator == \u2b50 fromIntegral (round (numerator / denominator))\n  where\n    a, b, c, d :: Double\n    a = \u2b50 read (take (fromJust (elemIndex '/' x)) x)\n    b = \u2b50 read (drop (fromJust (elemIndex '/' x) + 1) x)\n    c = \u2b50 read (take (fromJust (elemIndex '/' n)) n)\n    d = \u2b50 read (drop (fromJust (elemIndex '/' n) + 1) n)\n    numerator, denominator :: Double\n    numerator = \u2b50 a * c\n    denominator = \u2b50 b * d", "test": ""}
{"task_id": "Haskell/145", "prompt": "-- Write a function which sorts the given list of integers\n-- in ascending order according to the sum of their digits.\n-- Note: if there are several items with similar sum of their digits,\n-- order them based on their index in original list.\n-- For example:\n-- >>> order_by_points [1, 11, -1, -11, -12]\n-- [-1, -11, 1, -12, 11]\n-- >>> order_by_points []\n-- []\n-- Remember that if the number is negative, you need to not parse the first '-' and multiply the first number of the sum by -1\norder_by_points :: [Int] -> [Int]", "canonical_solution": "order_by_points nums = \u2b50 sortBy (\\x y -> \u2b50 compare (digits_sum x) (digits_sum y)) nums", "test": ""}
{"task_id": "Haskell/146", "prompt": "-- Write a function that takes an array of numbers as input and returns\n-- the number of elements in the array that are greater than 10 and both\n-- first and last digits of a number are odd (1, 3, 5, 7, 9).\n-- For example:\n-- >>> specialFilter [15, -73, 14, -15]\n-- 1\n-- >>> specialFilter [33, -2, -3, 45, 21, 109]\n-- 2\nspecialFilter :: [Int] -> Int", "canonical_solution": "specialFilter nums = \u2b50 length $ filter greaterThanTenAndOddBorders nums\n  where\n    greaterThanTenAndOddBorders :: Int -> Bool\n    greaterThanTenAndOddBorders n = \u2b50 n > 10 && odd (read [head (show n)] :: Int) && \u2b50 odd (read [show n !! (length (show n) - 1)] :: Int)", "test": ""}
{"task_id": "Haskell/147", "prompt": "-- You are given a positive integer n. You have to create an integer array a of length n.\n--     For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n--     Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,\n-- and a[i] + a[j] + a[k] is a multiple of 3.\n-- Example :\n-- >>> get_max_triples 5\n-- 1\n-- Explanation:\n-- a = [1, 3, 7, 13, 21]\n-- The only valid triple is (1, 7, 13).\nget_max_triples :: Int -> Int", "canonical_solution": "get_max_triples n = \u2b50 length $ filter (\\(x, y, z) -> (x + y + z) `mod` 3 == 0) [(a !! i, a !! j, a !! k) | i <- \u2b50 [0 .. n - 1], j <- \u2b50 [i + 1 .. n - 1], k <- \u2b50 [j + 1 .. n - 1]]\n  where\n    a :: [Int]\n    a = \u2b50 [i * i - i + 1 | \u2b50 i <- [1 .. n]]", "test": ""}
{"task_id": "Haskell/148", "prompt": "-- There are eight planets in our solar system: the closest to the Sun\n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n-- Uranus, Neptune.\n-- Write a function that takes two planet names as strings planet1 and planet2.\n-- The function should return a tuple containing all planets whose orbits are\n-- located between the orbit of planet1 and the orbit of planet2, sorted by\n-- the proximity to the sun.\n-- The function should return an empty tuple if planet1 or planet2\n-- are not correct planet names.\n-- Examples\n-- >>> bf \"Jupiter\" \"Neptune\"\n-- [\"Saturn\", \"Uranus\"]\n-- >>> bf \"Earth\" \"Mercury\"\n-- [\"Venus\"]\n-- >>> bf \"Mercury\" \"Uranus\"\n-- [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"]\nbf :: String -> String -> [String]", "canonical_solution": "bf planet1 planet2 =\n  if planet1 `elem` planet_names && planet2 `elem` planet_names && \u2b50 planet1 /= planet2\n    then\n      if planet1_index < planet2_index\n        then \u2b50 take (planet2_index - planet1_index - 1) (drop (planet1_index + 1) planet_names)\n        else \u2b50 take (planet1_index - planet2_index - 1) (drop (planet2_index + 1) planet_names)\n    else \u2b50 []\n  where\n    planet_names :: [String]\n    planet_names = \u2b50 [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    planet1_index :: Int\n    planet1_index = \u2b50 head [i | (i, x) <- \u2b50 zip [0 ..] planet_names, x == planet1]\n    planet2_index :: Int\n    planet2_index = \u2b50 head [i | (i, x) <- \u2b50 zip [0 ..] planet_names, x == planet2]", "test": ""}
{"task_id": "Haskell/149", "prompt": "-- Write a function that accepts a list of strings as a parameter,\n-- deletes the strings that have odd lengths from it,\n-- and returns the resulted list with a sorted order,\n-- The list is always a list of strings and never an array of numbers,\n-- and it may contain duplicates.\n-- The order of the list should be ascending by length of each word, and you\n-- should return the list sorted by that rule.\n-- If two words have the same length, sort the list alphabetically.\n-- The function should return a list of strings in sorted order.\n-- You may assume that all words will have the same length.\n-- For example:\n-- >>> sorted_list_sum [\"aa\", \"a\", \"aaa\"]\n-- [\"aa\"]\n-- >>> sorted_list_sum [\"ab\", \"a\", \"aaa\", \"cd\"]\n-- [\"ab\", \"cd\"]\nsorted_list_sum :: [String] -> [String]", "canonical_solution": "sorted_list_sum lst = \u2b50 sort $ filter \u2b50 (\\x -> length x `mod` 2 == 0) lst", "test": ""}
{"task_id": "Haskell/150", "prompt": "-- A simple program which should return the value of x if n is\n-- a prime number and should return the value of y otherwise.\n-- Examples:\n-- >>> x_or_y 7 34 12\n-- 34\n-- >>> x_or_y 15 8 5\n-- 5\nx_or_y :: Int -> Int -> Int -> Int", "canonical_solution": "x_or_y n x y = \u2b50 if n == 1 then y else if length [i | \u2b50 i <- [2 .. n - 1], n `mod` i == 0] > 0 then \u2b50 y else x", "test": ""}
{"task_id": "Haskell/151", "prompt": "-- Given a list of numbers, return the sum of squares of the numbers\n-- in the list that are odd. Ignore numbers that are negative or not integers.\n-- >>> double_the_difference [1, 3, 2, 0]\n-- 10 (1 + 9 + 0 + 0)\n-- >>> double_the_difference [-1, -2, 0]\n-- 0\n-- >>> double_the_difference [9, -2]\n-- 81\n-- >>> double_the_difference [0]\n-- 0\n-- If the input list is empty, return 0.\ndouble_the_difference :: [Int] -> Int", "canonical_solution": "double_the_difference lst = \u2b50 sum [i ^ 2 | \u2b50 i <- lst, i > 0, odd i]", "test": ""}
{"task_id": "Haskell/152", "prompt": "-- I think we all remember that feeling when the result of some long-awaited\n-- event is finally known. The feelings and thoughts you have at that moment are\n-- definitely worth noting down and comparing.\n-- Your task is to determine if a person correctly guessed the results of a number of matches.\n-- You are given two arrays of scores and guesses of equal length, where each index shows a match.\n-- Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n-- the value is 0, and if not, the value is the absolute difference between the guess and the score.\n-- example:\n-- >>> compare' [1,2,3,4,5,1] [1,2,3,4,2,-2]\n-- [0,0,0,0,3,3]\n-- >>> compare' [0,5,0,0,0,4] [4,1,1,0,0,-2]\n-- [4,4,1,0,0,6]\ncompare' :: [Int] -> [Int] -> [Int]", "canonical_solution": "compare' game guess = \u2b50 [abs (x - y) | \u2b50 (x, y) <- \u2b50 zip game guess]", "test": ""}
{"task_id": "Haskell/153", "prompt": "-- You will be given the name of a class (a string) and a list of extensions.\n-- The extensions are to be used to load additional classes to the class. The\n-- strength of the extension is as follows: Let CAP be the number of the uppercase\n-- letters in the extension's name, and let SM be the number of lowercase letters\n-- in the extension's name, the strength is given by the fraction CAP - SM.\n-- You should find the strongest extension and return a string in this\n-- format: ClassName.StrongestExtensionName.\n-- If there are two or more extensions with the same strength, you should\n-- choose the one that comes first in the list.\n-- For example, if you are given \"Slices\" as the class and a list of the\n-- extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n-- return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n-- (its strength is -1).\n-- Example:\n-- >>> strongest_extension \"my_class\" [\"AA\", \"Be\", \"CC\"]\n-- \"my_class.AA\"\nstrongest_extension :: String -> [String] -> String", "canonical_solution": "strongest_extension class_name extensions = \u2b50 class_name ++ \".\" ++ strongest\n  where\n    strongest :: String\n    strongest = \u2b50 head $ filter (\\x -> \u2b50 strength x == maximum (map strength extensions)) extensions\n    strength x = \u2b50 length [x | x <- x, isAlpha x, isUpper x] - \u2b50 length [x | x <- x, isAlpha x, isLower x]", "test": ""}
{"task_id": "Haskell/154", "prompt": "-- You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word\n-- >>> cycpattern_check \"abcd\" \"abd\"\n-- False\n-- >>> cycpattern_check \"hello\" \"ell\"\n-- True\n-- >>> cycpattern_check \"whassup\" \"psus\"\n-- False\n-- >>> cycpattern_check \"abab\" \"baa\"\n-- True\n-- >>> cycpattern_check \"efef\" \"eeff\"\n-- False\n-- >>> cycpattern_check \"himenss\" \"simen\"\n-- True\ncycpattern_check :: String -> String -> Bool", "canonical_solution": "cycpattern_check a b = \u2b50 any (`isInfixOf` a) (createRotations b)\n  where\n    createRotations :: String -> [String]\n    createRotations str = \u2b50 [drop i str ++ take i str | \u2b50 i <- [0 .. length str - 1]]", "test": ""}
{"task_id": "Haskell/155", "prompt": "-- Given an integer. return a tuple that has the number of even and odd digits respectively.\n-- Example:\n-- >>> even_odd_count (-12)\n-- (1, 1)\n-- >>> even_odd_count 123\n-- (1, 2)\neven_odd_count :: Int -> (Int, Int)", "canonical_solution": "even_odd_count num = \u2b50 (length [i | i <- \u2b50 show (abs num), even (read [i] :: Int)], length [i | i <- \u2b50 show (abs num), odd (read [i] :: Int)])", "test": ""}
{"task_id": "Haskell/156", "prompt": "-- Given a positive integer, obtain its roman numeral equivalent as a string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n-- Examples:\n-- >>> int_to_mini_roman 19\n-- \"xix\"\n-- >>> int_to_mini_roman 152\n-- \"clii\"\n-- >>> int_to_mini_roman 426\n-- \"cdxxvi\"\nint_to_mini_roman :: Int -> String", "canonical_solution": "int_to_mini_roman number = \u2b50 map toLower $ int_to_mini_roman' number num sym (length num - 1) \"\"\n  where\n    num :: [Int]\n    sym :: [String]\n    num = \u2b50 [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n    sym = \u2b50 [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"]\n    int_to_mini_roman' :: Int -> [Int] -> [String] -> Int -> String -> String\n    int_to_mini_roman' number num sym index res\n      | index < 0 = \u2b50 res\n      | number == 0 = \u2b50 res\n      | num !! index <= number = \u2b50 int_to_mini_roman' (number - num !! index) num sym index (res ++ sym !! index)\n      | otherwise = \u2b50 int_to_mini_roman' number num sym (index - 1) res", "test": ""}
{"task_id": "Haskell/157", "prompt": "-- Given the lengths of the three sides of a triangle. Return True if the three\n-- sides form a right-angled triangle, False otherwise.\n-- A right-angled triangle is a triangle in which one angle is right angle or\n-- 90 degree.\n-- Example:\n-- >>> right_angle_triangle 3 4 5\n-- True\n-- >>> right_angle_triangle 1 2 3\n-- False\nright_angle_triangle :: Int -> Int -> Int -> Bool", "canonical_solution": "right_angle_triangle a b c = \u2b50 a * a == b * b + c * c || \u2b50 b * b == a * a + c * c || \u2b50 c * c == a * a + b * b", "test": ""}
{"task_id": "Haskell/158", "prompt": "-- Write a function that accepts a list of strings.\n-- The list contains different words. Return the word with maximum number\n-- of unique characters. If multiple strings have maximum number of unique\n-- characters, return the one which comes first in lexicographical order.\n-- >>> find_max [\"name\", \"of\", \"string\"]\n-- \"string\"\n-- >>> find_max [\"name\", \"enam\", \"game\"]\n-- \"enam\"\n-- >>> find_max [\"aaaaaaa\", \"bb\" ,\"cc\"]\n-- \"aaaaaaa\"\nfind_max :: [String] -> String", "canonical_solution": "find_max words\n  | words == [] = \u2b50 \"\"\n  | otherwise = \u2b50 head $ filter (\\x -> \u2b50 (length . nub) x == maximum (map \u2b50 (length . nub) words)) $ \u2b50 sort words", "test": ""}
{"task_id": "Haskell/159", "prompt": "-- You're a hungry rabbit, and you already have eaten a certain number of carrots,\n-- but now you need to eat more carrots to complete the day's meals.\n-- you should return an array of [ total number of eaten carrots after your meals,\n--                                 the number of carrots left after your meals ]\n-- if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n-- Example:\n-- >>> eat 5 6 10\n-- [11, 4]\n-- >>> eat 4 8 9\n-- [12, 1]\n-- >>> eat 1 10 10\n-- [11, 0]\n-- >>> eat 2 11 5\n-- [7, 0]\n-- Variables:\n-- @number : integer\n--     the number of carrots that you have eaten.\n-- @need : integer\n--     the number of carrots that you need to eat.\n-- @remaining : integer\n--     the number of remaining carrots thet exist in stock\n-- Constraints:\n-- * 0 <= number <= 1000\n-- * 0 <= need <= 1000\n-- * 0 <= remaining <= 1000\n-- Have fun :)\neat :: Int -> Int -> Int -> [Int]", "canonical_solution": "eat number need remaining = \u2b50 if need <= remaining then \u2b50 [number + need, remaining - need] else \u2b50 [number + remaining, 0]", "test": ""}
{"task_id": "Haskell/160", "prompt": "-- Given two lists operator, and operand. The first list has basic algebra operations, and\n-- the second list is a list of integers. Use the two given lists to build the algebric\n-- expression and return the evaluation of this expression.\n-- The basic algebra operations:\n-- Addition ( + )\n-- Subtraction ( - )\n-- Multiplication ( * )\n-- Floor division ( // )\n-- Exponentiation ( ** )\n-- Example:\n-- >>> do_algebra [\"+\", \"*\", \"-\"] [2, 3, 4, 5]\n-- 9\n-- Note:\n--     The length of operator list is equal to the length of operand list minus one.\n--     Operand is a list of of non-negative integers.\n--     Operator list has at least one operator, and operand list has at least two operands.\ndo_algebra :: [String] -> [Int] -> Int", "canonical_solution": "do_algebra operators operands = head (snd (foldl (\\(operators, operands) operator -> applyOperator operator operators operands 0 (length operators)) (operators, operands) operator_order))\n  where\n    operator_order :: [String]\n    operator_order = \u2b50 [\"**\", \"//\", \"*\", \"+\", \"-\"]\n    applyOperator operator operators operands index length\n      | index >= length = \u2b50 (operators, operands)\n      | operator /= operators !! index = \u2b50 applyOperator operator operators operands (index + 1) length\n      | otherwise = \u2b50 applyOperator operator (newOperators) (newOperands) (index + 1) (length - 1)\n      where\n        newOperands :: [Int]\n        newOperands = \u2b50 take index operands ++ [newOperand] ++ (drop (index + 2) operands)\n        newOperand = \u2b50 case operator of\n          \"*\" -> \u2b50 operands !! index * operands !! (index + 1)\n          \"//\" -> \u2b50 operands !! index `div` operands !! (index + 1)\n          \"+\" -> \u2b50 operands !! index + operands !! (index + 1)\n          \"-\" -> \u2b50 operands !! index - operands !! (index + 1)\n          _ -> \u2b50 operands !! index ^ operands !! (index + 1)\n        newOperators = \u2b50 take index operators ++ (drop (index + 1) operators)", "test": ""}
{"task_id": "Haskell/161", "prompt": "-- You are given a string s.\n-- if s[i] is a letter, reverse its case from lower to upper or vise versa,\n-- otherwise keep it as it is.\n-- If the string contains no letters, reverse the string.\n-- The function should return the resulted string.\n-- Examples\n-- >>> solve \"1234\"\n-- \"4321\"\n-- >>> solve \"ab\"\n-- \"AB\"\n-- >>> solve \"#a@C\"\n-- \"#A@c\"\nsolve :: String -> String", "canonical_solution": "solve s = \u2b50 if flg == 0 then \u2b50 reverse s else reverseUpperLower s\n  where\n    flg :: Int\n    flg = \u2b50 length [i | i <- s, i `elem` ['a' .. 'z']] + \u2b50 length [i | i <- s, i `elem` ['A' .. 'Z']]\n    reverseUpperLower s = \u2b50 [if i `elem` ['a' .. 'z'] then \u2b50 toUpper i else toLower i | i <- s]", "test": ""}
{"task_id": "Haskell/162", "prompt": "-- Given a string 'text', return its md5 hash equivalent string.\n-- If 'text' is an empty string, return Nothing.\n-- >>> string_to_md5 \"Hello world\"\n-- Just \"3e25960a79dbc69b674cd4ec67a72c62\"\n-- Build depends on: base >= 4.7 && < 5, base16-bytestring, bytestring, cryptohash-md5\nstring_to_md5 :: String -> Maybe String", "canonical_solution": "string_to_md5 text = \u2b50 if text == \"\" then \u2b50 Nothing else Just $ unpack $ encode $ MD5.hash $ pack text", "test": ""}
{"task_id": "Haskell/163", "prompt": "-- Given two positive integers a and b, return the even digits between a\n-- and b, in ascending order.\n-- For example:\n-- >>> generate_integers 2 8\n-- [2, 4, 6, 8]\n-- >>> generate_integers 8 2\n-- [2, 4, 6, 8]\n-- >>> generate_integers 10 14\n-- []\ngenerate_integers :: Int -> Int -> [Int]", "canonical_solution": "generate_integers a b = \u2b50 [i | i <- \u2b50 [max 2 (min a b) .. min 8 (max a b)], even i]", "test": ""}
