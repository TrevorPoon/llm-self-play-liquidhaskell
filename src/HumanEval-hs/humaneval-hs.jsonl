{"task_id": "Haskell/0", "prompt": "-- Check if in given list of numbers, are any two numbers closer to each other than\n-- given threshold.\n-- >>> has_close_elements [1.0, 2.0, 3.0] 0.5\n-- False\n-- >>> has_close_elements [1.0, 2.8, 3.0, 4.0, 5.0, 2.0] 0.3\n-- True\nhas_close_elements :: [Float] -> Float -> Bool", "canonical_solution": "-- Task ID: HumanEval/0\n-- Assigned To: Author A\n\n-- Python Implementation:\n\n-- from typing import List\n-- \n-- \n-- def has_close_elements(numbers: List[float], threshold: float) -> bool:\n--     \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n--     given threshold.\n--     >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n--     False\n--     >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n--     True\n--     \"\"\"\n--     for idx, elem in enumerate(numbers):\n--         for idx2, elem2 in enumerate(numbers):\n--             if idx != idx2:\n--                 distance = abs(elem - elem2)\n--                 if distance < threshold:\n--                     return True\n-- \n--     return False\n-- \n\n\n-- Haskell Implementation:\n\n-- Check if in given list of numbers, are any two numbers closer to each other than\n-- given threshold.\n-- >>> has_close_elements [1.0, 2.0, 3.0] 0.5\n-- False\n-- >>> has_close_elements [1.0, 2.8, 3.0, 4.0, 5.0, 2.0] 0.3\n-- True\nhas_close_elements :: [Float] -> Float -> Bool\nhas_close_elements numbers threshold =\n  any (\\(x,y) -> abs (x - y) < threshold)\n      [ (x,y)\n      | (i, x) <- zip [0..] numbers\n      , (j, y) <- zip [0..] numbers\n      , i < j\n      ]\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (has_close_elements [1.0, 2.0, 3.9, 4.0, 5.0, 2.2] 0.3 == True)\n    check (has_close_elements [1.0, 2.0, 3.9, 4.0, 5.0, 2.2] 0.05 == False)\n    check (has_close_elements [1.0, 2.0, 5.9, 4.0, 5.0] 0.95 == True)\n    check (has_close_elements [1.0, 2.0, 5.9, 4.0, 5.0] 0.8 == False)\n    check (has_close_elements [1.0, 2.0, 3.0, 4.0, 5.0, 2.0] 0.1 == True)\n    check (has_close_elements [1.1, 2.2, 3.1, 4.1, 5.1] 1.0 == True)\n    check (has_close_elements [1.1, 2.2, 3.1, 4.1, 5.1] 0.5 == False)\n"}
{"task_id": "Haskell/1", "prompt": "-- Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n-- separate those group into separate strings and return the list of those.\n-- Separate groups are balanced (each open brace is properly closed) and not nested within each other\n-- Ignore any spaces in the input string.\n-- >>> separate_paren_groups \"( ) (( )) (( )( ))\"\n-- [\"()\",\"(())\",\"(()())\"]\nseparate_paren_groups :: String -> [String]", "canonical_solution": "-- Task ID: HumanEval/1\n-- Assigned To: Author A\n\n-- Python Implementation:\n\n-- from typing import List\n--\n--\n-- def separate_paren_groups(paren_string: str) -> List[str]:\n--     \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n--     separate those group into separate strings and return the list of those.\n--     Separate groups are balanced (each open brace is properly closed) and not nested within each other\n--     Ignore any spaces in the input string.\n--     >>> separate_paren_groups('( ) (( )) (( )( ))')\n--     ['()', '(())', '(()())']\n--     \"\"\"\n--     result = []\n--     current_string = []\n--     current_depth = 0\n--\n--     for c in paren_string:\n--         if c == '(':\n--             current_depth += 1\n--             current_string.append(c)\n--         elif c == ')':\n--             current_depth -= 1\n--             current_string.append(c)\n--\n--             if current_depth == 0:\n--                 result.append(''.join(current_string))\n--                 current_string.clear()\n--\n--     return result\n--\n\n-- Haskell Implementation:\n\n-- Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n-- separate those group into separate strings and return the list of those.\n-- Separate groups are balanced (each open brace is properly closed) and not nested within each other\n-- Ignore any spaces in the input string.\n-- >>> separate_paren_groups \"( ) (( )) (( )( ))\"\n-- [\"()\",\"(())\",\"(()())\"]\nseparate_paren_groups :: String -> [String]\nseparate_paren_groups paren_string =  get_paren_groups paren_string 0 []\n  where\n    get_paren_groups :: String -> Int -> [String] -> [String]\n    get_paren_groups \"\" _ groups =  groups\n    get_paren_groups ('(' : cs) 0 groups =  get_paren_groups cs 1 (groups ++ [\"(\"])\n    get_paren_groups (c : cs) depth groups\n      | c == '(' || c == ')' = get_paren_groups cs (depth + (get_d c))  ((reverse . tail . reverse $ groups) ++  [(head $ reverse groups) ++ [c]])\n      | otherwise =  get_paren_groups cs depth groups\n      where\n        get_d :: Char -> Int\n        get_d '(' =  1\n        get_d ')' =  -1\n        get_d _ =  0\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (separate_paren_groups \"(()()) ((())) () ((())()())\" == [\"(()())\",\"((()))\",\"()\",\"((())()())\"])\n    check (separate_paren_groups \"() (()) ((())) (((())))\"      == [\"()\",\"(())\",\"((()))\",\"(((())))\"])\n    check (separate_paren_groups \"(()(())((())))\"             == [\"(()(())((())))\"])\n    check (separate_paren_groups \"( ) (( )) (( )( ))\"           == [\"()\",\"(())\",\"(()())\"])\n"}
{"task_id": "Haskell/2", "prompt": "-- Given a positive floating point number, it can be decomposed into\n-- and integer part (largest integer smaller than given number) and decimals\n-- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n-- >>> truncate_number 3.5\n-- 0.5\ntruncate_number :: Float -> Float", "canonical_solution": "-- Task ID: HumanEval/2\n-- Assigned To: Author A\n\n-- Python Implementation:\n\n-- \n-- \n-- def truncate_number(number: float) -> float:\n--     \"\"\" Given a positive floating point number, it can be decomposed into\n--     and integer part (largest integer smaller than given number) and decimals\n--     (leftover part always smaller than 1).\n-- \n--     Return the decimal part of the number.\n--     >>> truncate_number(3.5)\n--     0.5\n--     \"\"\"\n--     return number % 1.0\n-- \n\n\n-- Haskell Implementation:\n\n-- Given a positive floating point number, it can be decomposed into\n-- and integer part (largest integer smaller than given number) and decimals\n-- (leftover part always smaller than 1).\n--\n-- Return the decimal part of the number.\n-- >>> truncate_number 3.5\n-- 0.5\ntruncate_number :: RealFrac a => a -> a\ntruncate_number x = x - fromIntegral (floor x)\n\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (truncate_number 3.5 == 0.5)\n    check (abs (truncate_number 1.33   - 0.33 ) < 1e-6)\n    check (abs (truncate_number 123.456 - 0.456) < 1e-6)\n"}
{"task_id": "Haskell/3", "prompt": "-- You're given a list of deposit and withdrawal operations on a bank account that starts with\n-- zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n-- at that point function should return True. Otherwise it should return False.\n-- >>> below_zero [1, 2, 3]\n-- False\n-- >>> below_zero [1, 2, -4, 5]\n-- True\nbelow_zero :: [Int] -> Bool", "canonical_solution": "-- Task ID: HumanEval/3\n-- Assigned To: Author A\n\n-- Python Implementation:\n\n-- from typing import List\n-- \n-- \n-- def below_zero(operations: List[int]) -> bool:\n--     \"\"\" You're given a list of deposit and withdrawal operations on a bank account that starts with\n--     zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n--     at that point function should return True. Otherwise it should return False.\n--     >>> below_zero([1, 2, 3])\n--     False\n--     >>> below_zero([1, 2, -4, 5])\n--     True\n--     \"\"\"\n--     balance = 0\n-- \n--     for op in operations:\n--         balance += op\n--         if balance < 0:\n--             return True\n-- \n--     return False\n-- \n\n\n-- Haskell Implementation:\n\n-- You're given a list of deposit and withdrawal operations on a bank account that starts with\n-- zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n-- at that point function should return True. Otherwise it should return False.\n-- >>> below_zero [1, 2, 3]\n-- False\n-- >>> below_zero [1, 2, -4, 5]\n-- True\nbelow_zero :: [Int] -> Bool\nbelow_zero operations =  any (< 0) $  scanl (+) 0 operations\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (below_zero []                         == False)\n    check (below_zero [1,2,-3,1,2,-3]            == False)\n    check (below_zero [1,2,-4,5,6]               == True)\n    check (below_zero [1,-1,2,-2,5,-5,4,-4]      == False)\n    check (below_zero [1,-1,2,-2,5,-5,4,-5]      == True)\n    check (below_zero [1,-2,2,-2,5,-5,4,-4]      == True)\n"}
{"task_id": "Haskell/4", "prompt": "-- For a given list of input numbers, calculate Mean Absolute Deviation\n-- around the mean of this dataset.\n-- Mean Absolute Deviation is the average absolute difference between each\n-- element and a centerpoint (mean in this case):\n-- MAD = average | x - x_mean |\n-- >>> mean_absolute_deviation [1.0, 2.0, 3.0, 4.0]\n-- 1.0\nmean_absolute_deviation :: [Float] -> Float", "canonical_solution": "-- Task ID: HumanEval/4\n-- Assigned To: Author A\n\n-- Python Implementation:\n\n-- from typing import List\n-- \n-- \n-- def mean_absolute_deviation(numbers: List[float]) -> float:\n--     \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n--     around the mean of this dataset.\n--     Mean Absolute Deviation is the average absolute difference between each\n--     element and a centerpoint (mean in this case):\n--     MAD = average | x - x_mean |\n--     >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n--     1.0\n--     \"\"\"\n--     mean = sum(numbers) / len(numbers)\n--     return sum(abs(x - mean) for x in numbers) / len(numbers)\n-- \n\n\n-- Haskell Implementation:\n\n-- For a given list of input numbers, calculate Mean Absolute Deviation\n-- around the mean of this dataset.\n-- Mean Absolute Deviation is the average absolute difference between each\n-- element and a centerpoint (mean in this case):\n-- MAD = average | x - x_mean |\n-- >>> mean_absolute_deviation [1.0, 2.0, 3.0, 4.0]\n-- 1.0\nmean_absolute_deviation :: [Float] -> Float\nmean_absolute_deviation numbers = sum  (map abs (map (\\x ->  x - mean) numbers)) /  fromIntegral (length numbers)\n    where\n        mean =  sum numbers /  fromIntegral (length numbers)\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (abs (mean_absolute_deviation [1.0,2.0,3.0]       - 2.0/3.0) < 1e-6)\n    check (abs (mean_absolute_deviation [1.0,2.0,3.0,4.0]   - 1.0     ) < 1e-6)\n    check (abs (mean_absolute_deviation [1.0,2.0,3.0,4.0,5.0] - 6.0/5.0) < 1e-6)\n"}
{"task_id": "Haskell/5", "prompt": "-- Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n-- >>> intersperse [] 4\n-- []\n-- >>> intersperse [1, 2, 3] 4\n-- [1,4,2,4,3,4]\nintersperse :: [Int] -> Int -> [Int]", "canonical_solution": "-- Task ID: HumanEval/5\n-- Assigned To: Author A\n\n-- Python Implementation:\n\n-- from typing import List\n-- \n-- \n-- def intersperse(numbers: List[int], delimeter: int) -> List[int]:\n--     \"\"\" Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n--     >>> intersperse([], 4)\n--     []\n--     >>> intersperse([1, 2, 3], 4)\n--     [1, 4, 2, 4, 3]\n--     \"\"\"\n--     if not numbers:\n--         return []\n-- \n--     result = []\n-- \n--     for n in numbers[:-1]:\n--         result.append(n)\n--         result.append(delimeter)\n-- \n--     result.append(numbers[-1])\n-- \n--     return result\n-- \n\n\n-- Haskell Implementation:\n\n-- Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n-- >>> intersperse [] 4\n-- []\n-- >>> intersperse [1, 2, 3] 4\n-- [1,4,2,4,3,4]\nintersperse :: [Int] -> Int -> [Int]\nintersperse [] _        = []\nintersperse [x] _       = [x]\nintersperse (x:xs) delim = x : delim : intersperse xs delim\n\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (intersperse []       7 == [])\n    check (intersperse [5,6,3,2] 8 == [5,8,6,8,3,8,2])\n    check (intersperse [2,2,2]   2 == [2,2,2,2,2])\n"}
{"task_id": "Haskell/6", "prompt": "-- Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n-- For each of the group, output the deepest level of nesting of parentheses.\n-- E.g. (()()) has maximum two levels of nesting while ((())) has three.\n-- >>> parse_nested_parens \"(()()) ((())) () ((())()())\"\n-- [2,3,1,3]\nparse_nested_parens :: String -> [Int]", "canonical_solution": "-- Task ID: HumanEval/6\n-- Assigned To: Author A\n\n-- Python Implementation:\n\n-- from typing import List\n-- \n-- \n-- def parse_nested_parens(paren_string: str) -> List[int]:\n--     \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n--     For each of the group, output the deepest level of nesting of parentheses.\n--     E.g. (()()) has maximum two levels of nesting while ((())) has three.\n-- \n--     >>> parse_nested_parens('(()()) ((())) () ((())()())')\n--     [2, 3, 1, 3]\n--     \"\"\"\n--     def parse_paren_group(s):\n--         depth = 0\n--         max_depth = 0\n--         for c in s:\n--             if c == '(':\n--                 depth += 1\n--                 max_depth = max(depth, max_depth)\n--             else:\n--                 depth -= 1\n-- \n--         return max_depth\n-- \n--     return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n-- \n\n\n-- Haskell Implementation:\n\n-- Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n-- For each of the group, output the deepest level of nesting of parentheses.\n-- E.g. (()()) has maximum two levels of nesting while ((())) has three.\n--\n-- >>> parse_nested_parens \"(()()) ((())) () ((())()())\"\n-- [2,3,1,3]\nparse_nested_parens :: String -> [Int]\nparse_nested_parens paren_string = get_paren_depths paren_string  0 []\n    where\n        get_paren_depths :: String -> Int -> [Int] -> [Int]\n        get_paren_depths \"\" _ max_depths =  max_depths\n        get_paren_depths ('(':cs) 0 max_depths =  get_paren_depths cs 1  (max_depths ++ [1])\n        get_paren_depths ('(':cs) depth max_depths =  get_paren_depths cs (depth + 1) ((reverse . tail . reverse $ max_depths) ++  [max (head $ reverse max_depths) (depth + 1)])\n        get_paren_depths (')':cs) depth max_depths =  get_paren_depths cs (depth - 1) max_depths\n        get_paren_depths (_:cs) depth max_depths =  get_paren_depths cs depth max_depths\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (parse_nested_parens \"(()()) ((())) () ((())()())\" == [2,3,1,3])\n    check (parse_nested_parens \"() (()) ((())) (((())))\"      == [1,2,3,4])\n    check (parse_nested_parens \"(()(())((())))\"             == [4])\n"}
{"task_id": "Haskell/7", "prompt": "-- Filter an input list of strings only for ones that contain given substring\n-- >>> filter_by_substring [] \"a\"\n-- []\n-- >>> filter_by_substring [\"abc\", \"bacd\", \"cde\", \"array\"] \"a\"\n-- [\"abc\",\"bacd\",\"array\"]\nfilter_by_substring :: [String] -> String -> [String]", "canonical_solution": "-- Task ID: HumanEval/7\n-- Assigned To: Author A\n\n-- Python Implementation:\n\n-- from typing import List\n-- \n-- \n-- def filter_by_substring(strings: List[str], substring: str) -> List[str]:\n--     \"\"\" Filter an input list of strings only for ones that contain given substring\n--     >>> filter_by_substring([], 'a')\n--     []\n--     >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n--     ['abc', 'bacd', 'array']\n--     \"\"\"\n--     return [x for x in strings if substring in x]\n-- \n\n\n-- Haskell Implementation:\nimport Data.List\n\n-- Filter an input list of strings only for ones that contain given substring\n-- >>> filter_by_substring [] \"a\"\n-- []\n-- >>> filter_by_substring [\"abc\", \"bacd\", \"cde\", \"array\"] \"a\"\n-- [\"abc\",\"bacd\",\"array\"]\nfilter_by_substring :: [String] -> String -> [String]\nfilter_by_substring strings substring =  [x | x <- strings,  substring `isInfixOf` x]\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (filter_by_substring []                          \"john\" == [])\n    check (filter_by_substring [\"xxx\",\"asd\",\"xxy\",\"john doe\",\"xxxAAA\",\"xxx\"] \"xxx\" == [\"xxx\",\"xxxAAA\",\"xxx\"])\n    check (filter_by_substring [\"xxx\",\"asd\",\"aaaxxy\",\"john doe\",\"xxxAAA\",\"xxx\"] \"xx\"  == [\"xxx\",\"aaaxxy\",\"xxxAAA\",\"xxx\"])\n    check (filter_by_substring [\"grunt\",\"trumpet\",\"prune\",\"gruesome\"]    \"run\" == [\"grunt\",\"prune\"])\n"}
{"task_id": "Haskell/8", "prompt": "-- For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n-- Empty sum should be equal to 0 and empty product should be equal to 1.\n-- >>> sum_product []\n-- (0,1)\n-- >>> sum_product [1, 2, 3, 4]\n-- (10,24)\nsum_product :: [Int] -> (Int, Int)", "canonical_solution": "-- Task ID: HumanEval/8\n-- Assigned To: Author A\n\n-- Python Implementation:\n\n-- from typing import List, Tuple\n-- \n-- \n-- def sum_product(numbers: List[int]) -> Tuple[int, int]:\n--     \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n--     Empty sum should be equal to 0 and empty product should be equal to 1.\n--     >>> sum_product([])\n--     (0, 1)\n--     >>> sum_product([1, 2, 3, 4])\n--     (10, 24)\n--     \"\"\"\n--     sum_value = 0\n--     prod_value = 1\n-- \n--     for n in numbers:\n--         sum_value += n\n--         prod_value *= n\n--     return sum_value, prod_value\n-- \n\n\n-- Haskell Implementation:\n\n-- For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n-- Empty sum should be equal to 0 and empty product should be equal to 1.\n-- >>> sum_product []\n-- (0,1)\n-- >>> sum_product [1, 2, 3, 4]\n-- (10,24)\nsum_product :: [Int] -> (Int, Int)\nsum_product numbers =  (sum numbers, product numbers)\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (sum_product []       == (0,1))\n    check (sum_product [1,1,1]  == (3,1))\n    check (sum_product [100,0]  == (100,0))\n    check (sum_product [3,5,7]  == (15,105))\n    check (sum_product [10]     == (10,10))\n"}
{"task_id": "Haskell/9", "prompt": "-- From a given list of integers, generate a list of rolling maximum element found until given moment\n-- in the sequence.\n-- >>> rolling_max [1, 2, 3, 2, 3, 4, 2]\n-- [1,2,3,3,3,4,4]\nrolling_max :: [Int] -> [Int]", "canonical_solution": "-- Task ID: HumanEval/9\n-- Assigned To: Author A\n\n-- Python Implementation:\n\n-- from typing import List, Tuple\n-- \n-- \n-- def rolling_max(numbers: List[int]) -> List[int]:\n--     \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n--     in the sequence.\n--     >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n--     [1, 2, 3, 3, 3, 4, 4]\n--     \"\"\"\n--     running_max = None\n--     result = []\n-- \n--     for n in numbers:\n--         if running_max is None:\n--             running_max = n\n--         else:\n--             running_max = max(running_max, n)\n-- \n--         result.append(running_max)\n-- \n--     return result\n-- \n\n\n-- Haskell Implementation:\n\n-- From a given list of integers, generate a list of rolling maximum element found until given moment\n-- in the sequence.\n-- >>> rolling_max [1, 2, 3, 2, 3, 4, 2]\n-- [1,2,3,3,3,4,4]\nrolling_max :: [Int] -> [Int]\nrolling_max numbers =  scanl1  max numbers\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (rolling_max [] == [])\n    check (rolling_max [1,2,3,4] == [1,2,3,4])\n    check (rolling_max [4,3,2,1] == [4,4,4,4])\n    check (rolling_max [3,2,3,100,3] == [3,3,3,100,100])\n"}
{"task_id": "Haskell/10", "prompt": "import Data.List\nis_palindrome :: String -> Bool\nis_palindrome string = string == reverse string\n-- Find the shortest palindrome that begins with a supplied string.\n-- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string that is a palindrome.\n-- - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n-- >>> make_palindrome \"\"\n-- \"\"\n-- >>> make_palindrome \"cat\"\n-- \"catac\"\n-- >>> make_palindrome \"cata\"\n-- \"catac\"\nmake_palindrome :: String -> String", "canonical_solution": "-- Task ID: HumanEval/10\n-- Assigned To: Author A\n\n-- Python Implementation:\n\n-- \n-- \n-- def is_palindrome(string: str) -> bool:\n--     \"\"\" Test if given string is a palindrome \"\"\"\n--     return string == string[::-1]\n-- \n-- \n-- def make_palindrome(string: str) -> str:\n--     \"\"\" Find the shortest palindrome that begins with a supplied string.\n--     Algorithm idea is simple:\n--     - Find the longest postfix of supplied string that is a palindrome.\n--     - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n--     >>> make_palindrome('')\n--     ''\n--     >>> make_palindrome('cat')\n--     'catac'\n--     >>> make_palindrome('cata')\n--     'catac'\n--     \"\"\"\n--     if not string:\n--         return ''\n-- \n--     beginning_of_suffix = 0\n-- \n--     while not is_palindrome(string[beginning_of_suffix:]):\n--         beginning_of_suffix += 1\n-- \n--     return string + string[:beginning_of_suffix][::-1]\n-- \n\n\n-- Haskell Implementation:\nimport Data.List\n\nis_palindrome :: String -> Bool\nis_palindrome string =  string ==  reverse string\n\n-- Find the shortest palindrome that begins with a supplied string.\n-- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string that is a palindrome.\n-- - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n-- >>> make_palindrome \"\"\n-- \"\"\n-- >>> make_palindrome \"cat\"\n-- \"catac\"\n-- >>> make_palindrome \"cata\"\n-- \"catac\"\nmake_palindrome :: String -> String\nmake_palindrome string\n    | null string =  \"\"\n    | otherwise =  string ++ reverse  (take beginning_of_suffix string)\n    where\n        beginning_of_suffix =  length $ takeWhile  (not . is_palindrome) $  tails string\n", "test": "-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (make_palindrome \"\" == \"\")\n    check (make_palindrome \"x\" == \"x\")\n    check (make_palindrome \"xyz\" == \"xyzyx\")\n    check (make_palindrome \"xyx\" == \"xyx\")\n    check (make_palindrome \"jerry\" == \"jerryrrej\")"}
{"task_id": "Haskell/11", "prompt": "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform binary XOR on these inputs and return result also as a string.\n-- >>> string_xor \"010\" \"110\"\n-- \"100\"\nstring_xor :: String -> String -> String", "canonical_solution": "-- Task ID: HumanEval/11\n-- Assigned To: Author A\n\n-- Python Implementation:\n\n-- from typing import List\n-- \n-- \n-- def string_xor(a: str, b: str) -> str:\n--     \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n--     Perform binary XOR on these inputs and return result also as a string.\n--     >>> string_xor('010', '110')\n--     '100'\n--     \"\"\"\n--     def xor(i, j):\n--         if i == j:\n--             return '0'\n--         else:\n--             return '1'\n-- \n--     return ''.join(xor(x, y) for x, y in zip(a, b))\n-- \n\n\n-- Haskell Implementation:\n\n-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform binary XOR on these inputs and return result also as a string.\n-- >>> string_xor \"010\" \"110\"\n-- \"100\"\nstring_xor :: String -> String -> String\nstring_xor a b =  [if x == y  then '0' else '1' |  (x, y) <-  zip a b]\n", "test": "-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (string_xor \"111000\" \"101010\" == \"010010\")\n    check (string_xor \"1\" \"1\" == \"0\")\n    check (string_xor \"0101\" \"0000\" == \"0101\")"}
{"task_id": "Haskell/12", "prompt": "-- Out of list of strings, return the longest one. Return the first one in case of multiple\n-- strings of the same length. Return Nothing in case the input list is empty.\n-- >>> longest []\n-- Nothing\n-- >>> longest [\"a\", \"b\", \"c\"]\n-- Just \"a\"\n-- >>> longest [\"a\", \"bb\", \"ccc\"]\n-- Just \"ccc\"\nlongest :: [String] -> Maybe String", "canonical_solution": "-- Task ID: HumanEval/12\n-- Assigned To: Author A\n\n-- Python Implementation:\n\n-- from typing import List, Optional\n-- \n-- \n-- def longest(strings: List[str]) -> Optional[str]:\n--     \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n--     strings of the same length. Return None in case the input list is empty.\n--     >>> longest([])\n-- \n--     >>> longest(['a', 'b', 'c'])\n--     'a'\n--     >>> longest(['a', 'bb', 'ccc'])\n--     'ccc'\n--     \"\"\"\n--     if not strings:\n--         return None\n-- \n--     maxlen = max(len(x) for x in strings)\n--     for s in strings:\n--         if len(s) == maxlen:\n--             return s\n-- \n\n\n-- Haskell Implementation:\nimport Data.List\nimport Data.Ord\n\n-- Out of list of strings, return the longest one. Return the first one in case of multiple\n-- strings of the same length. Return Nothing in case the input list is empty.\n-- >>> longest []\n-- Nothing\n-- >>> longest [\"a\", \"b\", \"c\"]\n-- Just \"a\"\n-- >>> longest [\"a\", \"bb\", \"ccc\"]\n-- Just \"ccc\"\nlongest :: [String] -> Maybe String\nlongest strings = case  strings of\n    [] ->  Nothing\n    _ ->  Just $ maximumBy  (comparing length) $  reverse strings\n", "test": "-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (longest [] == Nothing)\n    check (longest [\"x\",\"y\",\"z\"] == Just \"x\")\n    check (longest [\"x\",\"yyy\",\"zzzz\",\"www\",\"kkkk\",\"abc\"] == Just \"zzzz\")"}
{"task_id": "Haskell/13", "prompt": "-- Return a greatest common divisor of two integers a and b\n-- >>> greatest_common_divisor 3 5\n-- 1\n-- >>> greatest_common_divisor 25 15\n-- 5\ngreatest_common_divisor :: Int -> Int -> Int", "canonical_solution": "-- Task ID: HumanEval/13\n-- Assigned To: Author A\n\n-- Python Implementation:\n\n-- \n-- \n-- def greatest_common_divisor(a: int, b: int) -> int:\n--     \"\"\" Return a greatest common divisor of two integers a and b\n--     >>> greatest_common_divisor(3, 5)\n--     1\n--     >>> greatest_common_divisor(25, 15)\n--     5\n--     \"\"\"\n--     while b:\n--         a, b = b, a % b\n--     return a\n-- \n\n\n-- Haskell Implementation:\n\n-- Return a greatest common divisor of two integers a and b\n-- >>> greatest_common_divisor 3 5\n-- 1\n-- >>> greatest_common_divisor 25 15\n-- 5\ngreatest_common_divisor :: Int -> Int -> Int\ngreatest_common_divisor a b =  gcd  a b\n", "test": "-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (greatest_common_divisor 3 7 == 1)\n    check (greatest_common_divisor 10 15 == 5)\n    check (greatest_common_divisor 49 14 == 7)\n    check (greatest_common_divisor 144 60 == 12)"}
{"task_id": "Haskell/14", "prompt": "-- Return list of all prefixes from shortest to longest of the input string\n-- >>> all_prefixes \"abc\"\n-- [\"a\",\"ab\",\"abc\"]\nall_prefixes :: String  -> [String]", "canonical_solution": "-- Task ID: HumanEval/14\n-- Assigned To: Author A\n\n-- Python Implementation:\n\n-- from typing import List\n-- \n-- \n-- def all_prefixes(string: str) -> List[str]:\n--     \"\"\" Return list of all prefixes from shortest to longest of the input string\n--     >>> all_prefixes('abc')\n--     ['a', 'ab', 'abc']\n--     \"\"\"\n--     result = []\n-- \n--     for i in range(len(string)):\n--         result.append(string[:i+1])\n--     return result\n-- \n\n\n-- Haskell Implementation:\n\n-- Return list of all prefixes from shortest to longest of the input string\n-- >>> all_prefixes \"abc\"\n-- [\"a\",\"ab\",\"abc\"]\nall_prefixes :: String  -> [String]\nall_prefixes string =  [take (i+1) string |  i <-  [0..length string - 1]]\n", "test": "-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (all_prefixes \"\" == [])\n    check (all_prefixes \"asdfgh\" == [\"a\",\"as\",\"asd\",\"asdf\",\"asdfg\",\"asdfgh\"])\n    check (all_prefixes \"WWW\" == [\"W\",\"WW\",\"WWW\"])"}
{"task_id": "Haskell/15", "prompt": "-- Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n-- >>> string_sequence 0\n-- \"0\"\n-- >>> string_sequence 5\n-- \"0 1 2 3 4 5\"\nstring_sequence :: Int -> String", "canonical_solution": "-- Task ID: HumanEval/15\n-- Assigned To: Author A\n\n-- Python Implementation:\n\n-- \n-- \n-- def string_sequence(n: int) -> str:\n--     \"\"\" Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n--     >>> string_sequence(0)\n--     '0'\n--     >>> string_sequence(5)\n--     '0 1 2 3 4 5'\n--     \"\"\"\n--     return ' '.join([str(x) for x in range(n + 1)])\n-- \n\n\n-- Haskell Implementation:\n\n-- Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n-- >>> string_sequence 0\n-- \"0\"\n-- >>> string_sequence 5\n-- \"0 1 2 3 4 5\"\nstring_sequence :: Int -> String\nstring_sequence n =  unwords  [show x | x <-  [0..n]]\n", "test": "-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (string_sequence 0 == \"0\")\n    check (string_sequence 3 == \"0 1 2 3\")\n    check (string_sequence 10 == \"0 1 2 3 4 5 6 7 8 9 10\")"}
{"task_id": "Haskell/16", "prompt": "-- Given a string, find out how many distinct characters (regardless of case) does it consist of\n-- >>> count_distinct_characters \"xyzXYZ\"\n-- 3\n-- >>> count_distinct_characters \"Jerry\"\n-- 4\ncount_distinct_characters :: String -> Int", "canonical_solution": "-- Task ID: HumanEval/16\n-- Assigned To: Author A\n\n-- Python Implementation:\n\n-- \n-- \n-- def count_distinct_characters(string: str) -> int:\n--     \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n--     >>> count_distinct_characters('xyzXYZ')\n--     3\n--     >>> count_distinct_characters('Jerry')\n--     4\n--     \"\"\"\n--     return len(set(string.lower()))\n-- \n\n\n-- Haskell Implementation:\nimport Data.Char\nimport Data.List\n\n-- Given a string, find out how many distinct characters (regardless of case) does it consist of\n-- >>> count_distinct_characters \"xyzXYZ\"\n-- 3\n-- >>> count_distinct_characters \"Jerry\"\n-- 4\ncount_distinct_characters :: String -> Int\ncount_distinct_characters string =  length $  nub $  map toLower string\n", "test": "-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (count_distinct_characters \"\" == 0)\n    check (count_distinct_characters \"abcde\" == 5)\n    check (count_distinct_characters \"abcdecadeCADE\" == 5)\n    check (count_distinct_characters \"aaaaAAAAaaaa\" == 1)\n    check (count_distinct_characters \"Jerry jERRY JeRRRY\" == 5)"}
{"task_id": "Haskell/17", "prompt": "-- Input to this function is a string representing musical notes in a special ASCII format.\n-- Your task is to parse this string and return list of integers corresponding to how many beats does each\n-- not last.\n-- Here is a legend:\n-- 'o' - whole note, lasts four beats\n-- 'o|' - half note, lasts two beats\n-- '.|' - quater note, lasts one beat\n-- >>> parse_music \"o o| .| o| o| .| .| .| .| o o\"\n-- [4,2,1,2,2,1,1,1,1,4,4]\nparse_music :: String -> [Int]", "canonical_solution": "-- Task ID: HumanEval/17\n-- Assigned To: Author A\n\n-- Python Implementation:\n\n-- from typing import List\n-- \n-- \n-- def parse_music(music_string: str) -> List[int]:\n--     \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n--     Your task is to parse this string and return list of integers corresponding to how many beats does each\n--     not last.\n-- \n--     Here is a legend:\n--     'o' - whole note, lasts four beats\n--     'o|' - half note, lasts two beats\n--     '.|' - quater note, lasts one beat\n-- \n--     >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n--     [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n--     \"\"\"\n--     note_map = {'o': 4, 'o|': 2, '.|': 1}\n--     return [note_map[x] for x in music_string.split(' ') if x]\n-- \n\n\n-- Haskell Implementation:\n\n-- Input to this function is a string representing musical notes in a special ASCII format.\n-- Your task is to parse this string and return list of integers corresponding to how many beats does each\n-- not last.\n--\n-- Here is a legend:\n-- 'o' - whole note, lasts four beats\n-- 'o|' - half note, lasts two beats\n-- '.|' - quater note, lasts one beat\n--\n-- >>> parse_music \"o o| .| o| o| .| .| .| .| o o\"\n-- [4,2,1,2,2,1,1,1,1,4,4]\nparse_music :: String -> [Int]\nparse_music music_string =  [note_map x | x <-  words music_string]\n    where \n        note_map \"o\" =  4\n        note_map \"o|\" =  2\n        note_map \".|\" =  1\n", "test": "-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (parse_music \"\" == [])\n    check (parse_music \"o o o o\" == [4,4,4,4])\n    check (parse_music \".| .| .| .|\" == [1,1,1,1])\n    check (parse_music \"o| o| .| .| o o o o\" == [2,2,1,1,4,4,4,4])\n    check (parse_music \"o| .| o| .| o o| o o|\" == [2,1,2,1,4,2,4,2])"}
{"task_id": "Haskell/18", "prompt": "-- Find how many times a given substring can be found in the original string. Count overlaping cases.\n-- >>> how_many_times \"\" \"a\"\n-- 0\n-- >>> how_many_times \"aaa\" \"a\"\n-- 3\n-- >>> how_many_times \"aaaa\" \"aa\"\n-- 3\nhow_many_times :: String -> String -> Int", "canonical_solution": "-- Task ID: HumanEval/18\n-- Assigned To: Author A\n\n-- Python Implementation:\n\n-- \n-- \n-- def how_many_times(string: str, substring: str) -> int:\n--     \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n--     >>> how_many_times('', 'a')\n--     0\n--     >>> how_many_times('aaa', 'a')\n--     3\n--     >>> how_many_times('aaaa', 'aa')\n--     3\n--     \"\"\"\n--     times = 0\n-- \n--     for i in range(len(string) - len(substring) + 1):\n--         if string[i:i+len(substring)] == substring:\n--             times += 1\n-- \n--     return times\n-- \n\n\n-- Haskell Implementation:\nimport Data.List\n\n-- Find how many times a given substring can be found in the original string. Count overlaping cases.\n-- >>> how_many_times \"\" \"a\"\n-- 0\n-- >>> how_many_times \"aaa\" \"a\"\n-- 3\n-- >>> how_many_times \"aaaa\" \"aa\"\n-- 3\nhow_many_times :: String -> String -> Int\nhow_many_times string substring =  length $ filter  (substring `isPrefixOf`) $ map  (take  (length substring)) $  tails string\n\n", "test": "-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (how_many_times \"\" \"x\" == 0)\n    check (how_many_times \"xyxyxyx\" \"x\" == 4)\n    check (how_many_times \"cacacacac\" \"cac\" == 4)\n    check (how_many_times \"john doe\" \"john\" == 1)"}
{"task_id": "Haskell/19", "prompt": "-- Input is a space-delimited string of numberals from 'zero' to 'nine'.\n-- Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n-- Return the string with numbers sorted from smallest to largest\n-- >>> sort_numbers \"three one five\"\n-- \"one three five\"\nsort_numbers :: String -> String", "canonical_solution": "-- Task ID: HumanEval/19\n-- Assigned To: Author A\n\n-- Python Implementation:\n\n-- from typing import List\n-- \n-- \n-- def sort_numbers(numbers: str) -> str:\n--     \"\"\" Input is a space-delimited string of numberals from 'zero' to 'nine'.\n--     Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n--     Return the string with numbers sorted from smallest to largest\n--     >>> sort_numbers('three one five')\n--     'one three five'\n--     \"\"\"\n--     value_map = {\n--         'zero': 0,\n--         'one': 1,\n--         'two': 2,\n--         'three': 3,\n--         'four': 4,\n--         'five': 5,\n--         'six': 6,\n--         'seven': 7,\n--         'eight': 8,\n--         'nine': 9\n--     }\n--     return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n-- \n\n\n-- Haskell Implementation:\nimport Data.Map\nimport Data.List\n\n-- Input is a space-delimited string of numberals from 'zero' to 'nine'.\n-- Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n-- Return the string with numbers sorted from smallest to largest\n-- >>> sort_numbers \"three one five\"\n-- \"one three five\"\nsort_numbers :: String -> String\nsort_numbers numbers =  unwords $ sortOn  (value_map !) $  words numbers\n    where value_map = fromList  [(\"zero\", 0), (\"one\", 1), (\"two\", 2), (\"three\", 3), (\"four\", 4), (\"five\", 5),  (\"six\", 6), (\"seven\", 7), (\"eight\", 8), (\"nine\", 9)]\n", "test": "-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (sort_numbers \"\" == \"\")\n    check (sort_numbers \"three\" == \"three\")\n    check (sort_numbers \"three five nine\" == \"three five nine\")\n    check (sort_numbers \"five zero four seven nine eight\" == \"zero four five seven eight nine\")\n    check (sort_numbers \"six five four three two one zero\" == \"zero one two three four five six\")"}
{"task_id": "Haskell/20", "prompt": "-- From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n-- other and return them in order (smaller number, larger number).\n-- >>> find_closest_elements [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]\n-- (2.0,2.2)\n-- >>> find_closest_elements [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]\n-- (2.0,2.0)\nfind_closest_elements :: [Float] -> (Float, Float)", "canonical_solution": "-- Task ID: HumanEval/20\n-- Assigned To: Author A\n\n-- Python Implementation:\n\n-- from typing import List, Tuple\n-- \n-- \n-- def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n--     \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n--     other and return them in order (smaller number, larger number).\n--     >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n--     (2.0, 2.2)\n--     >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n--     (2.0, 2.0)\n--     \"\"\"\n--     closest_pair = None\n--     distance = None\n-- \n--     for idx, elem in enumerate(numbers):\n--         for idx2, elem2 in enumerate(numbers):\n--             if idx != idx2:\n--                 if distance is None:\n--                     distance = abs(elem - elem2)\n--                     closest_pair = tuple(sorted([elem, elem2]))\n--                 else:\n--                     new_distance = abs(elem - elem2)\n--                     if new_distance < distance:\n--                         distance = new_distance\n--                         closest_pair = tuple(sorted([elem, elem2]))\n-- \n--     return closest_pair\n-- \n\n\n-- Haskell Implementation:\nimport Data.List\nimport Data.Ord   (comparing)\nimport Data.List  (minimumBy)\n\n-- From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n-- other and return them in order (smaller number, larger number).\n-- >>> find_closest_elements [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]\n-- (2.0,2.2)\n-- >>> find_closest_elements [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]\n-- (2.0,2.0)\nfind_closest_elements :: (Ord a, Num a) => [a] -> (a, a)\nfind_closest_elements xs\n  | length xs < 2 = error \"need at least two elements\"\n  | otherwise     = minimumBy (comparing (\\(a,b) -> b - a)) pairs\n  where\n    sorted = sort xs\n    pairs  = zip sorted (tail sorted)\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (find_closest_elements [1.0, 2.0, 3.9, 4.0, 5.0, 2.2] == (3.9, 4.0))\n    check (find_closest_elements [1.0, 2.0, 5.9, 4.0, 5.0] == (5.0, 5.9))\n    check (find_closest_elements [1.0, 2.0, 3.0, 4.0, 5.0, 2.2] == (2.0, 2.2))\n    check (find_closest_elements [1.0, 2.0, 3.0, 4.0, 5.0, 2.0] == (2.0, 2.0))\n    check (find_closest_elements [1.1, 2.2, 3.1, 4.1, 5.1] == (2.2, 3.1))\n"}
{"task_id": "Haskell/21", "prompt": "-- Given list of numbers (of at least two elements), apply a linear transform to that list,\n-- such that the smallest number will become 0 and the largest will become 1\n-- >>> rescale_to_unit [1.0, 2.0, 3.0, 4.0, 5.0]\n-- [0.0,0.25,0.5,0.75,1.0]\nrescale_to_unit :: [Float] -> [Float]", "canonical_solution": "-- Task ID: HumanEval/21\n-- Assigned To: Author A\n\n-- Python Implementation:\n\n-- from typing import List\n-- \n-- \n-- def rescale_to_unit(numbers: List[float]) -> List[float]:\n--     \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n--     such that the smallest number will become 0 and the largest will become 1\n--     >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n--     [0.0, 0.25, 0.5, 0.75, 1.0]\n--     \"\"\"\n--     min_number = min(numbers)\n--     max_number = max(numbers)\n--     return [(x - min_number) / (max_number - min_number) for x in numbers]\n-- \n\n\n-- Haskell Implementation:\n\n-- Given list of numbers (of at least two elements), apply a linear transform to that list,\n-- such that the smallest number will become 0 and the largest will become 1\n-- >>> rescale_to_unit [1.0, 2.0, 3.0, 4.0, 5.0]\n-- [0.0,0.25,0.5,0.75,1.0]\nrescale_to_unit :: [Float] -> [Float]\nrescale_to_unit numbers = map  (\\x ->  (x - min_number) /  (max_number - min_number))  numbers\n    where min_number =  minimum numbers\n          max_number =  maximum numbers\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (rescale_to_unit [2.0, 49.9] == [0.0, 1.0])\n    check (rescale_to_unit [100.0, 49.9] == [1.0, 0.0])\n    check (rescale_to_unit [1.0, 2.0, 3.0, 4.0, 5.0] == [0.0, 0.25, 0.5, 0.75, 1.0])\n    check (rescale_to_unit [2.0, 1.0, 5.0, 3.0, 4.0] == [0.25, 0.0, 1.0, 0.5, 0.75])\n    check (rescale_to_unit [12.0, 11.0, 15.0, 13.0, 14.0] == [0.25, 0.0, 1.0, 0.5, 0.75])\n"}
{"task_id": "Haskell/22", "prompt": "-- Filter given list of strings only for integers. >>> filter_integers([\"a\", \"3.14\", \"5\"]) [5] >>> filter_integers([\"1\", \"2\", \"3\", \"abc\", \"{}\", \"[]\"]) [1, 2, 3]", "canonical_solution": "-- Task ID: HumanEval/22\n\n\n-- Haskell Implementation:\n\nimport Text.Read  (readMaybe)\nimport Data.Maybe (mapMaybe)\n\n-- Filter given list of strings only for integers.\n-- >>> filter_integers([\"a\", \"3.14\", \"5\"])\n-- [5]\n-- >>> filter_integers([\"1\", \"2\", \"3\", \"abc\", \"{}\", \"[]\"])\n-- [1, 2, 3]\nfilter_integers :: [String] -> [Int]\nfilter_integers = mapMaybe readMaybe", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (filter_integers [] == [])\n    check (filter_integers [\"4\", \"9\"] == [4, 9])\n    check (filter_integers [\"3\", \"3\", \"3\"] == [3, 3, 3])\n"}
{"task_id": "Haskell/23", "prompt": "-- Return length of given string\nstrlen :: String -> Int", "canonical_solution": "-- Task ID: HumanEval/23\n-- Assigned To: Author A\n\n-- Python Implementation:\n\n-- \n-- \n-- def strlen(string: str) -> int:\n--     \"\"\" Return length of given string\n--     >>> strlen('')\n--     0\n--     >>> strlen('abc')\n--     3\n--     \"\"\"\n--     return len(string)\n-- \n\n\n-- Haskell Implementation:\n\n-- Return length of given string\nstrlen :: String -> Int\nstrlen string =  length  string\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (strlen \"\" == 0)\n    check (strlen \"x\" == 1)\n    check (strlen \"asdasnakj\" == 9)\n"}
{"task_id": "Haskell/24", "prompt": "-- For a given number n, find the largest number that divides n evenly, smaller than n\n-- >>> largest_divisor 15\n-- 5\nlargest_divisor :: Int -> Int", "canonical_solution": "-- Task ID: HumanEval/24\n-- Assigned To: Author A\n\n-- Python Implementation:\n\n-- \n-- \n-- def largest_divisor(n: int) -> int:\n--     \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n--     >>> largest_divisor(15)\n--     5\n--     \"\"\"\n--     for i in reversed(range(n)):\n--         if n % i == 0:\n--             return i\n-- \n\n\n-- Haskell Implementation:\n\n-- For a given number n, find the largest number that divides n evenly, smaller than n\n-- >>> largest_divisor 15\n-- 5\nlargest_divisor :: Int -> Int\nlargest_divisor n =  maximum  [x | x <-  [1..n-1],  n `mod` x ==  0]\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (largest_divisor 3 == 1)\n    check (largest_divisor 7 == 1)\n    check (largest_divisor 10 == 5)\n    check (largest_divisor 100 == 50)\n    check (largest_divisor 49 == 7)\n"}
{"task_id": "Haskell/25", "prompt": "-- Return list of prime factors of given integer in the order from smallest to largest.\n-- Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n-- Input number should be equal to the product of all factors\n-- >>> factorize 8\n-- [2,2,2]\n-- >>> factorize 25\n-- [5,5]\n-- >>> factorize 70\n-- [2,5,7]\nfactorize :: Int -> [Int]", "canonical_solution": "-- Task ID: HumanEval/25\n-- Assigned To: Author A\n\n-- Python Implementation:\n\n-- from typing import List\n-- \n-- \n-- def factorize(n: int) -> List[int]:\n--     \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n--     Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n--     Input number should be equal to the product of all factors\n--     >>> factorize(8)\n--     [2, 2, 2]\n--     >>> factorize(25)\n--     [5, 5]\n--     >>> factorize(70)\n--     [2, 5, 7]\n--     \"\"\"\n--     import math\n--     fact = []\n--     i = 2\n--     while i <= int(math.sqrt(n) + 1):\n--         if n % i == 0:\n--             fact.append(i)\n--             n //= i\n--         else:\n--             i += 1\n-- \n--     if n > 1:\n--         fact.append(n)\n--     return fact\n-- \n\n\n-- Haskell Implementation:\n\n-- Return list of prime factors of given integer in the order from smallest to largest.\n-- Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n-- Input number should be equal to the product of all factors\n-- >>> factorize 8\n-- [2,2,2]\n-- >>> factorize 25\n-- [5,5]\n-- >>> factorize 70\n-- [2,5,7]\nfactorize :: Int -> [Int]\nfactorize n = factorize' n 2\n    where\n        factorize' :: Int -> Int -> [Int]\n        factorize' n i\n            | i * i > n =  [n]\n            | n `mod` i == 0 =  i :  factorize' (n `div` i) i\n            | otherwise =  factorize' n  (i + 1)\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (factorize 2 == [2])\n    check (factorize 4 == [2, 2])\n    check (factorize 8 == [2, 2, 2])\n    check (factorize (3 * 19) == [3, 19])\n    check (factorize (3 * 19 * 3 * 19) == [3, 3, 19, 19])\n    check (factorize (3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19])\n    check (factorize (3 * 19 * 19 * 19) == [3, 19, 19, 19])\n    check (factorize (3 * 2 * 3) == [2, 3, 3])\n"}
{"task_id": "Haskell/26", "prompt": "-- From a list of integers, remove all elements that occur more than once.\n-- Keep order of elements left the same as in the input.\n-- >>> remove_duplicates [1, 2, 3, 2, 4]\n-- [1,3,4]\nremove_duplicates :: [Int] -> [Int]", "canonical_solution": "-- Task ID: HumanEval/26\n-- Assigned To: Author A\n\n-- Python Implementation:\n\n-- from typing import List\n-- \n-- \n-- def remove_duplicates(numbers: List[int]) -> List[int]:\n--     \"\"\" From a list of integers, remove all elements that occur more than once.\n--     Keep order of elements left the same as in the input.\n--     >>> remove_duplicates([1, 2, 3, 2, 4])\n--     [1, 3, 4]\n--     \"\"\"\n--     import collections\n--     c = collections.Counter(numbers)\n--     return [n for n in numbers if c[n] <= 1]\n-- \n\n\n-- Haskell Implementation:\n\n-- From a list of integers, remove all elements that occur more than once.\n-- Keep order of elements left the same as in the input.\n-- >>> remove_duplicates [1, 2, 3, 2, 4]\n-- [1,3,4]\nremove_duplicates :: [Int] -> [Int]\nremove_duplicates numbers = [n |  (n, c) <- counts,  c <= 1]\n    where counts =  [(n, count n numbers) | n <-  numbers]\n          count n xs = length  [x | x <- xs,  x == n]\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (remove_duplicates [] == [])\n    check (remove_duplicates [1, 2, 3, 4] == [1, 2, 3, 4])\n    check (remove_duplicates [1, 2, 3, 2, 4, 3, 5] == [1, 4, 5])\n"}
{"task_id": "Haskell/27", "prompt": "-- For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n-- >>> flip_case \"Hello\"\n-- \"hELLO\"\nflip_case :: String -> String", "canonical_solution": "-- Task ID: HumanEval/27\n-- Assigned To: Author A\n\n-- Python Implementation:\n\n-- \n-- \n-- def flip_case(string: str) -> str:\n--     \"\"\" For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n--     >>> flip_case('Hello')\n--     'hELLO'\n--     \"\"\"\n--     return string.swapcase()\n-- \n\n\n-- Haskell Implementation:\nimport Data.Char\n\n-- For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n-- >>> flip_case \"Hello\"\n-- \"hELLO\"\nflip_case :: String -> String\nflip_case string =  map swap_case string\n    where swap_case c =  if isUpper c then  toLower c else  toUpper c\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (flip_case \"\" == \"\")\n    check (flip_case \"Hello!\" == \"hELLO!\")\n    check (flip_case \"These violent delights have violent ends\" == \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\")\n"}
{"task_id": "Haskell/28", "prompt": "-- Concatenate list of strings into a single string\nconcatenate :: [String] -> String", "canonical_solution": "-- Task ID: HumanEval/28\n-- Assigned To: Author A\n\n-- Python Implementation:\n\n-- from typing import List\n-- \n-- \n-- def concatenate(strings: List[str]) -> str:\n--     \"\"\" Concatenate list of strings into a single string\n--     >>> concatenate([])\n--     ''\n--     >>> concatenate(['a', 'b', 'c'])\n--     'abc'\n--     \"\"\"\n--     return ''.join(strings)\n-- \n\n\n-- Haskell Implementation:\n\n-- Concatenate list of strings into a single string\nconcatenate :: [String] -> String\nconcatenate strings =  concat strings\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (concatenate [] == \"\")\n    check (concatenate [\"x\", \"y\", \"z\"] == \"xyz\")\n    check (concatenate [\"x\", \"y\", \"z\", \"w\", \"k\"] == \"xyzwk\")\n"}
{"task_id": "Haskell/29", "prompt": "-- Filter an input list of strings only for ones that start with a given prefix.\n-- >>> filter_by_prefix [] \"a\"\n-- []\n-- >>> filter_by_prefix [\"abc\", \"bcd\", \"cde\", \"array\"] \"a\"\n-- [\"abc\",\"array\"]\nfilter_by_prefix :: [String] -> String -> [String]", "canonical_solution": "-- Task ID: HumanEval/29\n-- Assigned To: Author A\n\n-- Python Implementation:\n\n-- from typing import List\n-- \n-- \n-- def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n--     \"\"\" Filter an input list of strings only for ones that start with a given prefix.\n--     >>> filter_by_prefix([], 'a')\n--     []\n--     >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n--     ['abc', 'array']\n--     \"\"\"\n--     return [x for x in strings if x.startswith(prefix)]\n-- \n\n\n-- Haskell Implementation:\n\n-- Filter an input list of strings only for ones that start with a given prefix.\n-- >>> filter_by_prefix [] \"a\"\n-- []\n-- >>> filter_by_prefix [\"abc\", \"bcd\", \"cde\", \"array\"] \"a\"\n-- [\"abc\",\"array\"]\nfilter_by_prefix :: [String] -> String -> [String]\nfilter_by_prefix strings prefix =  [x | x <-  strings,  x `startsWith` prefix]\n    where startsWith :: String -> String -> Bool\n          startsWith string prefix =  take (length prefix)  string == prefix\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (filter_by_prefix [] \"john\" == [])\n    check (filter_by_prefix [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"] \"xxx\" == [\"xxx\", \"xxxAAA\", \"xxx\"])\n"}
{"task_id": "Haskell/30", "prompt": "-- Return only positive numbers in the list.\nget_positive :: [Int] -> [Int]", "canonical_solution": "-- Task ID: HumanEval/30\n-- Assigned To: Author A\n\n-- Python Implementation:\n\n-- \n-- \n-- def get_positive(l: list):\n--     \"\"\"Return only positive numbers in the list.\n--     >>> get_positive([-1, 2, -4, 5, 6])\n--     [2, 5, 6]\n--     >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n--     [5, 3, 2, 3, 9, 123, 1]\n--     \"\"\"\n--     return [e for e in l if e > 0]\n-- \n\n\n-- Haskell Implementation:\n\n-- Return only positive numbers in the list.\nget_positive :: [Int] -> [Int]\nget_positive l =  [x | x <- l,  x > 0]\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (get_positive [-1, -2, 4, 5, 6] == [4, 5, 6])\n    check (get_positive [5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10] == [5, 3, 2, 3, 3, 9, 123, 1])\n    check (get_positive [-1, -2] == [])\n    check (get_positive [] == [])"}
{"task_id": "Haskell/31", "prompt": "-- Return true if a given number is prime, and false otherwise.\n-- >>> is_prime 6\n-- False\n-- >>> is_prime 101\n-- True\n-- >>> is_prime 11\n-- True\n-- >>> is_prime 13441\n-- True\n-- >>> is_prime 61\n-- True\n-- >>> is_prime 4\n-- False\n-- >>> is_prime 1\n-- False\nis_prime :: Int -> Bool", "canonical_solution": "-- Task ID: HumanEval/31\n-- Assigned To: Author A\n\n-- Python Implementation:\n\n-- \n-- \n-- def is_prime(n):\n--     \"\"\"Return true if a given number is prime, and false otherwise.\n--     >>> is_prime(6)\n--     False\n--     >>> is_prime(101)\n--     True\n--     >>> is_prime(11)\n--     True\n--     >>> is_prime(13441)\n--     True\n--     >>> is_prime(61)\n--     True\n--     >>> is_prime(4)\n--     False\n--     >>> is_prime(1)\n--     False\n--     \"\"\"\n--     if n < 2:\n--         return False\n--     for k in range(2, n - 1):\n--         if n % k == 0:\n--             return False\n--     return True\n-- \n\n\n-- Haskell Implementation:\n\n-- Return true if a given number is prime, and false otherwise.\n-- >>> is_prime 6\n-- False\n-- >>> is_prime 101\n-- True\n-- >>> is_prime 11\n-- True\n-- >>> is_prime 13441\n-- True\n-- >>> is_prime 61\n-- True\n-- >>> is_prime 4\n-- False\n-- >>> is_prime 1\n-- False\nis_prime :: Int -> Bool\nis_prime n =  n > 1 &&  all (\\k ->  n `mod` k /= 0)  [2..n-1]\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (is_prime 6 == False)\n    check (is_prime 101 == True)\n    check (is_prime 11 == True)\n    check (is_prime 13441 == True)\n    check (is_prime 61 == True)\n    check (is_prime 4 == False)\n    check (is_prime 1 == False)\n    check (is_prime 5 == True)\n    check (is_prime 11 == True)\n    check (is_prime 17 == True)\n    check (is_prime (5 * 17) == False)\n    check (is_prime (11 * 7) == False)\n    check (is_prime (13441 * 19) == False)"}
{"task_id": "Haskell/32", "prompt": "roundTo :: Double -> Int -> Double\nroundTo x n = (fromInteger $ round $ x * (10^n)) / (10.0^^n)\n-- Evaluates polynomial with coefficients xs at point x.\n-- return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\npoly :: [Double] -> Double -> Double\npoly coeffs x = sum [coeff * x ** fromIntegral i | (i, coeff) <- zip [0..] coeffs]\n-- xs are coefficients of a polynomial.\n-- find_zero find x such that poly(x) = 0.\n-- find_zero returns only only zero point, even if there are many.\n-- Moreover, find_zero only takes list xs having even number of coefficients\n-- and largest non zero coefficient as it guarantees\n-- a solution.\n-- >>> roundTo (find_zero [1,2]) 2 -- f(x) = 1 + 2x\n-- -0.5\n-- >>> roundTo (find_zero [-6,11,-6,1]) 2 -- (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n-- 1.0", "canonical_solution": "-- Task ID: HumanEval/32\n-- Assigned To: Author A\n\n-- Python Implementation:\n\n-- import math\n-- \n-- \n-- def poly(xs: list, x: float):\n--     \"\"\"\n--     Evaluates polynomial with coefficients xs at point x.\n--     return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n--     \"\"\"\n--     return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n-- \n-- \n-- def find_zero(xs: list):\n--     \"\"\" xs are coefficients of a polynomial.\n--     find_zero find x such that poly(x) = 0.\n--     find_zero returns only only zero point, even if there are many.\n--     Moreover, find_zero only takes list xs having even number of coefficients\n--     and largest non zero coefficient as it guarantees\n--     a solution.\n--     >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n--     -0.5\n--     >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n--     1.0\n--     \"\"\"\n--     begin, end = -1., 1.\n--     while poly(xs, begin) * poly(xs, end) > 0:\n--         begin *= 2.0\n--         end *= 2.0\n--     while end - begin > 1e-10:\n--         center = (begin + end) / 2.0\n--         if poly(xs, center) * poly(xs, begin) > 0:\n--             begin = center\n--         else:\n--             end = center\n--     return begin\n-- \n\n\n-- Haskell Implementation:\nroundTo :: Double -> Int -> Double\nroundTo x n =  (fromInteger $ round $  x * (10^n)) /  (10.0^^n)\n\n-- Evaluates polynomial with coefficients xs at point x.\n-- return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\npoly :: [Double] -> Double -> Double\npoly coeffs x =  sum [coeff * x  ** fromIntegral i | (i, coeff) <-  zip [0..] coeffs]\n\n-- xs are coefficients of a polynomial.\n-- find_zero find x such that poly(x) = 0.\n-- find_zero returns only only zero point, even if there are many.\n-- Moreover, find_zero only takes list xs having even number of coefficients\n-- and largest non zero coefficient as it guarantees\n-- a solution.\n-- >>> roundTo (find_zero [1,2]) 2 -- f(x) = 1 + 2x\n-- -0.5\n-- >>> roundTo (find_zero [-6,11,-6,1]) 2 -- (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n-- 1.0\nfind_zero :: [Double] -> Double\nfind_zero coeffs = go (-1.0)  1.0\n    where\n        go :: Double -> Double -> Double\n        go begin end\n            | abs (end - begin) < 1e-10 =  begin\n            | otherwise =\n                let center =  (begin + end) / 2.0 in\n                    if  poly coeffs center * poly coeffs begin  > 0\n                        then  go center end\n                        else  go begin center\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True = return ()\ncheck False = error \"Test failed\"\n\nimport System.Random (StdGen, mkStdGen, randomR)\n\nmain :: IO ()\nmain = do\n let gen0 = mkStdGen 42\n runTests 100 gen0\n\nrunTests :: Int -> StdGen -> IO ()\nrunTests 0 _ = return ()\nrunTests n gen =\n let (val, gen1) = randomR (1,4 :: Int) gen\n ncoeff = 2 * val\n (coeffs, gen2) = genCoeffs ncoeff gen1\n solution = candidate coeffs\n ok = abs (poly coeffs solution) < 1e-4\n in check ok >> runTests (n-1) gen2\n\n-- generate a list of 'n' coefficients, replacing any 0 with 1\ngenCoeffs :: Int -> StdGen -> ([Int], StdGen)\ngenCoeffs 0 gen = ([], gen)\ngenCoeffs m gen =\n let (c, gen1) = randomR (-10,10 :: Int) gen\n coeff = if c == 0 then 1 else c\n (rest, gen2) = genCoeffs (m-1) gen1\n in (coeff : rest, gen2)\n"}
{"task_id": "Haskell/33", "prompt": "-- This function takes a list l and returns a list l' such that\n-- l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n-- to the values of the corresponding indicies of l, but sorted.\n-- >>> sort_third [1,2,3]\n-- [1,2,3]\n-- >>> sort_third [5,6,3,4,8,9,2]\n-- [2,6,3,4,8,9,5]\nsort_third :: [Int] -> [Int]", "canonical_solution": "-- Task ID: HumanEval/33\n-- Assigned To: Author C\n\n-- Python Implementation:\n\n-- \n-- \n-- def sort_third(l: list):\n--     \"\"\"This function takes a list l and returns a list l' such that\n--     l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n--     to the values of the corresponding indicies of l, but sorted.\n--     >>> sort_third([1, 2, 3])\n--     [1, 2, 3]\n--     >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n--     [2, 6, 3, 4, 8, 9, 5]\n--     \"\"\"\n--     l = list(l)\n--     l[::3] = sorted(l[::3])\n--     return l\n-- \n\n\n-- Haskell Implementation:\nimport Data.List (sort)\n\n-- This function takes a list l and returns a list l' such that\n-- l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n-- to the values of the corresponding indicies of l, but sorted.\n-- >>> sort_third [1,2,3]\n-- [1,2,3]\n-- >>> sort_third [5,6,3,4,8,9,2]\n-- [2,6,3,4,8,9,5]\nsort_third :: [Int] -> [Int]\nsort_third xs = replaceEveryThird xs (sort $ everyThird xs)\n  where\n    everyThird :: [Int] -> [Int]\n    everyThird [] =  []\n    everyThird (x:xs) =  x : everyThird  (drop 2 xs)\n    replaceEveryThird :: [Int] -> [Int] -> [Int]\n    replaceEveryThird [] _ =  []\n    replaceEveryThird xs [] =  xs\n    replaceEveryThird (x:xs) (y:ys) =  y : (take 2 xs ++  replaceEveryThird (drop 2 xs) ys)\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (sort_third [1, 2, 3] == sort_third [1, 2, 3])\n    check (sort_third [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10] == sort_third [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    check (sort_third [5, 8, -12, 4, 23, 2, 3, 11, 12, -10] == sort_third [5, 8, -12, 4, 23, 2, 3, 11, 12, -10])\n    check (sort_third [5, 6, 3, 4, 8, 9, 2] == [2, 6, 3, 4, 8, 9, 5])\n    check (sort_third [5, 8, 3, 4, 6, 9, 2] == [2, 8, 3, 4, 6, 9, 5])\n    check (sort_third [5, 6, 9, 4, 8, 3, 2] == [2, 6, 9, 4, 8, 3, 5])\n    check (sort_third [5, 6, 3, 4, 8, 9, 2, 1] == [2, 6, 3, 4, 8, 9, 5, 1])"}
{"task_id": "Haskell/34", "prompt": "-- Return sorted unique elements in a list\n-- >>> unique [5,3,5,2,3,3,9,0,123]\n-- [0,2,3,5,9,123]\nunique :: [Int] -> [Int]", "canonical_solution": "-- Task ID: HumanEval/34\n-- Assigned To: Author C\n\n-- Python Implementation:\n\n-- \n-- \n-- def unique(l: list):\n--     \"\"\"Return sorted unique elements in a list\n--     >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n--     [0, 2, 3, 5, 9, 123]\n--     \"\"\"\n--     return sorted(list(set(l)))\n-- \n\n\n-- Haskell Implementation:\nimport Data.List (sort, nub)\n\n-- Return sorted unique elements in a list\n-- >>> unique [5,3,5,2,3,3,9,0,123]\n-- [0,2,3,5,9,123]\nunique :: [Int] -> [Int]\nunique =  sort .  nub\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (unique [5, 3, 5, 2, 3, 3, 9, 0, 123] == [0, 2, 3, 5, 9, 123])"}
{"task_id": "Haskell/35", "prompt": "-- Return maximum element in the list.\n-- >>> max_element [1,2,3]\n-- 3\n-- >>> max_element [5,3,-5,2,-3,3,9,0,123,1,-10]\n-- 123\nmax_element :: [Int] -> Int", "canonical_solution": "-- Task ID: HumanEval/35\n-- Assigned To: Author C\n\n-- Python Implementation:\n\n-- \n-- \n-- def max_element(l: list):\n--     \"\"\"Return maximum element in the list.\n--     >>> max_element([1, 2, 3])\n--     3\n--     >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n--     123\n--     \"\"\"\n--     m = l[0]\n--     for e in l:\n--         if e > m:\n--             m = e\n--     return m\n-- \n\n\n-- Haskell Implementation:\n\n-- Return maximum element in the list.\n-- >>> max_element [1,2,3]\n-- 3\n-- >>> max_element [5,3,-5,2,-3,3,9,0,123,1,-10]\n-- 123\nmax_element :: [Int] -> Int\nmax_element =  maximum\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (max_element [1, 2, 3] == 3)\n    check (max_element [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10] == 124)"}
{"task_id": "Haskell/36", "prompt": "-- Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n-- >>> fizz_buzz 50\n-- 0\n-- >>> fizz_buzz 78\n-- 2\n-- >>> fizz_buzz 79\n-- 3\nfizz_buzz :: Int -> Int", "canonical_solution": "-- Task ID: HumanEval/36\n-- Assigned To: Author C\n\n-- Python Implementation:\n\n-- \n-- \n-- def fizz_buzz(n: int):\n--     \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n--     >>> fizz_buzz(50)\n--     0\n--     >>> fizz_buzz(78)\n--     2\n--     >>> fizz_buzz(79)\n--     3\n--     \"\"\"\n--     ns = []\n--     for i in range(n):\n--         if i % 11 == 0 or i % 13 == 0:\n--             ns.append(i)\n--     s = ''.join(list(map(str, ns)))\n--     ans = 0\n--     for c in s:\n--         ans += (c == '7')\n--     return ans\n-- \n\n\n-- Haskell Implementation:\n\n-- Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n-- >>> fizz_buzz 50\n-- 0\n-- >>> fizz_buzz 78\n-- 2\n-- >>> fizz_buzz 79\n-- 3\nfizz_buzz :: Int -> Int\nfizz_buzz =  length . filter  (== '7') . concatMap show . filter (\\x ->  x `mod` 11 == 0 ||  x `mod` 13 == 0) .  enumFromTo 0 . pred\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (fizz_buzz 50 == 0)\n    check (fizz_buzz 78 == 2)\n    check (fizz_buzz 79 == 3)\n    check (fizz_buzz 100 == 3)\n    check (fizz_buzz 200 == 6)\n    check (fizz_buzz 4000 == 192)\n    check (fizz_buzz 10000 == 639)\n    check (fizz_buzz 100000 == 8026)"}
{"task_id": "Haskell/37", "prompt": "-- This function takes a list l and returns a list l' such that\n-- l' is identical to l in the odd indicies, while its values at the even indicies are equal\n-- to the values of the even indicies of l, but sorted.\n-- >>> sort_even [1,2,3]\n-- [1,2,3]\n-- >>> sort_even [5,6,3,4]\n-- [3,6,5,4]\nsort_even :: [Int] -> [Int]", "canonical_solution": "-- Task ID: HumanEval/37\n-- Assigned To: Author C\n\n-- Python Implementation:\n\n-- \n-- \n-- def sort_even(l: list):\n--     \"\"\"This function takes a list l and returns a list l' such that\n--     l' is identical to l in the odd indicies, while its values at the even indicies are equal\n--     to the values of the even indicies of l, but sorted.\n--     >>> sort_even([1, 2, 3])\n--     [1, 2, 3]\n--     >>> sort_even([5, 6, 3, 4])\n--     [3, 6, 5, 4]\n--     \"\"\"\n--     evens = l[::2]\n--     odds = l[1::2]\n--     evens.sort()\n--     ans = []\n--     for e, o in zip(evens, odds):\n--         ans.extend([e, o])\n--     if len(evens) > len(odds):\n--         ans.append(evens[-1])\n--     return ans\n-- \n\n\n-- Haskell Implementation:\nimport Data.List (sort)\n\n-- This function takes a list l and returns a list l' such that\n-- l' is identical to l in the odd indicies, while its values at the even indicies are equal\n-- to the values of the even indicies of l, but sorted.\n-- >>> sort_even [1,2,3]\n-- [1,2,3]\n-- >>> sort_even [5,6,3,4]\n-- [3,6,5,4]\nsort_even :: [Int] -> [Int]\nsort_even xs = replaceEverySecond xs (sort $ everySecond xs)\n  where\n    everySecond :: [Int] -> [Int]\n    everySecond [] =  []\n    everySecond (x:xs) =  x : everySecond  (drop 1 xs)\n    replaceEverySecond :: [Int] -> [Int] -> [Int]\n    replaceEverySecond [] _ =  []\n    replaceEverySecond xs [] =  xs\n    replaceEverySecond (x:xs) (y:ys) =  y : (take 1 xs ++  replaceEverySecond  (drop 1 xs) ys)\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (sort_even [1, 2, 3] == [1, 2, 3])\n    check (sort_even [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10] == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    check (sort_even [5, 8, -12, 4, 23, 2, 3, 11, 12, -10] == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"}
{"task_id": "Haskell/38", "prompt": "-- returns encoded string by cycling groups of three characters.\nencode_cyclic :: String -> String", "canonical_solution": "-- Task ID: HumanEval/38\n-- Assigned To: Author C\n\n-- Python Implementation:\n\n-- \n-- \n-- def encode_cyclic(s: str):\n--     \"\"\"\n--     returns encoded string by cycling groups of three characters.\n--     \"\"\"\n--     # split string to groups. Each of length 3.\n--     groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n--     # cycle elements in each group. Unless group has fewer elements than 3.\n--     groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n--     return \"\".join(groups)\n-- \n-- \n-- def decode_cyclic(s: str):\n--     \"\"\"\n--     takes as input string encoded with encode_cyclic function. Returns decoded string.\n--     \"\"\"\n--     return encode_cyclic(encode_cyclic(s))\n-- \n\n\n-- Haskell Implementation:\n\n-- returns encoded string by cycling groups of three characters.\nencode_cyclic :: String -> String\nencode_cyclic = concatMap (\\x ->  if length x == 3 then  tail x ++ [head x] else  x) . chunksOf  3\n  where\n    chunksOf :: Int -> [a] -> [[a]]\n    chunksOf _ [] =  []\n    chunksOf n xs =  take n xs :  chunksOf n  (drop n xs)\n\n-- takes as input string encoded with encode_cyclic function. Returns decoded string.\ndecode_cyclic :: String -> String\ndecode_cyclic = encode_cyclic .  encode_cyclic\n", "test": "-- Test suite\ncheck :: Bool -> IO ()\ncheck True = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n forM_ [1..100] $ \\_ -> do\n len <- randomRIO (10, 20)\n str <- replicateM len (randomRIO ('a', 'z'))\n let encodedStr = encodeCyclic str\n check (candidate encodedStr == str)\n"}
{"task_id": "Haskell/39", "prompt": "-- prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n-- >>> prime_fib 1\n-- 2\n-- >>> prime_fib 2\n-- 3\n-- >>> prime_fib 3\n-- 5\n-- >>> prime_fib 4\n-- 13\n-- >>> prime_fib 5\n-- 89\nprime_fib :: Int -> Int", "canonical_solution": "-- Task ID: HumanEval/39\n-- Assigned To: Author C\n\n-- Python Implementation:\n\n-- \n-- \n-- def prime_fib(n: int):\n--     \"\"\"\n--     prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n--     >>> prime_fib(1)\n--     2\n--     >>> prime_fib(2)\n--     3\n--     >>> prime_fib(3)\n--     5\n--     >>> prime_fib(4)\n--     13\n--     >>> prime_fib(5)\n--     89\n--     \"\"\"\n--     import math\n-- \n--     def is_prime(p):\n--         if p < 2:\n--             return False\n--         for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n--             if p % k == 0:\n--                 return False\n--         return True\n--     f = [0, 1]\n--     while True:\n--         f.append(f[-1] + f[-2])\n--         if is_prime(f[-1]):\n--             n -= 1\n--         if n == 0:\n--             return f[-1]\n-- \n\n\n-- Haskell Implementation:\n\n-- prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n-- >>> prime_fib 1\n-- 2\n-- >>> prime_fib 2\n-- 3\n-- >>> prime_fib 3\n-- 5\n-- >>> prime_fib 4\n-- 13\n-- >>> prime_fib 5\n-- 89\nprime_fib :: Int -> Int\nprime_fib n = head $ drop (n - 1) $ filter is_prime $ map fib [1..]\n  where\n    fib :: Int -> Int\n    fib 1 =  2\n    fib 2 =  3\n    fib n =  fib (n - 1) +  fib (n - 2)\n    is_prime :: Int -> Bool\n    is_prime p =  p > 1 &&  all (\\k -> p `mod`  k /= 0)  [2..(p - 1)]\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (prime_fib 1 == 2)\n    check (prime_fib 2 == 3)\n    check (prime_fib 3 == 5)\n    check (prime_fib 4 == 13)\n    check (prime_fib 5 == 89)\n    check (prime_fib 6 == 233)\n    check (prime_fib 7 == 1597)\n    check (prime_fib 8 == 28657)\n    check (prime_fib 9 == 514229)\n    check (prime_fib 10 == 433494437)"}
{"task_id": "Haskell/40", "prompt": "-- triples_sum_to_zero takes a list of integers as an input.\n-- it returns True if there are three distinct elements in the list that\n-- sum to zero, and False otherwise.\n-- >>> triples_sum_to_zero [1,3,5,0]\n-- False\n-- >>> triples_sum_to_zero [1,3,-2,1]\n-- True\n-- >>> triples_sum_to_zero [1,2,3,7]\n-- False\n-- >>> triples_sum_to_zero [2,4,-5,3,9,7]\n-- True\n-- >>> triples_sum_to_zero [1]\n-- False\ntriples_sum_to_zero :: [Int] -> Bool", "canonical_solution": "-- Task ID: HumanEval/40\n-- Assigned To: Author C\n\n-- Python Implementation:\n\n-- \n-- \n-- def triples_sum_to_zero(l: list):\n--     \"\"\"\n--     triples_sum_to_zero takes a list of integers as an input.\n--     it returns True if there are three distinct elements in the list that\n--     sum to zero, and False otherwise.\n-- \n--     >>> triples_sum_to_zero([1, 3, 5, 0])\n--     False\n--     >>> triples_sum_to_zero([1, 3, -2, 1])\n--     True\n--     >>> triples_sum_to_zero([1, 2, 3, 7])\n--     False\n--     >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n--     True\n--     >>> triples_sum_to_zero([1])\n--     False\n--     \"\"\"\n--     for i in range(len(l)):\n--         for j in range(i + 1, len(l)):\n--             for k in range(j + 1, len(l)):\n--                 if l[i] + l[j] + l[k] == 0:\n--                     return True\n--     return False\n-- \n\n\n-- Haskell Implementation:\n\n-- triples_sum_to_zero takes a list of integers as an input.\n-- it returns True if there are three distinct elements in the list that\n-- sum to zero, and False otherwise.\n-- \n-- >>> triples_sum_to_zero [1,3,5,0]\n-- False\n-- >>> triples_sum_to_zero [1,3,-2,1]\n-- True\n-- >>> triples_sum_to_zero [1,2,3,7]\n-- False\n-- >>> triples_sum_to_zero [2,4,-5,3,9,7]\n-- True\n-- >>> triples_sum_to_zero [1]\n-- False\ntriples_sum_to_zero :: [Int] -> Bool\ntriples_sum_to_zero xs =  any (\\(a, b, c) ->  a + b + c == 0) $ triples xs\n  where\n    triples :: [Int] -> [(Int, Int, Int)]\n    triples [] =  []\n    triples (x:xs) =  [(x, y, z) | y <- xs, z <-  tail xs,  y /= z] ++  triples xs\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (triples_sum_to_zero [1, 3, 5, 0] == False)\n    check (triples_sum_to_zero [1, 3, 5, -1] == False)\n    check (triples_sum_to_zero [1, 3, -2, 1] == True)\n    check (triples_sum_to_zero [1, 2, 3, 7] == False)\n    check (triples_sum_to_zero [1, 2, 5, 7] == False)\n    check (triples_sum_to_zero [2, 4, -5, 3, 9, 7] == True)\n    check (triples_sum_to_zero [1] == False)\n    check (triples_sum_to_zero [1, 3, 5, -100] == False)\n    check (triples_sum_to_zero [100, 3, 5, -100] == False)\n"}
{"task_id": "Haskell/41", "prompt": "-- Imagine a road that's a perfectly straight infinitely long line.\n-- n cars are driving left to right;  simultaneously, a different set of n cars\n-- are driving right to left.   The two sets of cars start out being very far from\n-- each other.  All cars move in the same speed.  Two cars are said to collide\n-- when a car that's moving left to right hits a car that's moving right to left.\n-- However, the cars are infinitely sturdy and strong; as a result, they continue moving\n-- in their trajectory as if they did not collide.\n-- This function outputs the number of such collisions.\ncar_race_collision :: Int -> Int", "canonical_solution": "-- Task ID: HumanEval/41\n-- Assigned To: Author C\n\n-- Python Implementation:\n\n-- \n-- \n-- def car_race_collision(n: int):\n--     \"\"\"\n--     Imagine a road that's a perfectly straight infinitely long line.\n--     n cars are driving left to right;  simultaneously, a different set of n cars\n--     are driving right to left.   The two sets of cars start out being very far from\n--     each other.  All cars move in the same speed.  Two cars are said to collide\n--     when a car that's moving left to right hits a car that's moving right to left.\n--     However, the cars are infinitely sturdy and strong; as a result, they continue moving\n--     in their trajectory as if they did not collide.\n-- \n--     This function outputs the number of such collisions.\n--     \"\"\"\n--     return n**2\n-- \n\n\n-- Haskell Implementation:\n\n-- Imagine a road that's a perfectly straight infinitely long line.\n-- n cars are driving left to right;  simultaneously, a different set of n cars\n-- are driving right to left.   The two sets of cars start out being very far from\n-- each other.  All cars move in the same speed.  Two cars are said to collide\n-- when a car that's moving left to right hits a car that's moving right to left.\n-- However, the cars are infinitely sturdy and strong; as a result, they continue moving\n-- in their trajectory as if they did not collide.\n-- \n-- This function outputs the number of such collisions.\ncar_race_collision :: Int -> Int\ncar_race_collision n =  n^2\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (car_race_collision 2 == 4)\n    check (car_race_collision 3 == 9)\n    check (car_race_collision 4 == 16)\n    check (car_race_collision 8 == 64)\n    check (car_race_collision 10 == 100)\n"}
{"task_id": "Haskell/42", "prompt": "-- Return list with elements incremented by 1.\n-- >>> incr_list [1,2,3]\n-- [2,3,4]\n-- >>> incr_list [5,3,5,2,3,3,9,0,123]\n-- [6,4,6,3,4,4,10,1,124]\nincr_list :: [Int] -> [Int]", "canonical_solution": "-- Task ID: HumanEval/42\n-- Assigned To: Author C\n\n-- Python Implementation:\n\n-- \n-- \n-- def incr_list(l: list):\n--     \"\"\"Return list with elements incremented by 1.\n--     >>> incr_list([1, 2, 3])\n--     [2, 3, 4]\n--     >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n--     [6, 4, 6, 3, 4, 4, 10, 1, 124]\n--     \"\"\"\n--     return [(e + 1) for e in l]\n-- \n\n\n-- Haskell Implementation:\n\n-- Return list with elements incremented by 1.\n-- >>> incr_list [1,2,3]\n-- [2,3,4]\n-- >>> incr_list [5,3,5,2,3,3,9,0,123]\n-- [6,4,6,3,4,4,10,1,124]\nincr_list :: [Int] -> [Int]\nincr_list =  map (+1)\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (incr_list [] == [])\n    check (incr_list [3, 2, 1] == [4, 3, 2])\n    check (incr_list [5, 2, 5, 2, 3, 3, 9, 0, 123] == [6, 3, 6, 3, 4, 4, 10, 1, 124])\n"}
{"task_id": "Haskell/43", "prompt": "-- pairs_sum_to_zero takes a list of integers as an input.\n-- it returns True if there are two distinct elements in the list that\n-- sum to zero, and False otherwise.\n-- >>> pairs_sum_to_zero [1,3,5,0]\n-- False\n-- >>> pairs_sum_to_zero [1,3,-2,1]\n-- False\n-- >>> pairs_sum_to_zero [1,2,3,7]\n-- False\n-- >>> pairs_sum_to_zero [2,4,-5,3,5,7]\n-- True\n-- >>> pairs_sum_to_zero [1]\n-- False\npairs_sum_to_zero :: [Int] -> Bool", "canonical_solution": "-- Task ID: HumanEval/43\n-- Assigned To: Author C\n\n-- Python Implementation:\n\n-- \n-- \n-- def pairs_sum_to_zero(l):\n--     \"\"\"\n--     pairs_sum_to_zero takes a list of integers as an input.\n--     it returns True if there are two distinct elements in the list that\n--     sum to zero, and False otherwise.\n--     >>> pairs_sum_to_zero([1, 3, 5, 0])\n--     False\n--     >>> pairs_sum_to_zero([1, 3, -2, 1])\n--     False\n--     >>> pairs_sum_to_zero([1, 2, 3, 7])\n--     False\n--     >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n--     True\n--     >>> pairs_sum_to_zero([1])\n--     False\n--     \"\"\"\n--     for i, l1 in enumerate(l):\n--         for j in range(i + 1, len(l)):\n--             if l1 + l[j] == 0:\n--                 return True\n--     return False\n-- \n\n\n-- Haskell Implementation:\n\n-- pairs_sum_to_zero takes a list of integers as an input.\n-- it returns True if there are two distinct elements in the list that\n-- sum to zero, and False otherwise.\n-- >>> pairs_sum_to_zero [1,3,5,0]\n-- False\n-- >>> pairs_sum_to_zero [1,3,-2,1]\n-- False\n-- >>> pairs_sum_to_zero [1,2,3,7]\n-- False\n-- >>> pairs_sum_to_zero [2,4,-5,3,5,7]\n-- True\n-- >>> pairs_sum_to_zero [1]\n-- False\npairs_sum_to_zero :: [Int] -> Bool\npairs_sum_to_zero xs =  any (\\(a, b) ->  a + b == 0) $  pairs xs\n  where\n    pairs [] =  []\n    pairs (x:xs) =  [(x, y) | y <- xs] ++ pairs xs\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (pairs_sum_to_zero [1, 3, 5, 0] == False)\n    check (pairs_sum_to_zero [1, 3, -2, 1] == False)\n    check (pairs_sum_to_zero [1, 2, 3, 7] == False)\n    check (pairs_sum_to_zero [2, 4, -5, 3, 5, 7] == True)\n    check (pairs_sum_to_zero [1] == False)\n    check (pairs_sum_to_zero [-3, 9, -1, 3, 2, 30] == True)\n    check (pairs_sum_to_zero [-3, 9, -1, 3, 2, 31] == True)\n    check (pairs_sum_to_zero [-3, 9, -1, 4, 2, 30] == False)\n    check (pairs_sum_to_zero [-3, 9, -1, 4, 2, 31] == False)\n"}
{"task_id": "Haskell/44", "prompt": "-- Change numerical base of input number x to base.\n-- return string representation after the conversion.\n-- base numbers are less than 10.\n-- >>> change_base 8 3\n-- \"22\"\n-- >>> change_base 8 2\n-- \"1000\"\n-- >>> change_base 7 2\n-- \"111\"\nchange_base :: Int -> Int -> String", "canonical_solution": "-- Task ID: HumanEval/44\n-- Assigned To: Author C\n\n-- Python Implementation:\n\n-- \n-- \n-- def change_base(x: int, base: int):\n--     \"\"\"Change numerical base of input number x to base.\n--     return string representation after the conversion.\n--     base numbers are less than 10.\n--     >>> change_base(8, 3)\n--     '22'\n--     >>> change_base(8, 2)\n--     '1000'\n--     >>> change_base(7, 2)\n--     '111'\n--     \"\"\"\n--     ret = \"\"\n--     while x > 0:\n--         ret = str(x % base) + ret\n--         x //= base\n--     return ret\n-- \n\n\n-- Haskell Implementation:\n\n-- Change numerical base of input number x to base.\n-- return string representation after the conversion.\n-- base numbers are less than 10.\n-- >>> change_base 8 3\n-- \"22\"\n-- >>> change_base 8 2\n-- \"1000\"\n-- >>> change_base 7 2\n-- \"111\"\nchange_base :: Int -> Int -> String\nchange_base x base =  reverse $ change_base' x\n  where\n    change_base' :: Int -> String \n    change_base' 0 =  \"\"\n    change_base' x =  show (x `mod` base) ++  change_base' (x `div` base)\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (change_base 8 3 == \"22\")\n    check (change_base 9 3 == \"100\")\n    check (change_base 234 2 == \"11101010\")\n    check (change_base 16 2 == \"10000\")\n    check (change_base 8 2 == \"1000\")\n    check (change_base 7 2 == \"111\")\n    check (change_base 2 3 == \"2\")\n    check (change_base 3 4 == \"3\")\n    check (change_base 4 5 == \"4\")\n    check (change_base 5 6 == \"5\")\n    check (change_base 6 7 == \"6\")\n    check (change_base 7 8 == \"7\")\n"}
{"task_id": "Haskell/45", "prompt": "-- Given length of a side and high return area for a triangle.\n-- >>> triangle_area 5 3\n-- 7.5\ntriangle_area :: Double -> Double -> Double", "canonical_solution": "-- Task ID: HumanEval/45\n-- Assigned To: Author C\n\n-- Python Implementation:\n\n-- \n-- \n-- def triangle_area(a, h):\n--     \"\"\"Given length of a side and high return area for a triangle.\n--     >>> triangle_area(5, 3)\n--     7.5\n--     \"\"\"\n--     return a * h / 2.0\n-- \n\n\n-- Haskell Implementation:\n\n-- Given length of a side and high return area for a triangle.\n-- >>> triangle_area 5 3\n-- 7.5\ntriangle_area :: Double -> Double -> Double\ntriangle_area a h =  a * h /  2.0\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (triangle_area 5 3 == 7.5)\n    check (triangle_area 2 2 == 2.0)\n    check (triangle_area 10 8 == 40.0)\n"}
{"task_id": "Haskell/46", "prompt": "-- The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n-- fib4(0) -> 0\n-- fib4(1) -> 0\n-- fib4(2) -> 2\n-- fib4(3) -> 0\n-- fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n-- Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n-- >>> fib4 5\n-- 4\n-- >>> fib4 6\n-- 8\n-- >>> fib4 7\n-- 14\nfib4 :: Int -> Int", "canonical_solution": "-- Task ID: HumanEval/46\n-- Assigned To: Author C\n\n-- Python Implementation:\n\n-- \n-- \n-- def fib4(n: int):\n--     \"\"\"The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n--     fib4(0) -> 0\n--     fib4(1) -> 0\n--     fib4(2) -> 2\n--     fib4(3) -> 0\n--     fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n--     Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n--     >>> fib4(5)\n--     4\n--     >>> fib4(6)\n--     8\n--     >>> fib4(7)\n--     14\n--     \"\"\"\n--     results = [0, 0, 2, 0]\n--     if n < 4:\n--         return results[n]\n-- \n--     for _ in range(4, n + 1):\n--         results.append(results[-1] + results[-2] + results[-3] + results[-4])\n--         results.pop(0)\n-- \n--     return results[-1]\n-- \n\n\n-- Haskell Implementation:\n\n-- The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n-- fib4(0) -> 0\n-- fib4(1) -> 0\n-- fib4(2) -> 2\n-- fib4(3) -> 0\n-- fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n-- Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n-- >>> fib4 5\n-- 4\n-- >>> fib4 6\n-- 8\n-- >>> fib4 7\n-- 14\nfib4 :: Int -> Int\nfib4 n =  fib4' n 0 0 2 0\n  where\n    fib4' :: Int -> Int -> Int -> Int -> Int -> Int\n    fib4' 0 a b c d =  a\n    fib4' 1 a b c d =  b\n    fib4' 2 a b c d =  c\n    fib4' 3 a b c d =  d\n    fib4' n a b c d =  fib4' (n - 1) b c d  (a + b + c + d)\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (fib4 5 == 4)\n    check (fib4 8 == 28)\n    check (fib4 10 == 104)\n    check (fib4 12 == 386)\n"}
{"task_id": "Haskell/47", "prompt": "-- Return median of elements in the list l.\n-- >>> median [3,1,2,4,5]\n-- 3.0\n-- >>> median [-10,4,6,1000,10,20]\n-- 8.0\nmedian :: [Int] -> Double", "canonical_solution": "-- Task ID: HumanEval/47\n-- Assigned To: Author C\n\n-- Python Implementation:\n\n-- \n-- \n-- def median(l: list):\n--     \"\"\"Return median of elements in the list l.\n--     >>> median([3, 1, 2, 4, 5])\n--     3.0\n--     >>> median([-10, 4, 6, 1000, 10, 20])\n--     8.0\n--     \"\"\"\n--     l = sorted(l)\n--     if len(l) % 2 == 1:\n--         return l[len(l) // 2]\n--     else:\n--         return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n-- \n\n\n-- Haskell Implementation:\nimport Data.List (sort)\n\n-- Return median of elements in the list l.\n-- >>> median [3,1,2,4,5]\n-- 3.0\n-- >>> median [-10,4,6,1000,10,20]\n-- 8.0\nmedian :: [Int] -> Double\nmedian xs =  if odd len then fromIntegral (sorted !! (len `div` 2)) else  (fromIntegral (sorted !! (len `div` 2 - 1)) + fromIntegral (sorted !! (len `div` 2))) / 2\n  where\n    sorted :: [Int]\n    sorted =  sort xs\n    len =  length sorted", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (median [3, 1, 2, 4, 5] == 3)\n    check (median [-10, 4, 6, 1000, 10, 20] == 8.0)\n    check (median [5] == 5)\n    check (median [6, 5] == 5.5)\n    check (median [8, 1, 3, 9, 9, 2, 7] == 7)\n"}
{"task_id": "Haskell/48", "prompt": "-- Checks if given string is a palindrome\n-- >>> is_palindrome \"\"\n-- True\n-- >>> is_palindrome \"aba\"\n-- True\n-- >>> is_palindrome \"aaaaa\"\n-- True\n-- >>> is_palindrome \"zbcd\"\n-- False\nis_palindrome :: String -> Bool", "canonical_solution": "-- Task ID: HumanEval/48\n-- Assigned To: Author C\n\n-- Python Implementation:\n\n-- \n-- \n-- def is_palindrome(text: str):\n--     \"\"\"\n--     Checks if given string is a palindrome\n--     >>> is_palindrome('')\n--     True\n--     >>> is_palindrome('aba')\n--     True\n--     >>> is_palindrome('aaaaa')\n--     True\n--     >>> is_palindrome('zbcd')\n--     False\n--     \"\"\"\n--     for i in range(len(text)):\n--         if text[i] != text[len(text) - 1 - i]:\n--             return False\n--     return True\n-- \n\n\n-- Haskell Implementation:\n\n-- Checks if given string is a palindrome\n-- >>> is_palindrome \"\"\n-- True\n-- >>> is_palindrome \"aba\"\n-- True\n-- >>> is_palindrome \"aaaaa\"\n-- True\n-- >>> is_palindrome \"zbcd\"\n-- False\nis_palindrome :: String -> Bool\nis_palindrome =  (==) <*> reverse\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (is_palindrome \"\" == True)\n    check (is_palindrome \"aba\" == True)\n    check (is_palindrome \"aaaaa\" == True)\n    check (is_palindrome \"zbcd\" == False)\n    check (is_palindrome \"xywyx\" == True)\n    check (is_palindrome \"xywyz\" == False)\n    check (is_palindrome \"xywzx\" == False)\n"}
{"task_id": "Haskell/49", "prompt": "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp 3 5\n-- 3\n-- >>> modp 1101 101\n-- 2\n-- >>> modp 0 101\n-- 1\n-- >>> modp 3 11\n-- 8\n-- >>> modp 100 101\n-- 1\nmodp :: Int -> Int -> Int", "canonical_solution": "-- Task ID: HumanEval/49\n-- Assigned To: Author C\n\n-- Python Implementation:\n\n-- \n-- \n-- def modp(n: int, p: int):\n--     \"\"\"Return 2^n modulo p (be aware of numerics).\n--     >>> modp(3, 5)\n--     3\n--     >>> modp(1101, 101)\n--     2\n--     >>> modp(0, 101)\n--     1\n--     >>> modp(3, 11)\n--     8\n--     >>> modp(100, 101)\n--     1\n--     \"\"\"\n--     ret = 1\n--     for i in range(n):\n--         ret = (2 * ret) % p\n--     return ret\n-- \n\n\n-- Haskell Implementation:\n\n-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp 3 5\n-- 3\n-- >>> modp 1101 101\n-- 2\n-- >>> modp 0 101\n-- 1\n-- >>> modp 3 11\n-- 8\n-- >>> modp 100 101\n-- 1\nmodp :: Int -> Int -> Int\nmodp n p =  modp' n p 1\n  where\n    modp' :: Int -> Int -> Int -> Int\n    modp' 0 p ret =  ret\n    modp' n p ret =  modp' (n - 1) p  (mod (2 * ret) p)\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (modp 3 5 == 3)\n    check (modp 1101 101 == 2)\n    check (modp 0 101 == 1)\n    check (modp 3 11 == 8)\n    check (modp 100 101 == 1)\n    check (modp 30 5 == 4)\n    check (modp 31 5 == 3)\n"}
{"task_id": "Haskell/50", "prompt": "-- returns encoded string by shifting every character by 5 in the alphabet.\nencode_shift :: String -> String", "canonical_solution": "-- Task ID: HumanEval/50\n-- Assigned To: Author C\n\n-- Python Implementation:\n\n-- \n-- \n-- def encode_shift(s: str):\n--     \"\"\"\n--     returns encoded string by shifting every character by 5 in the alphabet.\n--     \"\"\"\n--     return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n-- \n-- \n-- def decode_shift(s: str):\n--     \"\"\"\n--     takes as input string encoded with encode_shift function. Returns decoded string.\n--     \"\"\"\n--     return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n-- \n\n\n-- Haskell Implementation:\nimport Data.Char (chr, ord)\n\n-- returns encoded string by shifting every character by 5 in the alphabet.\nencode_shift :: String -> String\nencode_shift =  map (\\c ->  chr (((ord c + 5 - ord 'a') `mod` 26) +  ord 'a'))\n\n-- takes as input string encoded with encode_shift function. Returns decoded string.\ndecode_shift :: String -> String\ndecode_shift =  map (\\c ->  chr (((ord c - 5 - ord 'a') `mod` 26) +  ord 'a'))\n", "test": "\n\n-- Test suite\n\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    let letters = ['a'..'z']\n    forM_ [1..100] $ \\_ -> do\n        len <- randomRIO (10,20)\n        str <- replicateM len (randomRIO ('a','z'))\n        let encoded = encode_shift str\n        check (decode_shift encoded == str)\n"}
{"task_id": "Haskell/51", "prompt": "-- remove_vowels is a function that takes string and returns string without vowels.\n-- >>> remove_vowels \"\"\n-- \"\"\n-- >>> remove_vowels \"abcdef\\nghijklm\"\n-- \"bcdf\\nghjklm\"\n-- >>> remove_vowels \"abcdef\"\n-- \"bcdf\"\n-- >>> remove_vowels \"aaaaa\"\n-- \"\"\n-- >>> remove_vowels \"aaBAA\"\n-- \"B\"\n-- >>> remove_vowels \"zbcd\"\n-- \"zbcd\"\nremove_vowels :: String -> String", "canonical_solution": "-- Task ID: HumanEval/51\n-- Assigned To: Author C\n\n-- Python Implementation:\n\n-- \n-- \n-- def remove_vowels(text):\n--     \"\"\"\n--     remove_vowels is a function that takes string and returns string without vowels.\n--     >>> remove_vowels('')\n--     ''\n--     >>> remove_vowels(\"abcdef\\nghijklm\")\n--     'bcdf\\nghjklm'\n--     >>> remove_vowels('abcdef')\n--     'bcdf'\n--     >>> remove_vowels('aaaaa')\n--     ''\n--     >>> remove_vowels('aaBAA')\n--     'B'\n--     >>> remove_vowels('zbcd')\n--     'zbcd'\n--     \"\"\"\n--     return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n-- \n\n\n-- Haskell Implementation:\n\n-- remove_vowels is a function that takes string and returns string without vowels.\n-- >>> remove_vowels \"\"\n-- \"\"\n-- >>> remove_vowels \"abcdef\\nghijklm\"\n-- \"bcdf\\nghjklm\"\n-- >>> remove_vowels \"abcdef\"\n-- \"bcdf\"\n-- >>> remove_vowels \"aaaaa\"\n-- \"\"\n-- >>> remove_vowels \"aaBAA\"\n-- \"B\"\n-- >>> remove_vowels \"zbcd\"\n-- \"zbcd\"\nremove_vowels :: String -> String\nremove_vowels =  filter (`notElem` \"aeiouAEIOU\")\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (remove_vowels \"\" == \"\")\n    check (remove_vowels \"abcdefghijklm\" == \"bcdfghjklm\")\n    check (remove_vowels \"fedcba\" == \"fdcb\")\n    check (remove_vowels \"eeeee\" == \"\")\n    check (remove_vowels \"acBAA\" == \"cB\")\n    check (remove_vowels \"EcBOO\" == \"cB\")\n    check (remove_vowels \"ybcd\" == \"ybcd\")\n"}
{"task_id": "Haskell/52", "prompt": "-- Return True if all numbers in the list l are below threshold t.\n-- >>> below_threshold [1,2,4,10] 100\n-- True\n-- >>> below_threshold [1,20,4,10] 5\n-- False\nbelow_threshold :: [Int] -> Int -> Bool", "canonical_solution": "-- Task ID: HumanEval/52\n-- Assigned To: Author C\n\n-- Python Implementation:\n\n-- \n-- \n-- def below_threshold(l: list, t: int):\n--     \"\"\"Return True if all numbers in the list l are below threshold t.\n--     >>> below_threshold([1, 2, 4, 10], 100)\n--     True\n--     >>> below_threshold([1, 20, 4, 10], 5)\n--     False\n--     \"\"\"\n--     for e in l:\n--         if e >= t:\n--             return False\n--     return True\n-- \n\n\n-- Haskell Implementation:\n\n-- Return True if all numbers in the list l are below threshold t.\n-- >>> below_threshold [1,2,4,10] 100\n-- True\n-- >>> below_threshold [1,20,4,10] 5\n-- False\nbelow_threshold :: [Int] -> Int -> Bool\nbelow_threshold numbers threshold =  all (< threshold) numbers\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (below_threshold [1,2,4,10] 100 == True)\n    check (below_threshold [1,20,4,10] 5   == False)\n    check (below_threshold [1,20,4,10] 21  == True)\n    check (below_threshold [1,20,4,10] 22  == True)\n    check (below_threshold [1,8,4,10]  11  == True)\n    check (below_threshold [1,8,4,10]  10  == False)\n"}
{"task_id": "Haskell/53", "prompt": "-- Add two numbers x and y\n-- >>> add 2 3\n-- 5\n-- >>> add 5 7\n-- 12\nadd :: Int -> Int -> Int", "canonical_solution": "-- Task ID: HumanEval/53\n-- Assigned To: Author C\n\n-- Python Implementation:\n\n-- \n-- \n-- def add(x: int, y: int):\n--     \"\"\"Add two numbers x and y\n--     >>> add(2, 3)\n--     5\n--     >>> add(5, 7)\n--     12\n--     \"\"\"\n--     return x + y\n-- \n\n\n-- Haskell Implementation:\n\n-- Add two numbers x and y\n-- >>> add 2 3\n-- 5\n-- >>> add 5 7\n-- 12\nadd :: Int -> Int -> Int\nadd =  (+)\n", "test": "\n\n-- Test suite\n\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\n main :: IO ()\nmain = do\n    check (add 0 1 == 1)\n    check (add 1 0 == 1)\n    check (add 2 3 == 5)\n    check (add 5 7 == 12)\n    check (add 7 5 == 12)\n    forM_ [1..100] $ \\_ -> do\n        x <- randomRIO (0,1000)\n        y <- randomRIO (0,1000)\n        check (add x y == x + y)\n"}
{"task_id": "Haskell/54", "prompt": "-- Check if two words have the same characters.\n-- >>> same_chars \"eabcdzzzz\" \"dddzzzzzzzddeddabc\"\n-- True\n-- >>> same_chars \"abcd\" \"dddddddabc\"\n-- True\n-- >>> same_chars \"dddddddabc\" \"abcd\"\n-- True\n-- >>> same_chars \"eabcd\" \"dddddddabc\"\n-- False\n-- >>> same_chars \"abcd\" \"dddddddabce\"\n-- False\n-- >>> same_chars \"eabcdzzzz\" \"dddzzzzzzzddddabc\"\n-- False\nsame_chars :: String -> String -> Bool", "canonical_solution": "-- Task ID: HumanEval/54\n-- Assigned To: Author C\n\n-- Python Implementation:\n\n-- \n-- \n-- def same_chars(s0: str, s1: str):\n--     \"\"\"\n--     Check if two words have the same characters.\n--     >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n--     True\n--     >>> same_chars('abcd', 'dddddddabc')\n--     True\n--     >>> same_chars('dddddddabc', 'abcd')\n--     True\n--     >>> same_chars('eabcd', 'dddddddabc')\n--     False\n--     >>> same_chars('abcd', 'dddddddabce')\n--     False\n--     >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n--     False\n--     \"\"\"\n--     return set(s0) == set(s1)\n-- \n\n\n-- Haskell Implementation:\nimport Data.List (nub, sort)\n\n-- Check if two words have the same characters.\n-- >>> same_chars \"eabcdzzzz\" \"dddzzzzzzzddeddabc\"\n-- True\n-- >>> same_chars \"abcd\" \"dddddddabc\"\n-- True\n-- >>> same_chars \"dddddddabc\" \"abcd\"\n-- True\n-- >>> same_chars \"eabcd\" \"dddddddabc\"\n-- False\n-- >>> same_chars \"abcd\" \"dddddddabce\"\n-- False\n-- >>> same_chars \"eabcdzzzz\" \"dddzzzzzzzddddabc\"\n-- False\nsame_chars :: String -> String -> Bool\nsame_chars s0 s1 =  sort (nub s0) ==  sort (nub s1)\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (same_chars \"eabcdzzzz\" \"dddzzzzzzzddeddabc\" == True)\n    check (same_chars \"abcd\"      \"dddddddabc\"         == True)\n    check (same_chars \"dddddddabc\" \"abcd\"              == True)\n    check (same_chars \"eabcd\"     \"dddddddabc\"         == False)\n    check (same_chars \"abcd\"      \"dddddddabcf\"        == False)\n    check (same_chars \"eabcdzzzz\" \"dddzzzzzzzddddabc\"  == False)\n    check (same_chars \"aabb\"      \"aaccc\"              == False)\n"}
{"task_id": "Haskell/55", "prompt": "-- Return n-th Fibonacci number.\n-- >>> fib 10\n-- 55\n-- >>> fib 1\n-- 1\n-- >>> fib 8\n-- 21\nfib :: Int -> Int", "canonical_solution": "-- Task ID: HumanEval/55\n-- Assigned To: Author C\n\n-- Python Implementation:\n\n-- \n-- \n-- def fib(n: int):\n--     \"\"\"Return n-th Fibonacci number.\n--     >>> fib(10)\n--     55\n--     >>> fib(1)\n--     1\n--     >>> fib(8)\n--     21\n--     \"\"\"\n--     if n == 0:\n--         return 0\n--     if n == 1:\n--         return 1\n--     return fib(n - 1) + fib(n - 2)\n-- \n\n\n-- Haskell Implementation:\n\n-- Return n-th Fibonacci number.\n-- >>> fib 10\n-- 55\n-- >>> fib 1\n-- 1\n-- >>> fib 8\n-- 21\nfib :: Int -> Int\nfib n =  fib' n 0 1\n  where\n    fib' :: Int -> Int -> Int -> Int\n    fib' 0 a b =  a\n    fib' n a b =  fib' (n - 1) b  (a + b)\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (fib 10 == 55)\n    check (fib 1  == 1)\n    check (fib 8  == 21)\n    check (fib 11 == 89)\n    check (fib 12 == 144)\n"}
{"task_id": "Haskell/56", "prompt": "-- brackets is a string of \"<\" and \">\".\n-- return True if every opening bracket has a corresponding closing bracket.\n-- >>> correct_bracketing \"<\"\n-- False\n-- >>> correct_bracketing \"<>\"\n-- True\n-- >>> correct_bracketing \"<<><>>\"\n-- True\n-- >>> correct_bracketing \"><<>\"\n-- False\ncorrect_bracketing :: String -> Bool", "canonical_solution": "-- Task ID: HumanEval/56\n-- Assigned To: Author C\n\n-- Python Implementation:\n\n-- \n-- \n-- def correct_bracketing(brackets: str):\n--     \"\"\" brackets is a string of \"<\" and \">\".\n--     return True if every opening bracket has a corresponding closing bracket.\n-- \n--     >>> correct_bracketing(\"<\")\n--     False\n--     >>> correct_bracketing(\"<>\")\n--     True\n--     >>> correct_bracketing(\"<<><>>\")\n--     True\n--     >>> correct_bracketing(\"><<>\")\n--     False\n--     \"\"\"\n--     depth = 0\n--     for b in brackets:\n--         if b == \"<\":\n--             depth += 1\n--         else:\n--             depth -= 1\n--         if depth < 0:\n--             return False\n--     return depth == 0\n-- \n\n\n-- Haskell Implementation:\n\n-- brackets is a string of \"<\" and \">\".\n-- return True if every opening bracket has a corresponding closing bracket.\n-- >>> correct_bracketing \"<\"\n-- False\n-- >>> correct_bracketing \"<>\"\n-- True\n-- >>> correct_bracketing \"<<><>>\"\n-- True\n-- >>> correct_bracketing \"><<>\"\n-- False\ncorrect_bracketing :: String -> Bool\ncorrect_bracketing = go 0\n  where\n    go :: Int -> String -> Bool\n    go depth []\n      = depth == 0\n    go depth (c:cs)\n      | depth < 0   = False\n      | c == '<'    = go (depth + 1) cs\n      | otherwise   = go (depth - 1) cs\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (correct_bracketing \"<>\"                       == True)\n    check (correct_bracketing \"<<><>>\"                   == True)\n    check (correct_bracketing \"<><><<><>><>\"            == True)\n    check (correct_bracketing \"<><><<<><><>><>><<><><<>>>\" == True)\n    check (correct_bracketing \"<<<><>>>>\"                == False)\n    check (correct_bracketing \"><<>\"                     == False)\n    check (correct_bracketing \"<\"                        == False)\n    check (correct_bracketing \"<<<<\"                     == False)\n    check (correct_bracketing \">\"                        == False)\n    check (correct_bracketing \"<<>\"                      == False)\n    check (correct_bracketing \"<><><<><>><>><<>\"         == False)\n    check (correct_bracketing \"<><><<><>><>>><>\"        == False)\n"}
{"task_id": "Haskell/57", "prompt": "-- Return True is list elements are monotonically increasing or decreasing.\n-- >>> monotonic [1,2,4,20]\n-- True\n-- >>> monotonic [1,20,4,10]\n-- False\n-- >>> monotonic [4,1,0,-10]\n-- True\nmonotonic :: [Int] -> Bool", "canonical_solution": "-- Task ID: HumanEval/57\n-- Assigned To: Author C\n\n-- Python Implementation:\n\n-- \n-- \n-- def monotonic(l: list):\n--     \"\"\"Return True is list elements are monotonically increasing or decreasing.\n--     >>> monotonic([1, 2, 4, 20])\n--     True\n--     >>> monotonic([1, 20, 4, 10])\n--     False\n--     >>> monotonic([4, 1, 0, -10])\n--     True\n--     \"\"\"\n--     if l == sorted(l) or l == sorted(l, reverse=True):\n--         return True\n--     return False\n-- \n\n\n-- Haskell Implementation:\nimport Data.List (sort)\n\n-- Return True is list elements are monotonically increasing or decreasing.\n-- >>> monotonic [1,2,4,20]\n-- True\n-- >>> monotonic [1,20,4,10]\n-- False\n-- >>> monotonic [4,1,0,-10]\n-- True\nmonotonic :: [Int] -> Bool\nmonotonic l =  l == sort l || l ==  reverse (sort l)\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (monotonic [1,2,4,10]       == True)\n    check (monotonic [1,2,4,20]       == True)\n    check (monotonic [1,20,4,10]      == False)\n    check (monotonic [4,1,0,-10]      == True)\n    check (monotonic [4,1,1,0]        == True)\n    check (monotonic [1,2,3,2,5,60]   == False)\n    check (monotonic [1,2,3,4,5,60]   == True)\n    check (monotonic [9,9,9,9]        == True)\n"}
{"task_id": "Haskell/58", "prompt": "-- Return sorted unique common elements for two lists.\n-- >>> common [1,4,3,34,653,2,5] [5,7,1,5,9,653,121]\n-- [1,5,653]\n-- >>> common [5,3,2,8] [3,2]\n-- [2,3]\ncommon :: [Int] -> [Int] -> [Int]", "canonical_solution": "-- Task ID: HumanEval/58\n-- Assigned To: Author C\n\n-- Python Implementation:\n\n-- \n-- \n-- def common(l1: list, l2: list):\n--     \"\"\"Return sorted unique common elements for two lists.\n--     >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n--     [1, 5, 653]\n--     >>> common([5, 3, 2, 8], [3, 2])\n--     [2, 3]\n-- \n--     \"\"\"\n--     ret = set()\n--     for e1 in l1:\n--         for e2 in l2:\n--             if e1 == e2:\n--                 ret.add(e1)\n--     return sorted(list(ret))\n-- \n\n\n-- Haskell Implementation:\nimport Data.List (sort, nub, intersect)\n\n-- Return sorted unique common elements for two lists.\n-- >>> common [1,4,3,34,653,2,5] [5,7,1,5,9,653,121]\n-- [1,5,653]\n-- >>> common [5,3,2,8] [3,2]\n-- [2,3]\ncommon :: [Int] -> [Int] -> [Int]\ncommon l1 l2 =  sort $ nub $ l1 `intersect` l2\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (common [1,4,3,34,653,2,5] [5,7,1,5,9,653,121] == [1,5,653])\n    check (common [5,3,2,8]           [3,2]               == [2,3])\n    check (common [4,3,2,8]           [3,2,4]             == [2,3,4])\n    check (common [4,3,2,8]           []                  == [])\n"}
{"task_id": "Haskell/59", "prompt": "-- Return the largest prime factor of n. Assume n > 1 and is not a prime.\n-- >>> largest_prime_factor 13195\n-- 29\n-- >>> largest_prime_factor 2048\n-- 2\nlargest_prime_factor :: Int -> Int", "canonical_solution": "-- Task ID: HumanEval/59\n-- Assigned To: Author C\n\n-- Python Implementation:\n\n-- \n-- \n-- def largest_prime_factor(n: int):\n--     \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n--     >>> largest_prime_factor(13195)\n--     29\n--     >>> largest_prime_factor(2048)\n--     2\n--     \"\"\"\n--     def is_prime(k):\n--         if k < 2:\n--             return False\n--         for i in range(2, k - 1):\n--             if k % i == 0:\n--                 return False\n--         return True\n--     largest = 1\n--     for j in range(2, n + 1):\n--         if n % j == 0 and is_prime(j):\n--             largest = max(largest, j)\n--     return largest\n-- \n\n\n-- Haskell Implementation:\n\n-- Return the largest prime factor of n. Assume n > 1 and is not a prime.\n-- >>> largest_prime_factor 13195\n-- 29\n-- >>> largest_prime_factor 2048\n-- 2\nlargest_prime_factor :: Int -> Int\nlargest_prime_factor n =  maximum $ filter (\\x -> n `mod` x == 0) $  filter is_prime [2..n]\n  where \n    is_prime :: Int -> Bool\n    is_prime k =  null [x | x <-  [2..k-1], k `mod` x == 0]", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (largest_prime_factor 15    == 5)\n    check (largest_prime_factor 27    == 3)\n    check (largest_prime_factor 63    == 7)\n    check (largest_prime_factor 330   == 11)\n    check (largest_prime_factor 13195 == 29)\n"}
{"task_id": "Haskell/60", "prompt": "-- sum_to_n is a function that sums numbers from 1 to n.\n-- >>> sum_to_n 30\n-- 465\n-- >>> sum_to_n 100\n-- 5050\n-- >>> sum_to_n 5\n-- 15\n-- >>> sum_to_n 10\n-- 55\n-- >>> sum_to_n 1\n-- 1\nsum_to_n :: Int -> Int", "canonical_solution": "-- Task ID: HumanEval/60\n-- Assigned To: Author C\n\n-- Python Implementation:\n\n-- \n-- \n-- def sum_to_n(n: int):\n--     \"\"\"sum_to_n is a function that sums numbers from 1 to n.\n--     >>> sum_to_n(30)\n--     465\n--     >>> sum_to_n(100)\n--     5050\n--     >>> sum_to_n(5)\n--     15\n--     >>> sum_to_n(10)\n--     55\n--     >>> sum_to_n(1)\n--     1\n--     \"\"\"\n--     return sum(range(n + 1))\n-- \n\n\n-- Haskell Implementation:\n\n-- sum_to_n is a function that sums numbers from 1 to n.\n-- >>> sum_to_n 30\n-- 465\n-- >>> sum_to_n 100\n-- 5050\n-- >>> sum_to_n 5\n-- 15\n-- >>> sum_to_n 10\n-- 55\n-- >>> sum_to_n 1\n-- 1\nsum_to_n :: Int -> Int\nsum_to_n n =  sum [1..n]\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (sum_to_n 1 == 1)\n    check (sum_to_n 6 == 21)\n    check (sum_to_n 11 == 66)\n    check (sum_to_n 30 == 465)\n    check (sum_to_n 100 == 5050)\n"}
{"task_id": "Haskell/61", "prompt": "-- brackets is a string of \"(\" and \")\".\n-- return True if every opening bracket has a corresponding closing bracket.\n-- >>> correct_bracketing \"(\"\n-- False\n-- >>> correct_bracketing \"()\"\n-- True\n-- >>> correct_bracketing \"(()())\"\n-- True\n-- >>> correct_bracketing \")(()\"\n-- False\ncorrect_bracketing :: String -> Bool", "canonical_solution": "-- Task ID: HumanEval/61\n-- Assigned To: Author C\n\n-- Python Implementation:\n\n-- \n-- \n-- def correct_bracketing(brackets: str):\n--     \"\"\" brackets is a string of \"(\" and \")\".\n--     return True if every opening bracket has a corresponding closing bracket.\n-- \n--     >>> correct_bracketing(\"(\")\n--     False\n--     >>> correct_bracketing(\"()\")\n--     True\n--     >>> correct_bracketing(\"(()())\")\n--     True\n--     >>> correct_bracketing(\")(()\")\n--     False\n--     \"\"\"\n--     depth = 0\n--     for b in brackets:\n--         if b == \"(\":\n--             depth += 1\n--         else:\n--             depth -= 1\n--         if depth < 0:\n--             return False\n--     return depth == 0\n-- \n\n\n-- Haskell Implementation:\n\n-- brackets is a string of \"(\" and \")\".\n-- return True if every opening bracket has a corresponding closing bracket.\n\n-- >>> correct_bracketing \"(\"\n-- False\n-- >>> correct_bracketing \"()\"\n-- True\n-- >>> correct_bracketing \"(()())\"\n-- True\n-- >>> correct_bracketing \")(()\"\n-- False\ncorrect_bracketing :: String -> Bool\ncorrect_bracketing = go 0\n  where\n    go :: Int -> String -> Bool\n    go depth []        = depth == 0\n    go depth (_:_) | depth < 0 = False\n    go depth (c:cs)\n      | c == '('        = go (depth + 1) cs\n      | c == ')'        = go (depth - 1) cs\n      | otherwise       = go depth       cs\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (correct_bracketing \"()\" == True)\n    check (correct_bracketing \"(()())\" == True)\n    check (correct_bracketing \"()()(()())()\" == True)\n    check (correct_bracketing \"()()((()()())())(()()(()))\" == True)\n    check (correct_bracketing \"((()())))\" == False)\n    check (correct_bracketing \")(()\" == False)\n    check (correct_bracketing \"(\" == False)\n    check (correct_bracketing \"((((\" == False)\n    check (correct_bracketing \")\" == False)\n    check (correct_bracketing \"(()\" == False)\n    check (correct_bracketing \"()()(()())())(()\" == False)\n    check (correct_bracketing \"()()(()())()))()\" == False)\n"}
{"task_id": "Haskell/62", "prompt": "-- xs represent coefficients of a polynomial.\n-- xs[0] + xs[1] * x + xs[2] * x^2 + ....\n-- Return derivative of this polynomial in the same form.\n-- >>> derivative [3,1,2,4,5]\n-- [1,4,12,20]\n-- >>> derivative [1,2,3]\n-- [2,6]\nderivative :: [Int] -> [Int]", "canonical_solution": "-- Task ID: HumanEval/62\n-- Assigned To: Author C\n\n-- Python Implementation:\n\n-- \n-- \n-- def derivative(xs: list):\n--     \"\"\" xs represent coefficients of a polynomial.\n--     xs[0] + xs[1] * x + xs[2] * x^2 + ....\n--     Return derivative of this polynomial in the same form.\n--     >>> derivative([3, 1, 2, 4, 5])\n--     [1, 4, 12, 20]\n--     >>> derivative([1, 2, 3])\n--     [2, 6]\n--     \"\"\"\n--     return [(i * x) for i, x in enumerate(xs)][1:]\n-- \n\n\n-- Haskell Implementation:\n\n-- xs represent coefficients of a polynomial.\n-- xs[0] + xs[1] * x + xs[2] * x^2 + ....\n-- Return derivative of this polynomial in the same form.\n-- >>> derivative [3,1,2,4,5]\n-- [1,4,12,20]\n-- >>> derivative [1,2,3]\n-- [2,6]\nderivative :: [Int] -> [Int]\nderivative xs =  [i * x | (i, x) <-  zip [1..] (tail xs)]\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (derivative [3, 1, 2, 4, 5] == [1, 4, 12, 20])\n    check (derivative [1, 2, 3] == [2, 6])\n    check (derivative [3, 2, 1] == [2, 2])\n    check (derivative [3, 2, 1, 0, 4] == [2, 2, 0, 16])\n    check (derivative [1] == [])\n"}
{"task_id": "Haskell/63", "prompt": "-- The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n-- fibfib(0) == 0\n-- fibfib(1) == 0\n-- fibfib(2) == 1\n-- fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n-- Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n-- >>> fibfib 1\n-- 0\n-- >>> fibfib 5\n-- 4\n-- >>> fibfib 8\n-- 24\nfibfib :: Int -> Int", "canonical_solution": "-- Task ID: HumanEval/63\n-- Assigned To: Author C\n\n-- Python Implementation:\n\n-- \n-- \n-- def fibfib(n: int):\n--     \"\"\"The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n--     fibfib(0) == 0\n--     fibfib(1) == 0\n--     fibfib(2) == 1\n--     fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n--     Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n--     >>> fibfib(1)\n--     0\n--     >>> fibfib(5)\n--     4\n--     >>> fibfib(8)\n--     24\n--     \"\"\"\n--     if n == 0:\n--         return 0\n--     if n == 1:\n--         return 0\n--     if n == 2:\n--         return 1\n--     return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n-- \n\n\n-- Haskell Implementation:\n\n-- The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n-- fibfib(0) == 0\n-- fibfib(1) == 0\n-- fibfib(2) == 1\n-- fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n-- Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n-- >>> fibfib 1\n-- 0\n-- >>> fibfib 5\n-- 4\n-- >>> fibfib 8\n-- 24\nfibfib :: Int -> Int\nfibfib n\n  | n == 0 =  0\n  | n == 1 =  0\n  | n == 2 =  1\n  | otherwise =  fibfib (n - 1) + fibfib (n - 2) +  fibfib (n - 3)\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (fibfib 2 == 1)\n    check (fibfib 1 == 0)\n    check (fibfib 5 == 4)\n    check (fibfib 8 == 24)\n    check (fibfib 10 == 81)\n    check (fibfib 12 == 274)\n    check (fibfib 14 == 927)\n"}
{"task_id": "Haskell/64", "prompt": "-- Write a function vowels_count which takes a string representing\n-- a word as input and returns the number of vowels in the string.\n-- Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n-- vowel, but only when it is at the end of the given word.\n-- Example:\n-- >>> vowels_count \"abcde\"\n-- 2\n-- >>> vowels_count \"ACEDY\"\n-- 3\nvowels_count :: String -> Int", "canonical_solution": "-- Task ID: HumanEval/64\n-- Assigned To: Author C\n\n-- Python Implementation:\n\n-- \n-- FIX = \"\"\"\n-- Add more test cases.\n-- \"\"\"\n-- \n-- def vowels_count(s):\n--     \"\"\"Write a function vowels_count which takes a string representing\n--     a word as input and returns the number of vowels in the string.\n--     Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n--     vowel, but only when it is at the end of the given word.\n-- \n--     Example:\n--     >>> vowels_count(\"abcde\")\n--     2\n--     >>> vowels_count(\"ACEDY\")\n--     3\n--     \"\"\"\n--     vowels = \"aeiouAEIOU\"\n--     n_vowels = sum(c in vowels for c in s)\n--     if s[-1] == 'y' or s[-1] == 'Y':\n--         n_vowels += 1\n--     return n_vowels\n-- \n\n\n-- Haskell Implementation:\n\n-- Write a function vowels_count which takes a string representing\n-- a word as input and returns the number of vowels in the string.\n-- Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n-- vowel, but only when it is at the end of the given word.\n\n-- Example:\n-- >>> vowels_count \"abcde\"\n-- 2\n-- >>> vowels_count \"ACEDY\"\n-- 3\nvowels_count :: String -> Int\nvowels_count [] = 0\nvowels_count s  =\n    let base = length $ filter (`elem` \"aeiouAEIOU\") s\n    in base + if last s `elem` \"yY\" then 1 else 0\n\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (vowels_count \"abcde\" == 2)\n    check (vowels_count \"Alone\" == 3)\n    check (vowels_count \"key\" == 2)\n    check (vowels_count \"bye\" == 1)\n    check (vowels_count \"keY\" == 2)\n    check (vowels_count \"bYe\" == 1)\n    check (vowels_count \"ACEDY\" == 3)\n"}
{"task_id": "Haskell/65", "prompt": "-- Circular shift the digits of the integer x, shift the digits right by shift\n-- and return the result as a string.\n-- If shift > number of digits, return digits reversed.\n-- >>> circular_shift 12 1\n-- \"21\"\n-- >>> circular_shift 12 2\n-- \"12\"\ncircular_shift :: Int -> Int -> String", "canonical_solution": "-- Task ID: HumanEval/65\n-- Assigned To: Author C\n\n-- Python Implementation:\n\n-- \n-- def circular_shift(x, shift):\n--     \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n--     and return the result as a string.\n--     If shift > number of digits, return digits reversed.\n--     >>> circular_shift(12, 1)\n--     \"21\"\n--     >>> circular_shift(12, 2)\n--     \"12\"\n--     \"\"\"\n--     s = str(x)\n--     if shift > len(s):\n--         return s[::-1]\n--     else:\n--         return s[len(s) - shift:] + s[:len(s) - shift]\n-- \n\n\n-- Haskell Implementation:\n\n-- Circular shift the digits of the integer x, shift the digits right by shift\n-- and return the result as a string.\n-- If shift > number of digits, return digits reversed.\n-- >>> circular_shift 12 1\n-- \"21\"\n-- >>> circular_shift 12 2\n-- \"12\"\ncircular_shift :: Int -> Int -> String\ncircular_shift x shift\n  | shift > length s =  reverse s\n  | otherwise =  drop (length s - shift) s ++  take (length s - shift) s\n  where \n    s :: String\n    s =  show x", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (circular_shift 100 2 == \"001\")\n    check (circular_shift 12 2 == \"12\")\n    check (circular_shift 97 8 == \"79\")\n    check (circular_shift 12 1 == \"21\")\n    check (circular_shift 11 101 == \"11\")\n"}
{"task_id": "Haskell/66", "prompt": "-- Task\n-- Write a function that takes a string as input and returns the sum of the upper characters only'\n-- ASCII codes.\n-- Examples:\n--     digitSum \"\" => 0\n--     digitSum \"abAB\" => 131\n--     digitSum \"abcCd\" => 67\n--     digitSum \"helloE\" => 69\n--     digitSum \"woArBld\" => 131\n--     digitSum \"aAaaaXa\" => 153\ndigitSum :: String -> Int", "canonical_solution": "-- Task ID: HumanEval/66\n-- Assigned To: Author E\n\n-- Python Implementation:\n\n-- \n-- def digitSum(s):\n--     \"\"\"Task\n--     Write a function that takes a string as input and returns the sum of the upper characters only'\n--     ASCII codes.\n-- \n--     Examples:\n--         digitSum(\"\") => 0\n--         digitSum(\"abAB\") => 131\n--         digitSum(\"abcCd\") => 67\n--         digitSum(\"helloE\") => 69\n--         digitSum(\"woArBld\") => 131\n--         digitSum(\"aAaaaXa\") => 153\n--     \"\"\"\n--     if s == \"\": return 0\n--     return sum(ord(char) if char.isupper() else 0 for char in s)\n-- \n\n\n-- Haskell Implementation:\nimport Data.Char\n\n-- Task\n-- Write a function that takes a string as input and returns the sum of the upper characters only'\n-- ASCII codes.\n--\n-- Examples:\n--     digitSum \"\" => 0\n--     digitSum \"abAB\" => 131\n--     digitSum \"abcCd\" => 67\n--     digitSum \"helloE\" => 69\n--     digitSum \"woArBld\" => 131\n--     digitSum \"aAaaaXa\" => 153\ndigitSum :: String -> Int\ndigitSum s =  sum [ord c | c <- s,  isUpper c]\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (digitSum \"\" == 0)\n    check (digitSum \"abAB\" == 131)\n    check (digitSum \"abcCd\" == 67)\n    check (digitSum \"helloE\" == 69)\n    check (digitSum \"woArBld\" == 131)\n    check (digitSum \"aAaaaXa\" == 153)\n    check (digitSum \" How are yOu?\" == 151)\n    check (digitSum \"You arE Very Smart\" == 327)\n"}
{"task_id": "Haskell/67", "prompt": "-- In this task, you will be given a string that represents a number of apples and oranges\n-- that are distributed in a basket of fruit this basket contains\n-- apples, oranges, and mango fruits. Given the string that represents the total number of\n-- the oranges and apples and an integer that represent the total number of the fruits\n-- in the basket return the number of the mango fruits in the basket.\n-- for examble:\n-- fruit_distribution \"5 apples and 6 oranges\" 19 ->19 - 5 - 6 = 8\n-- fruit_distribution \"0 apples and 1 oranges\" 3 -> 3 - 0 - 1 = 2\n-- fruit_distribution \"2 apples and 3 oranges\" 100 -> 100 - 2 - 3 = 95\n-- fruit_distribution \"100 apples and 1 oranges\" 120 -> 120 - 100 - 1 = 19\nfruit_distribution :: String -> Int -> Int", "canonical_solution": "-- Task ID: HumanEval/67\n-- Assigned To: Author E\n\n-- Python Implementation:\n\n-- \n-- def fruit_distribution(s,n):\n--     \"\"\"\n--     In this task, you will be given a string that represents a number of apples and oranges \n--     that are distributed in a basket of fruit this basket contains \n--     apples, oranges, and mango fruits. Given the string that represents the total number of \n--     the oranges and apples and an integer that represent the total number of the fruits \n--     in the basket return the number of the mango fruits in the basket.\n--     for examble:\n--     fruit_distribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n--     fruit_distribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n--     fruit_distribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n--     fruit_distribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n--     \"\"\"\n--     lis = list()\n--     for i in s.split(' '):\n--         if i.isdigit():\n--             lis.append(int(i))\n--     return n - sum(lis)\n-- \n\n\n-- Haskell Implementation:\nimport Data.Char\n\n-- In this task, you will be given a string that represents a number of apples and oranges\n-- that are distributed in a basket of fruit this basket contains\n-- apples, oranges, and mango fruits. Given the string that represents the total number of\n-- the oranges and apples and an integer that represent the total number of the fruits\n-- in the basket return the number of the mango fruits in the basket.\n-- for examble:\n-- fruit_distribution \"5 apples and 6 oranges\" 19 ->19 - 5 - 6 = 8\n-- fruit_distribution \"0 apples and 1 oranges\" 3 -> 3 - 0 - 1 = 2\n-- fruit_distribution \"2 apples and 3 oranges\" 100 -> 100 - 2 - 3 = 95\n-- fruit_distribution \"100 apples and 1 oranges\" 120 -> 120 - 100 - 1 = 19\n\nfruit_distribution :: String -> Int -> Int\nfruit_distribution s n =  n - sum (map read (words (filter (\\x ->  isDigit x || isSpace x) s)) :: [Int])\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (fruit_distribution \"5 apples and 6 oranges\" 19 == 8)\n    check (fruit_distribution \"5 apples and 6 oranges\" 21 == 10)\n    check (fruit_distribution \"0 apples and 1 oranges\" 3 == 2)\n    check (fruit_distribution \"1 apples and 0 oranges\" 3 == 2)\n    check (fruit_distribution \"2 apples and 3 oranges\" 100 == 95)\n    check (fruit_distribution \"2 apples and 3 oranges\" 5 == 0)\n    check (fruit_distribution \"1 apples and 100 oranges\" 120 == 19)\n"}
{"task_id": "Haskell/68", "prompt": "-- Given an array representing a branch of a tree that has non-negative integer nodes\n-- your task is to pluck one of the nodes and return it.\n-- The plucked node should be the node with the smallest even value.\n-- If multiple nodes with the same smallest even value are found return the node that has smallest index.\n-- The plucked node should be returned in a list, [ smalest_value, its index ],\n-- If there are no even values or the given array is empty, return [].\n-- Example 1:\n--     Input: [4,2,3]\n--     Output: [2, 1]\n--     Explanation: 2 has the smallest even value, and 2 has the smallest index.\n-- Example 2:\n--     Input: [1,2,3]\n--     Output: [2, 1]\n--     Explanation: 2 has the smallest even value, and 2 has the smallest index.\n-- Example 3:\n--     Input: []\n--     Output: []\n-- Example 4:\n--     Input: [5, 0, 3, 0, 4, 2]\n--     Output: [0, 1]\n--     Explanation: 0 is the smallest value, but  there are two zeros,\n--                  so we will choose the first zero, which has the smallest index.\n-- Constraints:\n--     * 1 <= nodes.length <= 10000\n--     * 0 <= node.value\npluck :: [Int] -> [Int]", "canonical_solution": "-- Task ID: HumanEval/68\n-- Assigned To: Author E\n\n-- Python Implementation:\n\n-- \n-- def pluck(arr):\n--     \"\"\"\n--     \"Given an array representing a branch of a tree that has non-negative integer nodes\n--     your task is to pluck one of the nodes and return it.\n--     The plucked node should be the node with the smallest even value.\n--     If multiple nodes with the same smallest even value are found return the node that has smallest index.\n-- \n--     The plucked node should be returned in a list, [ smalest_value, its index ],\n--     If there are no even values or the given array is empty, return [].\n-- \n--     Example 1:\n--         Input: [4,2,3]\n--         Output: [2, 1]\n--         Explanation: 2 has the smallest even value, and 2 has the smallest index.\n-- \n--     Example 2:\n--         Input: [1,2,3]\n--         Output: [2, 1]\n--         Explanation: 2 has the smallest even value, and 2 has the smallest index. \n-- \n--     Example 3:\n--         Input: []\n--         Output: []\n--     \n--     Example 4:\n--         Input: [5, 0, 3, 0, 4, 2]\n--         Output: [0, 1]\n--         Explanation: 0 is the smallest value, but  there are two zeros,\n--                      so we will choose the first zero, which has the smallest index.\n-- \n--     Constraints:\n--         * 1 <= nodes.length <= 10000\n--         * 0 <= node.value\n--     \"\"\"\n--     if(len(arr) == 0): return []\n--     evens = list(filter(lambda x: x%2 == 0, arr))\n--     if(evens == []): return []\n--     return [min(evens), arr.index(min(evens))]\n-- \n\n\n-- Haskell Implementation:\nimport Data.List\nimport Data.Ord\n\n-- Given an array representing a branch of a tree that has non-negative integer nodes\n-- your task is to pluck one of the nodes and return it.\n-- The plucked node should be the node with the smallest even value.\n-- If multiple nodes with the same smallest even value are found return the node that has smallest index.\n--\n-- The plucked node should be returned in a list, [ smalest_value, its index ],\n-- If there are no even values or the given array is empty, return [].\n--\n-- Example 1:\n--     Input: [4,2,3]\n--     Output: [2, 1]\n--     Explanation: 2 has the smallest even value, and 2 has the smallest index.\n--\n-- Example 2:\n--     Input: [1,2,3]\n--     Output: [2, 1]\n--     Explanation: 2 has the smallest even value, and 2 has the smallest index.\n--\n-- Example 3:\n--     Input: []\n--     Output: []\n--\n-- Example 4:\n--     Input: [5, 0, 3, 0, 4, 2]\n--     Output: [0, 1]\n--     Explanation: 0 is the smallest value, but  there are two zeros,\n--                  so we will choose the first zero, which has the smallest index.\n--\n-- Constraints:\n--     * 1 <= nodes.length <= 10000\n--     * 0 <= node.value\n\npluck :: [Int] -> [Int]\npluck xs =\n  case filter (even . fst) (zip xs [0..]) of\n    []   -> []\n    evs  -> let (v,i) = minimumBy (comparing fst <> comparing snd) evs\n            in [v,i]\n    ", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (pluck [4, 2, 3] == [2, 1])\n    check (pluck [1, 2, 3] == [2, 1])\n    check (pluck [] == [])\n    check (pluck [5, 0, 3, 0, 4, 2] == [0, 1])\n    check (pluck [1, 2, 3, 0, 5, 3] == [0, 3])\n    check (pluck [5, 4, 8, 4, 8] == [4, 1])\n    check (pluck [7, 6, 7, 1] == [6, 1])\n    check (pluck [7, 9, 7, 1] == [])\n"}
{"task_id": "Haskell/69", "prompt": "-- You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n-- zero, and has a frequency greater than or equal to the value of the integer itself.\n-- The frequency of an integer is the number of times it appears in the list.\n-- If no such a value exist, return -1.\n-- Examples:\n--     search [4, 1, 2, 2, 3, 1] == 2\n--     search [1, 2, 2, 3, 3, 3, 4, 4, 4] == 3\n--     search [5, 5, 4, 4, 4] == -1\nsearch :: [Int] -> Int", "canonical_solution": "-- Task ID: HumanEval/69\n-- Assigned To: Author E\n\n-- Python Implementation:\n\n-- \n-- def search(lst):\n--     '''\n--     You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n--     zero, and has a frequency greater than or equal to the value of the integer itself. \n--     The frequency of an integer is the number of times it appears in the list.\n--     If no such a value exist, return -1.\n--     Examples:\n--         search([4, 1, 2, 2, 3, 1]) == 2\n--         search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n--         search([5, 5, 4, 4, 4]) == -1\n--     '''\n--     frq = [0] * (max(lst) + 1)\n--     for i in lst:\n--         frq[i] += 1;\n-- \n--     ans = -1\n--     for i in range(1, len(frq)):\n--         if frq[i] >= i:\n--             ans = i\n--     \n--     return ans\n-- \n\n\n-- Haskell Implementation:\n\n-- You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n-- zero, and has a frequency greater than or equal to the value of the integer itself.\n-- The frequency of an integer is the number of times it appears in the list.\n-- If no such a value exist, return -1.\n-- Examples:\n--     search [4, 1, 2, 2, 3, 1] == 2\n--     search [1, 2, 2, 3, 3, 3, 4, 4, 4] == 3\n--     search [5, 5, 4, 4, 4] == -1\n\nsearch :: [Int] -> Int\nsearch lst =  let frq = map (\\x ->  length (filter (== x) lst)) [0..(maximum lst)]\n             in if null [i | i <- [1..(length frq - 1)], frq !! i >= i]  then -1 else maximum [i | i <- [1..(length frq - 1)],  frq !! i >= i]\n             ", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    -- manually generated tests\n    check (search [5, 5, 5, 5, 1] == 1)\n    check (search [4, 1, 4, 1, 4, 4] == 4)\n    check (search [3, 3] == -1)\n    check (search [8, 8, 8, 8, 8, 8, 8, 8] == 8)\n    check (search [2, 3, 3, 2, 2] == 2)\n    -- automatically generated tests\n    check (search [2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1] == 1)\n    check (search [3, 2, 8, 2] == 2)\n    check (search [6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10] == 1)\n    check (search [8, 8, 3, 6, 5, 6, 4] == -1)\n    check (search [6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9] == 1)\n    check (search [1, 9, 10, 1, 3] == 1)\n    check (search [6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10] == 5)\n    check (search [1] == 1)\n    check (search [8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5] == 4)\n    check (search [2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10] == 2)\n    check (search [1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3] == 1)\n    check (search [9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4] == 4)\n    check (search [2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7] == 4)\n    check (search [9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1] == 2)\n    check (search [5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8] == -1)\n    check (search [10] == -1)\n    check (search [9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2] == 2)\n    check (search [5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8] == 1)\n    check (search [7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6] == 1)\n    check (search [3, 10, 10, 9, 2] == -1)\n"}
{"task_id": "Haskell/70", "prompt": "-- Given list of integers, return list in strange order.\n-- Strange sorting, is when you start with the minimum value,\n-- then maximum of the remaining integers, then minimum and so on.\n-- Examples:\n-- strange_sort_list [1, 2, 3, 4] == [1, 4, 2, 3]\n-- strange_sort_list [5, 5, 5, 5] == [5, 5, 5, 5]\n-- strange_sort_list [] == []\nstrange_sort_list :: [Int] -> [Int]", "canonical_solution": "-- Task ID: HumanEval/70\n-- Assigned To: Author E\n\n-- Python Implementation:\n\n-- \n-- def strange_sort_list(lst):\n--     '''\n--     Given list of integers, return list in strange order.\n--     Strange sorting, is when you start with the minimum value,\n--     then maximum of the remaining integers, then minimum and so on.\n-- \n--     Examples:\n--     strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n--     strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n--     strange_sort_list([]) == []\n--     '''\n--     res, switch = [], True\n--     while lst:\n--         res.append(min(lst) if switch else max(lst))\n--         lst.remove(res[-1])\n--         switch = not switch\n--     return res\n-- \n\n\n-- Haskell Implementation:\nimport Data.List\n\n-- Given list of integers, return list in strange order.\n-- Strange sorting, is when you start with the minimum value,\n-- then maximum of the remaining integers, then minimum and so on.\n--\n-- Examples:\n-- strange_sort_list [1, 2, 3, 4] == [1, 4, 2, 3]\n-- strange_sort_list [5, 5, 5, 5] == [5, 5, 5, 5]\n-- strange_sort_list [] == []\n\nstrange_sort_list :: [Int] -> [Int]\nstrange_sort_list lst =  let helper [] _ = []\n                            helper lst True =  minimum lst : helper (delete (minimum lst) lst) False\n                            helper lst False =  maximum lst : helper (delete (maximum lst) lst) True\n                        in  helper lst True\n                        ", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (strange_sort_list [1, 2, 3, 4] == [1, 4, 2, 3])\n    check (strange_sort_list [5, 6, 7, 8, 9] == [5, 9, 6, 8, 7])\n    check (strange_sort_list [1, 2, 3, 4, 5] == [1, 5, 2, 4, 3])\n    check (strange_sort_list [5, 6, 7, 8, 9, 1] == [1, 9, 5, 8, 6, 7])\n    check (strange_sort_list [5, 5, 5, 5] == [5, 5, 5, 5])\n    check (strange_sort_list [] == [])\n    check (strange_sort_list [1, 2, 3, 4, 5, 6, 7, 8] == [1, 8, 2, 7, 3, 6, 4, 5])\n    check (strange_sort_list [0, 2, 2, 2, 5, 5, -5, -5] == [-5, 5, -5, 5, 0, 2, 2, 2])\n    check (strange_sort_list [111111] == [111111])\n"}
{"task_id": "Haskell/71", "prompt": "-- Given the lengths of the three sides of a triangle. Return the area of\n-- the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n-- Otherwise return -1\n-- Three sides make a valid triangle when the sum of any two sides is greater\n-- than the third side.\n-- Example:\n-- triangle_area 3 4 5 == 6.00\n-- triangle_area 1 2 10 == -1\ntriangle_area :: Double -> Double -> Double -> Double", "canonical_solution": "-- Task ID: HumanEval/71\n-- Assigned To: Author E\n\n-- Python Implementation:\n\n-- \n-- def triangle_area(a, b, c):\n--     '''\n--     Given the lengths of the three sides of a triangle. Return the area of\n--     the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n--     Otherwise return -1\n--     Three sides make a valid triangle when the sum of any two sides is greater \n--     than the third side.\n--     Example:\n--     triangle_area(3, 4, 5) == 6.00\n--     triangle_area(1, 2, 10) == -1\n--     '''\n--     if a + b <= c or a + c <= b or b + c <= a:\n--         return -1 \n--     s = (a + b + c)/2    \n--     area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n--     area = round(area, 2)\n--     return area\n-- \n\n\n-- Haskell Implementation:\n\n-- Given the lengths of the three sides of a triangle. Return the area of\n-- the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n-- Otherwise return -1\n-- Three sides make a valid triangle when the sum of any two sides is greater\n-- than the third side.\n-- Example:\n-- triangle_area 3 4 5 == 6.00\n-- triangle_area 1 2 10 == -1\n\ntriangle_area :: Double -> Double -> Double -> Double\ntriangle_area a b c =  if a + b <= c || a + c <= b || b + c <= a then -1 else  round' (sqrt (s * (s - a) * (s - b) * (s - c))) 2\n                      where \n                        s :: Double\n                        s =  (a + b + c) / 2\n                        round' x n =  (fromInteger $ round $ x * (10^n)) / (10.0^^n)", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (triangle_area 3 4 5 == 6.00)\n    check (triangle_area 1 2 10 == -1.0)\n    check (abs (triangle_area 4 8 5 - 8.18) < 1e-6)\n    check (abs (triangle_area 2 2 2 - 1.73) < 1e-6)\n    check (triangle_area 1 2 3 == -1.0)\n    check (abs (triangle_area 10 5 7 - 16.25) < 1e-6)\n    check (triangle_area 2 6 3 == -1.0)\n    check (abs (triangle_area 1 1 1 - 0.43) < 1e-6)\n    check (triangle_area 2 2 10 == -1.0)\n"}
{"task_id": "Haskell/72", "prompt": "-- Write a function that returns True if the object q will fly, and False otherwise.\n-- The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n-- Example:\n-- will_it_fly [1, 2] 5 == False\n-- 1+2 is less than the maximum possible weight, but it's unbalanced.\n-- will_it_fly [3, 2, 3] 1 == False\n-- it's balanced, but 3+2+3 is more than the maximum possible weight.\n-- will_it_fly [3, 2, 3] 9 == True\n-- 3+2+3 is less than the maximum possible weight, and it's balanced.\n-- will_it_fly [3] 5 == True\n-- 3 is less than the maximum possible weight, and it's balanced.\nwill_it_fly :: [Int] -> Int -> Bool", "canonical_solution": "-- Task ID: HumanEval/72\n-- Assigned To: Author E\n\n-- Python Implementation:\n\n-- \n-- def will_it_fly(q,w):\n--     '''\n--     Write a function that returns True if the object q will fly, and False otherwise.\n--     The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n-- \n--     Example:\n--     will_it_fly([1, 2], 5) \u279e False \n--     # 1+2 is less than the maximum possible weight, but it's unbalanced.\n-- \n--     will_it_fly([3, 2, 3], 1) \u279e False\n--     # it's balanced, but 3+2+3 is more than the maximum possible weight.\n-- \n--     will_it_fly([3, 2, 3], 9) \u279e True\n--     # 3+2+3 is less than the maximum possible weight, and it's balanced.\n-- \n--     will_it_fly([3], 5) \u279e True\n--     # 3 is less than the maximum possible weight, and it's balanced.\n--     '''\n--     if sum(q) > w:\n--         return False\n-- \n--     i, j = 0, len(q)-1\n--     while i<j:\n--         if q[i] != q[j]:\n--             return False\n--         i+=1\n--         j-=1\n--     return True\n-- \n\n\n-- Haskell Implementation:\n\n-- Write a function that returns True if the object q will fly, and False otherwise.\n-- The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n--\n-- Example:\n-- will_it_fly [1, 2] 5 == False\n-- 1+2 is less than the maximum possible weight, but it's unbalanced.\n--\n-- will_it_fly [3, 2, 3] 1 == False\n-- it's balanced, but 3+2+3 is more than the maximum possible weight.\n--\n-- will_it_fly [3, 2, 3] 9 == True\n-- 3+2+3 is less than the maximum possible weight, and it's balanced.\n--\n-- will_it_fly [3] 5 == True\n-- 3 is less than the maximum possible weight, and it's balanced.\n\nwill_it_fly :: [Int] -> Int -> Bool\nwill_it_fly q w =  sum q <= w && q ==  reverse q\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (will_it_fly [3, 2, 3] 9 == True)\n    check (will_it_fly [1, 2] 5 == False)\n    check (will_it_fly [3] 5 == True)\n    check (will_it_fly [3, 2, 3] 1 == False)\n    check (will_it_fly [1, 2, 3] 6 == False)\n    check (will_it_fly [5] 5 == True)\n"}
{"task_id": "Haskell/73", "prompt": "-- Given an array arr of integers, find the minimum number of elements that\n-- need to be changed to make the array palindromic. A palindromic array is an array that\n-- is read the same backwards and forwards. In one change, you can change one element to any other element.\n-- For example:\n-- smallest_change [1,2,3,5,4,7,9,6] == 4\n-- smallest_change [1, 2, 3, 4, 3, 2, 2] == 1\n-- smallest_change [1, 2, 3, 2, 1] == 0\nsmallest_change :: [Int] -> Int", "canonical_solution": "-- Task ID: HumanEval/73\n-- Assigned To: Author E\n\n-- Python Implementation:\n\n-- \n-- def smallest_change(arr):\n--     \"\"\"\n--     Given an array arr of integers, find the minimum number of elements that\n--     need to be changed to make the array palindromic. A palindromic array is an array that\n--     is read the same backwards and forwards. In one change, you can change one element to any other element.\n-- \n--     For example:\n--     smallest_change([1,2,3,5,4,7,9,6]) == 4\n--     smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n--     smallest_change([1, 2, 3, 2, 1]) == 0\n--     \"\"\"\n--     ans = 0\n--     for i in range(len(arr) // 2):\n--         if arr[i] != arr[len(arr) - i - 1]:\n--             ans += 1\n--     return ans\n-- \n\n\n-- Haskell Implementation:\n\n-- Given an array arr of integers, find the minimum number of elements that\n-- need to be changed to make the array palindromic. A palindromic array is an array that\n-- is read the same backwards and forwards. In one change, you can change one element to any other element.\n--\n-- For example:\n-- smallest_change [1,2,3,5,4,7,9,6] == 4\n-- smallest_change [1, 2, 3, 4, 3, 2, 2] == 1\n-- smallest_change [1, 2, 3, 2, 1] == 0\n\nsmallest_change :: [Int] -> Int\nsmallest_change arr =  length [i | i <- [0..(length arr `div` 2 - 1)], arr !! i /= arr !!  (length arr - i - 1)]\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (smallest_change [1, 2, 3, 5, 4, 7, 9, 6] == 4)\n    check (smallest_change [1, 2, 3, 4, 3, 2, 2] == 1)\n    check (smallest_change [1, 4, 2] == 1)\n    check (smallest_change [1, 4, 4, 2] == 1)\n    check (smallest_change [1, 2, 3, 2, 1] == 0)\n    check (smallest_change [3, 1, 1, 3] == 0)\n    check (smallest_change [1] == 0)\n    check (smallest_change [0, 1] == 1)\n"}
{"task_id": "Haskell/74", "prompt": "-- Write a function that accepts two lists of strings and returns the list that has\n-- total number of chars in the all strings of the list less than the other list.\n-- if the two lists have the same number of chars, return the first list.\n-- Examples\n-- total_match [] [] == []\n-- total_match [\"hi\", \"admin\"] [\"hI\", \"Hi\"] == [\"hI\", \"Hi\"]\n-- total_match [\"hi\", \"admin\"] [\"hi\", \"hi\", \"admin\", \"project\"] == [\"hi\", \"admin\"]\n-- total_match [\"hi\", \"admin\"] [\"hI\", \"hi\", \"hi\"] == [\"hI\", \"hi\", \"hi\"]\n-- total_match [\"4\"] [\"1\", \"2\", \"3\", \"4\", \"5\"] == [\"4\"]\ntotal_match :: [String] -> [String] -> [String]", "canonical_solution": "-- Task ID: HumanEval/74\n-- Assigned To: Author E\n\n-- Python Implementation:\n\n-- \n-- def total_match(lst1, lst2):\n--     '''\n--     Write a function that accepts two lists of strings and returns the list that has \n--     total number of chars in the all strings of the list less than the other list.\n-- \n--     if the two lists have the same number of chars, return the first list.\n-- \n--     Examples\n--     total_match([], []) \u279e []\n--     total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n--     total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n--     total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n--     total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n--     '''\n--     l1 = 0\n--     for st in lst1:\n--         l1 += len(st)\n--     \n--     l2 = 0\n--     for st in lst2:\n--         l2 += len(st)\n--     \n--     if l1 <= l2:\n--         return lst1\n--     else:\n--         return lst2\n-- \n\n\n-- Haskell Implementation:\n\n-- Write a function that accepts two lists of strings and returns the list that has\n-- total number of chars in the all strings of the list less than the other list.\n--\n-- if the two lists have the same number of chars, return the first list.\n--\n-- Examples\n-- total_match [] [] == []\n-- total_match [\"hi\", \"admin\"] [\"hI\", \"Hi\"] == [\"hI\", \"Hi\"]\n-- total_match [\"hi\", \"admin\"] [\"hi\", \"hi\", \"admin\", \"project\"] == [\"hi\", \"admin\"]\n-- total_match [\"hi\", \"admin\"] [\"hI\", \"hi\", \"hi\"] == [\"hI\", \"hi\", \"hi\"]\n-- total_match [\"4\"] [\"1\", \"2\", \"3\", \"4\", \"5\"] == [\"4\"]\n\ntotal_match :: [String] -> [String] -> [String]\ntotal_match lst1 lst2 =  if sum (map length lst1) <=  sum (map length lst2) then  lst1 else lst2\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (total_match [] [] == [])\n    check (total_match [\"hi\", \"admin\"] [\"hi\", \"hi\"] == [\"hi\", \"hi\"])\n    check (total_match [\"hi\", \"admin\"] [\"hi\", \"hi\", \"admin\", \"project\"] == [\"hi\", \"admin\"])\n    check (total_match [\"4\"] [\"1\", \"2\", \"3\", \"4\", \"5\"] == [\"4\"])\n    check (total_match [\"hi\", \"admin\"] [\"hI\", \"Hi\"] == [\"hI\", \"Hi\"])\n    check (total_match [\"hi\", \"admin\"] [\"hI\", \"hi\", \"hi\"] == [\"hI\", \"hi\", \"hi\"])\n    check (total_match [\"hi\", \"admin\"] [\"hI\", \"hi\", \"hii\"] == [\"hi\", \"admin\"])\n    check (total_match [] [\"this\"] == [])\n    check (total_match [\"this\"] [] == [])\n"}
{"task_id": "Haskell/75", "prompt": "-- Write a function that returns true if the given number is the multiplication of 3 prime numbers\n-- and false otherwise.\n-- Knowing that (a) is less then 100.\n-- Example:\n-- is_multiply_prime 30 == True\n-- 30 = 2 * 3 * 5\nis_multiply_prime :: Int -> Bool", "canonical_solution": "-- Task ID: HumanEval/75\n-- Assigned To: Author E\n\n-- Python Implementation:\n\n-- \n-- def is_multiply_prime(a):\n--     \"\"\"Write a function that returns true if the given number is the multiplication of 3 prime numbers\n--     and false otherwise.\n--     Knowing that (a) is less then 100. \n--     Example:\n--     is_multiply_prime(30) == True\n--     30 = 2 * 3 * 5\n--     \"\"\"\n--     def is_prime(n):\n--         for j in range(2,n):\n--             if n%j == 0:\n--                 return False\n--         return True\n-- \n--     for i in range(2,101):\n--         if not is_prime(i): continue\n--         for j in range(2,101):\n--             if not is_prime(j): continue\n--             for k in range(2,101):\n--                 if not is_prime(k): continue\n--                 if i*j*k == a: return True\n--     return False\n-- \n\n\n-- Haskell Implementation:\n\n-- Write a function that returns true if the given number is the multiplication of 3 prime numbers\n-- and false otherwise.\n-- Knowing that (a) is less then 100.\n-- Example:\n-- is_multiply_prime 30 == True\n-- 30 = 2 * 3 * 5\n\nis_multiply_prime :: Int -> Bool\nis_multiply_prime a =  let is_prime n =  null [i | i <- [2..(n-1)], n `mod` i == 0]\n                      in or [is_prime i && is_prime j && is_prime k && i * j * k == a | i <- [2..100], j <-  [2..100], k <- [2..100]]\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (is_multiply_prime 5 == False)\n    check (is_multiply_prime 30 == True)\n    check (is_multiply_prime 8 == True)\n    check (is_multiply_prime 10 == False)\n    check (is_multiply_prime 125 == True)\n    check (is_multiply_prime (3 * 5 * 7) == True)\n    check (is_multiply_prime (3 * 6 * 7) == False)\n    check (is_multiply_prime (9 * 9 * 9) == False)\n    check (is_multiply_prime (11 * 9 * 9) == False)\n    check (is_multiply_prime (11 * 13 * 7) == True)\n"}
{"task_id": "Haskell/76", "prompt": "-- Your task is to write a function that returns true if a number x is a simple\n-- power of n and false in other cases.\n-- x is a simple power of n if n**int=x\n-- For example:\n-- is_simple_power 1 4 => true\n-- is_simple_power 2 2 => true\n-- is_simple_power 8 2 => true\n-- is_simple_power 3 2 => false\n-- is_simple_power 3 1 => false\n-- is_simple_power 5 3 => false\nis_simple_power :: Int -> Int -> Bool", "canonical_solution": "-- Task ID: HumanEval/76\n-- Assigned To: Author E\n\n-- Python Implementation:\n\n-- \n-- def is_simple_power(x, n):\n--     \"\"\"Your task is to write a function that returns true if a number x is a simple\n--     power of n and false in other cases.\n--     x is a simple power of n if n**int=x\n--     For example:\n--     is_simple_power(1, 4) => true\n--     is_simple_power(2, 2) => true\n--     is_simple_power(8, 2) => true\n--     is_simple_power(3, 2) => false\n--     is_simple_power(3, 1) => false\n--     is_simple_power(5, 3) => false\n--     \"\"\"\n--     if (n == 1): \n--         return (x == 1) \n--     power = 1\n--     while (power < x): \n--         power = power * n \n--     return (power == x) \n-- \n\n\n-- Haskell Implementation:\n\n-- Your task is to write a function that returns true if a number x is a simple\n-- power of n and false in other cases.\n-- x is a simple power of n if n**int=x\n-- For example:\n-- is_simple_power 1 4 => true\n-- is_simple_power 2 2 => true\n-- is_simple_power 8 2 => true\n-- is_simple_power 3 2 => false\n-- is_simple_power 3 1 => false\n-- is_simple_power 5 3 => false\n\nis_simple_power :: Int -> Int -> Bool\nis_simple_power x n =  or [n ^ i == x |  i <- [0..x]]\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (is_simple_power 1 4 == True)\n    check (is_simple_power 2 2 == True)\n    check (is_simple_power 8 2 == True)\n    check (is_simple_power 3 2 == False)\n    check (is_simple_power 3 1 == False)\n    check (is_simple_power 5 3 == False)\n    check (is_simple_power 16 2 == True)\n    check (is_simple_power 143214 16 == False)\n    check (is_simple_power 4 2 == True)\n    check (is_simple_power 9 3 == True)\n    check (is_simple_power 16 4 == True)\n    check (is_simple_power 24 2 == False)\n    check (is_simple_power 128 4 == False)\n    check (is_simple_power 12 6 == False)\n    check (is_simple_power 1 1 == True)\n    check (is_simple_power 1 12 == True)\n"}
{"task_id": "Haskell/77", "prompt": "-- Write a function that takes an integer a and returns True\n-- if this ingeger is a cube of some integer number.\n-- Note: you may assume the input is always valid.\n-- Examples:\n-- iscube 1 ==> True\n-- iscube 2 ==> False\n-- iscube (-1) ==> True\n-- iscube 64 ==> True\n-- iscube 0 ==> True\n-- iscube 180 ==> False\niscube :: Int -> Bool", "canonical_solution": "-- Task ID: HumanEval/77\n-- Assigned To: Author E\n\n-- Python Implementation:\n\n-- \n-- def iscube(a):\n--     '''\n--     Write a function that takes an integer a and returns True \n--     if this ingeger is a cube of some integer number.\n--     Note: you may assume the input is always valid.\n--     Examples:\n--     iscube(1) ==> True\n--     iscube(2) ==> False\n--     iscube(-1) ==> True\n--     iscube(64) ==> True\n--     iscube(0) ==> True\n--     iscube(180) ==> False\n--     '''\n--     a = abs(a)\n--     return int(round(a ** (1. / 3))) ** 3 == a\n-- \n\n\n-- Haskell Implementation:\n\n-- Write a function that takes an integer a and returns True\n-- if this ingeger is a cube of some integer number.\n-- Note: you may assume the input is always valid.\n-- Examples:\n-- iscube 1 ==> True\n-- iscube 2 ==> False\n-- iscube (-1) ==> True\n-- iscube 64 ==> True\n-- iscube 0 ==> True\n-- iscube 180 ==> False\n\niscube :: Int -> Bool\niscube a = let b =  abs a\n           in round  (fromIntegral b ** (1.0 / 3.0)) ^ 3 == b\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (iscube 1 == True)\n    check (iscube 2 == False)\n    check (iscube (-1) == True)\n    check (iscube 64 == True)\n    check (iscube 180 == False)\n    check (iscube 1000 == True)\n    check (iscube 0 == True)\n    check (iscube 1729 == False)\n"}
{"task_id": "Haskell/78", "prompt": "-- You have been tasked to write a function that receives\n-- a hexadecimal number as a string and counts the number of hexadecimal\n-- digits that are primes (prime number, or a prime, is a natural number\n-- greater than 1 that is not a product of two smaller natural numbers).\n-- Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n-- Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n-- So you have to determine a number of the following digits: 2, 3, 5, 7,\n-- B (=decimal 11), D (=decimal 13).\n-- Note: you may assume the input is always correct or empty string,\n-- and symbols A,B,C,D,E,F are always uppercase.\n-- Examples:\n-- For num = \"AB\" the output should be 1.\n-- For num = \"1077E\" the output should be 2.\n-- For num = \"ABED1A33\" the output should be 4.\n-- For num = \"123456789ABCDEF0\" the output should be 6.\n-- For num = \"2020\" the output should be 2.\nhex_key :: String -> Int", "canonical_solution": "-- Task ID: HumanEval/78\n-- Assigned To: Author E\n\n-- Python Implementation:\n\n-- \n-- def hex_key(num):\n--     \"\"\"You have been tasked to write a function that receives \n--     a hexadecimal number as a string and counts the number of hexadecimal \n--     digits that are primes (prime number, or a prime, is a natural number \n--     greater than 1 that is not a product of two smaller natural numbers).\n--     Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n--     Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n--     So you have to determine a number of the following digits: 2, 3, 5, 7, \n--     B (=decimal 11), D (=decimal 13).\n--     Note: you may assume the input is always correct or empty string, \n--     and symbols A,B,C,D,E,F are always uppercase.\n--     Examples:\n--     For num = \"AB\" the output should be 1.\n--     For num = \"1077E\" the output should be 2.\n--     For num = \"ABED1A33\" the output should be 4.\n--     For num = \"123456789ABCDEF0\" the output should be 6.\n--     For num = \"2020\" the output should be 2.\n--     \"\"\"\n--     primes = ('2', '3', '5', '7', 'B', 'D')\n--     total = 0\n--     for i in range(0, len(num)):\n--         if num[i] in primes:\n--             total += 1\n--     return total\n-- \n\n\n-- Haskell Implementation:\n\n-- You have been tasked to write a function that receives\n-- a hexadecimal number as a string and counts the number of hexadecimal\n-- digits that are primes (prime number, or a prime, is a natural number\n-- greater than 1 that is not a product of two smaller natural numbers).\n-- Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n-- Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n-- So you have to determine a number of the following digits: 2, 3, 5, 7,\n-- B (=decimal 11), D (=decimal 13).\n-- Note: you may assume the input is always correct or empty string,\n-- and symbols A,B,C,D,E,F are always uppercase.\n-- Examples:\n-- For num = \"AB\" the output should be 1.\n-- For num = \"1077E\" the output should be 2.\n-- For num = \"ABED1A33\" the output should be 4.\n-- For num = \"123456789ABCDEF0\" the output should be 6.\n-- For num = \"2020\" the output should be 2.\n\nhex_key :: String -> Int\nhex_key num =  length [i | i <-  num, i `elem` \"2357BD\"]\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (hex_key \"AB\" == 1)\n    check (hex_key \"1077E\" == 2)\n    check (hex_key \"ABED1A33\" == 4)\n    check (hex_key \"2020\" == 2)\n    check (hex_key \"123456789ABCDEF0\" == 6)\n    check (hex_key \"112233445566778899AABBCCDDEEFF00\" == 12)\n    check (hex_key \"\" == 0)\n"}
{"task_id": "Haskell/79", "prompt": "-- You will be given a number in decimal form and your task is to convert it to\n-- binary format. The function should return a string, with each character representing a binary\n-- number. Each character in the string will be '0' or '1'.\n-- There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n-- The extra characters are there to help with the format.\n-- Examples:\n-- decimal_to_binary 15   # returns \"db1111db\"\n-- decimal_to_binary 32   # returns \"db100000db\"\ndecimal_to_binary :: Int -> String", "canonical_solution": "-- Task ID: HumanEval/79\n-- Assigned To: Author E\n\n-- Python Implementation:\n\n-- \n-- def decimal_to_binary(decimal):\n--     \"\"\"You will be given a number in decimal form and your task is to convert it to\n--     binary format. The function should return a string, with each character representing a binary\n--     number. Each character in the string will be '0' or '1'.\n-- \n--     There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n--     The extra characters are there to help with the format.\n-- \n--     Examples:\n--     decimal_to_binary(15)   # returns \"db1111db\"\n--     decimal_to_binary(32)   # returns \"db100000db\"\n--     \"\"\"\n--     return \"db\" + bin(decimal)[2:] + \"db\"\n-- \n\n\n-- Haskell Implementation:\nimport Numeric (showIntAtBase)\nimport Data.Char (intToDigit)\n\n-- You will be given a number in decimal form and your task is to convert it to\n-- binary format. The function should return a string, with each character representing a binary\n-- number. Each character in the string will be '0' or '1'.\n-- \n-- There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n-- The extra characters are there to help with the format.\n--\n-- Examples:\n-- decimal_to_binary 15   # returns \"db1111db\"\n-- decimal_to_binary 32   # returns \"db100000db\"\n\ndecimal_to_binary :: Int -> String\ndecimal_to_binary decimal =  \"db\" ++ showIntAtBase 2 intToDigit decimal \"db\"\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (decimal_to_binary 0 == \"db0db\")\n    check (decimal_to_binary 32 == \"db100000db\")\n    check (decimal_to_binary 103 == \"db1100111db\")\n    check (decimal_to_binary 15 == \"db1111db\")\n"}
{"task_id": "Haskell/80", "prompt": "-- You are given a string s.\n-- Your task is to check if the string is happy or not.\n-- A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n-- For example:\n-- is_happy \"a\" => False\n-- is_happy \"aa\" => False\n-- is_happy \"abcd\" => True\n-- is_happy \"aabb\" => False\n-- is_happy \"adb\" => True\n-- is_happy \"xyy\" => False\nis_happy :: String -> Bool", "canonical_solution": "-- Task ID: HumanEval/80\n-- Assigned To: Author E\n\n-- Python Implementation:\n\n-- \n-- def is_happy(s):\n--     \"\"\"You are given a string s.\n--     Your task is to check if the string is happy or not.\n--     A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n--     For example:\n--     is_happy(a) => False\n--     is_happy(aa) => False\n--     is_happy(abcd) => True\n--     is_happy(aabb) => False\n--     is_happy(adb) => True\n--     is_happy(xyy) => False\n--     \"\"\"\n--     if len(s) < 3:\n--       return False\n-- \n--     for i in range(len(s) - 2):\n--       \n--       if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n--         return False\n--     return True\n-- \n\n\n-- Haskell Implementation:\n\n-- You are given a string s.\n-- Your task is to check if the string is happy or not.\n-- A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n-- For example:\n-- is_happy \"a\" => False\n-- is_happy \"aa\" => False\n-- is_happy \"abcd\" => True\n-- is_happy \"aabb\" => False\n-- is_happy \"adb\" => True\n-- is_happy \"xyy\" => False\n\nis_happy :: String -> Bool\nis_happy s =  length s >= 3 && and  [s !! i /= s !! (i+1) && s !! (i+1) /= s !! (i+2) && s !! i /= s !! (i+2) | i <-  [0..(length s - 3)]]\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (is_happy \"a\" == False)\n    check (is_happy \"aa\" == False)\n    check (is_happy \"abcd\" == True)\n    check (is_happy \"aabb\" == False)\n    check (is_happy \"adb\" == True)\n    check (is_happy \"xyy\" == False)\n    check (is_happy \"iopaxpoi\" == True)\n    check (is_happy \"iopaxioi\" == False)\n"}
{"task_id": "Haskell/81", "prompt": "-- It is the last week of the semester and the teacher has to give the grades\n-- to students. The teacher has been making her own algorithm for grading.\n-- The only problem is, she has lost the code she used for grading.\n-- She has given you a list of GPAs for some students and you have to write\n-- a function that can output a list of letter grades using the following table:\n--          GPA       |    Letter grade\n--           4.0                A+\n--         > 3.7                A\n--         > 3.3                A-\n--         > 3.0                B+\n--         > 2.7                B\n--         > 2.3                B-\n--         > 2.0                C+\n--         > 1.7                C\n--         > 1.3                C-\n--         > 1.0                D+\n--         > 0.7                D\n--         > 0.0                D-\n--           0.0                E\n-- Example:\n-- numerical_letter_grade [4.0, 3, 1.7, 2, 3.5] == [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\nnumerical_letter_grade :: [Double] -> [String]", "canonical_solution": "-- Task ID: HumanEval/81\n-- Assigned To: Author E\n\n-- Python Implementation:\n\n-- \n-- def numerical_letter_grade(grades):\n--     \"\"\"It is the last week of the semester and the teacher has to give the grades\n--     to students. The teacher has been making her own algorithm for grading.\n--     The only problem is, she has lost the code she used for grading.\n--     She has given you a list of GPAs for some students and you have to write \n--     a function that can output a list of letter grades using the following table:\n--              GPA       |    Letter grade\n--               4.0                A+\n--             > 3.7                A \n--             > 3.3                A- \n--             > 3.0                B+\n--             > 2.7                B \n--             > 2.3                B-\n--             > 2.0                C+\n--             > 1.7                C\n--             > 1.3                C-\n--             > 1.0                D+ \n--             > 0.7                D \n--             > 0.0                D-\n--               0.0                E\n--     \n-- \n--     Example:\n--     grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n--     \"\"\"\n-- \n--    \n--     letter_grade = []\n--     for gpa in grades:\n--         if gpa == 4.0:\n--             letter_grade.append(\"A+\")\n--         elif gpa > 3.7:\n--             letter_grade.append(\"A\")\n--         elif gpa > 3.3:\n--             letter_grade.append(\"A-\")\n--         elif gpa > 3.0:\n--             letter_grade.append(\"B+\")\n--         elif gpa > 2.7:\n--             letter_grade.append(\"B\")\n--         elif gpa > 2.3:\n--             letter_grade.append(\"B-\")\n--         elif gpa > 2.0:\n--             letter_grade.append(\"C+\")\n--         elif gpa > 1.7:\n--             letter_grade.append(\"C\")\n--         elif gpa > 1.3:\n--             letter_grade.append(\"C-\")\n--         elif gpa > 1.0:\n--             letter_grade.append(\"D+\")\n--         elif gpa > 0.7:\n--             letter_grade.append(\"D\")\n--         elif gpa > 0.0:\n--             letter_grade.append(\"D-\")\n--         else:\n--             letter_grade.append(\"E\")\n--     return letter_grade\n-- \n\n\n-- Haskell Implementation:\n\n-- It is the last week of the semester and the teacher has to give the grades\n-- to students. The teacher has been making her own algorithm for grading.\n-- The only problem is, she has lost the code she used for grading.\n-- She has given you a list of GPAs for some students and you have to write\n-- a function that can output a list of letter grades using the following table:\n--          GPA       |    Letter grade\n--           4.0                A+\n--         > 3.7                A\n--         > 3.3                A-\n--         > 3.0                B+\n--         > 2.7                B\n--         > 2.3                B-\n--         > 2.0                C+\n--         > 1.7                C\n--         > 1.3                C-\n--         > 1.0                D+\n--         > 0.7                D\n--         > 0.0                D-\n--           0.0                E\n--\n--\n-- Example:\n-- numerical_letter_grade [4.0, 3, 1.7, 2, 3.5] == [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\n\nnumerical_letter_grade :: [Double] -> [String]\nnumerical_letter_grade grades =  map grade grades\n    where\n        grade :: Double -> String\n        grade gpa\n            | gpa == 4.0 =  \"A+\"\n            | gpa > 3.7 =  \"A\"\n            | gpa > 3.3 =  \"A-\"\n            | gpa > 3.0 =  \"B+\"\n            | gpa > 2.7 =  \"B\"\n            | gpa > 2.3 =  \"B-\"\n            | gpa > 2.0 =  \"C+\"\n            | gpa > 1.7 =  \"C\"\n            | gpa > 1.3 =  \"C-\"\n            | gpa > 1.0 =  \"D+\"\n            | gpa > 0.7 =  \"D\"\n            | gpa > 0.0 =  \"D-\"\n            | otherwise =  \"E\"\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (numerical_letter_grade [4.0, 3, 1.7, 2, 3.5] == [\"A+\", \"B\", \"C-\", \"C\", \"A-\"])\n    check (numerical_letter_grade [1.2] == [\"D+\"])\n    check (numerical_letter_grade [0.5] == [\"D-\"])\n    check (numerical_letter_grade [0.0] == [\"E\"])\n    check (numerical_letter_grade [1, 0.3, 1.5, 2.8, 3.3] == [\"D\", \"D-\", \"C-\", \"B\", \"B+\"])\n    check (numerical_letter_grade [0, 0.7] == [\"E\", \"D-\"])\n"}
{"task_id": "Haskell/82", "prompt": "-- Write a function that takes a string and returns True if the string\n-- length is a prime number or False otherwise\n-- Examples\n-- prime_length \"Hello\" == True\n-- prime_length \"abcdcba\" == True\n-- prime_length \"kittens\" == True\n-- prime_length \"orange\" == False\nprime_length :: String -> Bool", "canonical_solution": "-- Task ID: HumanEval/82\n-- Assigned To: Author E\n\n-- Python Implementation:\n\n-- \n-- def prime_length(string):\n--     \"\"\"Write a function that takes a string and returns True if the string\n--     length is a prime number or False otherwise\n--     Examples\n--     prime_length('Hello') == True\n--     prime_length('abcdcba') == True\n--     prime_length('kittens') == True\n--     prime_length('orange') == False\n--     \"\"\"\n--     l = len(string)\n--     if l == 0 or l == 1:\n--         return False\n--     for i in range(2, l):\n--         if l % i == 0:\n--             return False\n--     return True\n-- \n\n\n-- Haskell Implementation:\n\n-- Write a function that takes a string and returns True if the string\n-- length is a prime number or False otherwise\n-- Examples\n-- prime_length \"Hello\" == True\n-- prime_length \"abcdcba\" == True\n-- prime_length \"kittens\" == True\n-- prime_length \"orange\" == False\n\nprime_length :: String -> Bool\nprime_length string = let l =  length string\n                      in l /= 0 && l /= 1 && null [i | i <-  [2..(l-1)], l `mod` i == 0]\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (prime_length \"Hello\" == True)\n    check (prime_length \"abcdcba\" == True)\n    check (prime_length \"kittens\" == True)\n    check (prime_length \"orange\" == False)\n    check (prime_length \"wow\" == True)\n    check (prime_length \"world\" == True)\n    check (prime_length \"MadaM\" == True)\n    check (prime_length \"Wow\" == True)\n    check (prime_length \"\" == False)\n    check (prime_length \"HI\" == True)\n    check (prime_length \"go\" == True)\n    check (prime_length \"gogo\" == False)\n    check (prime_length \"aaaaaaaaaaaaaaa\" == False)\n    check (prime_length \"Madam\" == True)\n    check (prime_length \"M\" == False)\n    check (prime_length \"0\" == False)\n"}
{"task_id": "Haskell/83", "prompt": "-- Given a positive integer n, return the count of the numbers of n-digit\n-- positive integers that start or end with 1.\nstarts_one_ends :: Int -> Int", "canonical_solution": "-- Task ID: HumanEval/83\n-- Assigned To: Author E\n\n-- Python Implementation:\n\n-- \n-- def starts_one_ends(n):\n--     \"\"\"\n--     Given a positive integer n, return the count of the numbers of n-digit\n--     positive integers that start or end with 1.\n--     \"\"\"\n--     if n == 1: return 1\n--     return 18 * (10 ** (n - 2))\n-- \n\n\n-- Haskell Implementation:\n\n-- Given a positive integer n, return the count of the numbers of n-digit\n-- positive integers that start or end with 1.\n\nstarts_one_ends :: Int -> Int\nstarts_one_ends n =  if n == 1  then 1  else 18 * (10 ^ (n - 2))\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (starts_one_ends 1 == 1)\n    check (starts_one_ends 2 == 18)\n    check (starts_one_ends 3 == 180)\n    check (starts_one_ends 4 == 1800)\n    check (starts_one_ends 5 == 18000)\n"}
{"task_id": "Haskell/84", "prompt": "-- Given a positive integer N, return the total sum of its digits in binary.\n-- Example\n--     For N = 1000, the sum of digits will be 1 the output should be \"1\".\n--     For N = 150, the sum of digits will be 6 the output should be \"110\".\n--     For N = 147, the sum of digits will be 12 the output should be \"1100\".\n-- Variables:\n--     @N integer\n--          Constraints: 0 \u2264 N \u2264 10000.\n-- Output:\n--      a string of binary number\nsolve :: Int -> String", "canonical_solution": "-- Task ID: HumanEval/84\n-- Assigned To: Author E\n\n-- Python Implementation:\n\n-- \n-- def solve(N):\n--     \"\"\"Given a positive integer N, return the total sum of its digits in binary.\n--     \n--     Example\n--         For N = 1000, the sum of digits will be 1 the output should be \"1\".\n--         For N = 150, the sum of digits will be 6 the output should be \"110\".\n--         For N = 147, the sum of digits will be 12 the output should be \"1100\".\n--     \n--     Variables:\n--         @N integer\n--              Constraints: 0 \u2264 N \u2264 10000.\n--     Output:\n--          a string of binary number\n--     \"\"\"\n--     return bin(sum(int(i) for i in str(N)))[2:]\n-- \n\n\n-- Haskell Implementation:\nimport Data.Char\nimport Numeric (showIntAtBase)\n\n-- Given a positive integer N, return the total sum of its digits in binary.\n--\n-- Example\n--     For N = 1000, the sum of digits will be 1 the output should be \"1\".\n--     For N = 150, the sum of digits will be 6 the output should be \"110\".\n--     For N = 147, the sum of digits will be 12 the output should be \"1100\".\n--\n-- Variables:\n--     @N integer\n--          Constraints: 0 \u2264 N \u2264 10000.\n-- Output:\n--      a string of binary number\n\nsolve :: Int -> String\nsolve n =  showIntAtBase 2 intToDigit  (sum (map digitToInt  (show n))) \"\"\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (solve 1000 == \"1\")\n    check (solve 150 == \"110\")\n    check (solve 147 == \"1100\")\n    check (solve 333 == \"1001\")\n    check (solve 963 == \"10010\")\n"}
{"task_id": "Haskell/85", "prompt": "-- Given a non-empty list of integers lst. add the even elements that are at odd indices..\n-- Examples:\n--     add [4, 2, 6, 7] ==> 2\nadd :: [Int] -> Int", "canonical_solution": "-- Task ID: HumanEval/85\n-- Assigned To: Author E\n\n-- Python Implementation:\n\n--\n-- def add(lst):\n--     \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n--\n--\n--     Examples:\n--         add([4, 2, 6, 7]) ==> 2\n--     \"\"\"\n--     return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n--\n\n-- Haskell Implementation:\n\n-- Given a non-empty list of integers lst. add the even elements that are at odd indices..\n--\n-- Examples:\n--     add [4, 2, 6, 7] ==> 2\n\nadd :: [Int] -> Int\nadd lst =\n  sum\n    [ lst !! i\n      | i <-  [1, 3 ..  (length lst - 1)],\n        even  (lst !! i)\n    ]\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (add [4, 88] == 88)\n    check (add [4, 5, 6, 7, 2, 122] == 122)\n    check (add [4, 0, 6, 7] == 0)\n    check (add [4, 4, 6, 8] == 12)\n"}
{"task_id": "Haskell/86", "prompt": "-- Write a function that takes a string and returns an ordered version of it.\n-- Ordered version of string, is a string where all words (separated by space)\n-- are replaced by a new word where all the characters arranged in\n-- ascending order based on ascii value.\n-- Note: You should keep the order of words and blank spaces in the sentence.\n-- For example:\n-- anti_shuffle \"Hi\" returns \"Hi\"\n-- anti_shuffle \"hello\" returns \"ehllo\"\n-- anti_shuffle \"Hello World!!!\" returns \"Hello !!!Wdlor\"\nanti_shuffle :: String -> String", "canonical_solution": "-- Task ID: HumanEval/86\n-- Assigned To: Author E\n\n-- Python Implementation:\n\n-- \n-- def anti_shuffle(s):\n--     \"\"\"\n--     Write a function that takes a string and returns an ordered version of it.\n--     Ordered version of string, is a string where all words (separated by space)\n--     are replaced by a new word where all the characters arranged in\n--     ascending order based on ascii value.\n--     Note: You should keep the order of words and blank spaces in the sentence.\n-- \n--     For example:\n--     anti_shuffle('Hi') returns 'Hi'\n--     anti_shuffle('hello') returns 'ehllo'\n--     anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n--     \"\"\"\n--     return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n-- \n\n\n-- Haskell Implementation:\nimport Data.List\n\n-- Write a function that takes a string and returns an ordered version of it.\n-- Ordered version of string, is a string where all words (separated by space)\n-- are replaced by a new word where all the characters arranged in\n-- ascending order based on ascii value.\n-- Note: You should keep the order of words and blank spaces in the sentence.\n-- \n-- For example:\n-- anti_shuffle \"Hi\" returns \"Hi\"\n-- anti_shuffle \"hello\" returns \"ehllo\"\n-- anti_shuffle \"Hello World!!!\" returns \"Hello !!!Wdlor\"\n\nanti_shuffle :: String -> String\nanti_shuffle s =  unwords  [sort i | i <-  words s]\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (anti_shuffle \"Hi\" == \"Hi\")\n    check (anti_shuffle \"hello\" == \"ehllo\")\n    check (anti_shuffle \"number\" == \"bemnru\")\n    check (anti_shuffle \"abcd\" == \"abcd\")\n    check (anti_shuffle \"Hello World!!!\" == \"Hello !!!Wdlor\")\n    check (anti_shuffle \"\" == \"\")\n    check (anti_shuffle \"Hi. My name is Mister Robot. How are you?\" == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")\n"}
{"task_id": "Haskell/87", "prompt": "-- You are given a 2 dimensional data, as a nested lists,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the list,\n-- and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n-- each tuple is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row [[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1\n-- [(0,0),(1,4),(1,0),(2,5),(2,0)]\n-- >>> get_row [] 1\n-- []\n-- >>> get_row [[], [1], [1, 2, 3]] 3\n-- [(2,2)]\nget_row :: [[Int]] -> Int -> [(Int, Int)]", "canonical_solution": "-- Task ID: HumanEval/87\n-- Assigned To: Author E\n\n-- Python Implementation:\n\n--\n-- def get_row(lst, x):\n--     \"\"\"\n--     You are given a 2 dimensional data, as a nested lists,\n--     which is similar to matrix, however, unlike matrices,\n--     each row may contain a different number of columns.\n--     Given lst, and integer x, find integers x in the list,\n--     and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n--     each tuple is a coordinate - (row, columns), starting with 0.\n--     Sort coordinates initially by rows in ascending order.\n--     Also, sort coordinates of the row by columns in descending order.\n--\n--     Examples:\n--     get_row([\n--       [1,2,3,4,5,6],\n--       [1,2,3,4,1,6],\n--       [1,2,3,4,5,1]\n--     ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n--     get_row([], 1) == []\n--     get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n--     \"\"\"\n--     coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n--     return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n--\n\n-- Haskell Implementation:\nimport Data.List\n\n-- You are given a 2 dimensional data, as a nested lists,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the list,\n-- and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n-- each tuple is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n--\n-- Examples:\n-- >>> get_row [[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1\n-- [(0,0),(1,4),(1,0),(2,5),(2,0)]\n-- >>> get_row [] 1\n-- []\n-- >>> get_row [[], [1], [1, 2, 3]] 3\n-- [(2,2)]\n\nget_row :: [[Int]] -> Int -> [(Int, Int)]\nget_row lst x =\n  let coords =\n        [ (i, j)\n          | i <-  [0 .. (length lst - 1)],\n            j <-  [0 .. (length (lst !! i) - 1)],\n            (lst !! i) !! j  == x\n        ]\n   in sortBy\n        (\\x y ->  compare (fst x) (fst y))\n        ( sortBy\n            (\\x y ->  compare (snd y) (snd x))\n            coords\n        )\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (get_row [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]] 1 == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n    check (get_row [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]] 2 == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n    check (get_row [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]] 1 == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n    check (get_row [] 1 == [])\n    check (get_row [[1]] 2 == [])\n    check (get_row [[], [1], [1, 2, 3]] 3 == [(2, 2)])\n"}
{"task_id": "Haskell/88", "prompt": "-- Given an array of non-negative integers, return a copy of the given array after sorting,\n-- you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n-- or sort it in descending order if the sum( first index value, last index value) is even.\n-- Note:\n-- * don't change the given array.\n-- Examples:\n-- >>> sort_array []\n-- []\n-- >>> sort_array [5]\n-- [5]\n-- >>> sort_array [2, 4, 3, 0, 1, 5]\n-- [0,1,2,3,4,5]\n-- >>> sort_array [2, 4, 3, 0, 1, 5, 6]\n-- [6,5,4,3,2,1,0]\nsort_array :: [Int] -> [Int]", "canonical_solution": "-- Task ID: HumanEval/88\n-- Assigned To: Author E\n\n-- Python Implementation:\n\n--\n-- def sort_array(array):\n--     \"\"\"\n--     Given an array of non-negative integers, return a copy of the given array after sorting,\n--     you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n--     or sort it in descending order if the sum( first index value, last index value) is even.\n--\n--     Note:\n--     * don't change the given array.\n--\n--     Examples:\n--     * sort_array([]) => []\n--     * sort_array([5]) => [5]\n--     * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n--     * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n--     \"\"\"\n--     return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0)\n--\n\n-- Haskell Implementation:\nimport Data.List\n\n-- Given an array of non-negative integers, return a copy of the given array after sorting,\n-- you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n-- or sort it in descending order if the sum( first index value, last index value) is even.\n--\n-- Note:\n\n-- * don't change the given array.\n\n--\n-- Examples:\n\n-- >>> sort_array []\n-- []\n-- >>> sort_array [5]\n-- [5]\n-- >>> sort_array [2, 4, 3, 0, 1, 5]\n-- [0,1,2,3,4,5]\n-- >>> sort_array [2, 4, 3, 0, 1, 5, 6]\n-- [6,5,4,3,2,1,0]\n\nsort_array :: [Int] -> [Int]\nsort_array array =\n  if length array == 0\n    then  []\n    else\n      sortBy\n        ( \\x y ->\n            if (array !! 0 + array !!  (length array - 1)) `mod` 2 ==  0\n              then  compare y x\n              else  compare x y\n        )\n        array\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (sort_array [] == [])\n    check (sort_array [5] == [5])\n    check (sort_array [2, 4, 3, 0, 1, 5] == [0, 1, 2, 3, 4, 5])\n    check (sort_array [2, 4, 3, 0, 1, 5, 6] == [6, 5, 4, 3, 2, 1, 0])\n    check (sort_array [2, 1] == [1, 2])\n    check (sort_array [15, 42, 87, 32, 11, 0] == [0, 11, 15, 32, 42, 87])\n    check (sort_array [21, 14, 23, 11] == [23, 21, 14, 11])\n"}
{"task_id": "Haskell/89", "prompt": "-- Create a function encrypt that takes a string as an argument and\n-- returns a string encrypted with the alphabet being rotated.\n-- The alphabet should be rotated in a manner such that the letters\n-- shift down by two multiplied to two places.\n-- For example:\n-- >>> encrypt \"hi\"\n-- \"lm\"\n-- >>> encrypt \"asdfghjkl\"\n-- \"ewhjklnop\"\n-- >>> encrypt \"gf\"\n-- \"kj\"\n-- >>> encrypt \"et\"\n-- \"ix\"\nencrypt :: String -> String", "canonical_solution": "-- Task ID: HumanEval/89\n-- Assigned To: Author E\n\n-- Python Implementation:\n\n--\n-- def encrypt(s):\n--     \"\"\"Create a function encrypt that takes a string as an argument and\n--     returns a string encrypted with the alphabet being rotated.\n--     The alphabet should be rotated in a manner such that the letters\n--     shift down by two multiplied to two places.\n--     For example:\n--     encrypt('hi') returns 'lm'\n--     encrypt('asdfghjkl') returns 'ewhjklnop'\n--     encrypt('gf') returns 'kj'\n--     encrypt('et') returns 'ix'\n--     \"\"\"\n--     d = 'abcdefghijklmnopqrstuvwxyz'\n--     out = ''\n--     for c in s:\n--         if c in d:\n--             out += d[(d.index(c)+2*2) % 26]\n--         else:\n--             out += c\n--     return out\n--\n\n-- Haskell Implementation:\nimport Data.Char\n\n-- Create a function encrypt that takes a string as an argument and\n-- returns a string encrypted with the alphabet being rotated.\n-- The alphabet should be rotated in a manner such that the letters\n-- shift down by two multiplied to two places.\n-- For example:\n-- >>> encrypt \"hi\"\n-- \"lm\"\n-- >>> encrypt \"asdfghjkl\"\n-- \"ewhjklnop\"\n-- >>> encrypt \"gf\"\n-- \"kj\"\n-- >>> encrypt \"et\"\n-- \"ix\"\n\nencrypt :: String -> String\nencrypt s =\n  let d =  ['a' .. 'z']\n   in [ d !!  ((fromEnum c - fromEnum 'a' +  2 * 2) `mod`  26)\n        | c <-  s\n      ]\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (encrypt \"hi\" == \"lm\")\n    check (encrypt \"asdfghjkl\" == \"ewhjklnop\")\n    check (encrypt \"gf\" == \"kj\")\n    check (encrypt \"et\" == \"ix\")\n    check (encrypt \"faewfawefaewg\" == \"jeiajeaijeiak\")\n    check (encrypt \"hellomyfriend\" == \"lippsqcjvmirh\")\n    check (encrypt \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\" == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\n    check (encrypt \"a\" == \"e\")\n"}
{"task_id": "Haskell/90", "prompt": "-- You are given a list of integers.\n-- Write a function next_smallest() that returns the 2nd smallest element of the list.\n-- Return None if there is no such element.\n-- next_smallest [1, 2, 3, 4, 5] == 2\n-- next_smallest [5, 1, 4, 3, 2] == 2\n-- next_smallest [] == None\n-- next_smallest [1, 1] == None\nnext_smallest :: [Int] -> Maybe Int", "canonical_solution": "-- Task ID: HumanEval/90\n-- Assigned To: Author E\n\n-- Python Implementation:\n\n--\n-- def next_smallest(lst):\n--     \"\"\"\n--     You are given a list of integers.\n--     Write a function next_smallest() that returns the 2nd smallest element of the list.\n--     Return None if there is no such element.\n--\n--     next_smallest([1, 2, 3, 4, 5]) == 2\n--     next_smallest([5, 1, 4, 3, 2]) == 2\n--     next_smallest([]) == None\n--     next_smallest([1, 1]) == None\n--     \"\"\"\n--     lst = sorted(set(lst))\n--     return None if len(lst) < 2 else lst[1]\n--\n\n-- Haskell Implementation:\nimport Data.List\n\n-- You are given a list of integers.\n-- Write a function next_smallest() that returns the 2nd smallest element of the list.\n-- Return None if there is no such element.\n--\n-- next_smallest [1, 2, 3, 4, 5] == 2\n-- next_smallest [5, 1, 4, 3, 2] == 2\n-- next_smallest [] == None\n-- next_smallest [1, 1] == None\n\nnext_smallest :: [Int] -> Maybe Int\nnext_smallest lst =\n  if length  (sort (nub lst)) <  2\n    then  Nothing\n    else  Just (sort (nub lst) !! 1)", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (next_smallest [1, 2, 3, 4, 5]       == Just 2)\n    check (next_smallest [5, 1, 4, 3, 2]       == Just 2)\n    check (next_smallest []                    == Nothing)\n    check (next_smallest [1, 1]                == Nothing)\n    check (next_smallest [1, 1, 1, 1, 0]       == Just 1)\n    check (next_smallest [1, 1]                == Nothing)\n    check (next_smallest [-35, 34, 12, -45]    == Just (-35))\n"}
{"task_id": "Haskell/91", "prompt": "-- You'll be given a string of words, and your task is to count the number\n-- of boredoms. A boredom is a sentence that starts with the word \"I\".\n-- Sentences are delimited by '.', '?' or '!'.\n-- For example:\n-- >>> is_bored \"Hello world\"\n-- 0\n-- >>> is_bored \"The sky is blue. The sun is shining. I love this weather\"\n-- 1\nis_bored :: String -> Int", "canonical_solution": "-- Task ID: HumanEval/91\n-- Assigned To: Author E\n\n-- Python Implementation:\n\n--\n-- def is_bored(S):\n--     \"\"\"\n--     You'll be given a string of words, and your task is to count the number\n--     of boredoms. A boredom is a sentence that starts with the word \"I\".\n--     Sentences are delimited by '.', '?' or '!'.\n--\n--     For example:\n--     >>> is_bored(\"Hello world\")\n--     0\n--     >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n--     1\n--     \"\"\"\n--     import re\n--     sentences = re.split(r'[.?!]\\s*', S)\n--     return sum(sentence[0:2] == 'I ' for sentence in sentences)\n--\n\n-- Haskell Implementation:\nimport Data.List\n\n-- You'll be given a string of words, and your task is to count the number\n-- of boredoms. A boredom is a sentence that starts with the word \"I\".\n-- Sentences are delimited by '.', '?' or '!'.\n\n-- For example:\n-- >>> is_bored \"Hello world\"\n-- 0\n-- >>> is_bored \"The sky is blue. The sun is shining. I love this weather\"\n-- 1\nis_bored :: String -> Int\nis_bored s =\n  sum\n    [ 1\n      | sentence <-  splitOnDelimiters s,\n        take 2 sentence ==  \"I \"\n    ]\n\n-- Helper function to split the string based on delimiters '.', '!', and '?'\nsplitOnDelimiters :: String -> [String]\nsplitOnDelimiters [] =  []\nsplitOnDelimiters s = case break  (`elem` \".?!\") s of\n  (sentence, []) ->  [sentence]\n  (sentence, (_ : rest)) -> sentence :  splitOnDelimiters (dropWhile  (`elem` \" \") rest)\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (is_bored \"Hello world\"                                                        == 0)\n    check (is_bored \"Is the sky blue?\"                                                   == 0)\n    check (is_bored \"I love It !\"                                                        == 1)\n    check (is_bored \"bIt\"                                                               == 0)\n    check (is_bored \"I feel good today. I will be productive. will kill It\"               == 2)\n    check (is_bored \"You and I are going for a walk\"                                     == 0)\n"}
{"task_id": "Haskell/92", "prompt": "-- Create a function that takes 3 numbers.\n-- Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n-- Returns false in any other cases.\n-- Examples\n-- any_int 5 2 7 => True\n-- any_int 3 2 2 => False\n-- any_int 3 (-2) 1 => True\n-- any_int 3.6 (-2.2) 2 => False\nany_int :: Float -> Float -> Float -> Bool", "canonical_solution": "-- Task ID: HumanEval/92\n-- Assigned To: Author E\n\n-- Python Implementation:\n\n--\n-- def any_int(x, y, z):\n--     '''\n--     Create a function that takes 3 numbers.\n--     Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n--     Returns false in any other cases.\n--\n--     Examples\n--     any_int(5, 2, 7) \u279e True\n--\n--     any_int(3, 2, 2) \u279e False\n--\n--     any_int(3, -2, 1) \u279e True\n--\n--     any_int(3.6, -2.2, 2) \u279e False\n--\n--\n--\n--     '''\n--\n--     if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n--         if (x+y==z) or (x+z==y) or (y+z==x):\n--             return True\n--         return False\n--     return False\n--\n\n-- Haskell Implementation:\nimport Data.Typeable\n\n-- Create a function that takes 3 numbers.\n-- Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n-- Returns false in any other cases.\n--\n-- Examples\n-- any_int 5 2 7 => True\n--\n-- any_int 3 2 2 => False\n--\n-- any_int 3 (-2) 1 => True\n--\n-- any_int 3.6 (-2.2) 2 => False\n\nany_int :: Float -> Float -> Float -> Bool\nany_int x y z =\n  isInt x\n    && isInt y\n    && isInt  z\n    && (x + y == z ||  x + z == y ||  y + z == x)\n  where\n    isInt a = a ==  fromInteger (round a)\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (any_int 2    3   1   == True)\n    check (any_int 2.5  2   3   == False)\n    check (any_int 1.5  5   3.5 == False)\n    check (any_int 2    6   2   == False)\n    check (any_int 4    2   2   == True)\n    check (any_int 2.2  2.2 2.2 == False)\n    check (any_int (-4) 6   2   == True)\n    check (any_int 2    1   1   == True)\n    check (any_int 3    4   7   == True)\n    check (any_int 3.0  4   7   == False)\n"}
{"task_id": "Haskell/93", "prompt": "-- Write a function that takes a message, and encodes in such a\n-- way that it swaps case of all letters, replaces all vowels in\n-- the message with the letter that appears 2 places ahead of that\n-- vowel in the english alphabet.\n-- Assume only letters.\n-- Examples:\n-- >>> encode \"test\"\n-- \"TGST\"\n-- >>> encode \"This is a message\"\n-- \"tHKS KS C MGSSCGG\"\nencode :: String -> String", "canonical_solution": "-- Task ID: HumanEval/93\n-- Assigned To: Author E\n\n-- Python Implementation:\n\n--\n-- def encode(message):\n--     \"\"\"\n--     Write a function that takes a message, and encodes in such a\n--     way that it swaps case of all letters, replaces all vowels in\n--     the message with the letter that appears 2 places ahead of that\n--     vowel in the english alphabet.\n--     Assume only letters.\n--\n--     Examples:\n--     >>> encode('test')\n--     'TGST'\n--     >>> encode('This is a message')\n--     'tHKS KS C MGSSCGG'\n--     \"\"\"\n--     vowels = \"aeiouAEIOU\"\n--     vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n--     message = message.swapcase()\n--     return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n--\n\n-- Haskell Implementation:\nimport Data.Char\nimport Data.List\nimport Data.Maybe\n\n-- Write a function that takes a message, and encodes in such a\n-- way that it swaps case of all letters, replaces all vowels in\n-- the message with the letter that appears 2 places ahead of that\n-- vowel in the english alphabet.\n-- Assume only letters.\n--\n-- Examples:\n-- >>> encode \"test\"\n-- \"TGST\"\n-- >>> encode \"This is a message\"\n-- \"tHKS KS C MGSSCGG\"\nencode :: String -> String\nencode message =\n  let vowels =  \"aeiouAEIOU\"\n      vowels_replace =\n        zip\n          vowels\n          ( map\n              (\\x ->  chr (ord x + 2))\n              vowels\n          )\n      message' =\n        map\n          ( \\x ->\n              if isUpper x\n                then  toLower x\n                else  toUpper x\n          )\n          message\n   in map\n        ( \\x ->\n            if x `elem` vowels\n              then  (fromJust (lookup x vowels_replace))\n              else  x\n        )\n        message'\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (encode \"TEST\"                       == \"tgst\")\n    check (encode \"Mudasir\"                    == \"mWDCSKR\")\n    check (encode \"YES\"                        == \"ygs\")\n    check (encode \"This is a message\"          == \"tHKS KS C MGSSCGG\")\n    check (encode \"I DoNt KnOw WhAt tO WrItE\"  == \"k dQnT kNqW wHcT Tq wRkTg\")\n"}
{"task_id": "Haskell/94", "prompt": "-- You are given a list of integers.\n-- You need to find the largest prime value and return the sum of its digits.\n-- Examples:\n-- For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n-- For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n-- For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n-- For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n-- For lst = [0,81,12,3,1,21] the output should be 3\n-- For lst = [0,8,1,2,1,7] the output should be 7\nskjkasdkd :: [Int] -> Int", "canonical_solution": "-- Task ID: HumanEval/94\n-- Assigned To: Author E\n\n-- Python Implementation:\n\n--\n--\n-- def skjkasdkd(lst):\n--     \"\"\"You are given a list of integers.\n--     You need to find the largest prime value and return the sum of its digits.\n--\n--     Examples:\n--     For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n--     For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n--     For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n--     For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n--     For lst = [0,81,12,3,1,21] the output should be 3\n--     For lst = [0,8,1,2,1,7] the output should be 7\n--     \"\"\"\n--     def is_prime(n):\n--         for i in range(2,int(n**0.5)+1):\n--             if n%i==0:\n--                 return False\n--\n--         return True\n--     maxx = 0\n--     i = 0\n--     while i < len(lst):\n--         if(lst[i] > maxx and is_prime(lst[i])):\n--             maxx = lst[i]\n--         i+=1\n--     result = sum(int(digit) for digit in str(maxx))\n--     return result\n--\n--\n\n-- Haskell Implementation:\n\n-- You are given a list of integers.\n-- You need to find the largest prime value and return the sum of its digits.\n--\n-- Examples:\n-- For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n-- For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n-- For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n-- For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n-- For lst = [0,81,12,3,1,21] the output should be 3\n-- For lst = [0,8,1,2,1,7] the output should be 7\n\nskjkasdkd :: [Int] -> Int\nskjkasdkd lst =\n  let is_prime n =\n        null\n          [ i\n            | i <-  [2 .. (floor (sqrt  (fromIntegral n)))],\n              n `mod`  i == 0\n          ]\n      maxx =\n        maximum\n          [ i | i <-  lst, is_prime i\n          ]\n   in sum [read [i] | i <-  show maxx]\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (skjkasdkd [0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3] == 10)\n    check (skjkasdkd [1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]             == 25)\n    check (skjkasdkd [1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]     == 13)\n    check (skjkasdkd [0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]                       == 11)\n    check (skjkasdkd [0, 81, 12, 3, 1, 21]                                                    == 3)\n    check (skjkasdkd [0, 8, 1, 2, 1, 7]                                                      == 7)\n    check (skjkasdkd [8191]                                                                  == 19)\n    check (skjkasdkd [8191, 123456, 127, 7]                                                  == 19)\n    check (skjkasdkd [127, 97, 8192]                                                         == 10)\n"}
{"task_id": "Haskell/95", "prompt": "-- Given a dictionary, return True if all keys are strings in lower\n-- case or all keys are strings in upper case, else return False.\n-- The function should return False is the given dictionary is empty.\n-- Examples:\n-- check_dict_case [(\"a\",\"apple\"), (\"b\",\"banana\")] should return True.\n-- check_dict_case [(\"a\",\"apple\"), (\"A\",\"banana\"), (\"B\",\"banana\")] should return False.\n-- check_dict_case [(\"a\",\"apple\"), (\"8\",\"banana\"), (\"a\",\"apple\")] should return False.\n-- check_dict_case [(\"Name\",\"John\"), (\"Age\",\"36\"), (\"City\",\"Houston\")] should return False.\n-- check_dict_case [(\"STATE\",\"NC\"), (\"ZIP\",\"12345\")] should return True.\ncheck_dict_case :: [(String, String)] -> Bool", "canonical_solution": "-- Task ID: HumanEval/95\n-- Assigned To: Author E\n\n-- Python Implementation:\n\n--\n-- def check_dict_case(dict):\n--     \"\"\"\n--     Given a dictionary, return True if all keys are strings in lower\n--     case or all keys are strings in upper case, else return False.\n--     The function should return False is the given dictionary is empty.\n--     Examples:\n--     check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n--     check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n--     check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n--     check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n--     check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n--     \"\"\"\n--     if len(dict.keys()) == 0:\n--         return False\n--     else:\n--         state = \"start\"\n--         for key in dict.keys():\n--\n--             if isinstance(key, str) == False:\n--                 state = \"mixed\"\n--                 break\n--             if state == \"start\":\n--                 if key.isupper():\n--                     state = \"upper\"\n--                 elif key.islower():\n--                     state = \"lower\"\n--                 else:\n--                     break\n--             elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n--                     state = \"mixed\"\n--                     break\n--             else:\n--                 break\n--         return state == \"upper\" or state == \"lower\"\n--\n\n-- Haskell Implementation:\nimport Data.Char\n\n-- Given a dictionary, return True if all keys are strings in lower\n-- case or all keys are strings in upper case, else return False.\n-- The function should return False is the given dictionary is empty.\n-- Examples:\n-- check_dict_case [(\"a\",\"apple\"), (\"b\",\"banana\")] should return True.\n-- check_dict_case [(\"a\",\"apple\"), (\"A\",\"banana\"), (\"B\",\"banana\")] should return False.\n-- check_dict_case [(\"a\",\"apple\"), (\"8\",\"banana\"), (\"a\",\"apple\")] should return False.\n-- check_dict_case [(\"Name\",\"John\"), (\"Age\",\"36\"), (\"City\",\"Houston\")] should return False.\n-- check_dict_case [(\"STATE\",\"NC\"), (\"ZIP\",\"12345\")] should return True.\n\ncheck_dict_case :: [(String, String)] -> Bool\ncheck_dict_case dict =\n  length dict >  0\n    && all (\\x ->  all isUpper x) keys\n    || all\n      (\\x ->  all isLower x)\n      keys\n  where\n    keys = map  fst dict\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (check_dict_case [(\"p\",\"pineapple\"), (\"b\",\"banana\")]                                       == True)\n    check (check_dict_case [(\"p\",\"pineapple\"), (\"A\",\"banana\"), (\"B\",\"banana\")]                     == False)\n    check (check_dict_case [(\"p\",\"pineapple\"), (\"5\",\"banana\"), (\"a\",\"apple\")]                    == False)\n    check (check_dict_case [(\"Name\",\"John\"), (\"Age\",\"36\"), (\"City\",\"Houston\")]                   == False)\n    check (check_dict_case [(\"STATE\",\"NC\"), (\"ZIP\",\"12345\")]                                         == True)\n    check (check_dict_case [(\"fruit\",\"Orange\"), (\"taste\",\"Sweet\")]                                    == True)\n    check (check_dict_case []                                                                              == False)\n"}
{"task_id": "Haskell/96", "prompt": "-- Implement a function that takes an non-negative integer and returns an array of the first n\n-- integers that are prime numbers and less than n.\n-- for example:\n-- count_up_to 5 => [2,3]\n-- count_up_to 11 => [2,3,5,7]\n-- count_up_to 0 => []\n-- count_up_to 20 => [2,3,5,7,11,13,17,19]\n-- count_up_to 1 => []\n-- count_up_to 18 => [2,3,5,7,11,13,17]\ncount_up_to :: Int -> [Int]", "canonical_solution": "-- Task ID: HumanEval/96\n-- Assigned To: Author E\n\n-- Python Implementation:\n\n--\n-- def count_up_to(n):\n--     \"\"\"Implement a function that takes an non-negative integer and returns an array of the first n\n--     integers that are prime numbers and less than n.\n--     for example:\n--     count_up_to(5) => [2,3]\n--     count_up_to(11) => [2,3,5,7]\n--     count_up_to(0) => []\n--     count_up_to(20) => [2,3,5,7,11,13,17,19]\n--     count_up_to(1) => []\n--     count_up_to(18) => [2,3,5,7,11,13,17]\n--     \"\"\"\n--     primes = []\n--     for i in range(2, n):\n--         is_prime = True\n--         for j in range(2, i):\n--             if i % j == 0:\n--                 is_prime = False\n--                 break\n--         if is_prime:\n--             primes.append(i)\n--     return primes\n--\n--\n\n-- Haskell Implementation:\n\n-- Implement a function that takes an non-negative integer and returns an array of the first n\n-- integers that are prime numbers and less than n.\n-- for example:\n-- count_up_to 5 => [2,3]\n-- count_up_to 11 => [2,3,5,7]\n-- count_up_to 0 => []\n-- count_up_to 20 => [2,3,5,7,11,13,17,19]\n-- count_up_to 1 => []\n-- count_up_to 18 => [2,3,5,7,11,13,17]\n\ncount_up_to :: Int -> [Int]\ncount_up_to n =\n  [ i\n    | i <-  [2 .. (n - 1)],\n      is_prime  i\n  ]\n  where\n    is_prime n =\n      null\n        [ i\n          | i <-  [2 ..  (n - 1)],\n            n `mod`  i == 0\n        ]\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (count_up_to 5   == [2,3])\n    check (count_up_to 6   == [2,3,5])\n    check (count_up_to 7   == [2,3,5])\n    check (count_up_to 10  == [2,3,5,7])\n    check (count_up_to 0   == [])\n    check (count_up_to 22  == [2,3,5,7,11,13,17,19])\n    check (count_up_to 1   == [])\n    check (count_up_to 18  == [2,3,5,7,11,13,17])\n    check (count_up_to 47  == [2,3,5,7,11,13,17,19,23,29,31,37,41,43])\n    check (count_up_to 101 == [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97])\n"}
{"task_id": "Haskell/97", "prompt": "-- Complete the function that takes two integers and returns\n-- the product of their unit digits.\n-- Assume the input is always valid.\n-- Examples:\n-- multiply 148 412 should return 16.\n-- multiply 19 28 should return 72.\n-- multiply 2020 1851 should return 0.\n-- multiply 14 (-15) should return 20.\nmultiply :: Int -> Int -> Int", "canonical_solution": "-- Task ID: HumanEval/97\n-- Assigned To: Author E\n\n-- Python Implementation:\n\n--\n-- def multiply(a, b):\n--     \"\"\"Complete the function that takes two integers and returns\n--     the product of their unit digits.\n--     Assume the input is always valid.\n--     Examples:\n--     multiply(148, 412) should return 16.\n--     multiply(19, 28) should return 72.\n--     multiply(2020, 1851) should return 0.\n--     multiply(14,-15) should return 20.\n--     \"\"\"\n--     return abs(a % 10) * abs(b % 10)\n--\n\n-- Haskell Implementation:\n\n-- Complete the function that takes two integers and returns\n-- the product of their unit digits.\n-- Assume the input is always valid.\n-- Examples:\n-- multiply 148 412 should return 16.\n-- multiply 19 28 should return 72.\n-- multiply 2020 1851 should return 0.\n-- multiply 14 (-15) should return 20.\n\nmultiply :: Int -> Int -> Int\nmultiply a b =\n  abs  (a `mod` 10)\n    * abs  (b `mod` 10)\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (multiply 148   412  == 16)\n    check (multiply 19    28   == 72)\n    check (multiply 2020  1851 == 0)\n    check (multiply 14   (-15) == 20)\n    check (multiply 76    67   == 42)\n    check (multiply 17    27   == 49)\n    check (multiply 0     1    == 0)\n    check (multiply 0     0    == 0)\n"}
{"task_id": "Haskell/98", "prompt": "-- Given a string s, count the number of uppercase vowels in even indices.\n-- For example:\n-- count_upper \"aBCdEf\" returns 1\n-- count_upper \"abcdefg\" returns 0\n-- count_upper \"dBBE\" returns 0\ncount_upper :: String -> Int", "canonical_solution": "-- Task ID: HumanEval/98\n-- Assigned To: Author E\n\n-- Python Implementation:\n\n--\n-- def count_upper(s):\n--     \"\"\"\n--     Given a string s, count the number of uppercase vowels in even indices.\n--\n--     For example:\n--     count_upper('aBCdEf') returns 1\n--     count_upper('abcdefg') returns 0\n--     count_upper('dBBE') returns 0\n--     \"\"\"\n--     count = 0\n--     for i in range(0,len(s),2):\n--         if s[i] in \"AEIOU\":\n--             count += 1\n--     return count\n--\n\n-- Haskell Implementation:\n\n-- Given a string s, count the number of uppercase vowels in even indices.\n--\n-- For example:\n-- count_upper \"aBCdEf\" returns 1\n-- count_upper \"abcdefg\" returns 0\n-- count_upper \"dBBE\" returns 0\n\ncount_upper :: String -> Int\ncount_upper s =\n  length\n    [ i\n      | i <-  [0, 2 ..  (length s - 1)],\n        s !! i `elem`  \"AEIOU\"\n    ]\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (count_upper \"aBCdEf\" == 1)\n    check (count_upper \"abcdefg\"== 0)\n    check (count_upper \"dBBE\"   == 0)\n    check (count_upper \"B\"      == 0)\n    check (count_upper \"U\"      == 1)\n    check (count_upper \"\"       == 0)\n    check (count_upper \"EEEE\"   == 2)\n"}
{"task_id": "Haskell/99", "prompt": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer \"10\"\n-- 10\n-- >>> closest_integer \"15.3\"\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nclosest_integer :: String -> Integer", "canonical_solution": "-- Task ID: HumanEval/99\n-- Assigned To: Author D\n\n-- Python Implementation:\n\n-- \n-- def closest_integer(value):\n--     '''\n--     Create a function that takes a value (string) representing a number\n--     and returns the closest integer to it. If the number is equidistant\n--     from two integers, round it away from zero.\n-- \n--     Examples\n--     >>> closest_integer(\"10\")\n--     10\n--     >>> closest_integer(\"15.3\")\n--     15\n-- \n--     Note:\n--     Rounding away from zero means that if the given number is equidistant\n--     from two integers, the one you should return is the one that is the\n--     farthest from zero. For example closest_integer(\"14.5\") should\n--     return 15 and closest_integer(\"-14.5\") should return -15.\n--     '''\n--     from math import floor, ceil\n-- \n--     if value.count('.') == 1:\n--         # remove trailing zeros\n--         while (value[-1] == '0'):\n--             value = value[:-1]\n-- \n--     num = float(value)\n--     if value[-2:] == '.5':\n--         if num > 0:\n--             res = ceil(num)\n--         else:\n--             res = floor(num)\n--     elif len(value) > 0:\n--         res = int(round(num))\n--     else:\n--         res = 0\n-- \n--     return res\n-- \n-- \n\n\n-- Haskell Implementation:\n\n-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- \n-- Examples\n-- >>> closest_integer \"10\"\n-- 10\n-- >>> closest_integer \"15.3\"\n-- 15\n-- \n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nclosest_integer :: String -> Integer\nclosest_integer s = let n =  read s  :: Double\n    in round  n\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (closest_integer \"10\"   == 10)\n    check (closest_integer \"14.5\" == 15)\n    check (closest_integer \"-15.5\"== -16)\n    check (closest_integer \"15.3\" == 15)\n    check (closest_integer \"0\"    == 0)\n"}
{"task_id": "Haskell/100", "prompt": "-- Given a positive integer n, you have to make a pile of n levels of stones.\n-- The first level has n stones.\n-- The number of stones in the next level is:\n--     - the next odd number if n is odd.\n--     - the next even number if n is even.\n-- Return the number of stones in each level in a list, where element at index\n-- i represents the number of stones in the level (i+1).\n-- Examples:\n-- >>> make_a_pile 3\n-- [3,5,7]\nmake_a_pile :: Int -> [Int]", "canonical_solution": "-- Task ID: HumanEval/100\n-- Assigned To: Author D\n\n-- Python Implementation:\n\n--\n-- def make_a_pile(n):\n--     \"\"\"\n--     Given a positive integer n, you have to make a pile of n levels of stones.\n--     The first level has n stones.\n--     The number of stones in the next level is:\n--         - the next odd number if n is odd.\n--         - the next even number if n is even.\n--     Return the number of stones in each level in a list, where element at index\n--     i represents the number of stones in the level (i+1).\n--\n--     Examples:\n--     >>> make_a_pile(3)\n--     [3, 5, 7]\n--     \"\"\"\n--     return [n + 2*i for i in range(n)]\n--\n\n-- Haskell Implementation:\n\n-- Given a positive integer n, you have to make a pile of n levels of stones.\n-- The first level has n stones.\n-- The number of stones in the next level is:\n--     - the next odd number if n is odd.\n--     - the next even number if n is even.\n-- Return the number of stones in each level in a list, where element at index\n-- i represents the number of stones in the level (i+1).\n--\n-- Examples:\n-- >>> make_a_pile 3\n-- [3,5,7]\nmake_a_pile :: Int -> [Int]\nmake_a_pile n =\n  [ n +  2 * i\n    | i <-  [0 ..  n - 1]\n  ]\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (make_a_pile 3 == [3,5,7])\n    check (make_a_pile 4 == [4,6,8,10])\n    check (make_a_pile 5 == [5,7,9,11,13])\n    check (make_a_pile 6 == [6,8,10,12,14,16])\n    check (make_a_pile 8 == [8,10,12,14,16,18,20,22])"}
{"task_id": "Haskell/101", "prompt": "-- You will be given a string of words separated by commas or spaces. Your task is\n-- to split the string into words and return an array of the words.\n-- For example:\n-- >>> words_string \"Hi, my name is John\"\n-- [\"Hi\",\"my\",\"name\",\"is\",\"John\"]\n-- >>> words_string \"One, two, three, four, five, six\"\n-- [\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"]\nwords_string :: String -> [String]", "canonical_solution": "-- Task ID: HumanEval/101\n-- Assigned To: Author D\n\n-- Python Implementation:\n\n--\n-- def words_string(s):\n--     \"\"\"\n--     You will be given a string of words separated by commas or spaces. Your task is\n--     to split the string into words and return an array of the words.\n--\n--     For example:\n--     words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n--     words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n--     \"\"\"\n--     if not s:\n--         return []\n--\n--     s_list = []\n--\n--     for letter in s:\n--         if letter == ',':\n--             s_list.append(' ')\n--         else:\n--             s_list.append(letter)\n--\n--     s_list = \"\".join(s_list)\n--     return s_list.split()\n--\n\n-- Haskell Implementation:\n\n-- You will be given a string of words separated by commas or spaces. Your task is\n-- to split the string into words and return an array of the words.\n--\n-- For example:\n-- >>> words_string \"Hi, my name is John\"\n-- [\"Hi\",\"my\",\"name\",\"is\",\"John\"]\n-- >>> words_string \"One, two, three, four, five, six\"\n-- [\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"]\nwords_string :: String -> [String]\nwords_string s =  words $\n        map\n        ( \\c ->\n            if c ==  ','\n                then  ' '\n                else  c\n        )\n        s\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (words_string \"Hi, my name is John\" == [\"Hi\",\"my\",\"name\",\"is\",\"John\"])\n    check (words_string \"One, two, three, four, five, six\" == [\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"])\n    check (words_string \"Hi, my name\" == [\"Hi\",\"my\",\"name\"])\n    check (words_string \"One,, two, three, four, five, six,\" == [\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"])\n    check (words_string \"\" == [])\n    check (words_string \"ahmed     , gamal\" == [\"ahmed\",\"gamal\"])"}
{"task_id": "Haskell/102", "prompt": "-- This function takes two positive numbers x and y and returns the\n-- biggest even integer number that is in the range [x, y] inclusive. If\n-- there's no such number, then the function should return -1.\n-- For example:\n-- choose_num 12 15 = 14\n-- choose_num 13 12 = -1\nchoose_num :: Int -> Int -> Int", "canonical_solution": "-- Task ID: HumanEval/102\n-- Assigned To: Author D\n\n-- Python Implementation:\n\n--\n-- def choose_num(x, y):\n--     \"\"\"This function takes two positive numbers x and y and returns the\n--     biggest even integer number that is in the range [x, y] inclusive. If\n--     there's no such number, then the function should return -1.\n--\n--     For example:\n--     choose_num(12, 15) = 14\n--     choose_num(13, 12) = -1\n--     \"\"\"\n--     if x > y:\n--         return -1\n--     if y % 2 == 0:\n--         return y\n--     if x == y:\n--         return -1\n--     return y - 1\n--\n\n-- Haskell Implementation:\n\n-- This function takes two positive numbers x and y and returns the\n-- biggest even integer number that is in the range [x, y] inclusive. If\n-- there's no such number, then the function should return -1.\n--\n-- For example:\n-- choose_num 12 15 = 14\n-- choose_num 13 12 = -1\nchoose_num :: Int -> Int -> Int\nchoose_num x y\n  | x >  y =  -1\n  | y `mod`  2 == 0 =  y\n  | x ==  y =  -1\n  | otherwise =  y - 1\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (choose_num 12 15 == 14)\n    check (choose_num 13 12 == -1)\n    check (choose_num 33 12354 == 12354)\n    check (choose_num 5234 5233 == -1)\n    check (choose_num 6 29 == 28)\n    check (choose_num 27 10 == -1)\n    check (choose_num 7 7 == -1)\n    check (choose_num 546 546 == 546)"}
{"task_id": "Haskell/103", "prompt": "-- You are given two positive integers n and m, and your task is to compute the\n-- average of the integers from n through m (including n and m).\n-- Round the answer to the nearest integer and convert that to binary.\n-- If n is greater than m, return -1.\n-- Example:\n-- rounded_avg 1 5 => \"0b11\"\n-- rounded_avg 7 5 => -1\n-- rounded_avg 10 20 => \"0b1111\"\n-- rounded_avg 20 33 => \"0b11010\"\nrounded_avg :: Int -> Int -> Either Int String", "canonical_solution": "-- Task ID: HumanEval/103\n-- Assigned To: Author D\n\n-- Python Implementation:\n\n--\n-- def rounded_avg(n, m):\n--     \"\"\"You are given two positive integers n and m, and your task is to compute the\n--     average of the integers from n through m (including n and m).\n--     Round the answer to the nearest integer and convert that to binary.\n--     If n is greater than m, return -1.\n--     Example:\n--     rounded_avg(1, 5) => \"0b11\"\n--     rounded_avg(7, 5) => -1\n--     rounded_avg(10, 20) => \"0b1111\"\n--     rounded_avg(20, 33) => \"0b11010\"\n--     \"\"\"\n--     if m < n:\n--         return -1\n--     summation = 0\n--     for i in range(n, m+1):\n--         summation += i\n--     return bin(round(summation/(m - n + 1)))\n--\n\n-- Haskell Implementation:\n\n-- You are given two positive integers n and m, and your task is to compute the\n-- average of the integers from n through m (including n and m).\n-- Round the answer to the nearest integer and convert that to binary.\n-- If n is greater than m, return -1.\n-- Example:\n-- rounded_avg 1 5 => \"0b11\"\n-- rounded_avg 7 5 => -1\n-- rounded_avg 10 20 => \"0b1111\"\n-- rounded_avg 20 33 => \"0b11010\"\nimport Data.Char (intToDigit)\nimport Numeric (showIntAtBase)\n\nrounded_avg :: Int -> Int -> Either Int String\nrounded_avg n m\n  | m <  n =  Left (-1)\n  | otherwise =\n      let avg = round $ fromIntegral  (n + m) / 2\n       in Right $ \"0b\" ++  Numeric.showIntAtBase 2 Data.Char.intToDigit  avg \"\"\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (rounded_avg 1 5 == \"0b11\")\n    check (rounded_avg 7 13 == \"0b1010\")\n    check (rounded_avg 964 977 == \"0b1111001010\")\n    check (rounded_avg 996 997 == \"0b1111100100\")\n    check (rounded_avg 560 851 == \"0b1011000010\")\n    check (rounded_avg 185 546 == \"0b101101110\")\n    check (rounded_avg 362 496 == \"0b110101101\")\n    check (rounded_avg 350 902 == \"0b1001110010\")\n    check (rounded_avg 197 233 == \"0b11010111\")\n    check (rounded_avg 7 5 == -1)\n    check (rounded_avg 5 1 == -1)\n    check (rounded_avg 5 5 == \"0b101\")"}
{"task_id": "Haskell/104", "prompt": "-- Given a list of positive integers x. return a sorted list of all\n-- elements that hasn't any even digit.\n-- Note: Returned list should be sorted in increasing order.\n-- For example:\n-- >>> unique_digits [15, 33, 1422, 1]\n-- [1,15,33]\n-- >>> unique_digits [152, 323, 1422, 10]\n-- []\nunique_digits :: [Int] -> [Int]", "canonical_solution": "-- Task ID: HumanEval/104\n-- Assigned To: Author D\n\n-- Python Implementation:\n\n--\n-- def unique_digits(x):\n--     \"\"\"Given a list of positive integers x. return a sorted list of all\n--     elements that hasn't any even digit.\n--\n--     Note: Returned list should be sorted in increasing order.\n--\n--     For example:\n--     >>> unique_digits([15, 33, 1422, 1])\n--     [1, 15, 33]\n--     >>> unique_digits([152, 323, 1422, 10])\n--     []\n--     \"\"\"\n--     odd_digit_elements = []\n--     for i in x:\n--         if all (int(c) % 2 == 1 for c in str(i)):\n--             odd_digit_elements.append(i)\n--     return sorted(odd_digit_elements)\n--\n\n-- Haskell Implementation:\n\n-- Given a list of positive integers x. return a sorted list of all\n-- elements that hasn't any even digit.\n--\n-- Note: Returned list should be sorted in increasing order.\n--\n-- For example:\n-- >>> unique_digits [15, 33, 1422, 1]\n-- [1,15,33]\n-- >>> unique_digits [152, 323, 1422, 10]\n-- []\n\nimport Data.Char (digitToInt)\nimport Data.List (sort)\n\nunique_digits :: [Int] -> [Int]\nunique_digits x =  sort $ filter\n      (all odd .  map digitToInt .  show)\n      x\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (unique_digits [15,33,1422,1] == [1,15,33])\n    check (unique_digits [152,323,1422,10] == [])\n    check (unique_digits [12345,2033,111,151] == [111,151])\n    check (unique_digits [135,103,31] == [31,135])"}
{"task_id": "Haskell/105", "prompt": "-- Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n-- reverse the resulting array, and then replace each digit by its corresponding name from\n-- \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n-- For example:\n--   arr = [2, 1, 1, 4, 5, 8, 2, 3]\n--         -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8]\n--         -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n--   return [\"Eight\",\"Five\",\"Four\",\"Three\",\"Two\",\"Two\",\"One\",\"One\"]\n--   If the array is empty, return an empty array:\n--   arr = []\n--   return []\n--   If the array has any strange number ignore it:\n--   arr = [1, -1 , 55]\n--         -> sort arr -> [-1, 1, 55]\n--         -> reverse arr -> [55, 1, -1]\n--   return = ['One']\nby_length :: [Int] -> [String]", "canonical_solution": "-- Task ID: HumanEval/105\n-- Assigned To: Author D\n\n-- Python Implementation:\n\n-- \n-- def by_length(arr):\n--     \"\"\"\n--     Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n--     reverse the resulting array, and then replace each digit by its corresponding name from\n--     \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n-- \n--     For example:\n--       arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n--             -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n--             -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n--       return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n--     \n--       If the array is empty, return an empty array:\n--       arr = []\n--       return []\n--     \n--       If the array has any strange number ignore it:\n--       arr = [1, -1 , 55] \n--             -> sort arr -> [-1, 1, 55]\n--             -> reverse arr -> [55, 1, -1]\n--       return = ['One']\n--     \"\"\"\n--     dic = {\n--         1: \"One\",\n--         2: \"Two\",\n--         3: \"Three\",\n--         4: \"Four\",\n--         5: \"Five\",\n--         6: \"Six\",\n--         7: \"Seven\",\n--         8: \"Eight\",\n--         9: \"Nine\",\n--     }\n--     sorted_arr = sorted(arr, reverse=True)\n--     new_arr = []\n--     for var in sorted_arr:\n--         try:\n--             new_arr.append(dic[var])\n--         except:\n--             pass\n--     return new_arr\n-- \n\n\n-- Haskell Implementation:\n\n-- Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n-- reverse the resulting array, and then replace each digit by its corresponding name from\n-- \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n-- \n-- For example:\n--   arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n--         -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n--         -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n--   return [\"Eight\",\"Five\",\"Four\",\"Three\",\"Two\",\"Two\",\"One\",\"One\"]\n--     \n--   If the array is empty, return an empty array:\n--   arr = []\n--   return []\n--     \n--   If the array has any strange number ignore it:\n--   arr = [1, -1 , 55] \n--         -> sort arr -> [-1, 1, 55]\n--         -> reverse arr -> [55, 1, -1]\n--   return = ['One']\n\nimport Data.List (sort)\n\nby_length :: [Int] -> [String]\nby_length xs = map toWord $  filter isDigit $  reverse $  sort xs\n  where\n    isDigit x =  x >= 1 &&  x <= 9\n    toWord x = case  x of\n      1 ->  \"One\"\n      2 ->  \"Two\"\n      3 ->  \"Three\"\n      4 ->  \"Four\"\n      5 ->  \"Five\"\n      6 ->  \"Six\"\n      7 ->  \"Seven\"\n      8 ->  \"Eight\"\n      9 ->  \"Nine\"\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (by_length [2,1,1,4,5,8,2,3] == [\"Eight\",\"Five\",\"Four\",\"Three\",\"Two\",\"Two\",\"One\",\"One\"])\n    check (by_length [] == [])\n    check (by_length [1,-1,55] == [\"One\"])\n    check (by_length [1,-1,3,2] == [\"Three\",\"Two\",\"One\"])\n    check (by_length [9,4,8] == [\"Nine\",\"Eight\",\"Four\"])"}
{"task_id": "Haskell/106", "prompt": "-- Implement the function f that takes n as a parameter,\n-- and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n-- or the sum of numbers from 1 to i otherwise.\n-- i starts from 1.\n-- the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n-- Example:\n-- f 5 == [1,2,6,24,15]\nf :: Int -> [Int]", "canonical_solution": "-- Task ID: HumanEval/106\n-- Assigned To: Author D\n\n-- Python Implementation:\n\n--\n-- def f(n):\n--     \"\"\" Implement the function f that takes n as a parameter,\n--     and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n--     or the sum of numbers from 1 to i otherwise.\n--     i starts from 1.\n--     the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n--     Example:\n--     f(5) == [1, 2, 6, 24, 15]\n--     \"\"\"\n--     ret = []\n--     for i in range(1,n+1):\n--         if i%2 == 0:\n--             x = 1\n--             for j in range(1,i+1): x *= j\n--             ret += [x]\n--         else:\n--             x = 0\n--             for j in range(1,i+1): x += j\n--             ret += [x]\n--     return ret\n--\n\n-- Haskell Implementation:\n\n-- Implement the function f that takes n as a parameter,\n-- and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n-- or the sum of numbers from 1 to i otherwise.\n-- i starts from 1.\n-- the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n-- Example:\n-- f 5 == [1,2,6,24,15]\nf :: Int -> [Int]\nf n =\n  [ if  even i\n      then  product [1 .. i]\n      else  sum [1 .. i]\n    | i <-  [1 .. n]\n  ]\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (f 5 == [1,2,6,24,15])\n    check (f 7 == [1,2,6,24,15,720,28])\n    check (f 1 == [1])\n    check (f 3 == [1,2,6])"}
{"task_id": "Haskell/107", "prompt": "-- Given a positive integer n, return a tuple that has the number of even and odd\n-- integer palindromes that fall within the range(1, n), inclusive.\n-- Example 1:\n--     Input: 3\n--     Output: (1,2)\n--     Explanation:\n--     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n-- Example 2:\n--     Input: 12\n--     Output: (4,6)\n--     Explanation:\n--     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n-- Note:\n--     1. 1 <= n <= 10^3\n--     2. returned tuple has the number of even and odd integer palindromes respectively.\neven_odd_palindrome :: Int -> (Int, Int)", "canonical_solution": "-- Task ID: HumanEval/107\n-- Assigned To: Author D\n\n-- Python Implementation:\n\n-- \n-- def even_odd_palindrome(n):\n--     \"\"\"\n--     Given a positive integer n, return a tuple that has the number of even and odd\n--     integer palindromes that fall within the range(1, n), inclusive.\n-- \n--     Example 1:\n-- \n--         Input: 3\n--         Output: (1, 2)\n--         Explanation:\n--         Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n-- \n--     Example 2:\n-- \n--         Input: 12\n--         Output: (4, 6)\n--         Explanation:\n--         Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n-- \n--     Note:\n--         1. 1 <= n <= 10^3\n--         2. returned tuple has the number of even and odd integer palindromes respectively.\n--     \"\"\"\n--     def is_palindrome(n):\n--         return str(n) == str(n)[::-1]\n-- \n--     even_palindrome_count = 0\n--     odd_palindrome_count = 0\n-- \n--     for i in range(1, n+1):\n--         if i%2 == 1 and is_palindrome(i):\n--                 odd_palindrome_count += 1\n--         elif i%2 == 0 and is_palindrome(i):\n--             even_palindrome_count += 1\n--     return (even_palindrome_count, odd_palindrome_count)\n-- \n\n\n-- Haskell Implementation:\n\n-- Given a positive integer n, return a tuple that has the number of even and odd\n-- integer palindromes that fall within the range(1, n), inclusive.\n-- \n-- Example 1:\n-- \n--     Input: 3\n--     Output: (1,2)\n--     Explanation:\n--     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n-- \n-- Example 2:\n-- \n--     Input: 12\n--     Output: (4,6)\n--     Explanation:\n--     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n-- \n-- Note:\n--     1. 1 <= n <= 10^3\n--     2. returned tuple has the number of even and odd integer palindromes respectively.\n\neven_odd_palindrome :: Int -> (Int, Int)\neven_odd_palindrome n = (evenCount, oddCount)\n  where\n    isPalindrome x =  show x == reverse  (show x)\n    evenCount = length [x | x <-  [1..n], isPalindrome x,  even x]\n    oddCount = length [x | x <-  [1..n], isPalindrome x,  odd x]\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (even_odd_palindrome 123 == (8,13))\n    check (even_odd_palindrome 12 == (4,6))\n    check (even_odd_palindrome 3 == (1,2))\n    check (even_odd_palindrome 63 == (6,8))\n    check (even_odd_palindrome 25 == (5,6))\n    check (even_odd_palindrome 19 == (4,6))\n    check (even_odd_palindrome 9 == (4,5))\n    check (even_odd_palindrome 1 == (0,1))"}
{"task_id": "Haskell/108", "prompt": "-- Write a function count_nums which takes an array of integers and returns\n-- the number of elements which has a sum of digits > 0.\n-- If a number is negative, then its first signed digit will be negative:\n-- e.g. -123 has signed digits -1, 2, and 3.\n-- >>> count_nums [] == 0\n-- >>> count_nums [-1, 11, -11] == 1\n-- >>> count_nums [1, 1, 2] == 3\ncount_nums :: [Int] -> Int", "canonical_solution": "-- Task ID: HumanEval/108\n-- Assigned To: Author D\n\n-- Python Implementation:\n\n--\n-- def count_nums(arr):\n--     \"\"\"\n--     Write a function count_nums which takes an array of integers and returns\n--     the number of elements which has a sum of digits > 0.\n--     If a number is negative, then its first signed digit will be negative:\n--     e.g. -123 has signed digits -1, 2, and 3.\n--     >>> count_nums([]) == 0\n--     >>> count_nums([-1, 11, -11]) == 1\n--     >>> count_nums([1, 1, 2]) == 3\n--     \"\"\"\n--     def digits_sum(n):\n--         neg = 1\n--         if n < 0: n, neg = -1 * n, -1\n--         n = [int(i) for i in str(n)]\n--         n[0] = n[0] * neg\n--         return sum(n)\n--     return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n--\n\n-- Haskell Implementation:\n\n-- Write a function count_nums which takes an array of integers and returns\n-- the number of elements which has a sum of digits > 0.\n-- If a number is negative, then its first signed digit will be negative:\n-- e.g. -123 has signed digits -1, 2, and 3.\n-- >>> count_nums [] == 0\n-- >>> count_nums [-1, 11, -11] == 1\n-- >>> count_nums [1, 1, 2] == 3\nimport Data.Char (digitToInt)\n\ncount_nums :: [Int] -> Int\ncount_nums arr = length $ filter  (> 0) $ map digitsSum arr\n  where\n    digitsSum n =\n      if  n < 0\n        then  negate $ sum $ map digitToInt  $ tail $ show n\n        else  sum $ map digitToInt  $ show n\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (count_nums [] == 0)\n    check (count_nums [-1,-2,0] == 0)\n    check (count_nums [1,1,2,-2,3,4,5] == 6)\n    check (count_nums [1,6,9,-6,0,1,5] == 5)\n    check (count_nums [1,100,98,-7,1,-1] == 4)\n    check (count_nums [12,23,34,-45,-56,0] == 5)\n    check (count_nums [0,1] == 1)\n    check (count_nums [1] == 1)"}
{"task_id": "Haskell/109", "prompt": "-- We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n-- numbers in the array will be randomly ordered. Your task is to determine if\n-- it is possible to get an array sorted in non-decreasing order by performing\n-- the following operation on the given array:\n--     You are allowed to perform right shift operation any number of times.\n-- One right shift operation means shifting all elements of the array by one\n-- position in the right direction. The last element of the array will be moved to\n-- the starting position in the array i.e. 0th index.\n-- If it is possible to obtain the sorted array by performing the above operation\n-- then return True else return False.\n-- If the given array is empty then return True.\n-- Note: The given list is guaranteed to have unique elements.\n-- For Example:\n-- move_one_ball [3, 4, 5, 1, 2] ==>True\n-- Explanation: By performin 2 right shift operations, non-decreasing order can\n--              be achieved for the given array.\n-- move_one_ball [3, 5, 4, 1, 2] ==>False\n-- Explanation:It is not possible to get non-decreasing order for the given\n--             array by performing any number of right shift operations.\nmove_one_ball :: (Ord a) => [a] -> Bool", "canonical_solution": "-- Task ID: HumanEval/109\n-- Assigned To: Author D\n\n-- Python Implementation:\n\n--\n-- def move_one_ball(arr):\n--     \"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n--     numbers in the array will be randomly ordered. Your task is to determine if\n--     it is possible to get an array sorted in non-decreasing order by performing\n--     the following operation on the given array:\n--         You are allowed to perform right shift operation any number of times.\n--\n--     One right shift operation means shifting all elements of the array by one\n--     position in the right direction. The last element of the array will be moved to\n--     the starting position in the array i.e. 0th index.\n--\n--     If it is possible to obtain the sorted array by performing the above operation\n--     then return True else return False.\n--     If the given array is empty then return True.\n--\n--     Note: The given list is guaranteed to have unique elements.\n--\n--     For Example:\n--\n--     move_one_ball([3, 4, 5, 1, 2])==>True\n--     Explanation: By performin 2 right shift operations, non-decreasing order can\n--                  be achieved for the given array.\n--     move_one_ball([3, 5, 4, 1, 2])==>False\n--     Explanation:It is not possible to get non-decreasing order for the given\n--                 array by performing any number of right shift operations.\n--\n--     \"\"\"\n--     if len(arr)==0:\n--       return True\n--     sorted_array=sorted(arr)\n--     my_arr=[]\n--\n--     min_value=min(arr)\n--     min_index=arr.index(min_value)\n--     my_arr=arr[min_index:]+arr[0:min_index]\n--     for i in range(len(arr)):\n--       if my_arr[i]!=sorted_array[i]:\n--         return False\n--     return True\n--\n\n-- Haskell Implementation:\n\n-- We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n-- numbers in the array will be randomly ordered. Your task is to determine if\n-- it is possible to get an array sorted in non-decreasing order by performing\n-- the following operation on the given array:\n--     You are allowed to perform right shift operation any number of times.\n--\n-- One right shift operation means shifting all elements of the array by one\n-- position in the right direction. The last element of the array will be moved to\n-- the starting position in the array i.e. 0th index.\n--\n-- If it is possible to obtain the sorted array by performing the above operation\n-- then return True else return False.\n-- If the given array is empty then return True.\n--\n-- Note: The given list is guaranteed to have unique elements.\n--\n-- For Example:\n--\n-- move_one_ball [3, 4, 5, 1, 2] ==>True\n-- Explanation: By performin 2 right shift operations, non-decreasing order can\n--              be achieved for the given array.\n-- move_one_ball [3, 5, 4, 1, 2] ==>False\n-- Explanation:It is not possible to get non-decreasing order for the given\n--             array by performing any number of right shift operations.\nimport Data.List (sort)\n\nmove_one_ball :: (Ord a) => [a] -> Bool\nmove_one_ball [] = True\nmove_one_ball arr = any (\\i ->  rotate i arr ==  sort arr) [0 ..  length arr - 1]\n  where\n    rotate n xs =  drop n xs ++  take n xs\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (move_one_ball [3,4,5,1,2] == True)\n    check (move_one_ball [3,5,10,1,2] == True)\n    check (move_one_ball [4,3,1,2] == False)\n    check (move_one_ball [3,5,4,1,2] == False)\n    check (move_one_ball [] == True)"}
{"task_id": "Haskell/110", "prompt": "-- In this problem, you will implement a function that takes two lists of numbers,\n-- and determines whether it is possible to perform an exchange of elements\n-- between them to make lst1 a list of only even numbers.\n-- There is no limit on the number of exchanged elements between lst1 and lst2.\n-- If it is possible to exchange elements between the lst1 and lst2 to make\n-- all the elements of lst1 to be even, return \"YES\".\n-- Otherwise, return \"NO\".\n-- For example:\n-- exchange [1, 2, 3, 4] [1, 2, 3, 4] => \"YES\"\n-- exchange [1, 2, 3, 4] [1, 5, 3, 4] => \"NO\"\n-- It is assumed that the input lists will be non-empty.\nexchange :: [Int] -> [Int] -> String", "canonical_solution": "-- Task ID: HumanEval/110\n-- Assigned To: Author D\n\n-- Python Implementation:\n\n-- \n-- def exchange(lst1, lst2):\n--     \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n--     and determines whether it is possible to perform an exchange of elements\n--     between them to make lst1 a list of only even numbers.\n--     There is no limit on the number of exchanged elements between lst1 and lst2.\n--     If it is possible to exchange elements between the lst1 and lst2 to make\n--     all the elements of lst1 to be even, return \"YES\".\n--     Otherwise, return \"NO\".\n--     For example:\n--     exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n--     exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n--     It is assumed that the input lists will be non-empty.\n--     \"\"\"\n--     odd = 0\n--     even = 0\n--     for i in lst1:\n--         if i%2 == 1:\n--             odd += 1\n--     for i in lst2:\n--         if i%2 == 0:\n--             even += 1\n--     if even >= odd:\n--         return \"YES\"\n--     return \"NO\"\n--             \n-- \n\n\n-- Haskell Implementation:\n\n-- In this problem, you will implement a function that takes two lists of numbers,\n-- and determines whether it is possible to perform an exchange of elements\n-- between them to make lst1 a list of only even numbers.\n-- There is no limit on the number of exchanged elements between lst1 and lst2.\n-- If it is possible to exchange elements between the lst1 and lst2 to make\n-- all the elements of lst1 to be even, return \"YES\".\n-- Otherwise, return \"NO\".\n-- For example:\n-- exchange [1, 2, 3, 4] [1, 2, 3, 4] => \"YES\"\n-- exchange [1, 2, 3, 4] [1, 5, 3, 4] => \"NO\"\n-- It is assumed that the input lists will be non-empty.\nexchange :: [Int] -> [Int] -> String\nexchange lst1 lst2\n  | evenCount  >= oddCount =  \"YES\"\n  | otherwise =  \"NO\"\n  where\n    evenCount =  length $  filter even  lst2\n    oddCount =  length $  filter odd  lst1\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (exchange [1, 2, 3, 4] [1, 2, 3, 4] == \"YES\")\n    check (exchange [1, 2, 3, 4] [1, 5, 3, 4] == \"NO\")\n    check (exchange [1, 2, 3, 4] [2, 1, 4, 3] == \"YES\")\n    check (exchange [5, 7, 3] [2, 6, 4] == \"YES\")\n    check (exchange [5, 7, 3] [2, 6, 3] == \"NO\")\n    check (exchange [3, 2, 6, 1, 8, 9] [3, 5, 5, 1, 1, 1] == \"NO\")\n    check (exchange [100, 200] [200, 200] == \"YES\")\n"}
{"task_id": "Haskell/111", "prompt": "-- Given a string representing a space separated lowercase letters, return a dictionary\n-- of the letter with the most repetition and containing the corresponding count.\n-- If several letters have the same occurrence, return all of them.\n-- Example:\n-- histogram \"a b c\" == [('a',1),('b',1),('c',1)]\n-- histogram \"a b b a\" == [('a',2),('b',2)]\n-- histogram \"a b c a b\" == [('a',2),('b',2)]\n-- histogram \"b b b b a\" == [('b',4)]\n-- histogram(\"\") == []\nhistogram :: String -> [(Char, Int)]", "canonical_solution": "-- Task ID: HumanEval/111\n-- Assigned To: Author D\n\n-- Python Implementation:\n\n--\n-- def histogram(test):\n--     \"\"\"Given a string representing a space separated lowercase letters, return a dictionary\n--     of the letter with the most repetition and containing the corresponding count.\n--     If several letters have the same occurrence, return all of them.\n--\n--     Example:\n--     histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n--     histogram('a b b a') == {'a': 2, 'b': 2}\n--     histogram('a b c a b') == {'a': 2, 'b': 2}\n--     histogram('b b b b a') == {'b': 4}\n--     histogram('') == {}\n--\n--     \"\"\"\n--     dict1={}\n--     list1=test.split(\" \")\n--     t=0\n--\n--     for i in list1:\n--         if(list1.count(i)>t) and i!='':\n--             t=list1.count(i)\n--     if t>0:\n--         for i in list1:\n--             if(list1.count(i)==t):\n--\n--                 dict1[i]=t\n--     return dict1\n--\n\n-- Haskell Implementation:\n\n-- Given a string representing a space separated lowercase letters, return a dictionary\n-- of the letter with the most repetition and containing the corresponding count.\n-- If several letters have the same occurrence, return all of them.\n--\n-- Example:\n-- histogram \"a b c\" == [('a',1),('b',1),('c',1)]\n-- histogram \"a b b a\" == [('a',2),('b',2)]\n-- histogram \"a b c a b\" == [('a',2),('b',2)]\n-- histogram \"b b b b a\" == [('b',4)]\n-- histogram(\"\") == []\n\nimport Data.List (group, sort)\n\nhistogram :: String -> [(Char, Int)]\nhistogram str =\n  [ (c, n)\n    | (n, c) <-  freqs,\n      n ==  maxFreq\n  ]\n  where\n    freqs =\n      [ (length g, head g)\n        | g <-  group $ sort str,\n          head g  /= ' '\n      ]\n    maxFreq =  maximum $  map fst freqs\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (histogram \"a b b a\" == [('a',2),('b',2)])\n    check (histogram \"a b c a b\" == [('a',2),('b',2)])\n    check (histogram \"a b c d g\" == [('a',1),('b',1),('c',1),('d',1),('g',1)])\n    check (histogram \"r t g\" == [('r',1),('t',1),('g',1)])\n    check (histogram \"b b b b a\" == [('b',4)])\n    check (histogram \"r t g\" == [('r',1),('t',1),('g',1)])\n    check (histogram \"\" == [])\n    check (histogram \"a\" == [('a',1)])\n"}
{"task_id": "Haskell/112", "prompt": "-- Task\n-- We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n-- then check if the result string is palindrome.\n-- A string is called palindrome if it reads the same backward as forward.\n-- You should return a tuple containing the result string and True/False for the check.\n-- Example\n-- For s = \"abcde\", c = \"ae\", the result should be (\"bcd\",False)\n-- For s = \"abcdef\", c = \"b\"  the result should be (\"acdef\",False)\n-- For s = \"abcdedcba\", c = \"ab\", the result should be (\"cdedc\",True)\nreverse_delete :: String -> String -> (String, Bool)", "canonical_solution": "-- Task ID: HumanEval/112\n-- Assigned To: Author D\n\n-- Python Implementation:\n\n-- \n-- def reverse_delete(s,c):\n--     \"\"\"Task\n--     We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n--     then check if the result string is palindrome.\n--     A string is called palindrome if it reads the same backward as forward.\n--     You should return a tuple containing the result string and True/False for the check.\n--     Example\n--     For s = \"abcde\", c = \"ae\", the result should be ('bcd',False)\n--     For s = \"abcdef\", c = \"b\"  the result should be ('acdef',False)\n--     For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',True)\n--     \"\"\"\n--     s = ''.join([char for char in s if char not in c])\n--     return (s,s[::-1] == s)\n-- \n\n\n-- Haskell Implementation:\n\n-- Task\n-- We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n-- then check if the result string is palindrome.\n-- A string is called palindrome if it reads the same backward as forward.\n-- You should return a tuple containing the result string and True/False for the check.\n-- Example\n-- For s = \"abcde\", c = \"ae\", the result should be (\"bcd\",False)\n-- For s = \"abcdef\", c = \"b\"  the result should be (\"acdef\",False)\n-- For s = \"abcdedcba\", c = \"ab\", the result should be (\"cdedc\",True)\nreverse_delete :: String -> String -> (String, Bool)\nreverse_delete s c =  (s', s' ==  reverse s')\n  where\n    s' =v filter (`notElem`  c) s", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (reverse_delete \"abcde\" \"ae\" == (\"bcd\",False))\n    check (reverse_delete \"abcdef\" \"b\" == (\"acdef\",False))\n    check (reverse_delete \"abcdedcba\" \"ab\" == (\"cdedc\",True))\n    check (reverse_delete \"dwik\" \"w\" == (\"dik\",False))\n    check (reverse_delete \"a\" \"a\" == (\"\",True))\n    check (reverse_delete \"abcdedcba\" \"\" == (\"abcdedcba\",True))\n    check (reverse_delete \"abcdedcba\" \"v\" == (\"abcdedcba\",True))\n    check (reverse_delete \"vabba\" \"v\" == (\"abba\",True))\n    check (reverse_delete \"mamma\" \"mia\" == (\"\",True))\n"}
{"task_id": "Haskell/113", "prompt": "-- Given a list of strings, where each string consists of only digits, return a list.\n-- Each element i of the output should be \"the number of odd elements in the\n-- string i of the input.\" where all the i's should be replaced by the number\n-- of odd digits in the i'th string of the input.\n-- >>> odd_count [\"1234567\"]\n-- [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n-- >>> odd_count [\"3\",\"11111111\"]\n-- [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n--  \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\nodd_count :: [String] -> [String]", "canonical_solution": "-- Task ID: HumanEval/113\n-- Assigned To: Author D\n\n-- Python Implementation:\n\n--\n-- def odd_count(lst):\n--     \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n--     Each element i of the output should be \"the number of odd elements in the\n--     string i of the input.\" where all the i's should be replaced by the number\n--     of odd digits in the i'th string of the input.\n--\n--     >>> odd_count(['1234567'])\n--     [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n--     >>> odd_count(['3',\"11111111\"])\n--     [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n--      \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n--     \"\"\"\n--     res = []\n--     for arr in lst:\n--         n = sum(int(d)%2==1 for d in arr)\n--         res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n--     return res\n--\n\n-- Haskell Implementation:\n\n-- Given a list of strings, where each string consists of only digits, return a list.\n-- Each element i of the output should be \"the number of odd elements in the\n-- string i of the input.\" where all the i's should be replaced by the number\n-- of odd digits in the i'th string of the input.\n--\n-- >>> odd_count [\"1234567\"]\n-- [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n-- >>> odd_count [\"3\",\"11111111\"]\n-- [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n--  \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\nodd_count :: [String] -> [String]\nodd_count lst = map countOdd lst\n  where\n    countOdd s = \"the number of odd elements \" ++ show n ++ \"n the str\" ++  show n ++ \"ng \" ++ show n ++ \" of the \" ++  show n ++ \"nput.\"\n      where\n        n =\n          length $\n            filter  odd $\n              map  read $\n                map  (: []) s", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (odd_count [\"1234567\"] == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"])\n    check (odd_count [\"3\", \"11111111\"] == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"])\n    check (odd_count [\"271\", \"137\", \"314\"] == [\"the number of odd elements 2n the str2ng 2 of the 2nput.\", \"the number of odd elements 3n the str3ng 3 of the 3nput.\", \"the number of odd elements 2n the str2ng 2 of the 2nput.\"])\n    check True\n"}
{"task_id": "Haskell/114", "prompt": "-- Given an array of integers nums, find the minimum sum of any non-empty sub-array\n-- of nums.\n-- Example\n-- minSubArraySum [2, 3, 4, 1, 2, 4] == 1\n-- minSubArraySum [-1, -2, -3] == -6\nminSubArraySum :: [Int] -> Int", "canonical_solution": "-- Task ID: HumanEval/114\n-- Assigned To: Author D\n\n-- Python Implementation:\n\n-- \n-- def minSubArraySum(nums):\n--     \"\"\"\n--     Given an array of integers nums, find the minimum sum of any non-empty sub-array\n--     of nums.\n--     Example\n--     minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n--     minSubArraySum([-1, -2, -3]) == -6\n--     \"\"\"\n--     max_sum = 0\n--     s = 0\n--     for num in nums:\n--         s += -num\n--         if (s < 0):\n--             s = 0\n--         max_sum = max(s, max_sum)\n--     if max_sum == 0:\n--         max_sum = max(-i for i in nums)\n--     min_sum = -max_sum\n--     return min_sum\n-- \n\n\n-- Haskell Implementation:\n\n-- Given an array of integers nums, find the minimum sum of any non-empty sub-array\n-- of nums.\n-- Example\n-- minSubArraySum [2, 3, 4, 1, 2, 4] == 1\n-- minSubArraySum [-1, -2, -3] == -6\nminSubArraySum :: [Int] -> Int\nminSubArraySum [x] =  x\nminSubArraySum (x:xs) =  minimum  [n, n +  x, x]\n  where n =  minSubArraySum  xs", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (minSubArraySum [2, 3, 4, 1, 2, 4] == 1)\n    check (minSubArraySum [-1, -2, -3] == -6)\n    check (minSubArraySum [-1, -2, -3, 2, -10] == -14)\n    check (minSubArraySum [-9999999999999999] == -9999999999999999)\n    check (minSubArraySum [0, 10, 20, 1000000] == 0)\n    check (minSubArraySum [-1, -2, -3, 10, -5] == -6)\n    check (minSubArraySum [100, -1, -2, -3, 10, -5] == -6)\n    check (minSubArraySum [10, 11, 13, 8, 3, 4] == 3)\n    check (minSubArraySum [100, -33, 32, -1, 0, -2] == -33)\n    check (minSubArraySum [-10] == -10)\n    check (minSubArraySum [7] == 7)\n    check (minSubArraySum [1, -1] == -1)\n"}
{"task_id": "Haskell/115", "prompt": "-- You are given a rectangular grid of wells. Each row represents a single well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well has a corresponding bucket that can be used to extract water from it,\n-- and all buckets have the same capacity.\n-- Your task is to use the buckets to empty the wells.\n-- Output the number of times you need to lower the buckets.\n-- Example 1:\n--     Input:\n--         grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n--         bucket_capacity : 1\n--     Output: 6\n-- Example 2:\n--     Input:\n--         grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n--         bucket_capacity : 2\n--     Output: 5\n-- Example 3:\n--     Input:\n--         grid : [[0,0,0], [0,0,0]]\n--         bucket_capacity : 5\n--     Output: 0\n-- constraints:\n--     * all wells have the same length\n--     * 1 <= grid.length <= 10^2\n--     * 1 <= grid[:,1].length <= 10^2\n--     * grid[i][j] -> 0 | 1\n--     * 1 <= capacity <= 10\nmax_fill :: [[Int]] -> Int -> Int", "canonical_solution": "-- Task ID: HumanEval/115\n-- Assigned To: Author D\n\n-- Python Implementation:\n\n-- \n-- def max_fill(grid, capacity):\n--     import math\n--     \"\"\"\n--     You are given a rectangular grid of wells. Each row represents a single well,\n--     and each 1 in a row represents a single unit of water.\n--     Each well has a corresponding bucket that can be used to extract water from it, \n--     and all buckets have the same capacity.\n--     Your task is to use the buckets to empty the wells.\n--     Output the number of times you need to lower the buckets.\n-- \n--     Example 1:\n--         Input: \n--             grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n--             bucket_capacity : 1\n--         Output: 6\n-- \n--     Example 2:\n--         Input: \n--             grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n--             bucket_capacity : 2\n--         Output: 5\n--     \n--     Example 3:\n--         Input: \n--             grid : [[0,0,0], [0,0,0]]\n--             bucket_capacity : 5\n--         Output: 0\n-- \n--     Constraints:\n--         * all wells have the same length\n--         * 1 <= grid.length <= 10^2\n--         * 1 <= grid[:,1].length <= 10^2\n--         * grid[i][j] -> 0 | 1\n--         * 1 <= capacity <= 10\n--     \"\"\"\n--     return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n-- \n\n\n-- Haskell Implementation:\n\n-- You are given a rectangular grid of wells. Each row represents a single well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well has a corresponding bucket that can be used to extract water from it, \n-- and all buckets have the same capacity.\n-- Your task is to use the buckets to empty the wells.\n-- Output the number of times you need to lower the buckets.\n-- \n-- Example 1:\n--     Input: \n--         grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n--         bucket_capacity : 1\n--     Output: 6\n--\n-- Example 2:\n--     Input: \n--         grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n--         bucket_capacity : 2\n--     Output: 5\n-- \n-- Example 3:\n--     Input: \n--         grid : [[0,0,0], [0,0,0]]\n--         bucket_capacity : 5\n--     Output: 0\n-- \n-- constraints:\n--     * all wells have the same length\n--     * 1 <= grid.length <= 10^2\n--     * 1 <= grid[:,1].length <= 10^2\n--     * grid[i][j] -> 0 | 1\n--     * 1 <= capacity <= 10\n\nmax_fill :: [[Int]] -> Int -> Int\nmax_fill grid capacity = sum $ map  (ceiling . (/ fromIntegral  capacity) .  fromIntegral . sum) $  grid\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (max_fill [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]] 1 == 6)\n    check (max_fill [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]] 2 == 5)\n    check (max_fill [[0, 0, 0], [0, 0, 0]] 5 == 0)\n    check (max_fill [[1, 1, 1, 1], [1, 1, 1, 1]] 2 == 4)\n    check (max_fill [[1, 1, 1, 1], [1, 1, 1, 1]] 9 == 2)\n"}
{"task_id": "Haskell/116", "prompt": "-- In this Kata, you have to sort an array of non-negative integers according to\n-- number of ones in their binary representation in ascending order.\n-- For similar number of ones, sort based on decimal value.\n-- It must be implemented like this:\n-- >>> sort_array [1, 5, 2, 3, 4] == [1, 2, 3, 4, 5]\n-- >>> sort_array [-2, -3, -4, -5, -6] == [-6, -5, -4, -3, -2]\n-- >>> sort_array [1, 0, 2, 3, 4] [0, 1, 2, 3, 4]\nsort_array :: [Int] -> [Int]", "canonical_solution": "-- Task ID: HumanEval/116\n-- Assigned To: Author D\n\n-- Python Implementation:\n\n--\n-- def sort_array(arr):\n--     \"\"\"\n--     In this Kata, you have to sort an array of non-negative integers according to\n--     number of ones in their binary representation in ascending order.\n--     For similar number of ones, sort based on decimal value.\n--\n--     It must be implemented like this:\n--     >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n--     >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n--     >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n--     \"\"\"\n--     return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n--\n\n-- Haskell Implementation:\n\nimport Data.Char\nimport Data.List\nimport Numeric\n\n-- In this Kata, you have to sort an array of non-negative integers according to\n-- number of ones in their binary representation in ascending order.\n-- For similar number of ones, sort based on decimal value.\n--\n-- It must be implemented like this:\n-- >>> sort_array [1, 5, 2, 3, 4] == [1, 2, 3, 4, 5]\n-- >>> sort_array [-2, -3, -4, -5, -6] == [-6, -5, -4, -3, -2]\n-- >>> sort_array [1, 0, 2, 3, 4] [0, 1, 2, 3, 4]\nsort_array :: [Int] -> [Int]\nsort_array arr = sortBy g arr\n  where\n    f x y = compare  (countOnes $ abs x)  (countOnes $ abs y)\n    g x y =\n      if (f x y)  /= EQ\n        then  (f x y)\n        else  (compare x y)\n    countOnes x =\n      length $\n        filter  (== '1') $\n          showIntAtBase 2  intToDigit x \"\"\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (sort_array [1, 5, 2, 3, 4] == [1, 2, 4, 3, 5])\n    check (sort_array [-2, -3, -4, -5, -6] == [-4, -2, -6, -5, -3])\n    check (sort_array [1, 0, 2, 3, 4] == [0, 1, 2, 4, 3])\n    check (sort_array [] == [])\n    check (sort_array [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4] == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n    check (sort_array [3, 6, 44, 12, 32, 5] == [32, 3, 5, 6, 12, 44])\n    check (sort_array [2, 4, 8, 16, 32] == [2, 4, 8, 16, 32])\n    check (sort_array [2, 4, 8, 16, 32] == [2, 4, 8, 16, 32])\n"}
{"task_id": "Haskell/117", "prompt": "-- Given a string s and a natural number n, you have been tasked to implement\n-- a function that returns a list of all words from string s that contain exactly\n-- n consonants, in order these words appear in the string s.\n-- If the string s is empty then the function should return an empty list.\n-- Note: you may assume the input string contains only letters and spaces.\n-- Examples:\n-- select_words \"Mary had a little lamb\" 4 ==> [\"little\"]\n-- select_words \"Mary had a little lamb\" 3 ==> [\"Mary\", \"lamb\"]\n-- select_words \"simple white space\" 2 ==> []\n-- select_words \"Hello world\" 4 ==> [\"world\"]\n-- select_words \"Uncle sam\" 3 ==> [\"Uncle\"]\nselect_words :: String -> Int -> [String]", "canonical_solution": "-- Task ID: HumanEval/117\n-- Assigned To: Author D\n\n-- Python Implementation:\n\n-- \n-- def select_words(s, n):\n--     \"\"\"Given a string s and a natural number n, you have been tasked to implement \n--     a function that returns a list of all words from string s that contain exactly \n--     n consonants, in order these words appear in the string s.\n--     If the string s is empty then the function should return an empty list.\n--     Note: you may assume the input string contains only letters and spaces.\n--     Examples:\n--     select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n--     select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n--     select_words(\"simple white space\", 2) ==> []\n--     select_words(\"Hello world\", 4) ==> [\"world\"]\n--     select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n--     \"\"\"\n--     result = []\n--     for word in s.split():\n--         n_consonants = 0\n--         for i in range(0, len(word)):\n--             if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n--                 n_consonants += 1 \n--         if n_consonants == n:\n--             result.append(word)\n--     return result\n-- \n-- \n\n\n-- Haskell Implementation:\n\n-- Given a string s and a natural number n, you have been tasked to implement \n-- a function that returns a list of all words from string s that contain exactly \n-- n consonants, in order these words appear in the string s.\n-- If the string s is empty then the function should return an empty list.\n-- Note: you may assume the input string contains only letters and spaces.\n-- Examples:\n-- select_words \"Mary had a little lamb\" 4 ==> [\"little\"]\n-- select_words \"Mary had a little lamb\" 3 ==> [\"Mary\", \"lamb\"]\n-- select_words \"simple white space\" 2 ==> []\n-- select_words \"Hello world\" 4 ==> [\"world\"]\n-- select_words \"Uncle sam\" 3 ==> [\"Uncle\"]\nimport Data.Char (toLower)\n\nselect_words :: String -> Int -> [String]\nselect_words s n = filter  (\\word ->  countConsonants word == n) $  words s\n  where\n    countConsonants word = length $ filter  (\\c -> isConsonant c && isLetter c) word\n    isConsonant c =  toLower c `notElem`  \"aeiou\"\n    isLetter c =  c `elem` ['a'..'z'] ++  ['A'..'Z']\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (select_words \"Mary had a little lamb\" 4 == [\"little\"])\n    check (select_words \"Mary had a little lamb\" 3 == [\"Mary\", \"lamb\"])\n    check (select_words \"simple white space\" 2 == [])\n    check (select_words \"Hello world\" 4 == [\"world\"])\n    check (select_words \"Uncle sam\" 3 == [\"Uncle\"])\n    check (select_words \"\" 4 == [])\n    check (select_words \"a b c d e f\" 1 == [\"b\", \"c\", \"d\", \"f\"])\n"}
{"task_id": "Haskell/118", "prompt": "-- You are given a word. Your task is to find the closest vowel that stands between\n-- two consonants from the right side of the word (case sensitive).\n-- Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n-- find any vowel met the above condition.\n-- You may assume that the given string contains English letter only.\n-- Example:\n-- get_closest_vowel \"yogurt\" ==> \"u\"\n-- get_closest_vowel \"FULL\" ==> \"U\"\n-- get_closest_vowel \"quick\" ==> \"\"\n-- get_closest_vowel \"ab\" ==> \"\"\nget_closest_vowel :: String -> String", "canonical_solution": "-- Task ID: HumanEval/118\n-- Assigned To: Author D\n\n-- Python Implementation:\n\n--\n-- def get_closest_vowel(word):\n--     \"\"\"You are given a word. Your task is to find the closest vowel that stands between\n--     two consonants from the right side of the word (case sensitive).\n--\n--     Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n--     find any vowel met the above condition.\n--\n--     You may assume that the given string contains English letter only.\n--\n--     Example:\n--     get_closest_vowel(\"yogurt\") ==> \"u\"\n--     get_closest_vowel(\"FULL\") ==> \"U\"\n--     get_closest_vowel(\"quick\") ==> \"\"\n--     get_closest_vowel(\"ab\") ==> \"\"\n--     \"\"\"\n--     if len(word) < 3:\n--         return \"\"\n--\n--     vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n--     for i in range(len(word)-2, 0, -1):\n--         if word[i] in vowels:\n--             if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n--                 return word[i]\n--     return \"\"\n--\n\n-- Haskell Implementation:\n\n-- You are given a word. Your task is to find the closest vowel that stands between\n-- two consonants from the right side of the word (case sensitive).\n--\n-- Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n-- find any vowel met the above condition.\n--\n-- You may assume that the given string contains English letter only.\n--\n-- Example:\n-- get_closest_vowel \"yogurt\" ==> \"u\"\n-- get_closest_vowel \"FULL\" ==> \"U\"\n-- get_closest_vowel \"quick\" ==> \"\"\n-- get_closest_vowel \"ab\" ==> \"\"\nget_closest_vowel :: String -> String\nget_closest_vowel word = f (reverse  word)\n  where\n    f (x : y : z : xs) =\n      if vowel y && consonant x &&  consonant z\n        then  [y]\n        else  f (y : z : xs)\n    f _ =  \"\"\n    vowel x =  x `elem` \"aeiouAEIOU\"\n    consonant =  not . vowel\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (get_closest_vowel \"yogurt\" == \"u\")\n    check (get_closest_vowel \"full\" == \"u\")\n    check (get_closest_vowel \"easy\" == \"\")\n    check (get_closest_vowel \"eAsy\" == \"\")\n    check (get_closest_vowel \"ali\" == \"\")\n    check (get_closest_vowel \"bad\" == \"a\")\n    check (get_closest_vowel \"most\" == \"o\")\n    check (get_closest_vowel \"ab\" == \"\")\n    check (get_closest_vowel \"ba\" == \"\")\n    check (get_closest_vowel \"quick\" == \"\")\n    check (get_closest_vowel \"anime\" == \"i\")\n    check (get_closest_vowel \"Asia\" == \"\")\n    check (get_closest_vowel \"Above\" == \"o\")\n"}
{"task_id": "Haskell/119", "prompt": "-- You are given a list of two strings, both strings consist of open\n-- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if it is possible to concatenate the two strings in\n-- some order, that the resulting string will be good.\n-- A string S is considered to be good if and only if all parentheses in S\n-- are balanced. For example: the string '(())()' is good, while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens [\"()(\", \")\"] == \"Yes\"\n-- match_parens [\")\", \")\"] == \"No\"\nmatch_parens :: [String] -> String", "canonical_solution": "-- Task ID: HumanEval/119\n-- Assigned To: Author D\n\n-- Python Implementation:\n\n-- \n-- def match_parens(lst):\n--     '''\n--     You are given a list of two strings, both strings consist of open\n--     parentheses '(' or close parentheses ')' only.\n--     Your job is to check if it is possible to concatenate the two strings in\n--     some order, that the resulting string will be good.\n--     A string S is considered to be good if and only if all parentheses in S\n--     are balanced. For example: the string '(())()' is good, while the string\n--     '())' is not.\n--     Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n-- \n--     Examples:\n--     match_parens(['()(', ')']) == 'Yes'\n--     match_parens([')', ')']) == 'No'\n--     '''\n--     def check(s):\n--         val = 0\n--         for i in s:\n--             if i == '(':\n--                 val = val + 1\n--             else:\n--                 val = val - 1\n--             if val < 0:\n--                 return False\n--         return True if val == 0 else False\n-- \n--     S1 = lst[0] + lst[1]\n--     S2 = lst[1] + lst[0]\n--     return 'Yes' if check(S1) or check(S2) else 'No'\n-- \n\n\n-- Haskell Implementation:\n\n-- You are given a list of two strings, both strings consist of open\n-- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if it is possible to concatenate the two strings in\n-- some order, that the resulting string will be good.\n-- A string S is considered to be good if and only if all parentheses in S\n-- are balanced. For example: the string '(())()' is good, while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n-- \n-- Examples:\n-- match_parens [\"()(\", \")\"] == \"Yes\"\n-- match_parens [\")\", \")\"] == \"No\"\nmatch_parens :: [String] -> String\nmatch_parens [s1, s2] = if  check (s1 ++ s2) ||  check (s2 ++ s1)  then \"Yes\"  else \"No\"\n  where\n    check :: String -> Bool\n    check s = go s 0\n    go :: String -> Int -> Bool\n    go [] n =  n == 0\n    go ('(':xs) n =  go xs (n+1)\n    go (')':xs) n =  n > 0 &&  go xs (n-1)\n    go (_:xs) n =  go xs n\nmatchParens _ =  \"No\"\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (match_parens [\"()(\", \")\"] == \"Yes\")\n    check (match_parens [\")\", \")\"] == \"No\")\n    check (match_parens [\"(()(())\", \"())())\"] == \"No\")\n    check (match_parens [\")())\", \"(()()(\"] == \"Yes\")\n    check (match_parens [\"(())))\", \"(()())((\"] == \"Yes\")\n    check (match_parens [\"()\", \"())\"] == \"No\")\n    check (match_parens [\"(()(\", \"()))()\"] == \"Yes\")\n    check (match_parens [\"((( (?), placeholder\"] == \"No\")\n    check (match_parens [\")(()\", \"(()(\"] == \"No\")\n    check (match_parens [\")(\", \")(\"] == \"No\")\n    check (match_parens [\"(\", \")\"] == \"Yes\")\n    check (match_parens [\")\", \"(\"] == \"Yes\")\n"}
{"task_id": "Haskell/120", "prompt": "-- Given an array arr of integers and a positive integer k, return a sorted list\n-- of length k with the maximum k numbers in arr.\n-- Example 1:\n--     Input: arr = [-3, -4, 5], k = 3\n--     Output: [-4, -3, 5]\n-- Example 2:\n--     Input: arr = [4, -4, 4], k = 2\n--     Output: [4, 4]\n-- Example 3:\n--     Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n--     Output: [2]\n-- Note:\n--     1. The length of the array will be in the range of [1, 1000].\n--     2. The elements in the array will be in the range of [-1000, 1000].\n--     3. 0 <= k <= len(arr)\nmaximumK :: [Int] -> Int -> [Int]", "canonical_solution": "-- Task ID: HumanEval/120\n-- Assigned To: Author D\n\n-- Python Implementation:\n\n-- \n-- def maximum(arr, k):\n--     \"\"\"\n--     Given an array arr of integers and a positive integer k, return a sorted list \n--     of length k with the maximum k numbers in arr.\n-- \n--     Example 1:\n-- \n--         Input: arr = [-3, -4, 5], k = 3\n--         Output: [-4, -3, 5]\n-- \n--     Example 2:\n-- \n--         Input: arr = [4, -4, 4], k = 2\n--         Output: [4, 4]\n-- \n--     Example 3:\n-- \n--         Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n--         Output: [2]\n-- \n--     Note:\n--         1. The length of the array will be in the range of [1, 1000].\n--         2. The elements in the array will be in the range of [-1000, 1000].\n--         3. 0 <= k <= len(arr)\n--     \"\"\"\n--     if k == 0:\n--         return []\n--     arr.sort()\n--     ans = arr[-k:]\n--     return ans\n-- \n\n\n-- Haskell Implementation:\n\n-- Given an array arr of integers and a positive integer k, return a sorted list \n-- of length k with the maximum k numbers in arr.\n-- \n-- Example 1:\n-- \n--     Input: arr = [-3, -4, 5], k = 3\n--     Output: [-4, -3, 5]\n-- \n-- Example 2:\n-- \n--     Input: arr = [4, -4, 4], k = 2\n--     Output: [4, 4]\n-- \n-- Example 3:\n-- \n--     Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n--     Output: [2]\n-- \n-- Note:\n--     1. The length of the array will be in the range of [1, 1000].\n--     2. The elements in the array will be in the range of [-1000, 1000].\n--     3. 0 <= k <= len(arr)\nimport Data.List (sort)\n\nmaximumK :: [Int] -> Int -> [Int]\nmaximumK arr k =  reverse $  take k $  reverse $  sort arr\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (maximum [-3, -4, 5] 3 == [-4, -3, 5])\n    check (maximum [4, -4, 4] 2 == [4, 4])\n    check (maximum [-3, 2, 1, 2, -1, -2, 1] 1 == [2])\n    check (maximum [123, -123, 20, 0, 1, 2, -3] 3 == [2, 20, 123])\n    check (maximum [-123, 20, 0, 1, 2, -3] 4 == [0, 1, 2, 20])\n    check (maximum [5, 15, 0, 3, -13, -8, 0] 7 == [-13, -8, 0, 0, 3, 5, 15])\n    check (maximum [-1, 0, 2, 5, 3, -10] 2 == [3, 5])\n    check (maximum [1, 0, 5, -7] 1 == [5])\n    check (maximum [4, -4] 2 == [-4, 4])\n    check (maximum [-10, 10] 2 == [-10, 10])\n    check (maximum [1, 2, 3, -23, 243, -400, 0] 0 == [])\n"}
{"task_id": "Haskell/121", "prompt": "-- Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n-- Examples\n-- solution [5, 8, 7, 1] ==> 12\n-- solution [3, 3, 3, 3, 3] ==> 9\n-- solution [30, 13, 24, 321] ==> 0\nsolution :: [Int] -> Int", "canonical_solution": "-- Task ID: HumanEval/121\n-- Assigned To: Author D\n\n-- Python Implementation:\n\n--\n-- def solution(lst):\n--     \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n--\n--\n--     Examples\n--     solution([5, 8, 7, 1]) ==> 12\n--     solution([3, 3, 3, 3, 3]) ==> 9\n--     solution([30, 13, 24, 321]) ==> 0\n--     \"\"\"\n--     return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n--\n\n-- Haskell Implementation:\n\n-- Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n--\n--\n-- Examples\n-- solution [5, 8, 7, 1] ==> 12\n-- solution [3, 3, 3, 3, 3] ==> 9\n-- solution [30, 13, 24, 321] ==> 0\nsolution :: [Int] -> Int\nsolution lst =\n  sum\n    [ x\n      | (idx, x) <-  zip [0 ..] lst,\n        even  idx,\n        odd  x\n    ]\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (solution [5, 8, 7, 1] == 12)\n    check (solution [3, 3, 3, 3, 3] == 9)\n    check (solution [30, 13, 24, 321] == 0)\n    check (solution [5, 9] == 5)\n    check (solution [2, 4, 8] == 0)\n    check (solution [30, 13, 23, 32] == 23)\n    check (solution [3, 13, 2, 9] == 3)\n"}
{"task_id": "Haskell/122", "prompt": "-- Given a non-empty array of integers arr and an integer k, return\n-- the sum of the elements with at most two digits from the first k elements of arr.\n-- Example:\n--     Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n--     Output: 24 # sum of 21 + 3\n-- Constraints:\n--     1. 1 <= len(arr) <= 100\n--     2. 1 <= k <= len(arr)\nadd_elements :: [Int] -> Int -> Int", "canonical_solution": "-- Task ID: HumanEval/122\n-- Assigned To: Author D\n\n-- Python Implementation:\n\n-- \n-- def add_elements(arr, k):\n--     \"\"\"\n--     Given a non-empty array of integers arr and an integer k, return\n--     the sum of the elements with at most two digits from the first k elements of arr.\n-- \n--     Example:\n-- \n--         Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n--         Output: 24 # sum of 21 + 3\n-- \n--     Constraints:\n--         1. 1 <= len(arr) <= 100\n--         2. 1 <= k <= len(arr)\n--     \"\"\"\n--     return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n-- \n\n\n-- Haskell Implementation:\n\n-- Given a non-empty array of integers arr and an integer k, return\n-- the sum of the elements with at most two digits from the first k elements of arr.\n-- \n-- Example:\n-- \n--     Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n--     Output: 24 # sum of 21 + 3\n-- \n-- Constraints:\n--     1. 1 <= len(arr) <= 100\n--     2. 1 <= k <= len(arr)\nadd_elements :: [Int] -> Int -> Int\nadd_elements arr k =  sum  [x | x <-  take k arr,  length (show x) <= 2]\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (add_elements [1, -2, -3, 41, 57, 76, 87, 88, 99] 3 == -4)\n    check (add_elements [111, 121, 3, 4000, 5, 6] 2 == 0)\n    check (add_elements [11, 21, 3, 90, 5, 6, 7, 8, 9] 4 == 125)\n    check (add_elements [111, 21, 3, 4000, 5, 6, 7, 8, 9] 4 == 24)\n    check (add_elements [1] 1 == 1)\n"}
{"task_id": "Haskell/123", "prompt": "-- Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n-- The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n-- as follows: start with any positive integer n. Then each term is obtained from the\n-- previous term as follows: if the previous term is even, the next term is one half of\n-- the previous term. If the previous term is odd, the next term is 3 times the previous\n-- term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n-- Note:\n--     1. Collatz(1) is [1].\n--     2. returned list sorted in increasing order.\n-- For example:\n-- get_odd_collatz 5 returns [1,5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\nget_odd_collatz :: Int -> [Int]", "canonical_solution": "-- Task ID: HumanEval/123\n-- Assigned To: Author D\n\n-- Python Implementation:\n\n-- \n-- def get_odd_collatz(n):\n--     \"\"\"\n--     Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n-- \n--     The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n--     as follows: start with any positive integer n. Then each term is obtained from the \n--     previous term as follows: if the previous term is even, the next term is one half of \n--     the previous term. If the previous term is odd, the next term is 3 times the previous\n--     term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n-- \n--     Note: \n--         1. Collatz(1) is [1].\n--         2. returned list sorted in increasing order.\n-- \n--     For example:\n--     get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n--     \"\"\"\n--     if n%2==0:\n--         odd_collatz = [] \n--     else:\n--         odd_collatz = [n]\n--     while n > 1:\n--         if n % 2 == 0:\n--             n = n/2\n--         else:\n--             n = n*3 + 1\n--             \n--         if n%2 == 1:\n--             odd_collatz.append(int(n))\n-- \n--     return sorted(odd_collatz)\n-- \n\n\n-- Haskell Implementation:\n\n-- Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n-- \n-- The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n-- as follows: start with any positive integer n. Then each term is obtained from the \n-- previous term as follows: if the previous term is even, the next term is one half of \n-- the previous term. If the previous term is odd, the next term is 3 times the previous\n-- term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n-- \n-- Note: \n--     1. Collatz(1) is [1].\n--     2. returned list sorted in increasing order.\n-- \n-- For example:\n-- get_odd_collatz 5 returns [1,5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\nimport Data.List (sort)\n\nget_odd_collatz :: Int -> [Int]\nget_odd_collatz n = sort $ filter odd $ collatz n\n  where\n    collatz :: Int -> [Int]\n    collatz 1 =  [1]\n    collatz x\n      | even x =  x : collatz  (x `div` 2)\n      | otherwise =  x : collatz  (x * 3 +  1)\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (get_odd_collatz 14 == [1, 5, 7, 11, 13, 17])\n    check (get_odd_collatz 5 == [1, 5])\n    check (get_odd_collatz 12 == [1, 3, 5])\n    check (get_odd_collatz 1 == [1])\n"}
{"task_id": "Haskell/124", "prompt": "-- You have to write a function which validates a given date string and\n-- returns True if the date is valid otherwise False.\n-- The date is valid if all of the following rules are satisfied:\n-- 1. The date string is not empty.\n-- 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n-- 3. The months should not be less than 1 or higher than 12.\n-- 4. The date should be in the format: mm-dd-yyyy\n-- for example:\n-- >>> valid_date \"03-11-2000\"\n-- True\n-- >>> valid_date \"15-01-2012\"\n-- False\n-- >>> valid_date \"04-0-2040\"\n-- False\n-- >>> valid_date \"06-04-2020\"\n-- True\n-- >>> valid_date \"06/04/2020\"\n-- False\nvalid_date :: String -> Bool", "canonical_solution": "-- Task ID: HumanEval/124\n-- Assigned To: Author D\n\n-- Python Implementation:\n\n--\n-- def valid_date(date):\n--     \"\"\"You have to write a function which validates a given date string and\n--     returns True if the date is valid otherwise False.\n--     The date is valid if all of the following rules are satisfied:\n--     1. The date string is not empty.\n--     2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n--     3. The months should not be less than 1 or higher than 12.\n--     4. The date should be in the format: mm-dd-yyyy\n--\n--     for example:\n--     valid_date('03-11-2000') => True\n--\n--     valid_date('15-01-2012') => False\n--\n--     valid_date('04-0-2040') => False\n--\n--     valid_date('06-04-2020') => True\n--\n--     valid_date('06/04/2020') => False\n--     \"\"\"\n--     try:\n--         date = date.strip()\n--         month, day, year = date.split('-')\n--         month, day, year = int(month), int(day), int(year)\n--         if month < 1 or month > 12:\n--             return False\n--         if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n--             return False\n--         if month in [4,6,9,11] and day < 1 or day > 30:\n--             return False\n--         if month == 2 and day < 1 or day > 29:\n--             return False\n--     except:\n--         return False\n--\n--     return True\n--\n\n-- Haskell Implementation:\n\n-- You have to write a function which validates a given date string and\n-- returns True if the date is valid otherwise False.\n-- The date is valid if all of the following rules are satisfied:\n-- 1. The date string is not empty.\n-- 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n-- 3. The months should not be less than 1 or higher than 12.\n-- 4. The date should be in the format: mm-dd-yyyy\n--\n-- for example:\n-- >>> valid_date \"03-11-2000\"\n-- True\n-- >>> valid_date \"15-01-2012\"\n-- False\n-- >>> valid_date \"04-0-2040\"\n-- False\n-- >>> valid_date \"06-04-2020\"\n-- True\n-- >>> valid_date \"06/04/2020\"\n-- False\nimport Data.Char (digitToInt)\n\nvalid_date :: String -> Bool\nvalid_date date = case splitDate date of\n  Just (m, d, y) -> isValidDate m d y\n  _ ->  False\n  where\n    splitDate :: String -> Maybe (Int, Int, Int)\n    splitDate (m1 : m2 : '-' :  d1 : d2 : '-' :  y1 : y2 : y3 : y4 : []) =\n      Just\n        ( digitToInt m1 * 10 +  digitToInt m2,\n          digitToInt d1 * 10 +  digitToInt d2,\n          digitToInt y1 *  1000 + digitToInt y2 * 100 +  digitToInt y3 * 10 + digitToInt y4\n        )\n    splitDate _ = Nothing\n    isValidDate m d y =\n      m >=  1\n        && m <=  12\n        && ( m `elem`  [1, 3, 5, 7, 8, 10, 12] && d  >= 1 && d <= 31\n               || m `elem`  [4, 6, 9, 11] && d  >= 1 && d <= 30\n               || m == 2 && d  >= 1 && d <= 29 && (y `mod` 4 /=  0 || y `mod` 100 ==  0 && y `mod`  400 /= 0)\n           )\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (valid_date \"03-11-2000\" == True)\n    check (valid_date \"15-01-2012\" == False)\n    check (valid_date \"04-0-2040\" == False)\n    check (valid_date \"06-04-2020\" == True)\n    check (valid_date \"01-01-2007\" == True)\n    check (valid_date \"03-32-2011\" == False)\n    check (valid_date \"\" == False)\n    check (valid_date \"04-31-3000\" == False)\n    check (valid_date \"06-06-2005\" == True)\n    check (valid_date \"21-31-2000\" == False)\n    check (valid_date \"04-12-2003\" == True)\n    check (valid_date \"04122003\" == False)\n    check (valid_date \"20030412\" == False)\n    check (valid_date \"2003-04\" == False)\n    check (valid_date \"2003-04-12\" == False)\n    check (valid_date \"04-2003\" == False)\n"}
{"task_id": "Haskell/125", "prompt": "-- Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n-- should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n-- alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n-- Examples\n-- split_words \"Hello world!\" \u279e [\"Hello\",\"world!\"]\n-- split_words \"Hello,world!\" \u279e [\"Hello\",\"world!\"]\n-- split_words \"abcdef\" == 3\nsplit_words :: String -> Either Int [String]", "canonical_solution": "-- Task ID: HumanEval/125\n-- Assigned To: Author D\n\n-- Python Implementation:\n\n-- \n-- def split_words(txt):\n--     '''\n--     Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n--     should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n--     alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n--     Examples\n--     split_words(\"Hello world!\") \u279e [\"Hello\", \"world!\"]\n--     split_words(\"Hello,world!\") \u279e [\"Hello\", \"world!\"]\n--     split_words(\"abcdef\") == 3 \n--     '''\n--     if \" \" in txt:\n--         return txt.split()\n--     elif \",\" in txt:\n--         return txt.replace(',',' ').split()\n--     else:\n--         return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n-- \n\n\n-- Haskell Implementation:\nimport Data.Char\n\n-- Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n-- should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n-- alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n-- Examples\n-- split_words \"Hello world!\" \u279e [\"Hello\",\"world!\"]\n-- split_words \"Hello,world!\" \u279e [\"Hello\",\"world!\"]\n-- split_words \"abcdef\" == 3 \n\nsplit_words :: String -> Either Int [String]\nsplit_words txt\n  | ' ' `elem` txt =  Right $ words txt\n  | ',' `elem` txt =  Right $ words $  map (\\c -> if c == ',' then ' ' else c) txt\n  | otherwise =  Left $ length $ filter  (\\c -> isLower c && even (ord c)) txt\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (split_words \"Hello world!\" == [\"Hello\", \"world!\"])\n    check (split_words \"Hello,world!\" == [\"Hello\", \"world!\"])\n    check (split_words \"Hello world,!\" == [\"Hello\", \"world,!\"])\n    check (split_words \"Hello,Hello,world !\" == [\"Hello,Hello,world\", \"!\"])\n    check (split_words \"abcdef\" == 3)\n    check (split_words \"aaabb\" == 2)\n    check (split_words \"aaaBb\" == 1)\n    check (split_words \"\" == 0)\n"}
{"task_id": "Haskell/126", "prompt": "-- Given a list of numbers, return whether or not they are sorted\n-- in ascending order. If list has more than 1 duplicate of the same\n-- number, return False. Assume no negative numbers and only integers.\n-- Examples\n-- is_sorted [5] \u279e True\n-- is_sorted [1, 2, 3, 4, 5] \u279e True\n-- is_sorted [1, 3, 2, 4, 5] \u279e False\n-- is_sorted [1, 2, 3, 4, 5, 6] \u279e True\n-- is_sorted [1, 2, 3, 4, 5, 6, 7] \u279e True\n-- is_sorted [1, 3, 2, 4, 5, 6, 7] \u279e False\n-- is_sorted [1, 2, 2, 3, 3, 4] \u279e True\n-- is_sorted [1, 2, 2, 2, 3, 4] \u279e False\nis_sorted :: [Int] -> Bool", "canonical_solution": "-- Task ID: HumanEval/126\n-- Assigned To: Author D\n\n-- Python Implementation:\n\n-- \n-- def is_sorted(lst):\n--     '''\n--     Given a list of numbers, return whether or not they are sorted\n--     in ascending order. If list has more than 1 duplicate of the same\n--     number, return False. Assume no negative numbers and only integers.\n-- \n--     Examples\n--     is_sorted([5]) \u279e True\n--     is_sorted([1, 2, 3, 4, 5]) \u279e True\n--     is_sorted([1, 3, 2, 4, 5]) \u279e False\n--     is_sorted([1, 2, 3, 4, 5, 6]) \u279e True\n--     is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279e True\n--     is_sorted([1, 3, 2, 4, 5, 6, 7]) \u279e False\n--     is_sorted([1, 2, 2, 3, 3, 4]) \u279e True\n--     is_sorted([1, 2, 2, 2, 3, 4]) \u279e False\n--     '''\n--     count_digit = dict([(i, 0) for i in lst])\n--     for i in lst:\n--         count_digit[i]+=1 \n--     if any(count_digit[i] > 2 for i in lst):\n--         return False\n--     if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n--         return True\n--     else:\n--         return False\n--     \n--     \n-- \n\n\n-- Haskell Implementation:\n\n-- Given a list of numbers, return whether or not they are sorted\n-- in ascending order. If list has more than 1 duplicate of the same\n-- number, return False. Assume no negative numbers and only integers.\n-- \n-- Examples\n-- is_sorted [5] \u279e True\n-- is_sorted [1, 2, 3, 4, 5] \u279e True\n-- is_sorted [1, 3, 2, 4, 5] \u279e False\n-- is_sorted [1, 2, 3, 4, 5, 6] \u279e True\n-- is_sorted [1, 2, 3, 4, 5, 6, 7] \u279e True\n-- is_sorted [1, 3, 2, 4, 5, 6, 7] \u279e False\n-- is_sorted [1, 2, 2, 3, 3, 4] \u279e True\n-- is_sorted [1, 2, 2, 2, 3, 4] \u279e False\nimport Data.List (nub)\n\nis_sorted :: [Int] -> Bool\nis_sorted lst =  length (nub lst) == length lst &&  all (uncurry (<=)) (zip lst (tail lst))\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (is_sorted [5] == True)\n    check (is_sorted [1, 2, 3, 4, 5] == True)\n    check (is_sorted [1, 3, 2, 4, 5] == False)\n    check (is_sorted [1, 2, 3, 4, 5, 6] == True)\n    check (is_sorted [1, 2, 3, 4, 5, 6, 7] == True)\n    check (is_sorted [1, 3, 2, 4, 5, 6, 7] == False)\n    check (is_sorted [] == True)\n    check (is_sorted [1] == True)\n    check (is_sorted [3, 2, 1] == False)\n    check (is_sorted [1, 2, 2, 2, 3, 4] == False)\n    check (is_sorted [1, 2, 3, 3, 3, 4] == False)\n    check (is_sorted [1, 2, 2, 3, 3, 4] == True)\n    check (is_sorted [1, 2, 3, 4] == True)\n"}
{"task_id": "Haskell/127", "prompt": "-- You are given two intervals,\n-- where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n-- The given intervals are closed which means that the interval (start, end)\n-- includes both start and end.\n-- For each given interval, it is assumed that its start is less or equal its end.\n-- Your task is to determine whether the length of intersection of these two\n-- intervals is a prime number.\n-- Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n-- which its length is 1, which not a prime number.\n-- If the length of the intersection is a prime number, return \"YES\",\n-- otherwise, return \"NO\".\n-- If the two intervals don't intersect, return \"NO\".\n-- [input/output] samples:\n-- intersection (1, 2) (2, 3) ==> \"NO\"\n-- intersection (-1, 1) (0, 4) ==> \"NO\"\n-- intersection (-3, -1) (-5, 5) ==> \"YES\"\nintersection :: (Int, Int) -> (Int, Int) -> String", "canonical_solution": "-- Task ID: HumanEval/127\n-- Assigned To: Author D\n\n-- Python Implementation:\n\n-- \n-- def intersection(interval1, interval2):\n--     \"\"\"You are given two intervals,\n--     where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n--     The given intervals are closed which means that the interval (start, end)\n--     includes both start and end.\n--     For each given interval, it is assumed that its start is less or equal its end.\n--     Your task is to determine whether the length of intersection of these two \n--     intervals is a prime number.\n--     Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n--     which its length is 1, which not a prime number.\n--     If the length of the intersection is a prime number, return \"YES\",\n--     otherwise, return \"NO\".\n--     If the two intervals don't intersect, return \"NO\".\n-- \n-- \n--     [input/output] samples:\n--     intersection((1, 2), (2, 3)) ==> \"NO\"\n--     intersection((-1, 1), (0, 4)) ==> \"NO\"\n--     intersection((-3, -1), (-5, 5)) ==> \"YES\"\n--     \"\"\"\n--     def is_prime(num):\n--         if num == 1 or num == 0:\n--             return False\n--         if num == 2:\n--             return True\n--         for i in range(2, num):\n--             if num%i == 0:\n--                 return False\n--         return True\n-- \n--     l = max(interval1[0], interval2[0])\n--     r = min(interval1[1], interval2[1])\n--     length = r - l\n--     if length > 0 and is_prime(length):\n--         return \"YES\"\n--     return \"NO\"\n-- \n\n\n-- Haskell Implementation:\n\n-- You are given two intervals,\n-- where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n-- The given intervals are closed which means that the interval (start, end)\n-- includes both start and end.\n-- For each given interval, it is assumed that its start is less or equal its end.\n-- Your task is to determine whether the length of intersection of these two \n-- intervals is a prime number.\n-- Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n-- which its length is 1, which not a prime number.\n-- If the length of the intersection is a prime number, return \"YES\",\n-- otherwise, return \"NO\".\n-- If the two intervals don't intersect, return \"NO\".\n-- \n-- \n-- [input/output] samples:\n-- intersection (1, 2) (2, 3) ==> \"NO\"\n-- intersection (-1, 1) (0, 4) ==> \"NO\"\n-- intersection (-3, -1) (-5, 5) ==> \"YES\"\nintersection :: (Int, Int) -> (Int, Int) -> String\nintersection (a, b) (c, d)\n  | b < c || d < a = \"NO\"\n  | otherwise =  if is_prime (abs (min b d - max a c)) then  \"YES\" else \"NO\"\n  where\n    is_prime :: Int -> Bool\n    is_prime n =  n > 1 && all (\\k -> n `mod` k /= 0) [2..floor (sqrt (fromIntegral n))]\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (intersection (1, 2) (2, 3) == \"NO\")\n    check (intersection (-1, 1) (0, 4) == \"NO\")\n    check (intersection (-3, -1) (-5, 5) == \"YES\")\n    check (intersection (-2, 2) (-4, 0) == \"YES\")\n    check (intersection (-11, 2) (-1, -1) == \"NO\")\n    check (intersection (1, 2) (3, 5) == \"NO\")\n    check (intersection (1, 2) (1, 2) == \"NO\")\n    check (intersection (-2, -2) (-3, -2) == \"NO\")\n"}
{"task_id": "Haskell/128", "prompt": "-- You are given an array arr of integers and you need to return\n-- sum of magnitudes of integers multiplied by product of all signs\n-- of each number in the array, represented by 1, -1 or 0.\n-- Note: return None for empty arr.\n-- Example:\n-- >>> prod_signs [1, 2, 2, -4] == Just (-9)\n-- >>> prod_signs [0, 1] == Just 0\n-- >>> prod_signs [] == Nothing\nprod_signs :: [Int] -> Maybe Int", "canonical_solution": "-- Task ID: HumanEval/128\n-- Assigned To: Author D\n\n-- Python Implementation:\n\n-- \n-- def prod_signs(arr):\n--     \"\"\"\n--     You are given an array arr of integers and you need to return\n--     sum of magnitudes of integers multiplied by product of all signs\n--     of each number in the array, represented by 1, -1 or 0.\n--     Note: return None for empty arr.\n-- \n--     Example:\n--     >>> prod_signs([1, 2, 2, -4]) == -9\n--     >>> prod_signs([0, 1]) == 0\n--     >>> prod_signs([]) == None\n--     \"\"\"\n--     if not arr: return None\n--     prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n--     return prod * sum([abs(i) for i in arr])\n-- \n\n\n-- Haskell Implementation:\n\n-- You are given an array arr of integers and you need to return\n-- sum of magnitudes of integers multiplied by product of all signs\n-- of each number in the array, represented by 1, -1 or 0.\n-- Note: return None for empty arr.\n-- \n-- Example:\n-- >>> prod_signs [1, 2, 2, -4] == Just (-9)\n-- >>> prod_signs [0, 1] == Just 0\n-- >>> prod_signs [] == Nothing\nprod_signs :: [Int] -> Maybe Int\nprod_signs arr\n  | null arr =  Nothing\n  | otherwise =  Just $ prod * sum (map abs arr)\n  where\n    prod :: Int\n    prod =  if 0 `elem` arr then 0 else  (-1) ^ length (filter (< 0) arr)\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check True\n    check (prod_signs [1, 2, 2, -4] == -9)\n    check (prod_signs [0, 1] == 0)\n    check (prod_signs [1, 1, 1, 2, 3, -1, 1] == -10)\n    check (prod_signs [] == Nothing)\n    check (prod_signs [2, 4, 1, 2, -1, -1, 9] == 20)\n    check (prod_signs [-1, 1, -1, 1] == 4)\n    check (prod_signs [-1, 1, 1, 1] == -4)\n    check (prod_signs [-1, 1, 1, 0] == 0)\n    check True\n"}
{"task_id": "Haskell/129", "prompt": "-- Given a grid with N rows and N columns (N >= 2) and a positive integer k,\n-- each cell of the grid contains a value. Every integer in the range [1, N * N]\n-- inclusive appears exactly once on the cells of the grid.\n-- You have to find the minimum path of length k in the grid. You can start\n-- from any cell, and in each step you can move to any of the neighbor cells,\n-- in other words, you can go to cells which share an edge with you current\n-- cell.\n-- Please note that a path of length k means visiting exactly k cells (not\n-- necessarily distinct).\n-- You CANNOT go off the grid.\n-- A path A (of length k) is considered less than a path B (of length k) if\n-- after making the ordered lists of the values on the cells that A and B go\n-- through (let's call them lst_A and lst_B), lst_A is lexicographically less\n-- than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n-- such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n-- lst_A[j] = lst_B[j].\n-- It is guaranteed that the answer is unique.\n-- Return an ordered list of the values on the cells that the minimum path go through.\n-- Examples:\n--     Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n--     Output: [1, 2, 1]\n--     Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n--     Output: [1]\nminPath :: [[Int]] -> Int -> [Int]", "canonical_solution": "-- Task ID: HumanEval/129\n-- Assigned To: Author D\n\n-- Python Implementation:\n\n-- \n-- def minPath(grid, k):\n--     \"\"\"\n--     Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n--     each cell of the grid contains a value. Every integer in the range [1, N * N]\n--     inclusive appears exactly once on the cells of the grid.\n-- \n--     You have to find the minimum path of length k in the grid. You can start\n--     from any cell, and in each step you can move to any of the neighbor cells,\n--     in other words, you can go to cells which share an edge with you current\n--     cell.\n--     Please note that a path of length k means visiting exactly k cells (not\n--     necessarily distinct).\n--     You CANNOT go off the grid.\n--     A path A (of length k) is considered less than a path B (of length k) if\n--     after making the ordered lists of the values on the cells that A and B go\n--     through (let's call them lst_A and lst_B), lst_A is lexicographically less\n--     than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n--     such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n--     lst_A[j] = lst_B[j].\n--     It is guaranteed that the answer is unique.\n--     Return an ordered list of the values on the cells that the minimum path go through.\n-- \n--     Examples:\n-- \n--         Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n--         Output: [1, 2, 1]\n-- \n--         Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n--         Output: [1]\n--     \"\"\"\n--     n = len(grid)\n--     val = n * n + 1\n--     for i in range(n):\n--         for j in range(n):\n--             if grid[i][j] == 1:\n--                 temp = []\n--                 if i != 0:\n--                     temp.append(grid[i - 1][j])\n-- \n--                 if j != 0:\n--                     temp.append(grid[i][j - 1])\n-- \n--                 if i != n - 1:\n--                     temp.append(grid[i + 1][j])\n-- \n--                 if j != n - 1:\n--                     temp.append(grid[i][j + 1])\n-- \n--                 val = min(temp)\n-- \n--     ans = []\n--     for i in range(k):\n--         if i % 2 == 0:\n--             ans.append(1)\n--         else:\n--             ans.append(val)\n--     return ans\n-- \n\n\n-- Haskell Implementation:\nimport Data.List\n\n-- Given a grid with N rows and N columns (N >= 2) and a positive integer k,\n-- each cell of the grid contains a value. Every integer in the range [1, N * N]\n-- inclusive appears exactly once on the cells of the grid.\n-- \n-- You have to find the minimum path of length k in the grid. You can start\n-- from any cell, and in each step you can move to any of the neighbor cells,\n-- in other words, you can go to cells which share an edge with you current\n-- cell.\n-- Please note that a path of length k means visiting exactly k cells (not\n-- necessarily distinct).\n-- You CANNOT go off the grid.\n-- A path A (of length k) is considered less than a path B (of length k) if\n-- after making the ordered lists of the values on the cells that A and B go\n-- through (let's call them lst_A and lst_B), lst_A is lexicographically less\n-- than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n-- such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n-- lst_A[j] = lst_B[j].\n-- It is guaranteed that the answer is unique.\n-- Return an ordered list of the values on the cells that the minimum path go through.\n--\n-- Examples:\n--\n--     Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n--     Output: [1, 2, 1]\n--\n--     Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n--     Output: [1]\nminPath :: [[Int]] -> Int -> [Int]\nminPath grid k =  seq [1, smallest_neighbor $ one_pos grid] k\n    where\n        one_pos :: [[Int]] -> (Int, Int)\n        one_pos [] =  (-1, -1)\n        one_pos (x:xs) =  case elemIndex 1 x of\n            Just i -> (i, 0)\n            Nothing -> case one_pos xs of\n                (-1, -1) -> (-1, -1)\n                (i, j) -> (i, j + 1)\n\n        n = length grid\n\n        neighbors :: (Int, Int) -> [(Int, Int)]\n        neighbors (i, j) =  filter (\\(x, y) -> x >= 0 && x < n && y >= 0 && y < n) [(i - 1, j), (i, j - 1), (i + 1, j), (i, j + 1)]\n\n        smallest_neighbor :: (Int, Int) -> Int\n        smallest_neighbor (i, j) =  minimum $ map (\\(x, y) -> grid !! x !! y) $  neighbors (i, j)\n\n        seq :: [Int] -> Int -> [Int]\n        seq _ 0 =  []\n        seq (x:xs) k =  x : seq (xs ++ [x]) (k - 1)\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (minPath [[1, 2, 3], [4, 5, 6], [7, 8, 9]] 3 == [1, 2, 1])\n    check (minPath [[5, 9, 3], [4, 1, 6], [7, 8, 2]] 1 == [1])\n    check (minPath [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]] 4 == [1, 2, 1, 2])\n    check (minPath [[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]] 7 == [1, 10, 1, 10, 1, 10, 1])\n    check (minPath [[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]] 5 == [1, 7, 1, 7, 1])\n    check (minPath [[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]] 9 == [1, 6, 1, 6, 1, 6, 1, 6, 1])\n    check (minPath [[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]] 12 == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n    check (minPath [[2, 7, 4], [3, 1, 5], [6, 8, 9]] 8 == [1, 3, 1, 3, 1, 3, 1, 3])\n    check (minPath [[6, 1, 5], [3, 8, 9], [2, 7, 4]] 8 == [1, 5, 1, 5, 1, 5, 1, 5])\n    check (minPath [[1, 2], [3, 4]] 10 == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n    check (minPath [[1, 3], [3, 2]] 10 == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n"}
{"task_id": "Haskell/130", "prompt": "-- Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in\n-- the last couple centuries. However, what people don't know is Tribonacci sequence.\n-- Tribonacci sequence is defined by the recurrence:\n-- tri 1 = 3\n-- tri n = 1 + n / 2, if n is even.\n-- tri n =  tri (n - 1) + tri (n - 2) + tri (n + 1), if n is odd.\n-- For example:\n-- tri 2 = 1 + (2 / 2) = 2\n-- tri 4 = 3\n-- tri 3 = tri 2 + tri 1 + tri 4\n--       = 2 + 3 + 3 = 8\n-- You are given a non-negative integer number n, you have to a return a list of the\n-- first n + 1 numbers of the Tribonacci sequence.\n-- Examples:\n-- tri 3 = [1, 3, 2, 8]\ntri :: Int -> [Int]", "canonical_solution": "-- Task ID: HumanEval/130\n-- Assigned To: Author D\n\n-- Python Implementation:\n\n-- \n-- def tri(n):\n--     \"\"\"Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n--     the last couple centuries. However, what people don't know is Tribonacci sequence.\n--     Tribonacci sequence is defined by the recurrence:\n--     tri(1) = 3\n--     tri(n) = 1 + n / 2, if n is even.\n--     tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n--     For example:\n--     tri(2) = 1 + (2 / 2) = 2\n--     tri(4) = 3\n--     tri(3) = tri(2) + tri(1) + tri(4)\n--            = 2 + 3 + 3 = 8 \n--     You are given a non-negative integer number n, you have to a return a list of the \n--     first n + 1 numbers of the Tribonacci sequence.\n--     Examples:\n--     tri(3) = [1, 3, 2, 8]\n--     \"\"\"\n--     if n == 0:\n--         return [1]\n--     my_tri = [1, 3]\n--     for i in range(2, n + 1):\n--         if i % 2 == 0:\n--             my_tri.append(i / 2 + 1)\n--         else:\n--             my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n--     return my_tri\n-- \n\n\n-- Haskell Implementation:\n\n-- Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in\n-- the last couple centuries. However, what people don't know is Tribonacci sequence.\n-- Tribonacci sequence is defined by the recurrence:\n-- tri 1 = 3\n-- tri n = 1 + n / 2, if n is even.\n-- tri n =  tri (n - 1) + tri (n - 2) + tri (n + 1), if n is odd.\n-- For example:\n-- tri 2 = 1 + (2 / 2) = 2\n-- tri 4 = 3\n-- tri 3 = tri 2 + tri 1 + tri 4\n--       = 2 + 3 + 3 = 8\n-- You are given a non-negative integer number n, you have to a return a list of the\n-- first n + 1 numbers of the Tribonacci sequence.\n-- Examples:\n-- tri 3 = [1, 3, 2, 8]\ntri :: Int -> [Int]\ntri n =  map tri' [0..n]\n    where\n        tri' :: Int -> Int\n        tri' 0 =  1\n        tri' 1 =  3\n        tri' n\n            | even n =  1 + n `div` 2\n            | otherwise =  tri' (n - 1) +  tri' (n - 2) +  tri' (n + 1)\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (tri 3 == [1, 3, 2.0, 8.0])\n    check (tri 4 == [1, 3, 2.0, 8.0, 3.0])\n    check (tri 5 == [1, 3, 2.0, 8.0, 3.0, 15.0])\n    check (tri 6 == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n    check (tri 7 == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n    check (tri 8 == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n    check (tri 9 == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n    check (tri 20 == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0])\n    check (tri 0 == [1])\n    check (tri 1 == [1, 3])\n"}
{"task_id": "Haskell/131", "prompt": "-- Given a positive integer n, return the product of the odd digits.\n-- Return 0 if all digits are even.\n-- For example:\n-- digits 1  == 1\n-- digits 4  == 0\n-- digits 235 == 15\ndigits :: Int -> Int", "canonical_solution": "-- Task ID: HumanEval/131\n-- Assigned To: Author D\n\n-- Python Implementation:\n\n-- \n-- def digits(n):\n--     \"\"\"Given a positive integer n, return the product of the odd digits.\n--     Return 0 if all digits are even.\n--     For example:\n--     digits(1)  == 1\n--     digits(4)  == 0\n--     digits(235) == 15\n--     \"\"\"\n--     product = 1\n--     odd_count = 0\n--     for digit in str(n):\n--         int_digit = int(digit)\n--         if int_digit%2 == 1:\n--             product= product*int_digit\n--             odd_count+=1\n--     if odd_count ==0:\n--         return 0\n--     else:\n--         return product\n-- \n\n\n-- Haskell Implementation:\n\n-- Given a positive integer n, return the product of the odd digits.\n-- Return 0 if all digits are even.\n-- For example:\n-- digits 1  == 1\n-- digits 4  == 0\n-- digits 235 == 15\ndigits :: Int -> Int\ndigits n =  if odd_count == 0 then  0 else product\n  where\n    f :: Char -> (Int, Int) -> (Int, Int)\n    (product, odd_count) =  foldr f (1, 0) (show n)\n    f digit (acc, count)\n      | even int_digit =  (acc, count)\n      | otherwise =  (acc * int_digit, count + 1)\n      where\n        int_digit :: Int\n        int_digit =  read [digit] :: Int\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (digits 5 == 5)\n    check (digits 54 == 5)\n    check (digits 120 == 1)\n    check (digits 5014 == 5)\n    check (digits 98765 == 315)\n    check (digits 5576543 == 2625)\n    check (digits 2468 == 0)\n"}
{"task_id": "Haskell/132", "prompt": "-- Create a function that takes a string as input which contains only square brackets.\n-- The function should return True if and only if there is a valid subsequence of brackets\n-- where at least one bracket in the subsequence is nested.\n-- >>> is_nested \"[[]]\"\n-- True\n-- >>> is_nested \"[]]]]]]][[[[[]\"\n-- False\n-- >>> is_nested \"[][]\"\n-- False\n-- >>> is_nested \"[]\"\n-- False\n-- >>> is_nested \"[[][]]\"\n-- True\n-- >>> is_nested \"[[]][[\"\n-- True\nis_nested :: String -> Bool", "canonical_solution": "-- Task ID: HumanEval/132\n-- Assigned To: Author B\n\n-- Python Implementation:\n\n--\n-- def is_nested(string):\n--     '''\n--     Create a function that takes a string as input which contains only square brackets.\n--     The function should return True if and only if there is a valid subsequence of brackets\n--     where at least one bracket in the subsequence is nested.\n--\n--     is_nested('[[]]') \u279e True\n--     is_nested('[]]]]]]][[[[[]') \u279e False\n--     is_nested('[][]') \u279e False\n--     is_nested('[]') \u279e False\n--     is_nested('[[][]]') \u279e True\n--     is_nested('[[]][[') \u279e True\n--     '''\n--     opening_bracket_index = []\n--     closing_bracket_index = []\n--     for i in range(len(string)):\n--         if string[i] == '[':\n--             opening_bracket_index.append(i)\n--         else:\n--             closing_bracket_index.append(i)\n--     closing_bracket_index.reverse()\n--     cnt = 0\n--     i = 0\n--     l = len(closing_bracket_index)\n--     for idx in opening_bracket_index:\n--         if i < l and idx < closing_bracket_index[i]:\n--             cnt += 1\n--             i += 1\n--     return cnt >= 2\n--\n--\n--\n\n-- Haskell Implementation:\n-- Create a function that takes a string as input which contains only square brackets.\n-- The function should return True if and only if there is a valid subsequence of brackets\n-- where at least one bracket in the subsequence is nested.\n--\n-- >>> is_nested \"[[]]\"\n-- True\n-- >>> is_nested \"[]]]]]]][[[[[]\"\n-- False\n-- >>> is_nested \"[][]\"\n-- False\n-- >>> is_nested \"[]\"\n-- False\n-- >>> is_nested \"[[][]]\"\n-- True\n-- >>> is_nested \"[[]][[\"\n-- True\n\nis_nested :: String -> Bool\nis_nested string = is_nested' string 0 [] []\n  where\n    is_nested' :: String -> Int -> [Int] -> [Int] -> Bool\n    is_nested' ('[' : cs) index opening_bracket_index closing_bracket_index =  is_nested' cs (index + 1) (opening_bracket_index  ++ [index]) closing_bracket_index\n    is_nested' (']' : cs) index opening_bracket_index closing_bracket_index =  is_nested' cs (index + 1) opening_bracket_index ([index]  ++ closing_bracket_index)\n    is_nested' \"\" index opening_bracket_index closing_bracket_index\n      | index < 3 =  False\n      | otherwise =  is_nested'' opening_bracket_index closing_bracket_index 0 (length closing_bracket_index)\n      where\n        is_nested'' :: [Int] -> [Int] -> Int -> Int -> Bool\n        is_nested'' _ [] cnt l =  cnt >= 2\n        is_nested'' [] _ cnt l =  cnt >= 2\n        is_nested'' (o : os) (c : cs) cnt l\n          | o < c && cnt < l =  is_nested'' os cs (cnt + 1) l\n          | otherwise =  is_nested'' os (c : cs) cnt l\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (is_nested \"[[]]\" == True)\n    check (is_nested \"[]]]]]]][[[[[]\" == False)\n    check (is_nested \"[][]\" == False)\n    check (is_nested \"[]\" == False)\n    check (is_nested \"[[[[]]]]\" == True)\n    check (is_nested \"[]]]]]]]]]\" == False)\n    check (is_nested \"[][][[]]\" == True)\n    check (is_nested \"[[]\" == False)\n    check (is_nested \"[]]\" == False)\n    check (is_nested \"[[]][[\" == True)\n    check (is_nested \"[[][]]\" == True)\n    check (is_nested \"\" == False)\n    check (is_nested \"[[[[[[[[\" == False)\n    check (is_nested \"]]]]]]]]\" == False)\n"}
{"task_id": "Haskell/133", "prompt": "sum_squares :: [Double] -> Int\nsum_squares lst = sum_squares' lst 0\n  where\n    sum_squares' [] acc = acc\n    sum_squares' (x : xs) acc = sum_squares' xs (acc + ceiling x ^ 2)\n-- Since Python has no type declarations and only floats, the Haskell implementation cannot be as general as the Python implementation due to strict typing.\n-- Therefore, the Haskell implementation only accepts lists of Doubles, not mixed with Ints. For completeness, here is the implementation for Ints (no need for ceiling):", "canonical_solution": "-- Task ID: HumanEval/133\n-- Assigned To: Author B\n\n-- Python Implementation:\n\n--\n--\n-- def sum_squares(lst):\n--     \"\"\"You are given a list of numbers.\n--     You need to return the sum of squared numbers in the given list,\n--     round each element in the list to the upper int(Ceiling) first.\n--     Examples:\n--     For lst = [1,2,3] the output should be 14\n--     For lst = [1,4,9] the output should be 98\n--     For lst = [1,3,5,7] the output should be 84\n--     For lst = [1.4,4.2,0] the output should be 29\n--     For lst = [-2.4,1,1] the output should be 6\n--\n--\n--     \"\"\"\n--     import math\n--     squared = 0\n--     for i in lst:\n--         squared += math.ceil(i)**2\n--     return squared\n--\n\n-- Haskell Implementation:\nsum_squares :: [Double] -> Int\nsum_squares lst =  sum_squares' lst 0\n  where\n    sum_squares' [] acc =  acc\n    sum_squares' (x : xs) acc =  sum_squares' xs (acc + ceiling x ^ 2)\n\n-- Since Python has no type declarations and only floats, the Haskell implementation cannot be as general as the Python implementation due to strict typing.\n-- Therefore, the Haskell implementation only accepts lists of Doubles, not mixed with Ints. For completeness, here is the implementation for Ints (no need for ceiling):\nsum_squares_int :: [Int] -> Int\nsum_squares_int lst =  sum_squares' lst 0\n  where\n    sum_squares' [] acc =  acc\n    sum_squares' (x : xs) acc =  sum_squares' xs (acc + x ^ 2)\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (sum_squares [1, 2, 3] == 14)\n    check (sum_squares [1.0, 2, 3] == 14)\n    check (sum_squares [1, 3, 5, 7] == 84)\n    check (sum_squares [1.4, 4.2, 0] == 29)\n    check (sum_squares [-2.4, 1, 1] == 6)\n    check (sum_squares [100, 1, 15, 2] == 10230)\n    check (sum_squares [10000, 10000] == 200000000)\n    check (sum_squares [-1.4, 4.6, 6.3] == 75)\n    check (sum_squares [-1.4, 17.9, 18.9, 19.9] == 1086)\n    check (sum_squares [0] == 0)\n    check (sum_squares [-1] == 1)\n    check (sum_squares [-1, 1, 0] == 2)\n"}
{"task_id": "Haskell/134", "prompt": "import Data.Char (isLetter) \ncheck_if_last_char_is_a_letter :: String -> Bool", "canonical_solution": "-- Task ID: HumanEval/134\n-- Assigned To: Author B\n\n-- Python Implementation:\n\n--\n-- def check_if_last_char_is_a_letter(txt):\n--     '''\n--     Create a function that returns True if the last character\n--     of a given string is an alphabetical character and is not\n--     a part of a word, and False otherwise.\n--     Note: \"word\" is a group of characters separated by space.\n--\n--     Examples:\n--     check_if_last_char_is_a_letter(\"apple pie\") \u279e False\n--     check_if_last_char_is_a_letter(\"apple pi e\") \u279e True\n--     check_if_last_char_is_a_letter(\"apple pi e \") \u279e False\n--     check_if_last_char_is_a_letter(\"\") \u279e False\n--     '''\n--\n--     check = txt.split(' ')[-1]\n--     return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n--\n\n-- Haskell Implementation:\nimport Data.Char (isLetter)\n\ncheck_if_last_char_is_a_letter :: String -> Bool\ncheck_if_last_char_is_a_letter [] =  False\ncheck_if_last_char_is_a_letter txt =  isLetter $ last txt\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (check_if_last_char_is_a_letter \"apple\" == False)\n    check (check_if_last_char_is_a_letter \"apple pi e\" == True)\n    check (check_if_last_char_is_a_letter \"eeeee\" == False)\n    check (check_if_last_char_is_a_letter \"A\" == True)\n    check (check_if_last_char_is_a_letter \"Pumpkin pie \" == False)\n    check (check_if_last_char_is_a_letter \"Pumpkin pie 1\" == False)\n    check (check_if_last_char_is_a_letter \"\" == False)\n    check (check_if_last_char_is_a_letter \"eeeee e \" == False)\n    check (check_if_last_char_is_a_letter \"apple pie\" == False)\n    check (check_if_last_char_is_a_letter \"apple pi e \" == False)\n"}
{"task_id": "Haskell/135", "prompt": "-- Create a function which returns the largest index of an element which\n-- is not greater than or equal to the element immediately preceding it. If\n-- no such element exists then return -1. The given array will not contain\n-- uplicate values.\n-- >>> can_arrange [1,2,4,3,5]\n-- 3\n-- >>> can_arrange [1,2,3]\n-- -1\ncan_arrange :: [Int] -> Int", "canonical_solution": "-- Task ID: HumanEval/135\n-- Assigned To: Author B\n\n-- Python Implementation:\n\n--\n-- def can_arrange(arr):\n--     \"\"\"Create a function which returns the largest index of an element which\n--     is not greater than or equal to the element immediately preceding it. If\n--     no such element exists then return -1. The given array will not contain\n--     duplicate values.\n--\n--     Examples:\n--     can_arrange([1,2,4,3,5]) = 3\n--     can_arrange([1,2,3]) = -1\n--     \"\"\"\n--     ind=-1\n--     i=1\n--     while i<len(arr):\n--       if arr[i]<arr[i-1]:\n--         ind=i\n--       i+=1\n--     return ind\n--\n\n-- Haskell Implementation:\n-- Create a function which returns the largest index of an element which\n-- is not greater than or equal to the element immediately preceding it. If\n-- no such element exists then return -1. The given array will not contain\n-- uplicate values.\n--\n-- >>> can_arrange [1,2,4,3,5]\n-- 3\n-- >>> can_arrange [1,2,3]\n-- -1\ncan_arrange :: [Int] -> Int\ncan_arrange arr =  can_arrange' arr 1 (-1)\n  where\n    can_arrange' :: [Int] -> Int -> Int -> Int\n    can_arrange' [] index res =  res\n    can_arrange' (a : []) index res =  res\n    can_arrange' (a : b : xs) index res\n      | a >= b =  can_arrange' (b : xs) (index + 1) index\n      | otherwise =  can_arrange' (b : xs) (index + 1) res\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (can_arrange [1, 2, 4, 3, 5] == 3)\n    check (can_arrange [1, 2, 4, 5] == -1)\n    check (can_arrange [1, 4, 2, 5, 6, 7, 8, 9, 10] == 2)\n    check (can_arrange [4, 8, 5, 7, 3] == 4)\n    check (can_arrange [] == -1)\n"}
{"task_id": "Haskell/136", "prompt": "-- Create a function that returns a tuple (a, b), where 'a' is\n-- the largest of negative integers, and 'b' is the smallest\n-- of positive integers in a list.\n-- If there is no negative or positive integers, return them as None.\n-- Examples:\n-- >>> largest_smallest_integers [2, 4, 1, 3, 5, 7]\n-- (Nothing,Just 1)\n-- >>> largest_smallest_integers []\n-- (Nothing,Nothing)\n-- >>> largest_smallest_integers [0]\n-- (Nothing,Nothing)\nlargest_smallest_integers :: [Int] -> (Maybe Int, Maybe Int)", "canonical_solution": "-- Task ID: HumanEval/136\n-- Assigned To: Author B\n\n-- Python Implementation:\n\n--\n-- def largest_smallest_integers(lst):\n--     '''\n--     Create a function that returns a tuple (a, b), where 'a' is\n--     the largest of negative integers, and 'b' is the smallest\n--     of positive integers in a list.\n--     If there is no negative or positive integers, return them as None.\n--\n--     Examples:\n--     largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n--     largest_smallest_integers([]) == (None, None)\n--     largest_smallest_integers([0]) == (None, None)\n--     '''\n--     smallest = list(filter(lambda x: x < 0, lst))\n--     largest = list(filter(lambda x: x > 0, lst))\n--     return (max(smallest) if smallest else None, min(largest) if largest else None)\n--\n\n-- Haskell Implementation:\n\n-- Create a function that returns a tuple (a, b), where 'a' is\n-- the largest of negative integers, and 'b' is the smallest\n-- of positive integers in a list.\n-- If there is no negative or positive integers, return them as None.\n--\n-- Examples:\n-- >>> largest_smallest_integers [2, 4, 1, 3, 5, 7]\n-- (Nothing,Just 1)\n-- >>> largest_smallest_integers []\n-- (Nothing,Nothing)\n-- >>> largest_smallest_integers [0]\n-- (Nothing,Nothing)\n\nimport Data.Maybe\n\nlargest_smallest_integers :: [Int] -> (Maybe Int, Maybe Int)\nlargest_smallest_integers [] =  (Nothing, Nothing)\nlargest_smallest_integers arr =  largest_smallest_integers' arr Nothing Nothing\n  where\n    largest_smallest_integers' :: [Int] -> Maybe Int -> Maybe Int -> (Maybe Int, Maybe Int)\n    largest_smallest_integers' [] largest smallest = (largest, smallest)\n    largest_smallest_integers' (x : xs) largest smallest\n      | x < 0 && isNothing largest =  largest_smallest_integers' xs (Just x) smallest\n      | x < 0 =  largest_smallest_integers' xs (Just  (max (fromJust largest) x)) smallest\n      | x > 0 && isNothing smallest =  largest_smallest_integers' xs largest (Just x)\n      | x > 0 =  largest_smallest_integers' xs largest (Just  (min (fromJust smallest) x))\n      | otherwise =  largest_smallest_integers' xs largest smallest\n\n-- Alternative using fold:\nlargest_smallest_integers_fold :: [Int] -> (Maybe Int, Maybe Int)\nlargest_smallest_integers_fold [] =  (Nothing, Nothing)\nlargest_smallest_integers_fold arr =  foldl largest_smallest_integers_fold' (Nothing, Nothing) arr\n  where\n    largest_smallest_integers_fold' :: (Maybe Int, Maybe Int) -> Int -> (Maybe Int, Maybe Int)\n    largest_smallest_integers_fold' (largest, smallest) x\n      | x < 0 && isNothing largest =  (Just x, smallest)\n      | x < 0 =  (Just (max (fromJust largest) x), smallest)\n      | x > 0 && isNothing smallest =  (largest, Just x)\n      | x > 0 =  (largest, Just (min (fromJust smallest) x))\n      | otherwise =  (largest, smallest)\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (largest_smallest_integers [2, 4, 1, 3, 5, 7] == (Nothing, Just 1))\n    check (largest_smallest_integers [2, 4, 1, 3, 5, 7, 0] == (Nothing, Just 1))\n    check (largest_smallest_integers [1, 3, 2, 4, 5, 6, -2] == (Just (-2), Just 1))\n    check (largest_smallest_integers [4, 5, 3, 6, 2, 7, -7] == (Just (-7), Just 2))\n    check (largest_smallest_integers [7, 3, 8, 4, 9, 2, 5, -9] == (Just (-9), Just 2))\n    check (largest_smallest_integers [] == (Nothing, Nothing))\n    check (largest_smallest_integers [0] == (Nothing, Nothing))\n    check (largest_smallest_integers [-1, -3, -5, -6] == (Just (-1), Nothing))\n    check (largest_smallest_integers [-1, -3, -5, -6, 0] == (Just (-1), Nothing))\n    check (largest_smallest_integers [-6, -4, -4, -3, 1] == (Just (-3), Just 1))\n    check (largest_smallest_integers [-6, -4, -4, -3, -100, 1] == (Just (-3), Just 1))\n"}
{"task_id": "Haskell/137", "prompt": "-- Create a function that takes integers, floats, or strings representing\n-- real numbers, and returns the larger variable in its given variable type.\n-- Return Nothing if the values are equal.\n-- Note: If a real number is represented as a string, the floating point might be . or ,\n-- >>> compare_one (IntNumber 1) (FloatNumber 2.5)\n-- Just (FloatNumber 2.5)\n-- >>> compare_one (IntNumber 1) (StringNumber \"2,3\")\n-- Just (StringNumber \"2,3\")\n-- >>> compare_one (StringNumber \"5,1\") (StringNumber \"6\")\n-- Just (StringNumber \"6\")\n-- >>> compare_one (StringNumber \"1\") (IntNumber 1)\n-- Nothing\ncompare_one :: Either3 Int Float String -> Either3 Int Float String -> Maybe (Either3 Int Float String)", "canonical_solution": "-- Task ID: HumanEval/137\n-- Assigned To: Author B\n\n-- Python Implementation:\n\n--\n-- def compare_one(a, b):\n--     \"\"\"\n--     Create a function that takes integers, floats, or strings representing\n--     real numbers, and returns the larger variable in its given variable type.\n--     Return None if the values are equal.\n--     Note: If a real number is represented as a string, the floating point might be . or ,\n--\n--     compare_one(1, 2.5) \u279e 2.5\n--     compare_one(1, \"2,3\") \u279e \"2,3\"\n--     compare_one(\"5,1\", \"6\") \u279e \"6\"\n--     compare_one(\"1\", 1) \u279e None\n--     \"\"\"\n--     temp_a, temp_b = a, b\n--     if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n--     if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n--     if float(temp_a) == float(temp_b): return None\n--     return a if float(temp_a) > float(temp_b) else b\n--\n\n-- Haskell Implementation:\n\n-- Create a function that takes integers, floats, or strings representing\n-- real numbers, and returns the larger variable in its given variable type.\n-- Return Nothing if the values are equal.\n-- Note: If a real number is represented as a string, the floating point might be . or ,\n--\n-- >>> compare_one (IntNumber 1) (FloatNumber 2.5)\n-- Just (FloatNumber 2.5)\n-- >>> compare_one (IntNumber 1) (StringNumber \"2,3\")\n-- Just (StringNumber \"2,3\")\n-- >>> compare_one (StringNumber \"5,1\") (StringNumber \"6\")\n-- Just (StringNumber \"6\")\n-- >>> compare_one (StringNumber \"1\") (IntNumber 1)\n-- Nothing\ndata Either3 a b c = IntNumber a | FloatNumber b | StringNumber c deriving (Show, Eq)\n\ncompare_one :: Either3 Int Float String -> Either3 Int Float String -> Maybe (Either3 Int Float String)\ncompare_one x y =  if xf == yf then  Nothing else Just  (if xf > yf then x else y)\n  where\n    to_float :: Either3 Int Float String -> Float\n    to_float (IntNumber x) =  fromIntegral x\n    to_float (FloatNumber x) =  x\n    to_float (StringNumber x) =  read (map (\\c -> if c == ',' then  '.' else c) x) :: Float\n    xf :: Float\n    xf =  to_float x\n    yf :: Float\n    yf =  to_float y\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (compare_one 1 2 == Just 2)\n    check (compare_one 1 2.5 == Just 2.5)\n    check (compare_one 2 3 == Just 3)\n    check (compare_one 5 6 == Just 6)\n    check (compare_one 1 \"2,3\" == Just \"2,3\")\n    check (compare_one \"5,1\" \"6\" == Just \"6\")\n    check (compare_one \"1\" \"2\" == Just \"2\")\n    check (compare_one \"1\" 1 == Nothing)\n"}
{"task_id": "Haskell/138", "prompt": "-- Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n-- Example\n-- >>> is_equal_to_sum_even 4\n-- False\n-- >>> is_equal_to_sum_even 6\n-- False\n-- >>> is_equal_to_sum_even 8\n-- True\nis_equal_to_sum_even :: Int -> Bool", "canonical_solution": "-- Task ID: HumanEval/138\n-- Assigned To: Author B\n\n-- Python Implementation:\n\n--\n-- def is_equal_to_sum_even(n):\n--     \"\"\"Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n--     Example\n--     is_equal_to_sum_even(4) == False\n--     is_equal_to_sum_even(6) == False\n--     is_equal_to_sum_even(8) == True\n--     \"\"\"\n--     return n%2 == 0 and n >= 8\n--\n\n-- Haskell Implementation:\n\n-- Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n-- Example\n-- >>> is_equal_to_sum_even 4\n-- False\n-- >>> is_equal_to_sum_even 6\n-- False\n-- >>> is_equal_to_sum_even 8\n-- True\nis_equal_to_sum_even :: Int -> Bool\nis_equal_to_sum_even n =  n `mod` 2 == 0 &&  n >= 8\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (is_equal_to_sum_even 4 == False)\n    check (is_equal_to_sum_even 6 == False)\n    check (is_equal_to_sum_even 8 == True)\n    check (is_equal_to_sum_even 10 == True)\n    check (is_equal_to_sum_even 11 == False)\n    check (is_equal_to_sum_even 12 == True)\n    check (is_equal_to_sum_even 13 == False)\n    check (is_equal_to_sum_even 16 == True)\n"}
{"task_id": "Haskell/139", "prompt": "-- The Brazilian factorial is defined as:\n-- brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n-- where n > 0\n-- For example:\n-- >>> special_factorial 4\n-- 288\n-- The function will receive an integer as input and should return the special\n-- factorial of this integer.\nspecial_factorial :: Int -> Int", "canonical_solution": "-- Task ID: HumanEval/139\n-- Assigned To: Author B\n\n-- Python Implementation:\n\n--\n-- def special_factorial(n):\n--     \"\"\"The Brazilian factorial is defined as:\n--     brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n--     where n > 0\n--\n--     For example:\n--     >>> special_factorial(4)\n--     288\n--\n--     The function will receive an integer as input and should return the special\n--     factorial of this integer.\n--     \"\"\"\n--     fact_i = 1\n--     special_fact = 1\n--     for i in range(1, n+1):\n--         fact_i *= i\n--         special_fact *= fact_i\n--     return special_fact\n--\n\n-- Haskell Implementation:\n\n-- The Brazilian factorial is defined as:\n-- brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n-- where n > 0\n--\n-- For example:\n-- >>> special_factorial 4\n-- 288\n--\n-- The function will receive an integer as input and should return the special\n-- factorial of this integer.\nspecial_factorial :: Int -> Int\nspecial_factorial n =  product [product [1 .. i] | i <-  [1 .. n]]\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (special_factorial 4 == 288)\n    check (special_factorial 5 == 34560)\n    check (special_factorial 7 == 125411328000)\n    check (special_factorial 1 == 1)\n"}
{"task_id": "Haskell/140", "prompt": "-- Given a string text, replace all spaces in it with underscores,\n-- and if a string has more than 2 consecutive spaces,\n-- then replace all consecutive spaces with -\n-- >>> fix_spaces \"Example\"\n-- \"Example\"\n-- >>> fix_spaces \" Example 2\"\n-- \"_Example_2\"\n-- >>> fix_spaces \" Example 2\"\n-- \"_Example_2\"\n-- >>> fix_spaces \" Example   3\"\n-- \"_Example-3\"\nfix_spaces :: String -> String", "canonical_solution": "-- Task ID: HumanEval/140\n-- Assigned To: Author B\n\n-- Python Implementation:\n\n--\n-- def fix_spaces(text):\n--     \"\"\"\n--     Given a string text, replace all spaces in it with underscores,\n--     and if a string has more than 2 consecutive spaces,\n--     then replace all consecutive spaces with -\n--\n--     fix_spaces(\"Example\") == \"Example\"\n--     fix_spaces(\"Example 1\") == \"Example_1\"\n--     fix_spaces(\" Example 2\") == \"_Example_2\"\n--     fix_spaces(\" Example   3\") == \"_Example-3\"\n--     \"\"\"\n--     new_text = \"\"\n--     i = 0\n--     start, end = 0, 0\n--     while i < len(text):\n--         if text[i] == \" \":\n--             end += 1\n--         else:\n--             if end - start > 2:\n--                 new_text += \"-\"+text[i]\n--             elif end - start > 0:\n--                 new_text += \"_\"*(end - start)+text[i]\n--             else:\n--                 new_text += text[i]\n--             start, end = i+1, i+1\n--         i+=1\n--     if end - start > 2:\n--         new_text += \"-\"\n--     elif end - start > 0:\n--         new_text += \"_\"\n--     return new_text\n--\n\n-- Haskell Implementation:\n\n-- Given a string text, replace all spaces in it with underscores,\n-- and if a string has more than 2 consecutive spaces,\n-- then replace all consecutive spaces with -\n--\n-- >>> fix_spaces \"Example\"\n-- \"Example\"\n-- >>> fix_spaces \" Example 2\"\n-- \"_Example_2\"\n-- >>> fix_spaces \" Example 2\"\n-- \"_Example_2\"\n-- >>> fix_spaces \" Example   3\"\n-- \"_Example-3\"\nfix_spaces :: String -> String\nfix_spaces [] =  []\nfix_spaces string = fix_spaces' string 0 \"\"\n  where\n    fix_spaces' :: String -> Int -> String -> String\n    fix_spaces' (x : xs) count res\n      | xs == [] && count == 0 && x == ' ' =  res ++ \"_\"\n      | xs == [] && count > 0 && x == ' ' =  res ++ \"-\"\n      | xs == [] && count == 0 && x /= ' ' =  res ++ [x]\n      | xs == [] && count == 1 && x /= ' ' =  res ++ \"_\" ++ [x]\n      | xs == [] && count > 1 && x /= ' ' =  res ++ \"-\" ++ [x]\n      | x == ' ' =  fix_spaces' xs (count + 1) res\n      | x /= ' ' && count > 1 =  fix_spaces' xs 0 (res ++ \"-\" ++ [x])\n      | x /= ' ' && count == 1 =  fix_spaces' xs 0 (res ++ \"_\" ++ [x])\n      | otherwise =  fix_spaces' xs 0 (res ++ [x])\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (fix_spaces \"Example\" == \"Example\")\n    check (fix_spaces \"Mudasir Hanif \" == \"Mudasir_Hanif_\")\n    check (fix_spaces \"Yellow Yellow  Dirty  Fellow\" == \"Yellow_Yellow__Dirty__Fellow\")\n    check (fix_spaces \"Exa   mple\" == \"Exa-mple\")\n    check (fix_spaces \"   Exa 1 2 2 mple\" == \"-Exa_1_2_2_mple\")\n"}
{"task_id": "Haskell/141", "prompt": "-- Create a function which takes a string representing a file's name, and returns\n-- 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n-- A file's name is considered to be valid if and only if all the following conditions are met:\n-- - There should not be more than three digits ('0'-'9') in the file's name.\n-- - The file's name contains exactly one dot '.'\n-- - The substring before the dot should not be empty, and it starts with a letter from the latin alphapet ('a'-'z' and 'A'-'Z').\n-- - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n-- Examples:\n-- >>> file_name_check \"example.txt\"\n-- \"Yes\"\n-- >>> file_name_check \"1example.dll\"\n-- \"No\" (the name should start with a latin alphapet letter\nfile_name_check :: String -> String", "canonical_solution": "-- Task ID: HumanEval/141\n-- Assigned To: Author B\n\n-- Python Implementation:\n\n--\n-- def file_name_check(file_name):\n--     \"\"\"Create a function which takes a string representing a file's name, and returns\n--     'Yes' if the the file's name is valid, and returns 'No' otherwise.\n--     A file's name is considered to be valid if and only if all the following conditions\n--     are met:\n--     - There should not be more than three digits ('0'-'9') in the file's name.\n--     - The file's name contains exactly one dot '.'\n--     - The substring before the dot should not be empty, and it starts with a letter from\n--     the latin alphapet ('a'-'z' and 'A'-'Z').\n--     - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n--     Examples:\n--     file_name_check(\"example.txt\") # => 'Yes'\n--     file_name_check(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n--     \"\"\"\n--     suf = ['txt', 'exe', 'dll']\n--     lst = file_name.split(sep='.')\n--     if len(lst) != 2:\n--         return 'No'\n--     if not lst[1] in suf:\n--         return 'No'\n--     if len(lst[0]) == 0:\n--         return 'No'\n--     if not lst[0][0].isalpha():\n--         return 'No'\n--     t = len([x for x in lst[0] if x.isdigit()])\n--     if t > 3:\n--         return 'No'\n--     return 'Yes'\n--\n\n-- Haskell Implementation:\n\n-- Create a function which takes a string representing a file's name, and returns\n-- 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n-- A file's name is considered to be valid if and only if all the following conditions are met:\n-- - There should not be more than three digits ('0'-'9') in the file's name.\n-- - The file's name contains exactly one dot '.'\n-- - The substring before the dot should not be empty, and it starts with a letter from the latin alphapet ('a'-'z' and 'A'-'Z').\n-- - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n-- Examples:\n-- >>> file_name_check \"example.txt\"\n-- \"Yes\"\n-- >>> file_name_check \"1example.dll\"\n-- \"No\" (the name should start with a latin alphapet letter\nfile_name_check :: String -> String\nfile_name_check filename\n  | (length filename) < 5 = \"No\"\n  | otherwise =  if containsOneDot filename && containsNoMoreThanThreeDigits filename && endsOnTxtExeOrDll filename && doesNotStartWithDot filename && startWithLetterFromLatinAlphabet filename then  \"Yes\" else \"No\"\n  where\n    containsOneDot :: String -> Bool\n    containsOneDot filename =  length (filter (== '.') filename) == 1\n    containsNoMoreThanThreeDigits filename =  length (filter (\\x -> x `elem` ['0' .. '9']) filename) <= 3\n    endsOnTxtExeOrDll filename =  (drop (length filename - 4) filename) `elem` [\".txt\", \".exe\", \".dll\"]\n    doesNotStartWithDot filename =  head filename /= '.'\n    startWithLetterFromLatinAlphabet filename =  head filename `elem` ['a' .. 'z'] ||  head filename `elem` ['A' .. 'Z']\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (file_name_check \"example.txt\" == \"Yes\")\n    check (file_name_check \"1example.dll\" == \"No\")\n    check (file_name_check \"s1sdf3.asd\" == \"No\")\n    check (file_name_check \"K.dll\" == \"Yes\")\n    check (file_name_check \"MY16FILE3.exe\" == \"Yes\")\n    check (file_name_check \"His12FILE94.exe\" == \"No\")\n    check (file_name_check \"_Y.txt\" == \"No\")\n    check (file_name_check \"?aREYA.exe\" == \"No\")\n    check (file_name_check \"/this_is_valid.dll\" == \"No\")\n    check (file_name_check \"this_is_valid.wow\" == \"No\")\n    check (file_name_check \"this_is_valid.txt\" == \"Yes\")\n    check (file_name_check \"this_is_valid.txtexe\" == \"No\")\n    check (file_name_check \"#this2_i4s_5valid.ten\" == \"No\")\n    check (file_name_check \"@this1_is6_valid.exe\" == \"No\")\n    check (file_name_check \"this_is_12valid.6exe4.txt\" == \"No\")\n    check (file_name_check \"all.exe.txt\" == \"No\")\n    check (file_name_check \"I563_No.exe\" == \"Yes\")\n    check (file_name_check \"Is3youfault.txt\" == \"Yes\")\n    check (file_name_check \"no_one#knows.dll\" == \"Yes\")\n    check (file_name_check \"1I563_Yes3.exe\" == \"No\")\n    check (file_name_check \"I563_Yes3.txtt\" == \"No\")\n    check (file_name_check \"final..txt\" == \"No\")\n    check (file_name_check \"final132\" == \"No\")\n    check (file_name_check \".txt\" == \"No\")\n    check (file_name_check \"s.\" == \"No\")\n"}
{"task_id": "Haskell/142", "prompt": "-- This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a\n-- multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not\n-- change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\n-- Examples:\n-- >>> sum_squares [1,2,3]\n-- 6\n-- >>> sum_squares []\n-- 0\n-- >>> sum_squares [-1,-5,2,-1,-5]\n-- -126\nsum_squares :: [Int] -> Int", "canonical_solution": "-- Task ID: HumanEval/142\n-- Assigned To: Author B\n\n-- Python Implementation:\n\n--\n--\n--\n-- def sum_squares(lst):\n--     \"\"\"\"\n--     This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a\n--     multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not\n--     change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\n--\n--     Examples:\n--     For lst = [1,2,3] the output should be 6\n--     For lst = []  the output should be 0\n--     For lst = [-1,-5,2,-1,-5]  the output should be -126\n--     \"\"\"\n--     result =[]\n--     for i in range(len(lst)):\n--         if i %3 == 0:\n--             result.append(lst[i]**2)\n--         elif i % 4 == 0 and i%3 != 0:\n--             result.append(lst[i]**3)\n--         else:\n--             result.append(lst[i])\n--     return sum(result)\n--\n\n-- Haskell Implementation:\n\n-- This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a\n-- multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not\n-- change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\n--\n-- Examples:\n-- >>> sum_squares [1,2,3]\n-- 6\n-- >>> sum_squares []\n-- 0\n-- >>> sum_squares [-1,-5,2,-1,-5]\n-- -126\nsum_squares :: [Int] -> Int\nsum_squares lst =  sum_squares' lst 0 0\n  where\n    sum_squares' :: [Int] -> Int -> Int -> Int\n    sum_squares' [] sum _ =  sum\n    sum_squares' (x : xs) sum index\n      | index `mod` 3 == 0 =  sum_squares' xs (sum + x ^ 2) (index + 1)\n      | index `mod` 4 == 0 =  sum_squares' xs (sum + x ^ 3) (index + 1)\n      | otherwise =  sum_squares' xs (sum + x) (index + 1)\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (sum_squares [1, 2, 3] == 6)\n    check (sum_squares [1, 4, 9] == 14)\n    check (sum_squares [] == 0)\n    check (sum_squares [1, 1, 1, 1, 1, 1, 1, 1, 1] == 9)\n    check (sum_squares [-1, -1, -1, -1, -1, -1, -1, -1, -1] == -3)\n    check (sum_squares [0] == 0)\n    check (sum_squares [-1, -5, 2, -1, -5] == -126)\n    check (sum_squares [-56, -99, 1, 0, -2] == 3030)\n    check (sum_squares [-1, 0, 0, 0, 0, 0, 0, 0, -1] == 0)\n    check (sum_squares [-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37] == -14196)\n    check (sum_squares [-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10] == -1448)\n"}
{"task_id": "Haskell/143", "prompt": "-- You are given a string representing a sentence,\n-- the sentence contains some words separated by a space,\n-- and you have to return a string that contains the words from the original sentence,\n-- whose lengths are prime numbers,\n-- the order of the words in the new string should be the same as the original one.\n-- Example 1:\n-- >>> words_in_sentence \"This is a test\"\n-- \"is\"\n-- Example 2:\n-- >>> words_in_sentence \"lets go for swimming\"\n-- \"go for\"\n-- Constraints:\n-- * 1 <= len(sentence) <= 100\n-- * sentence contains only letters\nwords_in_sentence :: String -> String", "canonical_solution": "-- Task ID: HumanEval/143\n-- Assigned To: Author B\n\n-- Python Implementation:\n\n--\n-- def words_in_sentence(sentence):\n--     \"\"\"\n--     You are given a string representing a sentence,\n--     the sentence contains some words separated by a space,\n--     and you have to return a string that contains the words from the original sentence,\n--     whose lengths are prime numbers,\n--     the order of the words in the new string should be the same as the original one.\n--\n--     Example 1:\n--         Input: sentence = \"This is a test\"\n--         Output: \"is\"\n--\n--     Example 2:\n--         Input: sentence = \"lets go for swimming\"\n--         Output: \"go for\"\n--\n--     Constraints:\n--         * 1 <= len(sentence) <= 100\n--         * sentence contains only letters\n--     \"\"\"\n--     new_lst = []\n--     for word in sentence.split():\n--         flg = 0\n--         if len(word) == 1:\n--             flg = 1\n--         for i in range(2, len(word)):\n--             if len(word)%i == 0:\n--                 flg = 1\n--         if flg == 0 or len(word) == 2:\n--             new_lst.append(word)\n--     return \" \".join(new_lst)\n--\n\n-- Haskell Implementation:\n\n-- You are given a string representing a sentence,\n-- the sentence contains some words separated by a space,\n-- and you have to return a string that contains the words from the original sentence,\n-- whose lengths are prime numbers,\n-- the order of the words in the new string should be the same as the original one.\n--\n-- Example 1:\n-- >>> words_in_sentence \"This is a test\"\n-- \"is\"\n--\n-- Example 2:\n-- >>> words_in_sentence \"lets go for swimming\"\n-- \"go for\"\n--\n-- Constraints:\n\n-- * 1 <= len(sentence) <= 100\n\n-- * sentence contains only letters\n\nwords_in_sentence :: String -> String\nwords_in_sentence sentence =  unwords $  filter (\\x ->  is_prime (length x)) (words sentence)\n  where\n    is_prime :: Int -> Bool\n    is_prime n =  n > 1 &&  all (\\x -> n `mod` x /= 0) [2 .. n - 1]\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (words_in_sentence \"This is a test\" == \"is\")\n    check (words_in_sentence \"lets go for swimming\" == \"go for\")\n    check (words_in_sentence \"there is no place available here\" == \"there is no place\")\n    check (words_in_sentence \"Hi I am Hussein\" == \"Hi am Hussein\")\n    check (words_in_sentence \"go for it\" == \"go for it\")\n    check (words_in_sentence \"here\" == \"\")\n    check (words_in_sentence \"here is\" == \"is\")\n"}
{"task_id": "Haskell/144", "prompt": "-- Your task is to implement a function that will simplify the expression\n-- x * n. The function returns True if x * n evaluates to a whole number and False\n-- otherwise. Both x and n, are string representation of a fraction, and have the following format,\n-- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n-- You can assume that x, and n are valid fractions, and do not have zero as denominator.\n-- >>> simplify \"1/5\" \"5/1\"\n-- True\n-- >>> simplify \"1/6\" \"2/1\"\n-- False\n-- >>> simplify \"7/10\" \"10/2\"\n-- False\nsimplify :: String -> String -> Bool", "canonical_solution": "-- Task ID: HumanEval/144\n-- Assigned To: Author B\n\n-- Python Implementation:\n\n--\n-- def simplify(x, n):\n--     \"\"\"Your task is to implement a function that will simplify the expression\n--     x * n. The function returns True if x * n evaluates to a whole number and False\n--     otherwise. Both x and n, are string representation of a fraction, and have the following format,\n--     <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n--\n--     You can assume that x, and n are valid fractions, and do not have zero as denominator.\n--\n--     simplify(\"1/5\", \"5/1\") = True\n--     simplify(\"1/6\", \"2/1\") = False\n--     simplify(\"7/10\", \"10/2\") = False\n--     \"\"\"\n--     a, b = x.split(\"/\")\n--     c, d = n.split(\"/\")\n--     numerator = int(a) * int(c)\n--     denom = int(b) * int(d)\n--     if (numerator/denom == int(numerator/denom)):\n--         return True\n--     return False\n--\n\n-- Haskell Implementation:\n\n-- Your task is to implement a function that will simplify the expression\n-- x * n. The function returns True if x * n evaluates to a whole number and False\n-- otherwise. Both x and n, are string representation of a fraction, and have the following format,\n-- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n--\n-- You can assume that x, and n are valid fractions, and do not have zero as denominator.\n--\n-- >>> simplify \"1/5\" \"5/1\"\n-- True\n-- >>> simplify \"1/6\" \"2/1\"\n-- False\n-- >>> simplify \"7/10\" \"10/2\"\n-- False\n\nimport Data.List\nimport Data.Maybe\n\nsimplify :: String -> String -> Bool\nsimplify x n =  numerator / denominator ==  fromIntegral (round (numerator / denominator))\n  where\n    a, b, c, d :: Double\n    a =  read (take (fromJust (elemIndex '/' x)) x)\n    b =  read (drop (fromJust (elemIndex '/' x) + 1) x)\n    c =  read (take (fromJust (elemIndex '/' n)) n)\n    d =  read (drop (fromJust (elemIndex '/' n) + 1) n)\n    numerator, denominator :: Double\n    numerator =  a * c\n    denominator =  b * d\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (simplify \"1/5\" \"5/1\" == True)\n    check (simplify \"1/6\" \"2/1\" == False)\n    check (simplify \"5/1\" \"3/1\" == True)\n    check (simplify \"7/10\" \"10/2\" == False)\n    check (simplify \"2/10\" \"50/10\" == True)\n    check (simplify \"7/2\" \"4/2\" == True)\n    check (simplify \"11/6\" \"6/1\" == True)\n    check (simplify \"2/3\" \"5/2\" == False)\n    check (simplify \"5/2\" \"3/5\" == False)\n    check (simplify \"2/4\" \"8/4\" == True)\n    check (simplify \"2/4\" \"4/2\" == True)\n    check (simplify \"1/5\" \"5/1\" == True)\n    check (simplify \"1/5\" \"1/5\" == False)\n"}
{"task_id": "Haskell/145", "prompt": "-- Write a function which sorts the given list of integers\n-- in ascending order according to the sum of their digits.\n-- Note: if there are several items with similar sum of their digits,\n-- order them based on their index in original list.\n-- For example:\n-- >>> order_by_points [1, 11, -1, -11, -12]\n-- [-1, -11, 1, -12, 11]\n-- >>> order_by_points []\n-- []\n-- Remember that if the number is negative, you need to not parse the first '-' and multiply the first number of the sum by -1\norder_by_points :: [Int] -> [Int]", "canonical_solution": "-- Task ID: HumanEval/145\n-- Assigned To: Author B\n\n-- Python Implementation:\n\n--\n-- def order_by_points(nums):\n--     \"\"\"\n--     Write a function which sorts the given list of integers\n--     in ascending order according to the sum of their digits.\n--     Note: if there are several items with similar sum of their digits,\n--     order them based on their index in original list.\n--\n--     For example:\n--     >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n--     >>> order_by_points([]) == []\n--     \"\"\"\n--     def digits_sum(n):\n--         neg = 1\n--         if n < 0: n, neg = -1 * n, -1\n--         n = [int(i) for i in str(n)]\n--         n[0] = n[0] * neg\n--         return sum(n)\n--     return sorted(nums, key=digits_sum)\n--\n\n-- Haskell Implementation:\n\n-- Write a function which sorts the given list of integers\n-- in ascending order according to the sum of their digits.\n-- Note: if there are several items with similar sum of their digits,\n-- order them based on their index in original list.\n--\n-- For example:\n-- >>> order_by_points [1, 11, -1, -11, -12]\n-- [-1, -11, 1, -12, 11]\n-- >>> order_by_points []\n-- []\nimport Data.List (sortBy)\n\n-- Remember that if the number is negative, you need to not parse the first '-' and multiply the first number of the sum by -1\norder_by_points :: [Int] -> [Int]\norder_by_points nums =  sortBy (\\x y ->  compare (digits_sum x) (digits_sum y)) nums\n\ndigits_sum :: Int -> Int\ndigits_sum n\n  | n < 0 =  sum $ ((read [(show n) !! 1] :: Int) * (-1)) : map (\\x ->  read [x] :: Int) (drop 2 (show n))\n  | otherwise =  sum $ map (\\x ->  read [x] :: Int) (show n)\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (order_by_points [1, 11, -1, -11, -12] == [-1, -11, 1, -12, 11])\n    check (order_by_points [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46] == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\n    check (order_by_points [] == [])\n    check (order_by_points [1, -11, -32, 43, 54, -98, 2, -3] == [-3, -32, -98, -11, 1, 2, 43, 54])\n    check (order_by_points [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n    check (order_by_points [0, 6, 6, -76, -21, 23, 4] == [-76, -21, 0, 4, 23, 6, 6])\n    check (True == True)\n"}
{"task_id": "Haskell/146", "prompt": "-- Write a function that takes an array of numbers as input and returns\n-- the number of elements in the array that are greater than 10 and both\n-- first and last digits of a number are odd (1, 3, 5, 7, 9).\n-- For example:\n-- >>> specialFilter [15, -73, 14, -15]\n-- 1\n-- >>> specialFilter [33, -2, -3, 45, 21, 109]\n-- 2\nspecialFilter :: [Int] -> Int", "canonical_solution": "-- Task ID: HumanEval/146\n-- Assigned To: Author B\n\n-- Python Implementation:\n\n--\n-- def specialFilter(nums):\n--     \"\"\"Write a function that takes an array of numbers as input and returns\n--     the number of elements in the array that are greater than 10 and both\n--     first and last digits of a number are odd (1, 3, 5, 7, 9).\n--     For example:\n--     specialFilter([15, -73, 14, -15]) => 1\n--     specialFilter([33, -2, -3, 45, 21, 109]) => 2\n--     \"\"\"\n--\n--     count = 0\n--     for num in nums:\n--         if num > 10:\n--             odd_digits = (1, 3, 5, 7, 9)\n--             number_as_string = str(num)\n--             if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n--                 count += 1\n--\n--     return count\n--\n\n-- Haskell Implementation:\n\n-- Write a function that takes an array of numbers as input and returns\n-- the number of elements in the array that are greater than 10 and both\n-- first and last digits of a number are odd (1, 3, 5, 7, 9).\n-- For example:\n-- >>> specialFilter [15, -73, 14, -15]\n-- 1\n-- >>> specialFilter [33, -2, -3, 45, 21, 109]\n-- 2\nimport Data.List\n\nspecialFilter :: [Int] -> Int\nspecialFilter nums =  length $ filter greaterThanTenAndOddBorders nums\n  where\n    greaterThanTenAndOddBorders :: Int -> Bool\n    greaterThanTenAndOddBorders n =  n > 10 && odd (read [head (show n)] :: Int) &&  odd (read [show n !! (length (show n) - 1)] :: Int)\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (specialFilter [5, -2, 1, -5] == 0)\n    check (specialFilter [15, -73, 14, -15] == 1)\n    check (specialFilter [33, -2, -3, 45, 21, 109] == 2)\n    check (specialFilter [43, -12, 93, 125, 121, 109] == 4)\n    check (specialFilter [71, -2, -33, 75, 21, 19] == 3)\n    check (specialFilter [1] == 0)\n    check (specialFilter [] == 0)\n"}
{"task_id": "Haskell/147", "prompt": "-- You are given a positive integer n. You have to create an integer array a of length n.\n--     For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n--     Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,\n-- and a[i] + a[j] + a[k] is a multiple of 3.\n-- Example :\n-- >>> get_max_triples 5\n-- 1\n-- Explanation:\n-- a = [1, 3, 7, 13, 21]\n-- The only valid triple is (1, 7, 13).\nget_max_triples :: Int -> Int", "canonical_solution": "-- Task ID: HumanEval/147\n-- Assigned To: Author B\n\n-- Python Implementation:\n\n--\n-- def get_max_triples(n):\n--     \"\"\"\n--     You are given a positive integer n. You have to create an integer array a of length n.\n--         For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n--         Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,\n--     and a[i] + a[j] + a[k] is a multiple of 3.\n--\n--     Example :\n--         Input: n = 5\n--         Output: 1\n--         Explanation:\n--         a = [1, 3, 7, 13, 21]\n--         The only valid triple is (1, 7, 13).\n--     \"\"\"\n--     A = [i*i - i + 1 for i in range(1,n+1)]\n--     ans = []\n--     for i in range(n):\n--         for j in range(i+1,n):\n--             for k in range(j+1,n):\n--                 if (A[i]+A[j]+A[k])%3 == 0:\n--                     ans += [(A[i],A[j],A[k])]\n--     return len(ans)\n--\n\n-- Haskell Implementation:\n\n-- You are given a positive integer n. You have to create an integer array a of length n.\n--     For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n--     Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,\n-- and a[i] + a[j] + a[k] is a multiple of 3.\n--\n-- Example :\n-- >>> get_max_triples 5\n-- 1\n-- Explanation:\n-- a = [1, 3, 7, 13, 21]\n-- The only valid triple is (1, 7, 13).\nget_max_triples :: Int -> Int\nget_max_triples n =  length $ filter (\\(x, y, z) -> (x + y + z) `mod` 3 == 0) [(a !! i, a !! j, a !! k) | i <-  [0 .. n - 1], j <-  [i + 1 .. n - 1], k <-  [j + 1 .. n - 1]]\n  where\n    a :: [Int]\n    a =  [i * i - i + 1 |  i <- [1 .. n]]\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (get_max_triples 5 == 1)\n    check (get_max_triples 6 == 4)\n    check (get_max_triples 10 == 36)\n    check (get_max_triples 100 == 53361)\n"}
{"task_id": "Haskell/148", "prompt": "-- There are eight planets in our solar system: the closest to the Sun\n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n-- Uranus, Neptune.\n-- Write a function that takes two planet names as strings planet1 and planet2.\n-- The function should return a tuple containing all planets whose orbits are\n-- located between the orbit of planet1 and the orbit of planet2, sorted by\n-- the proximity to the sun.\n-- The function should return an empty tuple if planet1 or planet2\n-- are not correct planet names.\n-- Examples\n-- >>> bf \"Jupiter\" \"Neptune\"\n-- [\"Saturn\", \"Uranus\"]\n-- >>> bf \"Earth\" \"Mercury\"\n-- [\"Venus\"]\n-- >>> bf \"Mercury\" \"Uranus\"\n-- [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"]\nbf :: String -> String -> [String]", "canonical_solution": "-- Task ID: HumanEval/148\n-- Assigned To: Author B\n\n-- Python Implementation:\n\n--\n-- def bf(planet1, planet2):\n--     '''\n--     There are eight planets in our solar system: the closest to the Sun\n--     is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n--     Uranus, Neptune.\n--     Write a function that takes two planet names as strings planet1 and planet2.\n--     The function should return a tuple containing all planets whose orbits are\n--     located between the orbit of planet1 and the orbit of planet2, sorted by\n--     the proximity to the sun.\n--     The function should return an empty tuple if planet1 or planet2\n--     are not correct planet names.\n--     Examples\n--     bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n--     bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n--     bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n--     '''\n--     planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n--     if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n--         return ()\n--     planet1_index = planet_names.index(planet1)\n--     planet2_index = planet_names.index(planet2)\n--     if planet1_index < planet2_index:\n--         return (planet_names[planet1_index + 1: planet2_index])\n--     else:\n--         return (planet_names[planet2_index + 1 : planet1_index])\n--\n\n-- Haskell Implementation:\n\n-- There are eight planets in our solar system: the closest to the Sun\n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n-- Uranus, Neptune.\n-- Write a function that takes two planet names as strings planet1 and planet2.\n-- The function should return a tuple containing all planets whose orbits are\n-- located between the orbit of planet1 and the orbit of planet2, sorted by\n-- the proximity to the sun.\n-- The function should return an empty tuple if planet1 or planet2\n-- are not correct planet names.\n-- Examples\n-- >>> bf \"Jupiter\" \"Neptune\"\n-- [\"Saturn\", \"Uranus\"]\n-- >>> bf \"Earth\" \"Mercury\"\n-- [\"Venus\"]\n-- >>> bf \"Mercury\" \"Uranus\"\n-- [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"]\nbf :: String -> String -> [String]\nbf planet1 planet2 =\n  if planet1 `elem` planet_names && planet2 `elem` planet_names &&  planet1 /= planet2\n    then\n      if planet1_index < planet2_index\n        then  take (planet2_index - planet1_index - 1) (drop (planet1_index + 1) planet_names)\n        else  take (planet1_index - planet2_index - 1) (drop (planet2_index + 1) planet_names)\n    else  []\n  where\n    planet_names :: [String]\n    planet_names =  [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    planet1_index :: Int\n    planet1_index =  head [i | (i, x) <-  zip [0 ..] planet_names, x == planet1]\n    planet2_index :: Int\n    planet2_index =  head [i | (i, x) <-  zip [0 ..] planet_names, x == planet2]\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (bf \"Jupiter\" \"Neptune\" == [\"Saturn\", \"Uranus\"])\n    check (bf \"Earth\" \"Mercury\" == [\"Venus\"])\n    check (bf \"Mercury\" \"Uranus\" == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n    check (bf \"Neptune\" \"Venus\" == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n    check (bf \"Earth\" \"Earth\" == [])\n    check (bf \"Mars\" \"Earth\" == [])\n    check (bf \"Jupiter\" \"Makemake\" == [])\n"}
{"task_id": "Haskell/149", "prompt": "-- Write a function that accepts a list of strings as a parameter,\n-- deletes the strings that have odd lengths from it,\n-- and returns the resulted list with a sorted order,\n-- The list is always a list of strings and never an array of numbers,\n-- and it may contain duplicates.\n-- The order of the list should be ascending by length of each word, and you\n-- should return the list sorted by that rule.\n-- If two words have the same length, sort the list alphabetically.\n-- The function should return a list of strings in sorted order.\n-- You may assume that all words will have the same length.\n-- For example:\n-- >>> sorted_list_sum [\"aa\", \"a\", \"aaa\"]\n-- [\"aa\"]\n-- >>> sorted_list_sum [\"ab\", \"a\", \"aaa\", \"cd\"]\n-- [\"ab\", \"cd\"]\nsorted_list_sum :: [String] -> [String]", "canonical_solution": "-- Task ID: HumanEval/149\n-- Assigned To: Author B\n\n-- Python Implementation:\n\n--\n-- def sorted_list_sum(lst):\n--     \"\"\"Write a function that accepts a list of strings as a parameter,\n--     deletes the strings that have odd lengths from it,\n--     and returns the resulted list with a sorted order,\n--     The list is always a list of strings and never an array of numbers,\n--     and it may contain duplicates.\n--     The order of the list should be ascending by length of each word, and you\n--     should return the list sorted by that rule.\n--     If two words have the same length, sort the list alphabetically.\n--     The function should return a list of strings in sorted order.\n--     You may assume that all words will have the same length.\n--     For example:\n--     assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n--     assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n--     \"\"\"\n--     lst.sort()\n--     new_lst = []\n--     for i in lst:\n--         if len(i)%2 == 0:\n--             new_lst.append(i)\n--     return sorted(new_lst, key=len)\n--\n\n-- Haskell Implementation:\n\n-- Write a function that accepts a list of strings as a parameter,\n-- deletes the strings that have odd lengths from it,\n-- and returns the resulted list with a sorted order,\n-- The list is always a list of strings and never an array of numbers,\n-- and it may contain duplicates.\n-- The order of the list should be ascending by length of each word, and you\n-- should return the list sorted by that rule.\n-- If two words have the same length, sort the list alphabetically.\n-- The function should return a list of strings in sorted order.\n-- You may assume that all words will have the same length.\n-- For example:\n-- >>> sorted_list_sum [\"aa\", \"a\", \"aaa\"]\n-- [\"aa\"]\n-- >>> sorted_list_sum [\"ab\", \"a\", \"aaa\", \"cd\"]\n-- [\"ab\", \"cd\"]\nimport Data.List (sort)\n\nsorted_list_sum :: [String] -> [String]\nsorted_list_sum lst =  sort $ filter  (\\x -> length x `mod` 2 == 0) lst\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (sorted_list_sum [\"aa\", \"a\", \"aaa\"] == [\"aa\"])\n    check (sorted_list_sum [\"school\", \"AI\", \"asdf\", \"b\"] == [\"AI\", \"asdf\", \"school\"])\n    check (sorted_list_sum [\"d\", \"b\", \"c\", \"a\"] == [])\n    check (sorted_list_sum [\"d\", \"dcba\", \"abcd\", \"a\"] == [\"abcd\", \"dcba\"])\n    check (sorted_list_sum [\"AI\", \"ai\", \"au\"] == [\"AI\", \"ai\", \"au\"])\n    check (sorted_list_sum [\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"] == [])\n    check (sorted_list_sum [\"aaaa\", \"bbbb\", \"dd\", \"cc\"] == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"])\n"}
{"task_id": "Haskell/150", "prompt": "-- A simple program which should return the value of x if n is\n-- a prime number and should return the value of y otherwise.\n-- Examples:\n-- >>> x_or_y 7 34 12\n-- 34\n-- >>> x_or_y 15 8 5\n-- 5\nx_or_y :: Int -> Int -> Int -> Int", "canonical_solution": "-- Task ID: HumanEval/150\n-- Assigned To: Author B\n\n-- Python Implementation:\n\n--\n-- def x_or_y(n, x, y):\n--     \"\"\"A simple program which should return the value of x if n is\n--     a prime number and should return the value of y otherwise.\n--\n--     Examples:\n--     for x_or_y(7, 34, 12) == 34\n--     for x_or_y(15, 8, 5) == 5\n--\n--     \"\"\"\n--     if n == 1:\n--         return y\n--     for i in range(2, n):\n--         if n % i == 0:\n--             return y\n--             break\n--     else:\n--         return x\n--\n\n-- Haskell Implementation:\n\n-- A simple program which should return the value of x if n is\n-- a prime number and should return the value of y otherwise.\n--\n-- Examples:\n-- >>> x_or_y 7 34 12\n-- 34\n-- >>> x_or_y 15 8 5\n-- 5\nx_or_y :: Int -> Int -> Int -> Int\nx_or_y n x y =  if n == 1 then y else if length [i |  i <- [2 .. n - 1], n `mod` i == 0] > 0 then  y else x\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (x_or_y 7 34 12 == 34)\n    check (x_or_y 15 8 5 == 5)\n    check (x_or_y 3 33 5212 == 33)\n    check (x_or_y 1259 3 52 == 3)\n    check (x_or_y 7919 (-1) 12 == -1)\n    check (x_or_y 3609 1245 583 == 583)\n    check (x_or_y 91 56 129 == 129)\n    check (x_or_y 6 34 1234 == 1234)\n    check (x_or_y 1 2 0 == 0)\n    check (x_or_y 2 2 0 == 2)"}
{"task_id": "Haskell/151", "prompt": "-- Given a list of numbers, return the sum of squares of the numbers\n-- in the list that are odd. Ignore numbers that are negative or not integers.\n-- >>> double_the_difference [1, 3, 2, 0]\n-- 10 (1 + 9 + 0 + 0)\n-- >>> double_the_difference [-1, -2, 0]\n-- 0\n-- >>> double_the_difference [9, -2]\n-- 81\n-- >>> double_the_difference [0]\n-- 0\n-- If the input list is empty, return 0.\ndouble_the_difference :: [Int] -> Int", "canonical_solution": "-- Task ID: HumanEval/151\n-- Assigned To: Author B\n\n-- Python Implementation:\n\n--\n-- def double_the_difference(lst):\n--     '''\n--     Given a list of numbers, return the sum of squares of the numbers\n--     in the list that are odd. Ignore numbers that are negative or not integers.\n--\n--     double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n--     double_the_difference([-1, -2, 0]) == 0\n--     double_the_difference([9, -2]) == 81\n--     double_the_difference([0]) == 0\n--\n--     If the input list is empty, return 0.\n--     '''\n--     return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n--\n\n-- Haskell Implementation:\n\n-- Given a list of numbers, return the sum of squares of the numbers\n-- in the list that are odd. Ignore numbers that are negative or not integers.\n--\n-- >>> double_the_difference [1, 3, 2, 0]\n-- 10 (1 + 9 + 0 + 0)\n-- >>> double_the_difference [-1, -2, 0]\n-- 0\n-- >>> double_the_difference [9, -2]\n-- 81\n-- >>> double_the_difference [0]\n-- 0\n--\n-- If the input list is empty, return 0.\ndouble_the_difference :: [Int] -> Int\ndouble_the_difference lst =  sum [i ^ 2 |  i <- lst, i > 0, odd i]\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (double_the_difference [] == 0)\n    check (double_the_difference [5,4] == 25)\n    check (double_the_difference [0.1,0.2,0.3] == 0)\n    check (double_the_difference [-10,-20,-30] == 0)\n    check (double_the_difference [-1,-2,8] == 0)\n    check (double_the_difference [0.2,3,5] == 34)\n    let lst = [-99,-97 .. 99]\n        oddSum = sum [i^2 | i <- lst, odd i, i > 0]\n    check (double_the_difference lst == oddSum)"}
{"task_id": "Haskell/152", "prompt": "-- I think we all remember that feeling when the result of some long-awaited\n-- event is finally known. The feelings and thoughts you have at that moment are\n-- definitely worth noting down and comparing.\n-- Your task is to determine if a person correctly guessed the results of a number of matches.\n-- You are given two arrays of scores and guesses of equal length, where each index shows a match.\n-- Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n-- the value is 0, and if not, the value is the absolute difference between the guess and the score.\n-- example:\n-- >>> compare' [1,2,3,4,5,1] [1,2,3,4,2,-2]\n-- [0,0,0,0,3,3]\n-- >>> compare' [0,5,0,0,0,4] [4,1,1,0,0,-2]\n-- [4,4,1,0,0,6]\ncompare' :: [Int] -> [Int] -> [Int]", "canonical_solution": "-- Task ID: HumanEval/152\n-- Assigned To: Author B\n\n-- Python Implementation:\n\n--\n-- def compare(game,guess):\n--     \"\"\"I think we all remember that feeling when the result of some long-awaited\n--     event is finally known. The feelings and thoughts you have at that moment are\n--     definitely worth noting down and comparing.\n--     Your task is to determine if a person correctly guessed the results of a number of matches.\n--     You are given two arrays of scores and guesses of equal length, where each index shows a match.\n--     Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n--     the value is 0, and if not, the value is the absolute difference between the guess and the score.\n--\n--\n--     example:\n--\n--     compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n--     compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n--     \"\"\"\n--     return [abs(x-y) for x,y in zip(game,guess)]\n--\n\n-- Haskell Implementation:\n\n-- I think we all remember that feeling when the result of some long-awaited\n-- event is finally known. The feelings and thoughts you have at that moment are\n-- definitely worth noting down and comparing.\n-- Your task is to determine if a person correctly guessed the results of a number of matches.\n-- You are given two arrays of scores and guesses of equal length, where each index shows a match.\n-- Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n-- the value is 0, and if not, the value is the absolute difference between the guess and the score.\n--\n--\n-- example:\n--\n-- >>> compare' [1,2,3,4,5,1] [1,2,3,4,2,-2]\n-- [0,0,0,0,3,3]\n-- >>> compare' [0,5,0,0,0,4] [4,1,1,0,0,-2]\n-- [4,4,1,0,0,6]\ncompare' :: [Int] -> [Int] -> [Int]\ncompare' game guess =  [abs (x - y) |  (x, y) <-  zip game guess]\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (compare [1,2,3,4,5,1] [1,2,3,4,2,-2] == [0,0,0,0,3,3])\n    check (compare [0,5,0,0,0,4] [4,1,1,0,0,-2] == [4,4,1,0,0,6])\n    check (compare [1,2,3,4,5,1] [1,2,3,4,2,-2] == [0,0,0,0,3,3])\n    check (compare [0,0,0,0,0,0] [0,0,0,0,0,0] == [0,0,0,0,0,0])\n    check (compare [1,2,3] [-1,-2,-3] == [2,4,6])\n    check (compare [1,2,3,5] [-1,2,3,4] == [2,0,0,1])"}
{"task_id": "Haskell/153", "prompt": "-- You will be given the name of a class (a string) and a list of extensions.\n-- The extensions are to be used to load additional classes to the class. The\n-- strength of the extension is as follows: Let CAP be the number of the uppercase\n-- letters in the extension's name, and let SM be the number of lowercase letters\n-- in the extension's name, the strength is given by the fraction CAP - SM.\n-- You should find the strongest extension and return a string in this\n-- format: ClassName.StrongestExtensionName.\n-- If there are two or more extensions with the same strength, you should\n-- choose the one that comes first in the list.\n-- For example, if you are given \"Slices\" as the class and a list of the\n-- extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n-- return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n-- (its strength is -1).\n-- Example:\n-- >>> strongest_extension \"my_class\" [\"AA\", \"Be\", \"CC\"]\n-- \"my_class.AA\"\nstrongest_extension :: String -> [String] -> String", "canonical_solution": "-- Task ID: HumanEval/153\n-- Assigned To: Author B\n\n-- Python Implementation:\n\n--\n-- def strongest_extension(class_name, extensions):\n--     \"\"\"You will be given the name of a class (a string) and a list of extensions.\n--     The extensions are to be used to load additional classes to the class. The\n--     strength of the extension is as follows: Let CAP be the number of the uppercase\n--     letters in the extension's name, and let SM be the number of lowercase letters\n--     in the extension's name, the strength is given by the fraction CAP - SM.\n--     You should find the strongest extension and return a string in this\n--     format: ClassName.StrongestExtensionName.\n--     If there are two or more extensions with the same strength, you should\n--     choose the one that comes first in the list.\n--     For example, if you are given \"Slices\" as the class and a list of the\n--     extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n--     return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n--     (its strength is -1).\n--     Example:\n--     for strongest_extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n--     \"\"\"\n--     strong = extensions[0]\n--     my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n--     for s in extensions:\n--         val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n--         if val > my_val:\n--             strong = s\n--             my_val = val\n--\n--     ans = class_name + \".\" + strong\n--     return ans\n--\n--\n\n-- Haskell Implementation:\n\n-- You will be given the name of a class (a string) and a list of extensions.\n-- The extensions are to be used to load additional classes to the class. The\n-- strength of the extension is as follows: Let CAP be the number of the uppercase\n-- letters in the extension's name, and let SM be the number of lowercase letters\n-- in the extension's name, the strength is given by the fraction CAP - SM.\n-- You should find the strongest extension and return a string in this\n-- format: ClassName.StrongestExtensionName.\n-- If there are two or more extensions with the same strength, you should\n-- choose the one that comes first in the list.\n-- For example, if you are given \"Slices\" as the class and a list of the\n-- extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n-- return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n-- (its strength is -1).\n-- Example:\n-- >>> strongest_extension \"my_class\" [\"AA\", \"Be\", \"CC\"]\n-- \"my_class.AA\"\n\nimport Data.Char (isAlpha, isLower, isUpper)\n\nstrongest_extension :: String -> [String] -> String\nstrongest_extension class_name extensions =  class_name ++ \".\" ++ strongest\n  where\n    strongest :: String\n    strongest =  head $ filter (\\x ->  strength x == maximum (map strength extensions)) extensions\n    strength x =  length [x | x <- x, isAlpha x, isUpper x] -  length [x | x <- x, isAlpha x, isLower x]\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (Strongest_Extension \"Watashi\" [\"tEN\",\"niNE\",\"eIGHt8OKe\"] == \"Watashi.eIGHt8OKe\")\n    check (Strongest_Extension \"Boku123\" [\"nani\",\"NazeDa\",\"YEs.WeCaNe\",\"32145tggg\"] == \"Boku123.YEs.WeCaNe\")\n    check (Strongest_Extension \"**YESIMHERE\" [\"t\",\"eMptY\",\"nothing\",\"zeR00\",\"NuLl**\",\"123NoooneB321\"] == \"**YESIMHERE.NuLl**\")\n    check (Strongest_Extension \"K\" [\"Ta\",\"TAR\",\"t234An\",\"cosSo\"] == \"K.TAR\")\n    check (Strongest_Extension \"__HAHA\" [\"Tab\",\"123\",\"781345\",\"-*-\"] == \"__HAHA.123\")\n    check (Strongest_Extension \"YameRore\" [\"HhAas\",\"okIWILL123\",\"WorkOut\",\"Fails\",\"-*-\"] == \"YameRore.okIWILL123\")\n    check (Strongest_Extension \"finNNalLLly\" [\"Die\",\"NowW\",\"Wow\",\"WoW\"] == \"finNNalLLly.WoW\")\n    check (Strongest_Extension \"*\" [\"Bb\",\"91245\"] == \"*.Bb\")\n    check (Strongest_Extension \"Sp\" [\"671235\",\"Bb\"] == \"Sp.671235\")"}
{"task_id": "Haskell/154", "prompt": "-- You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word\n-- >>> cycpattern_check \"abcd\" \"abd\"\n-- False\n-- >>> cycpattern_check \"hello\" \"ell\"\n-- True\n-- >>> cycpattern_check \"whassup\" \"psus\"\n-- False\n-- >>> cycpattern_check \"abab\" \"baa\"\n-- True\n-- >>> cycpattern_check \"efef\" \"eeff\"\n-- False\n-- >>> cycpattern_check \"himenss\" \"simen\"\n-- True\ncycpattern_check :: String -> String -> Bool", "canonical_solution": "-- Task ID: HumanEval/154\n-- Assigned To: Author B\n\n-- Python Implementation:\n\n--\n-- def cycpattern_check(a, b):\n--     \"\"\"You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word\n--     cycpattern_check(\"abcd\",\"abd\") => False\n--     cycpattern_check(\"hello\",\"ell\") => True\n--     cycpattern_check(\"whassup\",\"psus\") => False\n--     cycpattern_check(\"abab\",\"baa\") => True\n--     cycpattern_check(\"efef\",\"eeff\") => False\n--     cycpattern_check(\"himenss\",\"simen\") => True\n--\n--     \"\"\"\n--     l = len(b)\n--     pat = b + b\n--     for i in range(len(a) - l + 1):\n--         for j in range(l + 1):\n--             if a[i:i+l] == pat[j:j+l]:\n--                 return True\n--     return False\n--\n\n-- Haskell Implementation:\n\n-- You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word\n-- >>> cycpattern_check \"abcd\" \"abd\"\n-- False\n-- >>> cycpattern_check \"hello\" \"ell\"\n-- True\n-- >>> cycpattern_check \"whassup\" \"psus\"\n-- False\n-- >>> cycpattern_check \"abab\" \"baa\"\n-- True\n-- >>> cycpattern_check \"efef\" \"eeff\"\n-- False\n-- >>> cycpattern_check \"himenss\" \"simen\"\n-- True\nimport Data.List\n\ncycpattern_check :: String -> String -> Bool\ncycpattern_check a b =  any (`isInfixOf` a) (createRotations b)\n  where\n    createRotations :: String -> [String]\n    createRotations str =  [drop i str ++ take i str |  i <- [0 .. length str - 1]]\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (cycpattern_check \"xyzw\" \"xyw\" == False)\n    check (cycpattern_check \"yello\" \"ell\" == True)\n    check (cycpattern_check \"whattup\" \"ptut\" == False)\n    check (cycpattern_check \"efef\" \"fee\" == True)\n    check (cycpattern_check \"abab\" \"aabb\" == False)\n    check (cycpattern_check \"winemtt\" \"tinem\" == True)"}
{"task_id": "Haskell/155", "prompt": "-- Given an integer. return a tuple that has the number of even and odd digits respectively.\n-- Example:\n-- >>> even_odd_count (-12)\n-- (1, 1)\n-- >>> even_odd_count 123\n-- (1, 2)\neven_odd_count :: Int -> (Int, Int)", "canonical_solution": "-- Task ID: HumanEval/155\n-- Assigned To: Author B\n\n-- Python Implementation:\n\n--\n-- def even_odd_count(num):\n--     \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n--\n--      Example:\n--         even_odd_count(-12) ==> (1, 1)\n--         even_odd_count(123) ==> (1, 2)\n--     \"\"\"\n--     even_count = 0\n--     odd_count = 0\n--     for i in str(abs(num)):\n--         if int(i)%2==0:\n--             even_count +=1\n--         else:\n--             odd_count +=1\n--     return (even_count, odd_count)\n--\n\n-- Haskell Implementation:\n\n-- Given an integer. return a tuple that has the number of even and odd digits respectively.\n--\n-- Example:\n-- >>> even_odd_count (-12)\n-- (1, 1)\n-- >>> even_odd_count 123\n-- (1, 2)\neven_odd_count :: Int -> (Int, Int)\neven_odd_count num =  (length [i | i <-  show (abs num), even (read [i] :: Int)], length [i | i <-  show (abs num), odd (read [i] :: Int)])\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (even_odd_count 7 == (0,1))\n    check (even_odd_count (-78) == (1,1))\n    check (even_odd_count 3452 == (2,2))\n    check (even_odd_count 346211 == (3,3))\n    check (even_odd_count (-345821) == (3,3))\n    check (even_odd_count (-2) == (1,0))\n    check (even_odd_count (-45347) == (2,3))\n    check (even_odd_count 0 == (1,0))"}
{"task_id": "Haskell/156", "prompt": "-- Given a positive integer, obtain its roman numeral equivalent as a string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n-- Examples:\n-- >>> int_to_mini_roman 19\n-- \"xix\"\n-- >>> int_to_mini_roman 152\n-- \"clii\"\n-- >>> int_to_mini_roman 426\n-- \"cdxxvi\"\nint_to_mini_roman :: Int -> String", "canonical_solution": "-- Task ID: HumanEval/156\n-- Assigned To: Author B\n\n-- Python Implementation:\n\n--\n-- def int_to_mini_roman(number):\n--     \"\"\"\n--     Given a positive integer, obtain its roman numeral equivalent as a string,\n--     and return it in lowercase.\n--     Restrictions: 1 <= num <= 1000\n--\n--     Examples:\n--     >>> int_to_mini_roman(19) == 'xix'\n--     >>> int_to_mini_roman(152) == 'clii'\n--     >>> int_to_mini_roman(426) == 'cdxxvi'\n--     \"\"\"\n--     num = [1, 4, 5, 9, 10, 40, 50, 90,\n--            100, 400, 500, 900, 1000]\n--     sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",\n--            \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"]\n--     i = 12\n--     res = ''\n--     while number:\n--         div = number // num[i]\n--         number %= num[i]\n--         while div:\n--             res += sym[i]\n--             div -= 1\n--         i -= 1\n--     return res.lower()\n--\n\n-- Haskell Implementation:\n\n-- Given a positive integer, obtain its roman numeral equivalent as a string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n--\n-- Examples:\n-- >>> int_to_mini_roman 19\n-- \"xix\"\n-- >>> int_to_mini_roman 152\n-- \"clii\"\n-- >>> int_to_mini_roman 426\n-- \"cdxxvi\"\nimport Data.Char (toLower)\n\nint_to_mini_roman :: Int -> String\nint_to_mini_roman number =  map toLower $ int_to_mini_roman' number num sym (length num - 1) \"\"\n  where\n    num :: [Int]\n    sym :: [String]\n    num =  [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n    sym =  [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"]\n    int_to_mini_roman' :: Int -> [Int] -> [String] -> Int -> String -> String\n    int_to_mini_roman' number num sym index res\n      | index < 0 =  res\n      | number == 0 =  res\n      | num !! index <= number =  int_to_mini_roman' (number - num !! index) num sym index (res ++ sym !! index)\n      | otherwise =  int_to_mini_roman' number num sym (index - 1) res\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (int_to_mini_roman 19 == \"xix\")\n    check (int_to_mini_roman 152 == \"clii\")\n    check (int_to_mini_roman 251 == \"ccli\")\n    check (int_to_mini_roman 426 == \"cdxxvi\")\n    check (int_to_mini_roman 500 == \"d\")\n    check (int_to_mini_roman 1 == \"i\")\n    check (int_to_mini_roman 4 == \"iv\")\n    check (int_to_mini_roman 43 == \"xliii\")\n    check (int_to_mini_roman 90 == \"xc\")\n    check (int_to_mini_roman 94 == \"xciv\")\n    check (int_to_mini_roman 532 == \"dxxxii\")\n    check (int_to_mini_roman 900 == \"cm\")\n    check (int_to_mini_roman 994 == \"cmxciv\")\n    check (int_to_mini_roman 1000 == \"m\")"}
{"task_id": "Haskell/157", "prompt": "-- Given the lengths of the three sides of a triangle. Return True if the three\n-- sides form a right-angled triangle, False otherwise.\n-- A right-angled triangle is a triangle in which one angle is right angle or\n-- 90 degree.\n-- Example:\n-- >>> right_angle_triangle 3 4 5\n-- True\n-- >>> right_angle_triangle 1 2 3\n-- False\nright_angle_triangle :: Int -> Int -> Int -> Bool", "canonical_solution": "-- Task ID: HumanEval/157\n-- Assigned To: Author B\n\n-- Python Implementation:\n\n--\n-- def right_angle_triangle(a, b, c):\n--     '''\n--     Given the lengths of the three sides of a triangle. Return True if the three\n--     sides form a right-angled triangle, False otherwise.\n--     A right-angled triangle is a triangle in which one angle is right angle or\n--     90 degree.\n--     Example:\n--     right_angle_triangle(3, 4, 5) == True\n--     right_angle_triangle(1, 2, 3) == False\n--     '''\n--     return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n--\n\n-- Haskell Implementation:\n\n-- Given the lengths of the three sides of a triangle. Return True if the three\n-- sides form a right-angled triangle, False otherwise.\n-- A right-angled triangle is a triangle in which one angle is right angle or\n-- 90 degree.\n-- Example:\n-- >>> right_angle_triangle 3 4 5\n-- True\n-- >>> right_angle_triangle 1 2 3\n-- False\nright_angle_triangle :: Int -> Int -> Int -> Bool\nright_angle_triangle a b c =  a * a == b * b + c * c ||  b * b == a * a + c * c ||  c * c == a * a + b * b\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (right_angle_triangle 3 4 5 == True)\n    check (right_angle_triangle 1 2 3 == False)\n    check (right_angle_triangle 10 6 8 == True)\n    check (right_angle_triangle 2 2 2 == False)\n    check (right_angle_triangle 7 24 25 == True)\n    check (right_angle_triangle 10 5 7 == False)\n    check (right_angle_triangle 5 12 13 == True)\n    check (right_angle_triangle 15 8 17 == True)\n    check (right_angle_triangle 48 55 73 == True)\n    check (right_angle_triangle 1 1 1 == False)\n    check (right_angle_triangle 2 2 10 == False)"}
{"task_id": "Haskell/158", "prompt": "-- Write a function that accepts a list of strings.\n-- The list contains different words. Return the word with maximum number\n-- of unique characters. If multiple strings have maximum number of unique\n-- characters, return the one which comes first in lexicographical order.\n-- >>> find_max [\"name\", \"of\", \"string\"]\n-- \"string\"\n-- >>> find_max [\"name\", \"enam\", \"game\"]\n-- \"enam\"\n-- >>> find_max [\"aaaaaaa\", \"bb\" ,\"cc\"]\n-- \"aaaaaaa\"\nfind_max :: [String] -> String", "canonical_solution": "-- Task ID: HumanEval/158\n-- Assigned To: Author B\n\n-- Python Implementation:\n\n--\n-- def find_max(words):\n--     \"\"\"Write a function that accepts a list of strings.\n--     The list contains different words. Return the word with maximum number\n--     of unique characters. If multiple strings have maximum number of unique\n--     characters, return the one which comes first in lexicographical order.\n--\n--     find_max([\"name\", \"of\", \"string\"]) == \"string\"\n--     find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n--     find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n--     \"\"\"\n--     return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n--\n\n-- Haskell Implementation:\n\n-- Write a function that accepts a list of strings.\n-- The list contains different words. Return the word with maximum number\n-- of unique characters. If multiple strings have maximum number of unique\n-- characters, return the one which comes first in lexicographical order.\n--\n-- >>> find_max [\"name\", \"of\", \"string\"]\n-- \"string\"\n-- >>> find_max [\"name\", \"enam\", \"game\"]\n-- \"enam\"\n-- >>> find_max [\"aaaaaaa\", \"bb\" ,\"cc\"]\n-- \"aaaaaaa\"\nimport Data.List (nub, sort)\n\nfind_max :: [String] -> String\nfind_max words\n  | words == [] =  \"\"\n  | otherwise =  head $ filter (\\x ->  (length . nub) x == maximum (map  (length . nub) words)) $  sort words\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (find_max [\"name\",\"of\",\"string\"] == \"string\")\n    check (find_max [\"name\",\"enam\",\"game\"] == \"enam\")\n    check (find_max [\"aaaaaaa\",\"bb\",\"cc\"] == \"aaaaaaa\")\n    check (find_max [\"abc\",\"cba\"] == \"abc\")\n    check (find_max [\"play\",\"this\",\"game\",\"of\",\"footbott\"] == \"footbott\")\n    check (find_max [\"we\",\"are\",\"gonna\",\"rock\"] == \"gonna\")\n    check (find_max [\"we\",\"are\",\"a\",\"mad\",\"nation\"] == \"nation\")\n    check (find_max [\"this\",\"is\",\"a\",\"prrk\"] == \"this\")\n    check (find_max [\"b\"] == \"b\")\n    check (find_max [\"play\",\"play\",\"play\"] == \"play\")"}
{"task_id": "Haskell/159", "prompt": "-- You're a hungry rabbit, and you already have eaten a certain number of carrots,\n-- but now you need to eat more carrots to complete the day's meals.\n-- you should return an array of [ total number of eaten carrots after your meals,\n--                                 the number of carrots left after your meals ]\n-- if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n-- Example:\n-- >>> eat 5 6 10\n-- [11, 4]\n-- >>> eat 4 8 9\n-- [12, 1]\n-- >>> eat 1 10 10\n-- [11, 0]\n-- >>> eat 2 11 5\n-- [7, 0]\n-- Variables:\n-- @number : integer\n--     the number of carrots that you have eaten.\n-- @need : integer\n--     the number of carrots that you need to eat.\n-- @remaining : integer\n--     the number of remaining carrots thet exist in stock\n-- Constraints:\n-- * 0 <= number <= 1000\n-- * 0 <= need <= 1000\n-- * 0 <= remaining <= 1000\n-- Have fun :)\neat :: Int -> Int -> Int -> [Int]", "canonical_solution": "-- Task ID: HumanEval/159\n-- Assigned To: Author B\n\n-- Python Implementation:\n\n--\n-- def eat(number, need, remaining):\n--     \"\"\"\n--     You're a hungry rabbit, and you already have eaten a certain number of carrots,\n--     but now you need to eat more carrots to complete the day's meals.\n--     you should return an array of [ total number of eaten carrots after your meals,\n--                                     the number of carrots left after your meals ]\n--     if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n--\n--     Example:\n--     * eat(5, 6, 10) -> [11, 4]\n--     * eat(4, 8, 9) -> [12, 1]\n--     * eat(1, 10, 10) -> [11, 0]\n--     * eat(2, 11, 5) -> [7, 0]\n--\n--     Variables:\n--     @number : integer\n--         the number of carrots that you have eaten.\n--     @need : integer\n--         the number of carrots that you need to eat.\n--     @remaining : integer\n--         the number of remaining carrots thet exist in stock\n--\n--     Constraints:\n--     * 0 <= number <= 1000\n--     * 0 <= need <= 1000\n--     * 0 <= remaining <= 1000\n--\n--     Have fun :)\n--     \"\"\"\n--     if(need <= remaining):\n--         return [ number + need , remaining-need ]\n--     else:\n--         return [ number + remaining , 0]\n--\n\n-- Haskell Implementation:\n\n-- You're a hungry rabbit, and you already have eaten a certain number of carrots,\n-- but now you need to eat more carrots to complete the day's meals.\n-- you should return an array of [ total number of eaten carrots after your meals,\n--                                 the number of carrots left after your meals ]\n-- if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n--\n-- Example:\n-- >>> eat 5 6 10\n-- [11, 4]\n-- >>> eat 4 8 9\n-- [12, 1]\n-- >>> eat 1 10 10\n-- [11, 0]\n-- >>> eat 2 11 5\n-- [7, 0]\n--\n-- Variables:\n-- @number : integer\n--     the number of carrots that you have eaten.\n-- @need : integer\n--     the number of carrots that you need to eat.\n-- @remaining : integer\n--     the number of remaining carrots thet exist in stock\n--\n-- Constraints:\n-- * 0 <= number <= 1000\n-- * 0 <= need <= 1000\n-- * 0 <= remaining <= 1000\n--\n-- Have fun :)\neat :: Int -> Int -> Int -> [Int]\neat number need remaining =  if need <= remaining then  [number + need, remaining - need] else  [number + remaining, 0]\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (eat 5 6 10 == [11,4])\n    check (eat 4 8 9 == [12,1])\n    check (eat 1 10 10 == [11,0])\n    check (eat 2 11 5 == [7,0])\n    check (eat 4 5 7 == [9,2])\n    check (eat 4 5 1 == [5,0])"}
{"task_id": "Haskell/160", "prompt": "-- Given two lists operator, and operand. The first list has basic algebra operations, and\n-- the second list is a list of integers. Use the two given lists to build the algebric\n-- expression and return the evaluation of this expression.\n-- The basic algebra operations:\n-- Addition ( + )\n-- Subtraction ( - )\n-- Multiplication ( * )\n-- Floor division ( // )\n-- Exponentiation ( ** )\n-- Example:\n-- >>> do_algebra [\"+\", \"*\", \"-\"] [2, 3, 4, 5]\n-- 9\n-- Note:\n--     The length of operator list is equal to the length of operand list minus one.\n--     Operand is a list of of non-negative integers.\n--     Operator list has at least one operator, and operand list has at least two operands.\ndo_algebra :: [String] -> [Int] -> Int", "canonical_solution": "{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}\n\n{-# HLINT ignore \"Redundant bracket\" #-}\nimport Text.Parsec.Token (GenLanguageDef (reservedNames))\n\n-- Task ID: HumanEval/160\n-- Assigned To: Author B\n\n-- Python Implementation:\n\n--\n-- def do_algebra(operator, operand):\n--     \"\"\"\n--     Given two lists operator, and operand. The first list has basic algebra operations, and\n--     the second list is a list of integers. Use the two given lists to build the algebric\n--     expression and return the evaluation of this expression.\n--\n--     The basic algebra operations:\n--     Addition ( + )\n--     Subtraction ( - )\n--     Multiplication ( * )\n--     Floor division ( // )\n--     Exponentiation ( ** )\n--\n--     Example:\n--     operator['+', '*', '-']\n--     array = [2, 3, 4, 5]\n--     result = 2 + 3 * 4 - 5\n--     => result = 9\n--\n--     Note:\n--         The length of operator list is equal to the length of operand list minus one.\n--         Operand is a list of of non-negative integers.\n--         Operator list has at least one operator, and operand list has at least two operands.\n--\n--     \"\"\"\n--     expression = str(operand[0])\n--     for oprt, oprn in zip(operator, operand[1:]):\n--         expression+= oprt + str(oprn)\n--     return eval(expression)\n--\n\n-- Haskell Implementation:\n\n-- Given two lists operator, and operand. The first list has basic algebra operations, and\n-- the second list is a list of integers. Use the two given lists to build the algebric\n-- expression and return the evaluation of this expression.\n--\n-- The basic algebra operations:\n-- Addition ( + )\n-- Subtraction ( - )\n-- Multiplication ( * )\n-- Floor division ( // )\n-- Exponentiation ( ** )\n--\n-- Example:\n-- >>> do_algebra [\"+\", \"*\", \"-\"] [2, 3, 4, 5]\n-- 9\n--\n-- Note:\n--     The length of operator list is equal to the length of operand list minus one.\n--     Operand is a list of of non-negative integers.\n--     Operator list has at least one operator, and operand list has at least two operands.\ndo_algebra :: [String] -> [Int] -> Int\ndo_algebra operators operands = head (snd (foldl (\\(operators, operands) operator -> applyOperator operator operators operands 0 (length operators)) (operators, operands) operator_order))\n  where\n    operator_order :: [String]\n    operator_order =  [\"**\", \"//\", \"*\", \"+\", \"-\"]\n    applyOperator operator operators operands index length\n      | index >= length =  (operators, operands)\n      | operator /= operators !! index =  applyOperator operator operators operands (index + 1) length\n      | otherwise =  applyOperator operator (newOperators) (newOperands) (index + 1) (length - 1)\n      where\n        newOperands :: [Int]\n        newOperands =  take index operands ++ [newOperand] ++ (drop (index + 2) operands)\n        newOperand =  case operator of\n          \"*\" ->  operands !! index * operands !! (index + 1)\n          \"//\" ->  operands !! index `div` operands !! (index + 1)\n          \"+\" ->  operands !! index + operands !! (index + 1)\n          \"-\" ->  operands !! index - operands !! (index + 1)\n          _ ->  operands !! index ^ operands !! (index + 1)\n        newOperators =  take index operators ++ (drop (index + 1) operators)\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (do_algebra [\"**\",\"*\",\"+\"] [2,3,4,5] == 37)\n    check (do_algebra [\"+\",\"*\",\"-\"] [2,3,4,5] == 9)\n    check (do_algebra [\"//\",\"*\"] [7,3,4] == 8)"}
{"task_id": "Haskell/161", "prompt": "-- You are given a string s.\n-- if s[i] is a letter, reverse its case from lower to upper or vise versa,\n-- otherwise keep it as it is.\n-- If the string contains no letters, reverse the string.\n-- The function should return the resulted string.\n-- Examples\n-- >>> solve \"1234\"\n-- \"4321\"\n-- >>> solve \"ab\"\n-- \"AB\"\n-- >>> solve \"#a@C\"\n-- \"#A@c\"\nsolve :: String -> String", "canonical_solution": "-- Task ID: HumanEval/161\n-- Assigned To: Author B\n\n-- Python Implementation:\n\n--\n-- def solve(s):\n--     \"\"\"You are given a string s.\n--     if s[i] is a letter, reverse its case from lower to upper or vise versa,\n--     otherwise keep it as it is.\n--     If the string contains no letters, reverse the string.\n--     The function should return the resulted string.\n--     Examples\n--     solve(\"1234\") = \"4321\"\n--     solve(\"ab\") = \"AB\"\n--     solve(\"#a@C\") = \"#A@c\"\n--     \"\"\"\n--     flg = 0\n--     idx = 0\n--     new_str = list(s)\n--     for i in s:\n--         if i.isalpha():\n--             new_str[idx] = i.swapcase()\n--             flg = 1\n--         idx += 1\n--     s = \"\"\n--     for i in new_str:\n--         s += i\n--     if flg == 0:\n--         return s[len(s)::-1]\n--     return s\n--\n\n-- Haskell Implementation:\n\n-- You are given a string s.\n-- if s[i] is a letter, reverse its case from lower to upper or vise versa,\n-- otherwise keep it as it is.\n-- If the string contains no letters, reverse the string.\n-- The function should return the resulted string.\n-- Examples\n-- >>> solve \"1234\"\n-- \"4321\"\n-- >>> solve \"ab\"\n-- \"AB\"\n-- >>> solve \"#a@C\"\n-- \"#A@c\"\nimport Data.Char (toLower, toUpper)\n\nsolve :: String -> String\nsolve s =  if flg == 0 then  reverse s else reverseUpperLower s\n  where\n    flg :: Int\n    flg =  length [i | i <- s, i `elem` ['a' .. 'z']] +  length [i | i <- s, i `elem` ['A' .. 'Z']]\n    reverseUpperLower s =  [if i `elem` ['a' .. 'z'] then  toUpper i else toLower i | i <- s]\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (solve \"AsDf\" == \"aSdF\")\n    check (solve \"1234\" == \"4321\")\n    check (solve \"ab\" == \"AB\")\n    check (solve \"#a@C\" == \"#A@c\")\n    check (solve \"#AsdfW^45\" == \"#aSDFw^45\")\n    check (solve \"#6@2\" == \"2@6#\")\n    check (solve \"#$a^D\" == \"#$A^d\")\n    check (solve \"#ccc\" == \"#CCC\")"}
{"task_id": "Haskell/162", "prompt": "-- Given a string 'text', return its md5 hash equivalent string.\n-- If 'text' is an empty string, return Nothing.\n-- >>> string_to_md5 \"Hello world\"\n-- Just \"3e25960a79dbc69b674cd4ec67a72c62\"\n-- Build depends on: base >= 4.7 && < 5, base16-bytestring, bytestring, cryptohash-md5\nstring_to_md5 :: String -> Maybe String", "canonical_solution": "-- Task ID: HumanEval/162\n-- Assigned To: Author B\n\n-- Python Implementation:\n\n--\n-- def string_to_md5(text):\n--     \"\"\"\n--     Given a string 'text', return its md5 hash equivalent string.\n--     If 'text' is an empty string, return None.\n--\n--     >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n--     \"\"\"\n--     import hashlib\n--     return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n--\n\n-- Haskell Implementation:\n\n-- Given a string 'text', return its md5 hash equivalent string.\n-- If 'text' is an empty string, return Nothing.\n--\n-- >>> string_to_md5 \"Hello world\"\n-- Just \"3e25960a79dbc69b674cd4ec67a72c62\"\n\nimport Crypto.Hash.MD5 qualified as MD5\nimport Data.ByteString.Base16 (encode)\nimport Data.ByteString.Char8 (pack, unpack)\nimport Data.Maybe\n\n-- Build depends on: base >= 4.7 && < 5, base16-bytestring, bytestring, cryptohash-md5\n\nstring_to_md5 :: String -> Maybe String\nstring_to_md5 text =  if text == \"\" then  Nothing else Just $ unpack $ encode $ MD5.hash $ pack text\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (string_to_md5 \"Hello world\" == Just \"3e25960a79dbc69b674cd4ec67a72c62\")\n    check (string_to_md5 \"\" == Nothing)\n    check (string_to_md5 \"A B C\" == Just \"0ef78513b0cb8cef12743f5aeb35f888\")\n    check (string_to_md5 \"password\" == Just \"5f4dcc3b5aa765d61d8327deb882cf99\")"}
{"task_id": "Haskell/163", "prompt": "-- Given two positive integers a and b, return the even digits between a\n-- and b, in ascending order.\n-- For example:\n-- >>> generate_integers 2 8\n-- [2, 4, 6, 8]\n-- >>> generate_integers 8 2\n-- [2, 4, 6, 8]\n-- >>> generate_integers 10 14\n-- []\ngenerate_integers :: Int -> Int -> [Int]", "canonical_solution": "-- Task ID: HumanEval/163\n-- Assigned To: Author B\n\n-- Python Implementation:\n\n--\n-- def generate_integers(a, b):\n--     \"\"\"\n--     Given two positive integers a and b, return the even digits between a\n--     and b, in ascending order.\n--\n--     For example:\n--     generate_integers(2, 8) => [2, 4, 6, 8]\n--     generate_integers(8, 2) => [2, 4, 6, 8]\n--     generate_integers(10, 14) => []\n--     \"\"\"\n--     lower = max(2, min(a, b))\n--     upper = min(8, max(a, b))\n--\n--     return [i for i in range(lower, upper+1) if i % 2 == 0]\n--\n\n-- Haskell Implementation:\n\n-- Given two positive integers a and b, return the even digits between a\n-- and b, in ascending order.\n--\n-- For example:\n-- >>> generate_integers 2 8\n-- [2, 4, 6, 8]\n-- >>> generate_integers 8 2\n-- [2, 4, 6, 8]\n-- >>> generate_integers 10 14\n-- []\ngenerate_integers :: Int -> Int -> [Int]\ngenerate_integers a b =  [i | i <-  [max 2 (min a b) .. min 8 (max a b)], even i]\n", "test": "\n\n-- Test suite\ncheck :: Bool -> IO ()\ncheck True  = return ()\ncheck False = error \"Test failed\"\n\nmain :: IO ()\nmain = do\n    check (generate_integers 2 10 == [2,4,6,8])\n    check (generate_integers 10 2 == [2,4,6,8])\n    check (generate_integers 132 2 == [2,4,6,8])\n    check (generate_integers 17 89 == [])"}
